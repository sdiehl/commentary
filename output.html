<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#ghc-source-code-abbreviations">GHC Source Code Abbreviations</a></li>
<li><a href="#aging-in-the-generational-gc">Aging in the generational GC</a></li>
<li><a href="#improving-llvm-alias-analysis">Improving LLVM Alias Analysis</a><ul>
<li><a href="#llvm-alias-analysis-infrastructure">LLVM Alias Analysis Infrastructure</a></li>
<li><a href="#maxs-work">Max's Work</a></li>
<li><a href="#tbaa">TBAA</a></li>
<li><a href="#stg-cmm-alias-properties">STG / Cmm Alias Properties</a></li>
<li><a href="#how-to-track-tbaa-information">How to Track TBAA information</a></li>
<li><a href="#llvm-type-system">LLVM type system</a></li>
<li><a href="#problems-optmisations-to-solve">Problems / Optmisations to Solve</a><ul>
<li><a href="#llvm-optimisations">LLVM Optimisations</a></li>
<li><a href="#safe-loads-speculative-load">Safe Loads (speculative load)</a></li>
<li><a href="#ghc-heap-check-case-merging">GHC Heap Check (case merging)</a></li>
</ul></li>
</ul></li>
<li><a href="#ghc-commentary-the-ghc-api">GHC Commentary: The GHC API</a><ul>
<li><a href="#targets">Targets</a></li>
<li><a href="#dependency-analysis">Dependency Analysis</a></li>
<li><a href="#the-modsummary-type">The ModSummary type</a></li>
<li><a href="#loading-compiling-the-modules">Loading (compiling) the Modules</a></li>
</ul></li>
<li><a href="#ghc-commentary-asynchronous-exceptions">GHC Commentary: Asynchronous Exceptions</a></li>
<li><a href="#ghc-commentary-backends">GHC Commentary: Backends</a><ul>
<li><a href="#foreign-calls-and-hints">Foreign calls and hints</a></li>
</ul></li>
<li><a href="#the-block-allocator">The Block Allocator</a><ul>
<li><a href="#structure-of-blocks">Structure of blocks</a></li>
</ul></li>
<li><a href="#ghc-commentary-garbage-collecting-cafs">GHC Commentary: Garbage Collecting CAFs</a><ul>
<li><a href="#static-reference-tables">Static Reference Tables</a></li>
<li><a href="#evacuating-static-objects">Evacuating Static Objects</a></li>
</ul></li>
<li><a href="#calling-convention">Calling Convention</a></li>
<li><a href="#return-convention">Return Convention</a><ul>
<li><a href="#historical-page">Historical page</a></li>
</ul></li>
<li><a href="#cleanup-after-the-new-codegen-is-enabled">Cleanup after the new codegen is enabled</a><ul>
<li><a href="#independent-tasks">Independent tasks</a></li>
<li><a href="#towards-removing-codegencg">Towards removing codeGen/Cg*</a></li>
<li><a href="#later">Later</a></li>
</ul></li>
<li><a href="#cmm-implementing-exception-handling">Cmm: Implementing Exception Handling</a><ul>
<li><a href="#reading-references">Reading references</a></li>
<li><a href="#other-information">Other information</a><ul>
<li><a href="#note-to-reader">Note To Reader</a></li>
</ul></li>
</ul></li>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#the-cmm-language">The Cmm language</a><ul>
<li><a href="#additions-in-cmm">Additions in Cmm</a></li>
<li><a href="#compiling-cmm-with-ghc">Compiling Cmm with GHC</a><ul>
<li><a href="#code-blocks-in-cmm">Code Blocks in Cmm</a></li>
<li><a href="#variables-registers-and-types">Variables, Registers and Types</a></li>
<li><a href="#literals-and-labels">Literals and Labels</a></li>
<li><a href="#sections-and-directives">Sections and Directives</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#statements-and-calls">Statements and Calls</a></li>
<li><a href="#operators-and-primitive-operations">Operators and Primitive Operations</a></li>
</ul></li>
<li><a href="#cmm-design-observations-and-areas-for-potential-improvement">Cmm Design: Observations and Areas for Potential Improvement</a></li>
</ul></li>
<li><a href="#code-generator">Code Generator</a><ul>
<li><a href="#a-brief-history-of-code-generator">A brief history of code generator</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#first-stage-stg-to-cmm-conversion">First stage: STG to Cmm conversion</a></li>
<li><a href="#second-stage-the-cmm-pipeline">Second stage: the Cmm pipeline</a></li>
<li><a href="#dumping-and-debugging-cmm">Dumping and debugging Cmm</a></li>
<li><a href="#register-allocator-code">Register Allocator Code</a><ul>
<li><a href="#the-register-allocator">The register allocator</a></li>
<li><a href="#graph-coloring">Graph coloring</a></li>
<li><a href="#miscellanea">Miscellanea</a></li>
</ul></li>
</ul></li>
<li><a href="#the-ghc-commentary---coding-style-guidelines-for-the-compiler">The GHC Commentary - Coding Style Guidelines for the compiler</a><ul>
<li><a href="#general-style">General Style</a></li>
<li><a href="#comments">Comments</a><ul>
<li><a href="#comments-on-top-level-entities">Comments on top-level entities</a></li>
<li><a href="#comments-in-the-source-code">Comments in the source code</a></li>
<li><a href="#comments-and-examples">Comments and examples</a></li>
<li><a href="#longer-comments-or-architectural-commentary">Longer comments or architectural commentary</a></li>
<li><a href="#commit-messages">Commit messages</a></li>
</ul></li>
<li><a href="#warnings">Warnings</a></li>
<li><a href="#exports-and-imports">Exports and Imports</a><ul>
<li><a href="#exports">Exports</a></li>
<li><a href="#imports">Imports</a></li>
</ul></li>
<li><a href="#compiler-versions-and-language-extensions">Compiler versions and language extensions</a><ul>
<li><a href="#literate-haskell">Literate Haskell</a></li>
<li><a href="#the-c-preprocessor-cpp">The C Preprocessor (CPP)</a></li>
<li><a href="#platform-tests">Platform tests</a></li>
</ul></li>
<li><a href="#tabs-vs-spaces">Tabs vs Spaces</a></li>
</ul></li>
<li><a href="#coercions-in-ghcs-core-language">Coercions in GHC's core language</a><ul>
<li><a href="#difficulties-with-the-current-approach">Difficulties with the current approach</a></li>
<li><a href="#main-proposal">Main proposal</a></li>
</ul></li>
<li><a href="#parsing-of-command-line-arguments">Parsing of command line arguments</a><ul>
<li><a href="#static-flags">Static flags</a></li>
<li><a href="#dynamic-flags">Dynamic flags</a></li>
</ul></li>
<li><a href="#the-ghc-commentary">The GHC Commentary</a><ul>
<li><a href="#editing-the-commentary">Editing the Commentary</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#contributed-documentation">Contributed Documentation</a></li>
</ul></li>
<li><a href="#ghc-commentary-the-compiler">GHC Commentary: The Compiler</a><ul>
<li><a href="#overall-structure">Overall Structure</a></li>
</ul></li>
<li><a href="#compiler-and-runtime-system-ways-in-ghc">Compiler and runtime system ways in GHC</a><ul>
<li><a href="#available-ways-in-a-standard-ghc">Available ways in a standard GHC</a><ul>
<li><a href="#ways-for-parallel-execution-on-clusters-and-multicores">Ways for parallel execution on clusters and multicores</a></li>
</ul></li>
<li><a href="#combining-ways">Combining ways</a></li>
</ul></li>
<li><a href="#internals">Internals</a><ul>
<li><a href="#what-problems-do-we-need-to-solve">What problems do we need to solve?</a></li>
<li><a href="#current-mechanisms">Current mechanisms</a></li>
<li><a href="#new-concepts-for-backpack">New concepts for Backpack</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#constraints">Constraints</a></li>
</ul></li>
<li><a href="#rts-configurations">RTS Configurations</a><ul>
<li><a href="#combinations">Combinations</a></li>
<li><a href="#other-configuration-options">Other configuration options</a></li>
</ul></li>
<li><a href="#contracts-for-haskell">Contracts for Haskell</a><ul>
<li><a href="#involved">Involved</a></li>
<li><a href="#overview-1">Overview</a></li>
<li><a href="#the-plan">The plan</a></li>
<li><a href="#current-status">Current status</a></li>
<li><a href="#questions">Questions</a></li>
<li><a href="#references">References</a></li>
</ul></li>
<li><a href="#the-ghc-commentary-coding-style-guidelines-for-rts-c-code">The GHC Commentary: Coding Style Guidelines for RTS C code</a><ul>
<li><a href="#comments-1">Comments</a></li>
<li><a href="#references-1">References</a></li>
<li><a href="#portability-issues">Portability issues</a><ul>
<li><a href="#which-c-standard">Which C Standard?</a></li>
<li><a href="#other-portability-conventions">Other portability conventions</a></li>
</ul></li>
<li><a href="#debuggingrobustness-tricks">Debugging/robustness tricks</a></li>
<li><a href="#syntactic-details">Syntactic details</a></li>
<li><a href="#inline-functions">Inline functions</a></li>
<li><a href="#source-control-issues">Source-control issues</a></li>
</ul></li>
<li><a href="#copying-gc">Copying GC</a><ul>
<li><a href="#case-expressions">Case expressions</a></li>
<li><a href="#shadowing">Shadowing</a></li>
<li><a href="#human-readable-core-generation">Human readable Core generation</a></li>
</ul></li>
<li><a href="#cps-conversion">CPS Conversion</a><ul>
<li><a href="#overview-2">Overview</a></li>
<li><a href="#design-aspects">Design Aspects</a></li>
<li><a href="#simple-design">Simple Design</a></li>
<li><a href="#to-be-worked-out">To be worked out</a></li>
<li><a href="#pipeline">Pipeline</a></li>
<li><a href="#todo">TODO</a></li>
<li><a href="#current-pipeline">Current Pipeline</a></li>
<li><a href="#non-cps-changes">Non-CPS Changes</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#loopholes">Loopholes</a><ul>
<li><a href="#gc-blocks">GC Blocks</a></li>
<li><a href="#update-frames">Update Frames</a></li>
<li><a href="#user-defined-continuations">User defined continuations</a></li>
<li><a href="#branches-to-continuations">Branches to continuations</a></li>
</ul></li>
<li><a href="#not-in-scope-of-current-work">Not in Scope of Current Work</a><ul>
<li><a href="#static-reference-table-handling-srt">Static Reference Table Handling (SRT)</a></li>
<li><a href="#cmm-optimization-assumed-by-cps">Cmm Optimization assumed by CPS</a></li>
</ul></li>
<li><a href="#notes-on-future-development">Notes on future development</a><ul>
<li><a href="#handling-gc">Handling GC</a></li>
</ul></li>
</ul></li>
<li><a href="#the-ghc-commentary-data-types-and-data-constructors">The GHC Commentary: Data types and data constructors</a><ul>
<li><a href="#data-types">Data types</a></li>
</ul></li>
<li><a href="#the-life-cycle-of-a-data-type">The life cycle of a data type</a><ul>
<li><a href="#the-constructor-wrapper-functions">The constructor wrapper functions</a></li>
<li><a href="#the-constructor-worker-functions">The constructor worker functions</a></li>
<li><a href="#external-core">External Core</a></li>
<li><a href="#unboxing-strict-fields">Unboxing strict fields</a></li>
<li><a href="#labels-and-info-tables">Labels and info tables</a></li>
</ul></li>
<li><a href="#demand-analyser-in-ghc">Demand analyser in GHC</a><ul>
<li><a href="#demand-signatures">Demand signatures</a><ul>
<li><a href="#demand-descriptions">Demand descriptions</a></li>
</ul></li>
<li><a href="#worker-wrapper-split">Worker-Wrapper split</a></li>
<li><a href="#relevant-compiler-parts">Relevant compiler parts</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#algorithm-description">Algorithm description</a><ul>
<li><a href="#covariant-and-contravariant-positions">Covariant and contravariant positions</a></li>
</ul></li>
<li><a href="#requirements-for-legal-instances">Requirements for legal instances</a></li>
</ul></li>
<li><a href="#llvm-back-end-design">LLVM Back-end Design</a></li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#framework">Framework</a></li>
<li><a href="#llvm-code-generation">LLVM Code Generation</a></li>
<li><a href="#register-pinning">Register Pinning</a></li>
<li><a href="#code-generation">Code Generation</a><ul>
<li><a href="#unregisterised-vs.-registerised">Unregisterised Vs. Registerised</a></li>
</ul></li>
<li><a href="#cmmdata">CmmData</a><ul>
<li><a href="#st-pass-generation">1st Pass : Generation</a></li>
</ul></li>
<li><a href="#cmmstaticlit">CmmStaticLit</a><ul>
<li><a href="#nd-pass-resolution">2nd Pass : Resolution</a></li>
</ul></li>
<li><a href="#cmmproc">CmmProc</a></li>
</ul></li>
<li><a href="#desugaring-instance-declarations">Desugaring instance declarations</a><ul>
<li><a href="#basic-stuff">Basic stuff</a></li>
<li><a href="#dictionary-functions">Dictionary functions</a></li>
<li><a href="#the-inline-strategy">The INLINE strategy</a></li>
<li><a href="#the-out-of-line-a-strategy">The out-of-line (A) strategy</a></li>
<li><a href="#the-out-of-line-b-strategy">The out-of-line (B) strategy</a></li>
<li><a href="#user-inline-pragmas-and-out-of-line-a">User INLINE pragmas and out-of-line (A)</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#bugs-other-problems">Bugs &amp; Other Problems</a></li>
<li><a href="#compiling-more-than-one-module-at-once">Compiling more than one module at once</a><ul>
<li><a href="#the-overall-driver">The overall driver</a><ul>
<li><a href="#dependency-analysis-1">Dependency analysis</a></li>
<li><a href="#recompilation-checking-and-stability">Recompilation checking and stability</a></li>
<li><a href="#compilation">Compilation</a></li>
</ul></li>
</ul></li>
<li><a href="#eager-promotion">Eager Promotion</a></li>
<li><a href="#eager-version-bumping-strategy">Eager Version Bumping Strategy</a><ul>
<li><a href="#type-variables-and-term-variables">Type variables and term variables</a></li>
</ul></li>
<li><a href="#hc-files-and-the-evil-mangler">HC files and the Evil Mangler</a></li>
<li><a href="#strictness-analysis-examples">Strictness analysis: examples</a></li>
<li><a href="#system-fc-equality-constraints-and-coercions">System FC: equality constraints and coercions</a><ul>
<li><a href="#coercions-and-coercion-kinds">Coercions and Coercion Kinds</a></li>
<li><a href="#gadts">GADTs</a></li>
<li><a href="#representation-of-coercion-assumptions">Representation of coercion assumptions</a></li>
<li><a href="#newtypes-are-coerced-types">Newtypes are coerced types</a></li>
<li><a href="#roles">Roles</a></li>
<li><a href="#simplification">Simplification</a></li>
</ul></li>
<li><a href="#ghc-commentary-runtime-aspects-of-the-ffi">GHC Commentary: Runtime aspects of the FFI</a><ul>
<li><a href="#foreign-import-wrapper">Foreign Import &quot;wrapper&quot;</a></li>
</ul></li>
<li><a href="#function-calls">Function Calls</a><ul>
<li><a href="#generic-apply">Generic apply</a></li>
</ul></li>
<li><a href="#the-garbage-collector">The Garbage Collector</a><ul>
<li><a href="#gc-overview">GC overview</a></li>
<li><a href="#gc-data-structures">GC data structures</a><ul>
<li><a href="#generation">generation</a></li>
<li><a href="#nursery">nursery</a></li>
</ul></li>
</ul></li>
<li><a href="#i-know-kung-fu-learning-stg-by-example">I know kung fu: learning STG by example</a><ul>
<li><a href="#what-is-stg-exactly">What is STG, exactly?</a></li>
<li><a href="#an-overview-of-the-stg-machine">An overview of the STG machine</a><ul>
<li><a href="#components-of-the-machine">Components of the machine</a></li>
<li><a href="#important-concepts-in-the-machine">Important concepts in the machine</a></li>
<li><a href="#overview-of-execution-model-of-the-machine">Overview of execution model of the machine</a></li>
</ul></li>
<li><a href="#saturated-application-to-known-functions">Saturated application to known functions</a><ul>
<li><a href="#example-1-function-application-with-sufficient-stack-space">Example 1: function application with sufficient stack space</a></li>
<li><a href="#example-2-function-application-that-needs-to-grow-the-stack">Example 2: function application that needs to grow the stack</a></li>
</ul></li>
<li><a href="#example-3-unsaturated-applications-to-known-functions">Example 3: Unsaturated applications to known functions</a></li>
<li><a href="#example-4-applications-to-unknown-functions">Example 4: Applications to unknown functions</a><ul>
<li><a href="#dealing-with-generic-application">Dealing with generic application</a></li>
<li><a href="#making-the-call-to-the-generic-application-code">Making the call to the generic application code</a></li>
</ul></li>
<li><a href="#example-5-oversaturated-applications-to-known-functions">Example 5: oversaturated applications to known functions</a></li>
<li><a href="#example-6-allocation-of-thunks-and-data">Example 6: allocation of thunks and data</a><ul>
<li><a href="#checking-for-sufficient-heap-space">Checking for sufficient heap space</a></li>
<li><a href="#performing-the-actual-allocation">Performing the actual allocation</a></li>
<li><a href="#returning-an-allocated-value-to-the-caller">Returning an allocated value to the caller</a></li>
<li><a href="#dealing-with-the-forced-scrutinee">Dealing with the forced scrutinee</a></li>
</ul></li>
<li><a href="#example-8-thunks-and-thunk-update">Example 8: thunks and thunk update</a><ul>
<li><a href="#thunk-entry-point">Thunk entry point</a></li>
<li><a href="#continuation-of-the-thunk">Continuation of the thunk</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
<li><a href="#support-for-generic-programming">Support for generic programming</a><ul>
<li><a href="#status">Status</a></li>
<li><a href="#main-components">Main components</a></li>
<li><a href="#things-that-have-been-removed">Things that have been removed</a></li>
<li><a href="#what-already-works">What already works</a></li>
<li><a href="#testing">Testing</a></li>
</ul></li>
<li><a href="#kind-polymorphic-overhaul">Kind polymorphic overhaul</a><ul>
<li><a href="#generic-representation-universe">Generic representation universe</a></li>
<li><a href="#universe-interpretation">Universe interpretation</a><ul>
<li><a href="#names">Names</a></li>
</ul></li>
<li><a href="#metadata-representation">Metadata representation</a></li>
<li><a href="#conversion-between-user-datatypes-and-generic-representation">Conversion between user datatypes and generic representation</a></li>
<li><a href="#example-datatype-encoding-lists-derived-by-the-compiler">Example datatype encoding: lists (derived by the compiler)</a><ul>
<li><a href="#digression">Digression</a></li>
</ul></li>
<li><a href="#ghc-8.0-and-later">GHC 8.0 and later</a><ul>
<li><a href="#type-level-metadata-encoding">Type-level metadata encoding</a></li>
<li><a href="#strictness">Strictness</a></li>
</ul></li>
<li><a href="#source-tree-layout">Source Tree Layout</a></li>
<li><a href="#build-system-basics">Build System Basics</a></li>
<li><a href="#coding-style">Coding Style</a></li>
</ul></li>
<li><a href="#the-ghc-commentary-ghci">The GHC Commentary: GHCi</a><ul>
<li><a href="#debugging-the-interpreter">Debugging the interpreter</a></li>
<li><a href="#useful-stuff-to-know-about-the-interpreter">Useful stuff to know about the interpreter</a><ul>
<li><a href="#stack-management">Stack management</a></li>
<li><a href="#building-constructors">Building constructors</a></li>
<li><a href="#perspective">Perspective</a></li>
</ul></li>
<li><a href="#case-returns-between-interpreted-and-compiled-code">case returns between interpreted and compiled code</a><ul>
<li><a href="#returning-to-interpreted-code.">Returning to interpreted code.</a></li>
<li><a href="#returning-to-compiled-code.">Returning to compiled code.</a></li>
</ul></li>
<li><a href="#unboxed-tuples-a-right-royal-spanner-in-the-works">Unboxed tuples: a Right Royal Spanner In The Works</a></li>
</ul></li>
<li><a href="#porting-ghc-using-llvm-backend">Porting GHC using LLVM backend</a><ul>
<li><a href="#registerised-mode">Registerised Mode</a></li>
</ul></li>
<li><a href="#packages-in-ghc">Packages in GHC</a><ul>
<li><a href="#the-problem">The problem</a></li>
<li><a href="#assumptions">Assumptions</a></li>
<li><a href="#the-open-question">The open question</a></li>
<li><a href="#plan-a-ghcs-current-story">Plan A: GHC's current story</a></li>
<li><a href="#plan-b-package-mounting">Plan B: package mounting</a></li>
<li><a href="#plan-c-mention-the-package-in-the-import">Plan C: mention the package in the import</a></li>
</ul></li>
<li><a href="#problems">Problems</a><ul>
<li><a href="#breaking-re-installations">Breaking re-installations</a></li>
<li><a href="#type-errors-when-using-packages-together">Type errors when using packages together</a></li>
</ul></li>
<li><a href="#goals">Goals</a></li>
<li><a href="#implementation-plan">Implementation Plan</a><ul>
<li><a href="#persistent-package-store">Persistent package store</a></li>
<li><a href="#views">Views</a></li>
<li><a href="#consistent-developer-environment">Consistent developer environment</a></li>
<li><a href="#garbage-collection">Garbage collection</a></li>
<li><a href="#cabal-remove">cabal remove</a></li>
<li><a href="#cabal-upgrade">cabal upgrade</a></li>
<li><a href="#current-status-1">Current Status</a><ul>
<li><a href="#unique-install-location">Unique Install Location</a></li>
<li><a href="#ghc-pkg">ghc-pkg</a></li>
<li><a href="#adhoc-dependency-resolution">Adhoc dependency resolution</a></li>
<li><a href="#detect-whether-an-overwrite-happens-and-warn-about-it">Detect whether an overwrite happens and warn about it</a></li>
<li><a href="#garbage-collection-1">Garbage Collection</a></li>
<li><a href="#about-shadowing">About Shadowing</a></li>
<li><a href="#about-unique-identifier">About Unique Identifier</a></li>
</ul></li>
<li><a href="#original-plan">Original Plan</a></li>
<li><a href="#hashes-and-identifiers">Hashes and identifiers</a></li>
<li><a href="#install-location-of-installed-cabal-packages">Install location of installed Cabal packages</a><ul>
<li><a href="#hash">Hash</a></li>
<li><a href="#unique-number">Unique number</a></li>
</ul></li>
<li><a href="#simplistic-dependency-resolution">Simplistic dependency resolution</a></li>
<li><a href="#build-flavours">Build flavours</a><ul>
<li><a href="#the-cabal-hash">The Cabal hash</a></li>
<li><a href="#released-and-unreleased-packages">Released and Unreleased packages</a></li>
</ul></li>
<li><a href="#dependency-resolution-in-cabal-install">Dependency resolution in cabal-install</a></li>
<li><a href="#garbage-collection-2">Garbage Collection</a></li>
<li><a href="#currently-open-design-decisions">Currently open design decisions</a><ul>
<li><a href="#handling-of-dirty-builds">Handling of dirty builds</a></li>
<li><a href="#build-flavours-1">Build flavours</a></li>
<li><a href="#simplistic-dependency-resolution-1">Simplistic dependency resolution</a></li>
</ul></li>
<li><a href="#related-topics">Related topics</a><ul>
<li><a href="#separating-storage-and-selection-of-packages">Separating storage and selection of packages</a></li>
<li><a href="#first-class-environments">First class environments</a></li>
</ul></li>
<li><a href="#questions-to-remember">Questions to remember</a></li>
</ul></li>
<li><a href="#the-haskell-execution-model">The Haskell Execution Model</a></li>
<li><a href="#heap_alloced">HEAP_ALLOCED</a><ul>
<li><a href="#method-1-put-static-closures-in-an-aligned-section">Method 1: put static closures in an aligned section</a></li>
<li><a href="#method-2-copy-static-closures-into-a-special-area-at-startup">Method 2: copy static closures into a special area at startup</a></li>
</ul></li>
<li><a href="#heap-and-stack-checks">Heap and Stack checks</a></li>
<li><a href="#ghc-commentary-the-layout-of-heap-objects">GHC Commentary: The Layout of Heap Objects</a><ul>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#heap-objects">Heap Objects</a></li>
<li><a href="#info-tables">Info Tables</a></li>
<li><a href="#types-of-payload-layout">Types of Payload Layout</a><ul>
<li><a href="#pointers-first-layout">Pointers-first layout</a></li>
<li><a href="#bitmap-layout">Bitmap layout</a></li>
</ul></li>
<li><a href="#dynamic-vs.-static-objects">Dynamic vs. Static objects</a><ul>
<li><a href="#dynamic-objects">Dynamic objects</a></li>
<li><a href="#static-objects">Static objects</a></li>
</ul></li>
<li><a href="#types-of-object">Types of object</a><ul>
<li><a href="#data-constructors">Data Constructors</a></li>
<li><a href="#function-closures">Function Closures</a></li>
<li><a href="#thunks">Thunks</a></li>
<li><a href="#selector-thunks">Selector thunks</a></li>
<li><a href="#partial-applications">Partial applications</a></li>
<li><a href="#generic-application">Generic application</a></li>
<li><a href="#stack-application">Stack application</a></li>
<li><a href="#indirections">Indirections</a></li>
<li><a href="#byte-code-objects">Byte-code objects</a></li>
<li><a href="#black-holes">Black holes</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#mvars">MVars</a></li>
<li><a href="#weak-pointers">Weak pointers</a></li>
<li><a href="#stable-names">Stable Names</a></li>
<li><a href="#thread-state-objects">Thread State Objects</a></li>
<li><a href="#stm-objects">STM objects</a></li>
<li><a href="#forwarding-pointers">Forwarding Pointers</a></li>
</ul></li>
<li><a href="#how-to-add-new-heap-objects">How to add new heap objects</a></li>
<li><a href="#change-history">Change History</a></li>
<li><a href="#speculation-and-commentary">Speculation and Commentary</a></li>
<li><a href="#record-of-performance-improvements-made-to-the-hoopl-library-starting-january-2012">Record of performance improvements made to the Hoopl library starting January 2012</a></li>
</ul></li>
<li><a href="#haskell-program-coverage">Haskell Program Coverage</a><ul>
<li><a href="#binary-tick-boxes">Binary Tick Boxes</a></li>
<li><a href="#machine-generated-haskell">Machine Generated Haskell</a></li>
</ul></li>
<li><a href="#compiling-one-module-hscmain">Compiling one module: HscMain</a></li>
<li><a href="#the-diagram">The Diagram</a></li>
<li><a href="#picture-of-the-main-compiler-pipeline">Picture of the main compiler pipeline</a><ul>
<li><a href="#source-locations">Source Locations</a></li>
</ul></li>
<li><a href="#interface-files">Interface files</a><ul>
<li><a href="#when-is-an-interface-file-loaded">When is an interface file loaded?</a></li>
</ul></li>
<li><a href="#immix-garbage-collector">Immix Garbage Collector</a></li>
<li><a href="#the-patches">The patches</a><ul>
<li><a href="#the-main-patch">The main patch</a></li>
<li><a href="#line-before-inscreasing-block-size">Line before inscreasing block size</a></li>
<li><a href="#allocate-in-lines-in-minor-gcs">Allocate in lines in minor GCs</a></li>
<li><a href="#remove-partial-list">Remove partial list</a></li>
</ul></li>
<li><a href="#to-do">To do</a></li>
<li><a href="#ghc-source-tree-roadmap-includes">GHC Source Tree Roadmap: includes/</a><ul>
<li><a href="#external-apis">External APIs</a></li>
<li><a href="#derived-constants">Derived Constants</a></li>
<li><a href="#used-when-compiling-via-c">Used when compiling via C</a></li>
<li><a href="#the-rts-external-apis">The RTS external APIs</a></li>
</ul></li>
<li><a href="#installing-using-the-llvm-back-end">Installing &amp; Using the LLVM Back-end</a><ul>
<li><a href="#installing">Installing</a></li>
<li><a href="#llvm-support">LLVM Support</a></li>
<li><a href="#using">Using</a></li>
<li><a href="#supported-platforms-correctness">Supported Platforms &amp; Correctness</a></li>
<li><a href="#shared-libraries">Shared Libraries</a></li>
<li><a href="#performance">Performance</a></li>
</ul></li>
<li><a href="#ghc-commentary-librariesinteger">GHC Commentary: Libraries/Integer</a><ul>
<li><a href="#selecting-an-integer-implementation">Selecting an Integer implementation</a></li>
<li><a href="#the-integer-interface">The Integer interface</a></li>
<li><a href="#how-integer-is-handled-inside-ghc">How Integer is handled inside GHC</a></li>
</ul></li>
<li><a href="#an-integrated-code-generator-for-ghc">An Integrated Code Generator for GHC</a><ul>
<li><a href="#design-elements">Design elements</a></li>
<li><a href="#design-philosophy">Design philosophy</a></li>
<li><a href="#proposed-compilation-pipeline">Proposed compilation pipeline</a><ul>
<li><a href="#convert-from-stg-to-control-flow-graph">Convert from STG to control flow graph</a></li>
<li><a href="#instruction-selection">Instruction selection</a></li>
<li><a href="#optimisation">Optimisation</a></li>
<li><a href="#proc-point-analysis">Proc-point analysis</a></li>
<li><a href="#register-allocation">Register allocation</a></li>
<li><a href="#stack-layout">Stack layout</a></li>
<li><a href="#tidy-up">Tidy up</a></li>
</ul></li>
<li><a href="#machine-dependence">Machine-dependence</a></li>
</ul></li>
<li><a href="#ghc-commentary-the-byte-code-interpreter-and-dynamic-linker">GHC Commentary: The byte-code interpreter and dynamic linker</a><ul>
<li><a href="#linker">Linker</a></li>
<li><a href="#bytecode-interpreter">Bytecode Interpreter</a></li>
</ul></li>
<li><a href="#the-io-manager">The I/O Manager</a></li>
<li><a href="#key-data-types">Key data types</a></li>
<li><a href="#kinds">Kinds</a><ul>
<li><a href="#representing-kinds">Representing kinds</a></li>
<li><a href="#kind-subtyping">Kind subtyping</a></li>
</ul></li>
<li><a href="#linearity">Linearity</a></li>
<li><a href="#ticky">Ticky</a><ul>
<li><a href="#declarations-for-ticky-counters">Declarations for ticky counters</a></li>
</ul></li>
<li><a href="#strictness-and-let-floating">Strictness and let-floating</a></li>
<li><a href="#coercions">Coercions</a></li>
<li><a href="#warn-arity">WARN: arity /</a></li>
<li><a href="#explaining-demand-transformers">Explaining demand transformers</a></li>
<li><a href="#nofib-stuff">Nofib stuff</a></li>
<li><a href="#ghc-commentary-libraries">GHC Commentary: Libraries</a></li>
<li><a href="#building-packages-that-ghc-doesnt-depend-on">Building packages that GHC doesn't depend on</a></li>
<li><a href="#classifying-boot-packages">Classifying boot packages</a><ul>
<li><a href="#required-or-optional">Required or optional</a></li>
<li><a href="#coupling-to-ghc">Coupling to GHC</a></li>
<li><a href="#zero-boot-packages">Zero-boot packages</a></li>
<li><a href="#installation">Installation</a></li>
</ul></li>
<li><a href="#boot-packages-dependencies">Boot packages dependencies</a></li>
<li><a href="#repositories">Repositories</a></li>
<li><a href="#the-llvm-backend">The LLVM backend</a></li>
<li><a href="#loopification">Loopification</a></li>
<li><a href="#llvm-mangler">LLVM Mangler</a><ul>
<li><a href="#tables_next_to_code-tntc">TABLES_NEXT_TO_CODE (TNTC)</a></li>
<li><a href="#stack-alignment">Stack Alignment</a></li>
<li><a href="#simd-avx">SIMD / AVX</a></li>
</ul></li>
<li><a href="#migrating-old-commentary">Migrating Old Commentary</a><ul>
<li><a href="#before-the-show-begins">Before the Show Begins</a></li>
<li><a href="#genesis">Genesis</a></li>
<li><a href="#the-beast-dissected">The Beast Dissected</a></li>
<li><a href="#rts-libraries">RTS &amp; Libraries</a></li>
<li><a href="#extensions-or-making-a-complicated-system-more-complicated">Extensions, or Making a Complicated System More Complicated</a></li>
</ul></li>
<li><a href="#the-marvellous-module-structure-of-ghc">The Marvellous Module Structure of GHC</a><ul>
<li><a href="#compilation-order-is-as-follows">Compilation order is as follows:</a></li>
<li><a href="#typechecker-stuff">Typechecker stuff</a></li>
<li><a href="#hssyn-stuff">HsSyn stuff</a></li>
<li><a href="#library-stuff-base-package">Library stuff: base package</a></li>
<li><a href="#high-level-dependency-graph">High-level Dependency Graph</a></li>
</ul></li>
<li><a href="#module-types">Module Types</a><ul>
<li><a href="#module">Module</a></li>
<li><a href="#modiface">ModIface</a></li>
<li><a href="#moddetails">ModDetails</a><ul>
<li><a href="#modguts">ModGuts</a></li>
</ul></li>
<li><a href="#modsummary">ModSummary</a></li>
<li><a href="#homemodinfo">HomeModInfo</a></li>
<li><a href="#homepackagetable">HomePackageTable</a></li>
<li><a href="#externalpackagestate">ExternalPackageState</a></li>
</ul></li>
<li><a href="#multi-instance-packages">Multi-instance packages</a><ul>
<li><a href="#todo-list">ToDo list</a></li>
<li><a href="#next-step-dealing-with-ways">Next step: dealing with ways</a></li>
</ul></li>
<li><a href="#native-code-generator-ncg">Native Code Generator (NCG)</a><ul>
<li><a href="#files-parts">Files, Parts</a></li>
<li><a href="#overview-3">Overview</a><ul>
<li><a href="#spilling">Spilling</a></li>
<li><a href="#dealing-with-common-cases-fast">Dealing with common cases fast</a></li>
</ul></li>
<li><a href="#complications-observations-and-possible-improvements">Complications, observations, and possible improvements</a><ul>
<li><a href="#real-vs-virtual-registers-in-the-instruction-selectors">Real vs virtual registers in the instruction selectors</a></li>
</ul></li>
<li><a href="#selecting-insns-for-64-bit-valuesloadsstores-on-32-bit-platforms">Selecting insns for 64-bit values/loads/stores on 32-bit platforms</a></li>
<li><a href="#shortcomings-and-inefficiencies-in-the-register-allocator">Shortcomings and inefficiencies in the register allocator</a><ul>
<li><a href="#redundant-reconstruction-of-the-control-flow-graph">Redundant reconstruction of the control flow graph</a></li>
<li><a href="#really-ridiculous-method-for-doing-spilling">Really ridiculous method for doing spilling</a></li>
<li><a href="#redundant-move-support-for-revised-instruction-selector-suggestion">Redundant-move support for revised instruction selector suggestion</a></li>
</ul></li>
<li><a href="#x86-arcana-that-you-should-know-about">x86 arcana that you should know about</a></li>
<li><a href="#generating-code-for-ccalls">Generating code for ccalls</a></li>
<li><a href="#duplicate-implementation-for-many-stg-macros">Duplicate implementation for many STG macros</a></li>
<li><a href="#how-to-debug-the-ncg-without-losing-your-sanityhaircool">How to debug the NCG without losing your sanity/hair/cool</a></li>
<li><a href="#historical-page-1">Historical page</a></li>
</ul></li>
<li><a href="#overview-of-modules-in-the-new-code-generator">Overview of modules in the new code generator</a><ul>
<li><a href="#the-new-cmm-data-type">The new Cmm data type</a></li>
<li><a href="#module-structure-of-the-new-code-generator">Module structure of the new code generator</a><ul>
<li><a href="#basic-datatypes-and-infrastructure">Basic datatypes and infrastructure</a></li>
<li><a href="#analyses-and-transformations">Analyses and transformations</a></li>
<li><a href="#linking-the-pipeline">Linking the pipeline</a></li>
<li><a href="#dead-code">Dead code</a></li>
</ul></li>
<li><a href="#historical-page-2">Historical page</a></li>
</ul></li>
<li><a href="#ghcs-glorious-new-code-generator">GHC's glorious new code generator</a><ul>
<li><a href="#workflow-for-the-new-code-generator-and-hoopl">Workflow for the new code generator and Hoopl</a></li>
<li><a href="#status-report-april-2011">Status report April 2011</a></li>
<li><a href="#historical-page-3">Historical page</a></li>
</ul></li>
<li><a href="#design-of-the-new-code-generator">Design of the new code generator</a><ul>
<li><a href="#overview-4">Overview</a></li>
<li><a href="#the-cmm-pipeline">The Cmm pipeline</a><ul>
<li><a href="#branches-to-continuations-and-the-adams-optimisation">Branches to continuations and the &quot;Adams optimisation&quot;</a></li>
</ul></li>
<li><a href="#runtime-system">Runtime system</a></li>
</ul></li>
<li><a href="#note-historical-page">NOTE: Historical page</a></li>
<li><a href="#stupidity-in-the-new-code-generator">Stupidity in the New Code Generator</a><ul>
<li><a href="#cantankerous-comparisons">Cantankerous Comparisons</a></li>
<li><a href="#dead-stackheap-checks">Dead stack/heap checks</a></li>
<li><a href="#instruction-reordering">Instruction reordering</a></li>
<li><a href="#stack-space-overuse">Stack space overuse</a></li>
<li><a href="#double-temp-use-means-no-inlinining">Double temp-use means no inlinining?</a></li>
<li><a href="#stupid-spills">Stupid spills</a></li>
<li><a href="#noppy-proc-points">Noppy proc-points</a></li>
<li><a href="#lots-of-temporary-variables">Lots of temporary variables</a></li>
<li><a href="#double-proc-points">Double proc points</a></li>
<li><a href="#rewriting-stacks">Rewriting stacks</a></li>
<li><a href="#spilling-hpsp">Spilling Hp/Sp</a></li>
<li><a href="#up-and-down">Up and Down</a></li>
<li><a href="#sp-is-generally-stupid">Sp is generally stupid</a></li>
<li><a href="#heap-and-r1-aliasing">Heap and R1 aliasing</a></li>
</ul></li>
<li><a href="#old-code-generator-prior-to-ghc-7.8">Old Code Generator (prior to GHC 7.8)</a><ul>
<li><a href="#storage-manager-representations">Storage manager representations</a></li>
<li><a href="#generated-cmm-naming-convention">Generated Cmm Naming Convention</a></li>
<li><a href="#modules">Modules</a><ul>
<li><a href="#memory-and-register-management">Memory and Register Management</a></li>
<li><a href="#function-calls-and-parameter-passing">Function Calls and Parameter Passing</a></li>
<li><a href="#misc-utilities">Misc utilities</a></li>
<li><a href="#special-runtime-support">Special runtime support</a></li>
</ul></li>
</ul></li>
<li><a href="#ordering-the-core-to-core-optimisation-passes">Ordering the Core-to-Core optimisation passes</a><ul>
<li><a href="#this-ordering-obeys-all-the-constraints-except-5">This ordering obeys all the constraints except (5)</a></li>
<li><a href="#constraints-1">Constraints</a><ul>
<li><a href="#float-in-before-strictness">1. float-in before strictness</a></li>
<li><a href="#dont-simplify-between-float-in-and-strictness">2. Don't simplify between float-in and strictness</a></li>
<li><a href="#want-full-laziness-before-foldrbuild">3. Want full-laziness before foldr/build</a></li>
<li><a href="#want-strictness-after-foldrbuild">4. Want strictness after foldr/build</a></li>
<li><a href="#want-full-laziness-after-strictness">5. Want full laziness after strictness</a></li>
<li><a href="#want-float-in-after-foldrbuild">6. Want float-in after foldr/build</a></li>
<li><a href="#want-simplify-after-float-inwards">7. Want simplify after float-inwards</a></li>
<li><a href="#if-full-laziness-is-ever-done-after-strictness">8. If full laziness is ever done after strictness</a></li>
<li><a href="#ignore-inline-pragmas-flag-for-final-simplification">9. Ignore-inline-pragmas flag for final simplification</a></li>
<li><a href="#run-float-inwards-once-more-after-strictness-simplify">10. Run Float Inwards once more after strictness-simplify</a></li>
</ul></li>
</ul></li>
<li><a href="#overall-organisation-of-ghc">Overall organisation of GHC</a></li>
<li><a href="#ghc-source-code">GHC source code</a></li>
<li><a href="#package-compatibility">Package Compatibility</a><ul>
<li><a href="#dont-reorganise-packages">1. Don't reorganise packages</a></li>
<li><a href="#provide-older-versions-of-base-with-a-new-ghc-release">2. Provide older version(s) of base with a new GHC release</a></li>
<li><a href="#allow-packages-to-re-export-modules">4. Allow packages to re-export modules</a></li>
<li><a href="#provide-backwards-compatible-versions-of-base">4.1 Provide backwards-compatible versions of base</a></li>
<li><a href="#rename-base-and-provide-a-compatibility-wrapper">4.2 Rename base, and provide a compatibility wrapper</a></li>
<li><a href="#dont-rename-base">4.3 Don't rename base</a></li>
<li><a href="#do-some-kind-of-providesrequires-interface-in-cabal">5. Do some kind of provides/requires interface in Cabal</a><ul>
<li><a href="#make-api-specifications-more-symmetric">5.1 Make API specifications more symmetric</a></li>
<li><a href="#make-api-specifications-explicit">5.2 Make API specifications explicit</a></li>
<li><a href="#make-api-specifications-more-specific">5.3 Make API specifications more specific</a></li>
</ul></li>
<li><a href="#distributions-at-the-hackage-level">6. Distributions at the Hackage level</a></li>
<li><a href="#allow-package-overlaps">7. Allow package overlaps</a></li>
<li><a href="#the-problem-of-lax-version-dependencies">The problem of lax version dependencies</a></li>
</ul></li>
<li><a href="#note-about-this-page">Note about this page</a></li>
<li><a href="#explicit-package-imports">Explicit package imports</a><ul>
<li><a href="#is-the-from-compulsory">Is the 'from <package>' compulsory?</a></li>
<li><a href="#package-versions">Package versions</a></li>
<li><a href="#importing-from-the-home-package">Importing from the home package</a></li>
<li><a href="#the-as-p-alias">The 'as P' alias</a></li>
<li><a href="#qualified-names">Qualified names</a></li>
<li><a href="#exporting-modules-from-other-packages">Exporting modules from other packages</a></li>
<li><a href="#syntax">Syntax</a><ul>
<li><a href="#syntax-formalised-and-summarised">Syntax formalised and summarised</a></li>
<li><a href="#proposal-for-package-mounting">Proposal for Package Mounting</a></li>
<li><a href="#evaluation">Evaluation</a></li>
<li><a href="#note-on-package-grafting">Note on Package Grafting</a></li>
</ul></li>
<li><a href="#alternative-proposal-for-packages-with-explicit-namespaces">Alternative Proposal for Packages (with explicit namespaces)</a></li>
<li><a href="#a-different-but-related-problem">A different, but related, problem</a></li>
<li><a href="#proposal">Proposal</a><ul>
<li><a href="#naming-a-namespace">Naming a namespace</a></li>
<li><a href="#what-namespaces-are-available-by-default">What namespaces are available by default?</a></li>
<li><a href="#namespace-resolution">Namespace resolution</a></li>
<li><a href="#syntax-1">Syntax</a></li>
<li><a href="#exports-1">Exports</a></li>
<li><a href="#implicit-imports">Implicit imports</a></li>
<li><a href="#exposed-vs-hidden-packages">Exposed vs Hidden packages</a></li>
<li><a href="#what-if-you-wanted-to-import-a.b.c-from-p1-and-a.b.c-from-p2-into-the-same-module">What if you wanted to import A.B.C from P1 and A.B.C from P2 into the <em>same</em> module?</a></li>
</ul></li>
</ul></li>
<li><a href="#package-reorg">Package Reorg</a><ul>
<li><a href="#goals-1">Goals</a></li>
<li><a href="#proposal-1">Proposal</a><ul>
<li><a href="#what-is-in-the-core-packages">What is in the Core Packages?</a></li>
<li><a href="#requirements-to-libraries-to-be-included-in-core-set">Requirements to libraries to be included in core set</a></li>
<li><a href="#the-base-package">The base package</a></li>
<li><a href="#other-packages">Other packages</a></li>
</ul></li>
<li><a href="#testing-1">Testing</a></li>
<li><a href="#implementation-specific-notes">Implementation-specific notes</a><ul>
<li><a href="#notes-about-ghc">Notes about GHC</a></li>
<li><a href="#notes-about-hugs">Notes about Hugs</a></li>
</ul></li>
</ul></li>
<li><a href="#commentary-the-package-system">Commentary: The Package System</a><ul>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#identifying-packages">Identifying Packages</a></li>
<li><a href="#design-constraints">Design constraints</a></li>
<li><a href="#the-plan-1">The Plan</a><ul>
<li><a href="#detecting-abi-incompatibility">Detecting ABI incompatibility</a></li>
<li><a href="#allowing-abi-compatibilty">Allowing ABI compatibilty</a></li>
</ul></li>
</ul></li>
<li><a href="#the-parser">The Parser</a><ul>
<li><a href="#principles">Principles</a></li>
<li><a href="#avoiding-right-recursion">Avoiding right-recursion</a></li>
<li><a href="#indentation">Indentation</a></li>
<li><a href="#syntax-extensions">Syntax extensions</a></li>
</ul></li>
<li><a href="#pinned-objects">Pinned Objects</a></li>
<li><a href="#overview-5">Overview</a></li>
<li><a href="#the-driver-pipeline">The driver pipeline</a></li>
<li><a href="#the-compiler-pipeline">The compiler pipeline</a></li>
<li><a href="#video">Video</a></li>
<li><a href="#platforms">Platforms</a><ul>
<li><a href="#limitations">Limitations</a></li>
<li><a href="#macros">Macros</a></li>
</ul></li>
<li><a href="#pointer-tagging-1">Pointer Tagging</a><ul>
<li><a href="#meaning-of-the-tag-bits">Meaning of the tag bits</a></li>
<li><a href="#optimisations-enabled-by-tag-bits">Optimisations enabled by tag bits</a></li>
<li><a href="#garbage-collection-with-tagged-pointers">Garbage collection with tagged pointers</a></li>
<li><a href="#invariants">Invariants</a></li>
<li><a href="#compacting-gc">Compacting GC</a></li>
<li><a href="#dealing-with-tags-in-the-code">Dealing with tags in the code</a></li>
</ul></li>
<li><a href="#position-independent-code-and-dynamic-linking">Position-Independent Code and Dynamic Linking</a><ul>
<li><a href="#how-to-access-symbols">How to access symbols</a></li>
<li><a href="#clabel.labeldynamic">CLabel.labelDynamic</a></li>
<li><a href="#info-tables-1">Info Tables</a></li>
<li><a href="#imported-labels-in-srts-windows">Imported labels in SRTs (Windows)</a></li>
<li><a href="#pic-and-dynamic-linking-support-in-the-ncg">PIC and dynamic linking support in the NCG</a></li>
<li><a href="#how-things-are-done-on-different-platforms">How things are done on different platforms</a><ul>
<li><a href="#position-dependent-code">Position dependent code</a></li>
<li><a href="#position-independent-code">Position independent code</a></li>
</ul></li>
<li><a href="#linking-on-elf">Linking on ELF</a></li>
<li><a href="#mangling-dynamic-library-names">Mangling dynamic library names</a></li>
</ul></li>
<li><a href="#ghc-commentary-the-c-code-generator">GHC Commentary: The C code generator</a><ul>
<li><a href="#header-files">Header files</a></li>
<li><a href="#prototypes">Prototypes</a></li>
</ul></li>
<li><a href="#primitive-operations-primops">Primitive Operations (PrimOps)</a><ul>
<li><a href="#the-primops.txt.pp-file">The primops.txt.pp file</a></li>
<li><a href="#implementation-of-primops">Implementation of PrimOps</a><ul>
<li><a href="#inline-primops">Inline PrimOps</a></li>
<li><a href="#out-of-line-primops">Out-of-line PrimOps</a></li>
</ul></li>
<li><a href="#adding-a-new-primop">Adding a new PrimOp</a></li>
</ul></li>
<li><a href="#profiling">Profiling</a><ul>
<li><a href="#cost-centre-profiling">Cost-centre profiling</a></li>
<li><a href="#ticky-ticky-profiling">Ticky-ticky profiling</a></li>
</ul></li>
<li><a href="#recompilation-avoidance">Recompilation Avoidance</a><ul>
<li><a href="#what-is-recompilation-avoidance">What is recompilation avoidance?</a></li>
<li><a href="#example-2">Example</a></li>
<li><a href="#why-do-we-need-recompilation-avoidance">Why do we need recompilation avoidance?</a></li>
<li><a href="#how-does-it-work">How does it work?</a><ul>
<li><a href="#deciding-whether-to-recompile">Deciding whether to recompile</a></li>
<li><a href="#example-3">Example</a></li>
<li><a href="#how-does-fingerprinting-work">How does fingerprinting work?</a></li>
<li><a href="#mutually-recursive-groups-of-entities">Mutually recursive groups of entities</a></li>
<li><a href="#fixities">Fixities</a></li>
<li><a href="#instances">Instances</a></li>
<li><a href="#orphans">Orphans</a></li>
<li><a href="#rules">Rules</a></li>
<li><a href="#on-ordering">On ordering</a></li>
<li><a href="#packages">Packages</a></li>
<li><a href="#package-version-changes">Package version changes</a></li>
</ul></li>
<li><a href="#interface-stability">Interface stability</a></li>
</ul></li>
<li><a href="#the-register-allocator-1">The Register Allocator</a><ul>
<li><a href="#overview-6">Overview</a></li>
<li><a href="#code-map">Code map</a></li>
<li><a href="#references-2">References</a></li>
<li><a href="#register-pressure-in-haskell-code">Register pressure in Haskell code</a></li>
<li><a href="#hackingdebugging">Hacking/Debugging</a></li>
<li><a href="#runtime-performance">Runtime performance</a></li>
<li><a href="#possible-improvements">Possible Improvements</a></li>
</ul></li>
<li><a href="#haskell-excecution-registers">Haskell Excecution: Registers</a></li>
<li><a href="#relevant-ghc-parts-for-demand-analysis-results">Relevant GHC parts for Demand Analysis results</a></li>
<li><a href="#remembered-sets">Remembered Sets</a><ul>
<li><a href="#remembered-set-maintenance-during-mutation">Remembered set maintenance during mutation</a><ul>
<li><a href="#thunk-updates">Thunk Updates</a></li>
<li><a href="#mutable-objects-mut_var-mvar">Mutable objects: MUT_VAR, MVAR</a></li>
<li><a href="#arrays-mut_arr_ptrs">Arrays: MUT_ARR_PTRS</a></li>
<li><a href="#threads-tso">Threads: TSO</a></li>
</ul></li>
<li><a href="#remembered-set-maintenance-during-gc">Remembered set maintenance during GC</a></li>
</ul></li>
<li><a href="#the-renamer">The renamer</a><ul>
<li><a href="#unused-imports">Unused imports</a></li>
<li><a href="#name-space-management">Name Space Management</a></li>
<li><a href="#rebindable-syntax">Rebindable syntax</a></li>
</ul></li>
<li><a href="#replacing-the-native-code-generator">Replacing the Native Code Generator</a></li>
<li><a href="#resource-limits">Resource Limits</a><ul>
<li><a href="#code-generation-changes">Code generation changes</a><ul>
<li><a href="#dynamic-closure-allocation">Dynamic closure allocation</a></li>
<li><a href="#caf-allocation">CAF Allocation</a></li>
<li><a href="#thunk-code">Thunk code</a></li>
<li><a href="#foreign-calls">Foreign calls</a></li>
</ul></li>
<li><a href="#case-split">Case split</a></li>
<li><a href="#front-end-changes">Front-end changes</a></li>
</ul></li>
<li><a href="#garbage-collection-roots">Garbage Collection Roots</a></li>
<li><a href="#ghc-source-tree-roadmap-rts">GHC Source Tree Roadmap: rts/</a><ul>
<li><a href="#subdirectories-of-rts">Subdirectories of rts/</a></li>
<li><a href="#haskell-execution">Haskell Execution</a></li>
<li><a href="#the-wikicommentaryrtsstorage-storage-manager">The [wiki:Commentary/Rts/Storage Storage Manager]</a></li>
<li><a href="#data-structures">Data Structures</a></li>
<li><a href="#the-wikicommentaryrtsscheduler-scheduler">The [wiki:Commentary/Rts/Scheduler Scheduler]</a></li>
<li><a href="#c-files-the-wikicommentaryrtsffi-ffi">C files: the [wiki:Commentary/Rts/FFI FFI]</a></li>
<li><a href="#the-wikicommentaryrtsinterpreter-byte-code-interpreter">The [wiki:Commentary/Rts/Interpreter Byte-code Interpreter]</a></li>
<li><a href="#wikicommentaryprofiling-profiling">[wiki:Commentary/Profiling Profiling]</a></li>
<li><a href="#rts-debugging">RTS Debugging</a></li>
<li><a href="#the-front-panel">The Front Panel</a></li>
<li><a href="#other">Other</a></li>
<li><a href="#old-stuff">OLD stuff</a></li>
</ul></li>
<li><a href="#sanity-checking">Sanity Checking</a></li>
<li><a href="#the-scheduler">The Scheduler</a><ul>
<li><a href="#os-threads">OS Threads</a></li>
<li><a href="#haskell-threads">Haskell threads</a></li>
</ul></li>
<li><a href="#seq-magic">Seq magic</a><ul>
<li><a href="#the-baseline-position">The baseline position</a><ul>
<li><a href="#problem-1-trac-1031">Problem 1 (Trac #1031)</a></li>
<li><a href="#problem-2-trac-2273">Problem 2 (Trac #2273)</a></li>
<li><a href="#problem-3-trac-5262">Problem 3 (Trac #5262)</a></li>
<li><a href="#problem-4-seq-in-the-io-monad">Problem 4: seq in the IO monad</a></li>
<li><a href="#problem-5-the-need-for-special-rules">Problem 5: the need for special rules</a></li>
</ul></li>
</ul></li>
<li><a href="#a-better-way">A better way</a></li>
<li><a href="#the-ghc-commentary-signals">The GHC Commentary: Signals</a><ul>
<li><a href="#signal-handling-in-the-rts">Signal handling in the RTS</a><ul>
<li><a href="#the-timer-signal">The timer signal</a></li>
</ul></li>
<li><a href="#the-interrupt-signal">The interrupt signal</a></li>
<li><a href="#signal-handling-in-haskell-code">Signal handling in Haskell code</a></li>
<li><a href="#rts-alarm-signals-and-foreign-libraries">RTS Alarm Signals and Foreign Libraries</a></li>
</ul></li>
<li><a href="#slop">Slop</a><ul>
<li><a href="#why-do-we-want-to-avoid-slop">Why do we want to avoid slop?</a></li>
<li><a href="#how-does-slop-arise">How does slop arise?</a></li>
<li><a href="#what-do-we-do-about-it">What do we do about it?</a></li>
</ul></li>
<li><a href="#layout-of-important-files-and-directories">Layout of important files and directories</a><ul>
<li><a href="#stuff-that-appears-only-in-a-build-tree">Stuff that appears only in a build tree</a></li>
<li><a href="#stack-layout-1">Stack Layout</a><ul>
<li><a href="#representing-stack-slots">Representing Stack Slots</a></li>
<li><a href="#laying-out-the-stack">Laying out the stack</a></li>
<li><a href="#a-greedy-algorithm">A greedy algorithm</a></li>
</ul></li>
</ul></li>
<li><a href="#layout-of-the-stack">Layout of the stack</a><ul>
<li><a href="#info-tables-for-stack-frames">Info tables for stack frames</a></li>
<li><a href="#layout-of-the-payload">Layout of the payload</a></li>
<li><a href="#kinds-of-stack-frame">Kinds of Stack Frame</a></li>
</ul></li>
<li><a href="#the-stg-syntax-data-types">The STG syntax data types</a></li>
<li><a href="#ghc-commentary-software-transactional-memory-stm">GHC Commentary: Software Transactional Memory (STM)</a></li>
<li><a href="#background">Background</a><ul>
<li><a href="#definitions">Definitions</a><ul>
<li><a href="#useful-rts-terms">Useful RTS terms</a></li>
<li><a href="#transactional-memory-terms">Transactional Memory terms</a></li>
</ul></li>
</ul></li>
<li><a href="#overview-of-features">Overview of Features</a><ul>
<li><a href="#reading-and-writing">Reading and Writing</a></li>
<li><a href="#blocking">Blocking</a></li>
<li><a href="#choice">Choice</a></li>
<li><a href="#data-invariants">Data Invariants</a></li>
<li><a href="#exceptions">Exceptions</a></li>
</ul></li>
<li><a href="#overview-of-the-implementation">Overview of the Implementation</a><ul>
<li><a href="#transactions-that-read-and-write.">Transactions that Read and Write.</a><ul>
<li><a href="#transactional-record">Transactional Record</a></li>
<li><a href="#starting">Starting</a></li>
<li><a href="#reading">Reading</a></li>
<li><a href="#writing">Writing</a></li>
<li><a href="#validation">Validation</a></li>
<li><a href="#committing">Committing</a></li>
<li><a href="#aborting">Aborting</a></li>
<li><a href="#exceptions-1">Exceptions</a></li>
</ul></li>
<li><a href="#invariants-1">Invariants</a><ul>
<li><a href="#details">Details</a></li>
<li><a href="#changes-from-choice">Changes from Choice</a></li>
</ul></li>
<li><a href="#other-details">Other Details</a><ul>
<li><a href="#detecting-long-running-transactions">Detecting Long Running Transactions</a></li>
<li><a href="#transaction-state">Transaction State</a></li>
<li><a href="#gc-and-aba">GC and ABA</a></li>
<li><a href="#tokens-and-version-numbers.">Tokens and Version Numbers.</a></li>
<li><a href="#implementation-invariants">Implementation Invariants</a></li>
<li><a href="#fine-grain-locking">Fine Grain Locking</a></li>
</ul></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul></li>
<li><a href="#ghc-commentary-storage">GHC Commentary: Storage</a></li>
<li><a href="#general-overview">General overview</a></li>
<li><a href="#important-note">IMPORTANT NOTE</a></li>
<li><a href="#the-demand-analyzer">The demand analyzer</a><ul>
<li><a href="#important-datatypes">Important datatypes</a></li>
</ul></li>
<li><a href="#symbol-names">Symbol Names</a><ul>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#unboxed-tuples">Unboxed Tuples</a></li>
<li><a href="#alphanumeric-characters">Alphanumeric Characters</a></li>
<li><a href="#constructor-characters">Constructor Characters</a></li>
<li><a href="#variable-characters">Variable Characters</a></li>
<li><a href="#other-1">Other</a></li>
<li><a href="#examples">Examples</a></li>
</ul></li>
<li><a href="#the-monad-for-renaming-typechecking-desugaring">The monad for renaming, typechecking, desugaring</a></li>
<li><a href="#kirstens-sketchy-notes-on-getting-ticky-to-work">Kirsten's sketchy notes on getting ticky to work</a></li>
<li><a href="#the-ghc-commentary-checking-types">The GHC Commentary: Checking Types</a><ul>
<li><a href="#the-overall-flow-of-things">The Overall Flow of Things</a><ul>
<li><a href="#entry-points-into-the-type-checker">Entry Points Into the Type Checker</a></li>
<li><a href="#renaming-and-type-checking-a-module">Renaming and Type Checking a Module</a></li>
</ul></li>
<li><a href="#type-checking-a-declaration-group">Type Checking a Declaration Group</a></li>
<li><a href="#type-checking-type-and-class-declarations">Type checking Type and Class Declarations</a></li>
<li><a href="#more-details">More Details</a><ul>
<li><a href="#types-variables-and-zonking">Types Variables and Zonking</a></li>
<li><a href="#type-representation">Type Representation</a></li>
<li><a href="#type-checking-environment">Type Checking Environment</a></li>
<li><a href="#expressions-1">Expressions</a></li>
<li><a href="#handling-of-dictionaries-and-method-instances">Handling of Dictionaries and Method Instances</a></li>
</ul></li>
<li><a href="#connection-with-ghcs-constraint-solver">Connection with GHC's Constraint Solver</a></li>
<li><a href="#generating-evidence">Generating Evidence</a></li>
<li><a href="#the-solver">The Solver</a><ul>
<li><a href="#given-constraints">Given Constraints</a></li>
<li><a href="#derived-constraints">Derived Constraints</a></li>
<li><a href="#wanted-constraints">Wanted Constraints</a></li>
</ul></li>
<li><a href="#views-of-types">Views of types</a></li>
<li><a href="#overloaded-types">Overloaded types</a></li>
<li><a href="#classifying-types">Classifying types</a></li>
<li><a href="#unique">Unique</a></li>
<li><a href="#current-design">Current design</a><ul>
<li><a href="#known-key-things">Known-key things</a></li>
<li><a href="#interface-files-1">Interface files</a></li>
</ul></li>
<li><a href="#redesign-2014">Redesign (2014)</a></li>
</ul></li>
<li><a href="#unpacking-primitive-fields">Unpacking primitive fields</a><ul>
<li><a href="#goals-and-non-goals">Goals and non-goals</a></li>
<li><a href="#detailed-design">Detailed design</a></li>
<li><a href="#benchmarks">Benchmarks</a></li>
</ul></li>
<li><a href="#unused-imports-1">Unused imports</a><ul>
<li><a href="#the-current-story">The current story</a></li>
<li><a href="#examples-1">Examples</a></li>
<li><a href="#specfication">Specfication</a></li>
<li><a href="#implementation-1">Implementation</a></li>
<li><a href="#algorithm">Algorithm</a></li>
</ul></li>
<li><a href="#updates">Updates</a></li>
<li><a href="#the-user-manual">The user manual</a></li>
<li><a href="#ghc-boot-library-version-history">GHC Boot Library Version History</a></li>
<li><a href="#ghc-commentary-weak-pointers-and-finalizers">GHC Commentary: Weak Pointers and Finalizers</a></li>
<li><a href="#work-in-progress-on-the-llvm-backend">Work in Progress on the LLVM Backend</a><ul>
<li><a href="#llvm-ir-representation">LLVM IR Representation</a></li>
<li><a href="#tables_next_to_code">TABLES_NEXT_TO_CODE</a></li>
<li><a href="#llvm-alias-analysis-pass">LLVM Alias Analysis Pass</a></li>
<li><a href="#optimise-llvm-for-the-type-of-code-ghc-produces">Optimise LLVM for the type of Code GHC produces</a></li>
<li><a href="#update-the-back-end-to-use-the-new-cmm-data-types-new-code-generator">Update the Back-end to use the new Cmm data types / New Code Generator</a></li>
<li><a href="#llvms-link-time-optimisations">LLVM's Link Time Optimisations</a></li>
<li><a href="#llvm-cross-compiler-port">LLVM Cross Compiler / Port</a></li>
<li><a href="#get-rid-of-proc-point-splitting">Get rid of Proc Point Splitting</a></li>
<li><a href="#dont-pass-around-dead-stg-registers">Don't Pass Around Dead STG Registers</a></li>
</ul></li>
<li><a href="#wired-in-and-known-key-things">Wired-in and known-key things</a><ul>
<li><a href="#wired-in-things">Wired-in things</a></li>
<li><a href="#known-key-things-1">Known-key things</a></li>
<li><a href="#initialisation">Initialisation</a></li>
</ul></li>
<li><a href="#ghc-commentary-the-word">GHC Commentary: The Word</a></li>
</ul>
</div>
<h1 id="ghc-source-code-abbreviations">GHC Source Code Abbreviations</h1>
<p>Certain abbreviations are used pervasively throughout the GHC source code. This page gives a partial list of them and their expansion:</p>
<ul>
<li><strong>ANF</strong>: A-normal form</li>
</ul>
<ul>
<li><strong>CAF</strong>: Constant Applicative Form</li>
</ul>
<ul>
<li><strong>Class</strong>: Type Class</li>
</ul>
<ul>
<li><strong>Cmm</strong>: The final IR used in GHC, based on the C-- language</li>
</ul>
<ul>
<li><strong>Core</strong>: GHC core language. Based on System FC (variant of System F). Represents a type-checked and desugared program in some (out of several) intermediate compilation step</li>
</ul>
<ul>
<li><strong>CoreFV</strong>: Free variables in core</li>
</ul>
<ul>
<li>'''CoreLint''': Type and sanity-checking of core. (Lint: Jargon for a program analysis that looks for bug-suspicious code.)</li>
</ul>
<ul>
<li>'''CoreSubst''': Substitution in core</li>
</ul>
<ul>
<li>'''CoreSyn''': Core abstract syntax</li>
</ul>
<ul>
<li>'''DataCon''': Data constructor</li>
</ul>
<ul>
<li><strong>Ds</strong>: Desugarer</li>
</ul>
<ul>
<li><strong>Gbl</strong>: Global</li>
</ul>
<ul>
<li><strong>Hs</strong>: Haskell Syntax (generally as opposed to Core, for example, Expr vs HsExpr)</li>
</ul>
<ul>
<li><strong>Hsc</strong>: Haskell compiler. Means it Deals with compiling a single module and no more.</li>
</ul>
<ul>
<li>'''HsSyn''': Haskell abstract syntax</li>
</ul>
<ul>
<li><strong>Id</strong>: Synonym for Var, but indicating a term variable</li>
</ul>
<ul>
<li><strong>Iface</strong>: Interface, as in Haskell interface (.hi) files</li>
</ul>
<ul>
<li>'''IfaceSyn''': Interface abstract syntax</li>
</ul>
<ul>
<li><strong>LHs</strong>: Located Haskell something</li>
</ul>
<ul>
<li><strong>Loc</strong>: Location, as in SrcLoc</li>
</ul>
<ul>
<li><strong>Located</strong>: Something annotated with a SrcSpan</li>
</ul>
<ul>
<li><strong>Lcl</strong>: Local</li>
</ul>
<ul>
<li><strong>nativeGen</strong>: Native code generator (generates assembly from Cmm)</li>
</ul>
<ul>
<li><strong>Occ</strong>: Occurrence</li>
<li>However, in the context of <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/RdrNameType#TheOccNametype">OccName</a>, &quot;occurrence&quot; actually means &quot;classified (i.e. as a type name, value name, etc) but not qualified and not yet resolved&quot;</li>
</ul>
<ul>
<li><strong>PId</strong>: Package ID</li>
</ul>
<ul>
<li>'''PprCore''': Pretty-printing core</li>
</ul>
<ul>
<li><strong>Rdr</strong>: Parser (or reader)</li>
</ul>
<ul>
<li><strong>Rn</strong>: Rename or Renamer</li>
</ul>
<ul>
<li><strong>Rts</strong>: Run Time System</li>
</ul>
<ul>
<li>'''SimplCore''': Simplify core (the so-called simplifier belongs to this, as does the strictness analyser)</li>
</ul>
<ul>
<li>'''SrcLoc''': Source location (filename, line number, character position)</li>
</ul>
<ul>
<li>'''SrcSpan''': Source location span (filename, start line number and character position, end line number and character position)</li>
</ul>
<ul>
<li><strong>STG</strong>: [Commentary/Compiler/StgSynType Spineless Tagless G-machine]</li>
</ul>
<ul>
<li><strong>Tc</strong>: TypeCheck{ing,er}</li>
</ul>
<ul>
<li><strong>TSO</strong>: <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#ThreadStateObjects">Thread State Object</a></li>
</ul>
<ul>
<li>'''TyCon''': Type constructor</li>
</ul>
<ul>
<li>'''TyThing''': Something that is type-checkable</li>
</ul>
<ul>
<li><strong>Ty</strong>: Type</li>
</ul>
<ul>
<li>'''TyVar''': Synonym for Var, but indicating a type variable</li>
</ul>
<ul>
<li><strong>Var</strong>: A variable with some information about its type (or kind)</li>
</ul>
<h1 id="aging-in-the-generational-gc">Aging in the generational GC</h1>
<p>Aging is an important technique in generational GC: the idea is that objects that have only recently been allocated have not had sufficient chance to die, and so promoting them immediately to the next generation may lead to retention of unnecessary data. The problem is amplified if the prematurely promoted objects are thunks that are subsequently updated, leading to retention of an arbitrary amount of live data until the next collection of the old generation, which may be a long time coming.</p>
<p>The idea is that instead of promoting live objects directly from generation 0 into generation 1, they stay in generation 0 for a &quot;while&quot;, and if they live long enough, they get promoted. The simplest way is to segment the objects in generation 0 by the number of collections they have survived, up to a maximum. GHC 6.12 used to do this: each generation had a tunable number of <em>steps</em>. Objects were initially promoted to step 0, copied through each subsequent step on following GC cycles, and then eventually promoted to the next generation.</p>
<p>Measurement we made showed that the optimal number of steps was somewhere between 1 and 3 (2 was almost always better than either 1 or 3). In priniciple it is possible to have a fractional number of steps, although GHC 6.12 only supported integral numbers.</p>
<p>In GHC 6.13 and later, we made the following change: each block now points to the generation to which objects in that block will be copied in the next GC (the</p>
<pre><code>dest` field of `bdescr</code></pre>
<p>). This lets us decide on a block-by-block basis which objects to promote and which to retain in a generation, and lets us implement fractional numbers of steps. At the same time, we dropped the notion of explicit steps, so each generation just has a single list of blocks. This means that we can no longer do aging of more than 2 GC cycles, but since the measurements showed that this was unlikely to be beneficial, and the new structure is much simpler, we felt it was worthwhile.</p>
<p>Blocks in the nursery have a</p>
<pre><code>dest` field pointing to generation 0, and blocks of live objects in generation 0 have a `dest</code></pre>
<p>field pointing to generation 1. This gives us the same effect as 2 steps did in the GHC 6.12, except that intermediate generations (e.g. gen 1 in a 3-gen setup) now only have one step rather than 2. We could implement aging in the intermediate generations too if that turns out to be beneficial (more than 2 generations is rarely better than 2, according to our measurements).</p>
<h1 id="improving-llvm-alias-analysis">Improving LLVM Alias Analysis</h1>
<p>This page tracks the information and progress relevant to improving the alias analysis pass for the LLVM backend of GHC.</p>
<p>This correspond to bug #5567.</p>
<h2 id="llvm-alias-analysis-infrastructure">LLVM Alias Analysis Infrastructure</h2>
<p>Some links to the various documentation on LLVM's AA support:</p>
<ul>
<li><a href="http://llvm.org/docs/AliasAnalysis.html">LLVM Alias Analysis Infrastructure</a></li>
<li><a href="http://llvm.org/docs/Passes.html">LLVM's Analysis and Transform Passes</a></li>
<li><a href="http://llvm.org/docs/GetElementPtr.html">The Often Misunderstood GEP Instruction</a></li>
<li><a href="http://llvm.org/docs/LangRef.html">LLVM Language Reference</a></li>
<li><a href="http://groups.google.com/group/llvm-dev/browse_thread/thread/2a5944692508bcc2/363c96bb1c6a506d?show_docid=363c96bb1c6a506d&amp;pli=1">LLVM Dev List: Comparison of Alias Analysis in LLVM</a></li>
</ul>
<h2 id="maxs-work">Max's Work</h2>
<p>Max had a crack at writing a custom alias analysis pass for LLVM, relevant links are:</p>
<ul>
<li><a href="http://lists.cs.uiuc.edu/pipermail/llvmdev/2011-September/043603.html">Email to LLVM dev</a></li>
<li><a href="http://blog.omega-prime.co.uk/?p=135">Blog post about results</a></li>
<li><a href="https://github.com/bgamari/ghc-llvm-analyses">A port to LLVM 3.6</a></li>
</ul>
<h2 id="tbaa">TBAA</h2>
<p>LLVM as of version 2.9 includes Type Based Alias Analysis. This mean using metadata you can specify a type hierarchy (with alias properties between types) and annotate your code with these types to improve the alias information. This should allow us to improve the alias analysis without any changes to LLVM itself like Max made.</p>
<ul>
<li><a href="http://llvm.org/docs/LangRef.html#tbaa">LLVM TBBA Doc</a></li>
</ul>
<h2 id="stg-cmm-alias-properties">STG / Cmm Alias Properties</h2>
<p><strong>Question</strong> (David Terei): What alias properties does the codegen obey? Sp and Hp never alias? R<n> registers never alias? ....</p>
<p><strong>Answer</strong> (Simon Marlow): Sp[] and Hp[] never alias, R[] never aliases with Sp[], and that's about it.</p>
<pre><code>I64[ Sp + n ] = &quot;stack&quot;

I64[ Base + n ] = &quot;base&quot;

I64[ Hp + n ] = &quot;heap&quot;
I64[ R1 + n ] = &quot;heap&quot;

I64[ I64[Sp + n]  ] = &quot;heap&quot;
I64[ I64[Sp + n] + m  ] = &quot;heap&quot;

I64[ I64[R1 + n] ] = &quot;heap&quot;
I64[ I64[R1 + n] + m ] = &quot;heap&quot;
I64[ I64[Sp + n] +  I64 [R1 + n] ] = &quot;heap&quot;</code></pre>
<p><em>' Simon</em>': As long as it propagates properly, such that every F(Sp) is a stack pointer, where F() is any expression context except a dereference. That is, we better be sure that</p>
<pre><code>I64[Sp + R1[n]]</code></pre>
<p>is &quot;stack&quot;, not &quot;heap&quot;.</p>
<h2 id="how-to-track-tbaa-information">How to Track TBAA information</h2>
<p>Really to be sound and support Cmm in full we would need to track and propagate TBAA information. It's Types after all! At the moment we don't. We simply rely on the fact that the Cmm code generated for loads and stores is nearly always in the form of:</p>
<pre><code>I64[ Sp ... ] = ...</code></pre>
<p>That is to say, it has the values it depends on for the pointer derivation in-lined in the load or store expression. It is very rarely of the form:</p>
<pre><code>x = Sp + 8
I64[x] = ...</code></pre>
<p>And when it is, 'it is' (unconfirmed) always deriving a &quot;heap&quot; pointer, &quot;stack&quot; pointers are always of the in-line variety. This assumption if true allows us to look at just a store or load in isolation to properly Type it.</p>
<p>There are two ways to type this 'properly'.</p>
<p>1. Do data flow analysis. This is the only proper way to do it but also annoying. 2. Do block local analysis. Instead of doing full blow data flow analysis, just track the type of pointers stored to CmmLocal regs at the block level. This is safe but just may miss some opportunities when a CmmLocal's value is assigned in another block... My hunch is this is quite rare so this method should be fairly effective (and easier to implement and quicker to run that 1.)</p>
<h2 id="llvm-type-system">LLVM type system</h2>
<p>The above aliasing information can be encoded as follows:</p>
<pre><code>&lt;nowiki&gt;0&lt;/nowiki&gt; = metadata &lt;nowiki&gt;{&lt;/nowiki&gt; metadata &lt;nowiki&gt;&quot;top&quot;&lt;/nowiki&gt; }
&lt;nowiki&gt;1&lt;/nowiki&gt; = metadata &lt;nowiki&gt;{&lt;/nowiki&gt; metadata &lt;nowiki&gt;&quot;heap&quot;,&lt;/nowiki&gt; metadata &lt;nowiki&gt;0&lt;/nowiki&gt; }
&lt;nowiki&gt;2&lt;/nowiki&gt; = metadata &lt;nowiki&gt;{&lt;/nowiki&gt; metadata &lt;nowiki&gt;&quot;stack&quot;,&lt;/nowiki&gt; metadata &lt;nowiki&gt;0&lt;/nowiki&gt; }
&lt;nowiki&gt;3&lt;/nowiki&gt; = metadata &lt;nowiki&gt;{&lt;/nowiki&gt; metadata &lt;nowiki&gt;&quot;rx&quot;,&lt;/nowiki&gt; metadata &lt;nowiki&gt;1&lt;/nowiki&gt; }
&lt;nowiki&gt;4&lt;/nowiki&gt; = metadata &lt;nowiki&gt;{&lt;/nowiki&gt; metadata &lt;nowiki&gt;&quot;base&quot;,&lt;/nowiki&gt; metadata &lt;nowiki&gt;0&lt;/nowiki&gt; }
&lt;nowiki&gt;5&lt;/nowiki&gt; = metadata &lt;nowiki&gt;{&lt;/nowiki&gt; metadata &lt;nowiki&gt;&quot;other&quot;,&lt;/nowiki&gt; metadata &lt;nowiki&gt;0&lt;/nowiki&gt; }</code></pre>
<p>The fact that</p>
<pre><code>R[]` never aliases with `Sp[]</code></pre>
<p>is never used as the one way relation isn't expressible in LLVM.</p>
<p>Stores/loads needs to be annotated with</p>
<pre><code>&lt;nowiki&gt;tbaa</code></pre>
<p></nowiki> and one of the above four types e.g.</p>
<pre><code>%ln1NH1 = load i64* %Sp_Arg, align 8, &lt;nowiki&gt;tbaa&lt;/nowiki&gt; &lt;nowiki&gt;2&lt;/nowiki&gt;</code></pre>
<h2 id="problems-optmisations-to-solve">Problems / Optmisations to Solve</h2>
<h3 id="llvm-optimisations">LLVM Optimisations</h3>
<p>Roman reported that running 'opt -std-compile-opts' gives much better code than running 'opt -O3'.</p>
<p><strong>Following is from Roman Leschinskiy</strong></p>
<p>'-O2 -std-compile-opts' does the trick but it's obviously overkill because it essentially executes the whole optimisation pipeline twice. The crucial passes seem to be loop rotation and loop invariant code motion. These are already executed twice by -O2 but it seems that they don't have enough information then and that something interesting happens in later passes which allows them to work much better the third time.</p>
<h3 id="safe-loads-speculative-load">Safe Loads (speculative load)</h3>
<p>We want to allow LLVM to speculatively hoist loads out of conditional blocks. Relevant LLVM source code is here:</p>
<ul>
<li><a href="http://llvm.org/docs/doxygen/html/SimplifyCFG_8cpp_source.html">SimplifyCFG Source Code</a></li>
<li><a href="http://llvm.org/docs/doxygen/html/namespacellvm.html#a4899ff634bf732c16dd22ecfdafdea7d">llvm::isSafeToSpeculativelyExecute</a></li>
<li><a href="http://lists.cs.uiuc.edu/pipermail/llvmdev/2012-January/046958.html">LLVM Mailing List Discussion about 'Safe loads'</a></li>
</ul>
<p><strong>Following is from Roman Leshchinskiy</strong></p>
<p>I've poked around a bit and things are rather complicated. So far I've identified two problems. Here is a small example function:</p>
<pre><code> foo as n = loop 0# 0.0##
  where
    loop i x
      | i &gt;=# n = (# x, I# i #)
* # indexDoubleArray# as i)</code></pre>
<p>This is the interesting C-- bit:</p>
<pre><code> saH_ret()
    cb0:
        Hp = Hp + 8;
        if (Hp &gt; I32[BaseReg + 92]) goto cb5;
        ;
        if (%MO_S_Ge_W32(R1, I32[Sp + 16])) goto cb9;
        _saO::I32 = R1 + 1;
        F64[Sp + 0] = %MO_F_Mul_W64(F64[Sp + 0],
                                    F64[I32[Sp + 12] + ((R1 &lt;&lt; 3) + 8)]);
        R1 = _saO::I32;
        Hp = Hp - 8;
        jump saH_info; // [R1]</code></pre>
<p>Look at what indexDoubleArray# compiles to: F64[I32[Sp + 12] + ((R1 &lt;&lt; 3) + 8)]. We would very much like LLVM to hoist the I32[Sp+12] bit (i.e., loading the pointer to the ByteArray data) out of the loop because that might allow all sorts of wonderful optimisation such as promoting it to a register. But alas, this doesn't happen, LLVM leaves the load in the loop. Why? Because it assumes that the load might fail (for instance, if Sp is NULL) and so can't move it past conditionals. We know, of course, that this particular load can't fail and so can be executed speculatively but there doesn't seem to be a way of communicating this to LLVM.</p>
<p>As a quick experiment, I hacked LLVM to accept &quot;safe&quot; annotations on loads and then manually annotated the LLVM assembly generated by GHC and that helped quite a bit. I suppose that's the way to go - we'll have to get this into LLVM in some form and then the backend will have to generate those annotations for loads which can't fail. I assume they are loads through the stack pointer and perhaps the heap pointer unless we're loading newly allocated memory (those loads can't be moved past heap checks). In any case, the stack pointer is the most important thing. I can also imagine annotating pointers (such as Sp) rather than instructions but that doesn't seem to be the LLVM way and it's also less flexible.</p>
<h3 id="ghc-heap-check-case-merging">GHC Heap Check (case merging)</h3>
<p>See bug #1498</p>
<p><strong>Following is from Roman Leshchinskiy</strong></p>
<p>I investigated heap check a bit more and it seems to me that it's largely GHC's fault. LLVM does do loop unswitching which correctly pulls out loop-invariant heap checks but that happens fairly late in its pipeline and heap checks interfere with optimisations before that.</p>
<p>However, we really shouldn't be generating those heap checks in the first place. Here is a small example loop:</p>
<pre><code> foo as n = loop 0# 0.0##
  where
    loop i x
      | i &gt;=# n = (# (), D# x #)
* # indexDoubleArray# as i)</code></pre>
<p>This is the C-- that GHC generates:</p>
<pre><code> sep_ret()
    ceO:
        Hp = Hp + 12;
        if (Hp &gt; I32[BaseReg + 92]) goto ceT;

        if (%MO_S_Ge_W32(R1, I32[Sp + 16])) goto ceX;

        _seA::I32 = R1 + 1;
        F64[Sp + 0] = %MO_F_Mul_W64(F64[Sp + 0], F64[I32[Sp + 12] + ((R1 &lt;&lt; 3) + 8)]);
        R1 = _seA::I32;
        Hp = Hp - 12;
        jump sep_info ();
    ceT:
        I32[BaseReg + 112] = 12;
        goto ceR;
    ceR:
        I32[Sp + 8] = sep_info;
        I32[BaseReg + 32] = 131327;
        jump stg_gc_ut ();
    ceX:
        I32[Hp - 8] = GHC.Types.D#_con_info;
        F64[Hp - 4] = F64[Sp + 0];
        I32[Sp + 16] = Hp - 7;
        R1 = GHC.Unit.()_closure+1;
        Sp = Sp + 16;
        jump (I32[Sp + 4]) ();</code></pre>
<p>Note how in each loop iteration, we add 12 to Hp, then do the heap check and then subtract 12 from Hp again. I really don't think we should be generating that and then relying on LLVM to optimise it away.</p>
<p>This happens because GHC commons up heap checks for case alternatives and does just one check before evaluating the case. The relevant comment from CgCase.lhs is this:</p>
<p>A more interesting situation is this:</p>
<pre><code>          &lt;nowiki&gt;A!;&lt;/nowiki&gt;
          ...A...
          case x# of
            0#      -&gt; &lt;nowiki&gt;B!;&lt;/nowiki&gt; ...B...
            default -&gt; &lt;nowiki&gt;C!;&lt;/nowiki&gt; ...C...</code></pre>
<p>where x! indicates a possible heap-check point. The heap checks in the alternatives <strong>can</strong> be omitted, in which case the topmost heapcheck will take their worst case into account.</p>
<p>This certainly makes sense if A allocates. But with vector-based code at least, a lot of the time neither A nor C will allocate <strong>and</strong> C will tail-call A again so by pushing the heap check into A!, we are now doing it <strong>in</strong> the loop rather than at the end.</p>
<p>It seems to me that we should only do this if A actually allocates and leave the heap checks in the alternatives if it doesn't (perhaps we could also use a common heap check if <strong>all</strong> alternatives allocate). I tried to hack this and see what happens but found the code in CgCase and friends largely incomprehensible. What would I have to change to implement this (perhaps controlled by a command line flag) and is it a good idea at all?</p>
<h1 id="ghc-commentary-the-ghc-api">GHC Commentary: The GHC API</h1>
<p>This section of the commentary describes everything between [wiki:Commentary/Compiler/HscMain HscMain] and the front-end; that is, the parts of GHC that coordinate the compilation of multiple modules.</p>
<p>The GHC API is rather stateful; the state of an interaction with GHC is stored in an abstract value of type</p>
<pre><code>GHC.Session</code></pre>
<p>. The only fundamental reason for this choice is that the</p>
<pre><code>Session</code></pre>
<p>models the state of the RTS's linker, which must be single-threaded.</p>
<p>Although the GHC API apparently supports multiple clients, because each can be interacting with a different</p>
<pre><code>Session</code></pre>
<p>, in fact it only supports one client that is actually executing code, because the [wiki:Commentary/Rts/Interpreter#Linker RTS linker] has a single global symbol table.</p>
<p>This part of the commentary is not a tutorial on <em>using</em> the GHC API: for that, see <a href="http://haskell.org/haskellwiki/GHC/As_a_library">Using GHC as a Library</a>. Here we are going to talk about the implementation.</p>
<p>A typical interaction with the GHC API goes something like the following:</p>
<ul>
<li>You probably want to wrap the whole program in
<pre><code>defaultErrorHandler defaultDynFlags</code></pre>
<p>to get error messages</p></li>
<li>Create a new session:
<pre><code>newSession</code></pre></li>
<li>Set the flags:
<pre><code>getSessionDynFlags</code></pre>
<p>,</p>
<pre><code>setSessionDynFlags</code></pre>
<p>.</p></li>
<li>Add some <em>targets</em>:
<pre><code>setTargets</code></pre>
<p>,</p>
<pre><code>addTarget</code></pre>
<p>,</p>
<pre><code>guessTarget</code></pre></li>
<li>Perform <a href="ref(Dependency_Analysis)" title="wikilink">ref(Dependency Analysis)</a>:
<pre><code>depanal</code></pre></li>
<li>Load (compile) the source files:
<pre><code>load</code></pre></li>
</ul>
<p>Warning: Initializing GHC is tricky! Here is a template that seems to initialize GHC and a session. Derived from ghc's Main.main function.</p>
<pre><code>import DynFlags
import GHC

mode = Interactive

main = defaultErrorHandler defaultDynFlags $ do
  s &lt;- newSession mode (Just &quot;/usr/local/lib/ghc-6.5&quot;)
  flags &lt;- getSessionDynFlags s
  (flags, _) &lt;- parseDynamicFlags flags []
  GHC.defaultCleanupHandler flags $ do
    setSessionDynFlags s flags{ hscTarget=HscInterpreted }
    -- your code here</code></pre>
<p>You must pass the path to</p>
<pre><code>package.conf</code></pre>
<p>as an argument to</p>
<pre><code>newSession</code></pre>
<p>.</p>
<p>The</p>
<pre><code>hscTarget</code></pre>
<p>field of</p>
<pre><code>DynFlags</code></pre>
<p>tells the compiler what kind of output to generate from compilation. There is unfortunately some overlap between this and the</p>
<pre><code>GhcMode</code></pre>
<p>passed to</p>
<pre><code>newSession</code></pre>
<p>; we hope to clean this up in the future, but for now it's probably a good idea to make sure that these two settings are consisent. That is, if</p>
<pre><code>mode==Interactive</code></pre>
<p>, then</p>
<pre><code>hscTarget==Interpreted</code></pre>
<p>, if</p>
<pre><code>mode==JustTypecheck</code></pre>
<p>then</p>
<pre><code>hscTarget==HscNothing</code></pre>
<p>.</p>
<h2 id="targets">Targets</h2>
<p>The targets specify the source files or modules at the top of the dependency tree. For a Haskell program there is often just a single target</p>
<pre><code>Main.hs</code></pre>
<p>, but for a library the targets would consist of every visible module in the library.</p>
<p>The</p>
<pre><code>Target</code></pre>
<p>type is defined in <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a>. Note that a</p>
<pre><code>Target</code></pre>
<p>includes not just the file or module name, but also optionally the complete source text of the module as a</p>
<pre><code>StringBuffer</code></pre>
<dl>

<dd>this is to support an interactive development environment where the source file is being edited, and the in-memory copy of the source file is to be used in preference to the version on disk.
</dd>
</dl>
<h2 id="dependency-analysis">Dependency Analysis</h2>
<p>The dependency analysis phase determines all the Haskell source files that are to be compiled or loaded in the current session, by traversing the transitive dependencies of the targets. This process is called the <em>downsweep</em> because we are traversing the dependency tree downwards from the targets. (The <em>upsweep</em>, where we compile all these files happens in the opposite direction of course).</p>
<p>The</p>
<pre><code>downsweep</code></pre>
<p>function takes the targets and returns a list of</p>
<pre><code>ModSummary</code></pre>
<p>consisting of all the modules to be compiled/loaded.</p>
<h2 id="the-modsummary-type">The ModSummary type</h2>
<p>A</p>
<pre><code>ModSummary</code></pre>
<p>(defined in <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a>) contains various information about a module:</p>
<ul>
<li>Its
<pre><code>Module</code></pre>
<p>, which includes the package that it belongs to</p></li>
<li>Its
<pre><code>ModLocation</code></pre>
<p>, which lists the pathnames of all the files associated with the module</p></li>
<li>The modules that it imports</li>
<li>The time it was last modified</li>
<li>... some other things</li>
</ul>
<p>We collect</p>
<pre><code>ModSumary</code></pre>
<p>information for all the modules we are interested in during the <em>downsweep</em>, below. Extracting the information about the module name and the imports from a source file is the job of <a href="GhcFile(compiler/main/HeaderInfo.hs)" class="uri" title="wikilink">GhcFile(compiler/main/HeaderInfo.hs)</a> which partially parses the source file.</p>
<p>Converting a given module name into a</p>
<pre><code>ModSummary</code></pre>
<p>is done by</p>
<pre><code>summariseModule</code></pre>
<p>in <a href="GhcFile(compiler/main/GHC.hs)" class="uri" title="wikilink">GhcFile(compiler/main/GHC.hs)</a>. Similarly, if we have a filename rather than a module name, we generate a</p>
<pre><code>ModSummary</code></pre>
<p>using</p>
<pre><code>summariseFile</code></pre>
<p>.</p>
<h2 id="loading-compiling-the-modules">Loading (compiling) the Modules</h2>
<p>When the dependency analysis is complete, we can load these modules by calling</p>
<pre><code>GHC.load</code></pre>
<p>. The same interface is used regardless of whether we are loading modules into GHCi with the</p>
<pre><code>:load</code></pre>
<p>command, or compiling a program with</p>
<pre><code>ghc --make</code></pre>
<dl>

<dd>we always end up calling
<pre><code>GHC.load</code></pre>
<p>.</p>
</dd>
</dl>
<p>The process in principle is fairly simple:</p>
<ul>
<li>Visit each module in the dependency tree from the bottom up, invoking [wiki:Commentary/Compiler/HscMain HscMain]</li>
</ul>
<p><code>  to compile it (the </code><em><code>upsweep</code></em><code>).</code></p>
<ul>
<li>Finally, link all the code together. In GHCi this involves loading all the object code into memory and linking it</li>
</ul>
<p><code>  with the [wiki:Commentary/Rts/Interpreter#Linker RTS linker], and then linking all the byte-code together.  In</code><br />
<code>  </code></p>
<pre><code>--make</code></pre>
<p>mode this involves invoking the external linker to link the object code into a binary.</p>
<p>The process is made more tricky in practice for two reasons:</p>
<ul>
<li>We might not need to compile certain modules, if none of their dependencies have changed. GHC's</li>
</ul>
<p><code>  [wiki:Commentary/Compiler/RecompilationAvoidance recompilation checker] determines whether a module really needs</code><br />
<code>  to be compiled or not.</code></p>
<ul>
<li>In GHCi, we might just be reloading the program after making some changes, so we don't even want to re-link</li>
</ul>
<p><code>  modules for which no dependencies have changed.</code></p>
<h1 id="ghc-commentary-asynchronous-exceptions">GHC Commentary: Asynchronous Exceptions</h1>
<h1 id="ghc-commentary-backends">GHC Commentary: Backends</h1>
<p>After [wiki:Commentary/Compiler/CmmType Cmm] has been generated, we have a choice of targets to compile to:</p>
<ul>
<li>[wiki:Commentary/Compiler/Backends/PprC The C code generator]</li>
<li>[wiki:Commentary/Compiler/Backends/NCG The native code generator]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM The LLVM code generator]</li>
<li>[wiki:Commentary/Compiler/Backends/GHCi The GHCi code generator]</li>
</ul>
<p>These backends are completely interchangeable. Our preferred route is the native code generator. The C code generator is used for portable, non-optimised, or unregisterised compilation (Note that the LLVM backend also supports building GHC in unregisterised mode as well as registerised mode so it is usually the preferred route for porting GHC).</p>
<p>= Types in the back end (aka &quot;The</p>
<pre><code>Rep</code></pre>
<p>swamp&quot;) =</p>
<p>I have completed a major representation change, affecting both old and new code generators, of the various</p>
<pre><code>Rep</code></pre>
<p>types. It's pervasive in that it touches a lot of files; and in the native code-gen very many lines are changed. The new situation is much cleaner.</p>
<p>Here are the highlights of the new design.</p>
<p>==</p>
<pre><code>CmmType</code></pre>
<p>==</p>
<p>There is a new type</p>
<pre><code>CmmType`, defined in module `CmmExpr`, which is just what it sounds like: it&#39;s the type of a `CmmExpr` or a `CmmReg</code></pre>
<p>.</p>
<ul>
<li>A
<pre><code>CmmType` is &#39;&#39;abstract&#39;&#39;: its representation is private to `CmmExpr</code></pre>
<p>. That makes it easy to change representation.</p></li>
<li>A
<pre><code>CmmType` is actually just a pair of a `Width` and a category (`CmmCat</code></pre>
<p>).</p></li>
<li>The
<pre><code>Width</code></pre>
<p>type is exported and widely used in pattern-matching, but it does what it says on the tin: width only.</p></li>
<li>In contrast, the
<pre><code>CmmCat` type is entirely private to `CmmExpr</code></pre>
<p>. It is just an enumeration that allows us to distinguish: floats, gc pointers, and other.</p></li>
</ul>
<p>Other important points are these:</p>
<ul>
<li>Each
<pre><code>LocalReg` has a `CmmType` attached; this replaces the previous unsavoury combination of `MachRep` and `CmmKind</code></pre>
<p>. Indeed, both of the latter are gone entirely.</p></li>
</ul>
<ul>
<li>Notice that a
<pre><code>CmmType` accurately knows about gc-pointer-hood. Ultimately we will abandon static-reference-table generation in STG syntax, and instead generate SRTs from the Cmm code.  We&#39;ll need to update the RTS `.cmm</code></pre>
<p>files to declare pointer-hood.</p></li>
</ul>
<ul>
<li>The type
<pre><code>TyCon.PrimRep` remains; it enumerates the representations that a Haskell value can take.  Differences from `CmmType</code></pre>
<dl>

<dd>
</dd>
</dl>
<ul>
<li><pre><code>PrimRep` contains `VoidRep`, but `CmmType</code></pre>
<p>has no zero-width form.</p></li>
<li><pre><code>CmmType` includes sub-word width values (e.g. 8-bit) which `PrimRep</code></pre>
<p>does not.</p></li>
</ul></li>
</ul>
<p><code>  The function </code></p>
<pre><code>primRepCmmType` converts a non-void `PrimRep` to a `CmmType</code></pre>
<p>.</p>
<ul>
<li><pre><code>CmmLint</code></pre>
<p>is complains if you assign a gc-ptr to a non-gc-ptr and vice versa. It treats &quot;gc-ptr + constant&quot; as a gc-ptr.</p></li>
</ul>
<p><code>   </code><em><code>NB:</code> <code>you'd</code> <code>better</code> <code>not</code> <code>make</code> <code>an</code> <code>interior</code> <code>pointer</code> <code>live</code> <code>across</code> <code>a</code> <code>call</code></em><code>, else we'll save it on the stack and treat it as a GC root.  It's not clear how to guarantee this doesn't happen as the result of some optimisation.</code></p>
<p>'''Parsing</p>
<pre><code>.cmm` RTS files.&#39;&#39;&#39;  The global register `P0` is a gc-pointer version of `R0</code></pre>
<p>. They both map to the same physical register, though!</p>
<p>== The</p>
<pre><code>MachOp</code></pre>
<p>type ==</p>
<p>The</p>
<pre><code>MachOp</code></pre>
<p>type enumerates (in machine-independent form) the available machine instructions. The principle they embody is that <em>everything except the width is embodied in the opcode</em>. In particular, we have</p>
<ul>
<li><pre><code>MO_S_Lt`, `MO_U_Lt`, and `MO_F_Lt</code></pre>
<p>for comparison (signed, unsigned, and float).</p></li>
<li><pre><code>MO_SS_Conv`, `MO_SF_Conv` etc, for conversion (`SS` is signed-to-signed, `SF</code></pre>
<p>is signed-to-float, etc).</p></li>
</ul>
<p>These constructor all take</p>
<pre><code>Width</code></pre>
<p>arguments.</p>
<p>The</p>
<pre><code>MachOp` data type is defined in `CmmExpr`, not in a separate `MachOp</code></pre>
<p>module.</p>
<h2 id="foreign-calls-and-hints">Foreign calls and hints</h2>
<p>In the new Cmm representation (</p>
<pre><code>ZipCfgCmmRep`), but not the old one, arguments and results to all calls, including foreign ones, are ordinary `CmmExpr` or `CmmReg</code></pre>
<p>respectively. The extra information we need for foreign calls (is this signed? is this an address?) are kept in the calling convention. Specifically:</p>
<ul>
<li><pre><code>MidUnsafeCall` calls a `MidCallTarget</code></pre></li>
<li><pre><code>MidCallTarget` is either a `CallishMachOp` or a `ForeignTarget</code></pre></li>
<li>In the latter case we supply a
<pre><code>CmmExpr` (the function to call) and a `ForeignConvention</code></pre></li>
<li>A
<pre><code>ForeignConvention` contains the C calling convention (stdcall, ccall etc), and a list of `ForiegnHints</code></pre>
<p>for arguments and for results. (We might want to rename this type.)</p></li>
</ul>
<p>This simple change was horribly pervasive. The old Cmm rep (and Michael Adams's stuff) still has arguments and results being (argument,hint) pairs, as before.</p>
<p>== Native code generation and the</p>
<pre><code>Size</code></pre>
<p>type ==</p>
<p>The native code generator has an instruction data type for each architecture. Many of the instructions in these data types used to have a</p>
<pre><code>MachRep` argument, but now have a `Size` argument instead.  In fact, so far as the native code generators are concerned, these `Size` types (which can be machine-specific) are simply a plug-in replacement for `MachRep`, with one big difference: &#39;&#39;&#39;`Size</code></pre>
<p>is completely local to the native code generator''' and hence can be changed at will without affecting the rest of the compiler.</p>
<pre><code>Size</code></pre>
<p>is badly named, but I inherited the name from the previous code.</p>
<p>I rather think that many instructions should have a</p>
<pre><code>Width` parameter, not a `Size</code></pre>
<p>parameter. But I didn't feel confident to change this. Generally speaking the NCG is a huge swamp and needs re-factoring.</p>
<p>I'm working on getting Backtraces in GHC. Progress can be seen here: <a href="https://github.com/abacathoo/ghc" class="uri">https://github.com/abacathoo/ghc</a></p>
<h1 id="the-block-allocator">The Block Allocator</h1>
<p>Source: <a href="GhcFile(includes/rts/storage/Block.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/Block.h)</a>, <a href="GhcFile(rts/sm/BlockAlloc.h)" class="uri" title="wikilink">GhcFile(rts/sm/BlockAlloc.h)</a>, <a href="GhcFile(rts/sm/BlockAlloc.c)" class="uri" title="wikilink">GhcFile(rts/sm/BlockAlloc.c)</a>, <a href="GhcFile(includes/rts/storage/MBlock.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/MBlock.h)</a>, <a href="GhcFile(rts/sm/MBlock.c)" class="uri" title="wikilink">GhcFile(rts/sm/MBlock.c)</a>.</p>
<p>The block allocator is where the storage manager derives much of its flexibilty. Rather than keep our heap in a single contiguous region of memory, or one contiguous region per generation, we manage linked lists of memory blocks. Managing contiguous regions is difficult, especially when you want to change the size of some of the areas. A block-structured storage arrangement has several advantages:</p>
<ul>
<li>resizing areas of memory is easy: just chain more blocks onto the list.</li>
</ul>
<ul>
<li>managing large objects without copying is easy: allocate each one a complete block, and use the block linkage to</li>
</ul>
<p><code>  chain them together.</code></p>
<ul>
<li>free memory can be recycled faster, because a block is a block.</li>
</ul>
<p>The concept relies on the property that most data objects are significantly smaller than a block, and only rarely do we need to allocate objects that approach or exceed the size of a block.</p>
<h2 id="structure-of-blocks">Structure of blocks</h2>
<p>We want to allocate memory in units of a small block (around 4k, say). Furthermore, we want each block to have an associated small structure called a <em>block descriptor</em>, which contains information about the block: its link field, which generation it belongs to, and so on. This is similar to the well-known &quot;BiBOP&quot; (Big Bag of Pages) technique, where objects with similar tags are collected together on a page so as to avoid needing to store an individual tag with each object.</p>
<p>We want a function</p>
<pre><code>Bdescr(p)</code></pre>
<p>, that, given an arbitrary pointer into a block, returns the address of the block descriptor that corresponds to the block containing that pointer.</p>
<p>There are two options:</p>
<ul>
<li>Put the block descriptor at the start of the block.
<pre><code>Bdescr(p) = p &amp; ~BLOCK_SIZE</code></pre>
<p>. This option has problems if</p></li>
</ul>
<p><code>  we need to allocate a contiguous region larger than a single block (GHC does this occasionally when allocating</code><br />
<code>  a large number of objects in one go).</code></p>
<ul>
<li>Allocate memory in larger units (a <em>megablock</em>), divide the megablock into blocks, and put all the block</li>
</ul>
<p><code>  descriptors at the beginning.  The megablock is aligned, so that the address of the block descriptor for</code><br />
<code>  a block is a simple function of its address.  The 'Bdescr' function is more complicated than the first</code><br />
<code>  method, but it is easier to allocate contiguous regions (unless the contiguous region is larger than</code><br />
<code>  a megablock...).</code></p>
<p>We adopt the second approach. The following diagram shows a megablock:</p>
<p><a href="Image(sm-block.png)" class="uri" title="wikilink">Image(sm-block.png)</a></p>
<p>We currently have megablocks of 1Mb in size (m = 20) with blocks of 4k in size (k = 12), and these sizes are easy to change (<a href="GhcFile(includes/rts/Constants.h)" class="uri" title="wikilink">GhcFile(includes/rts/Constants.h)</a>).</p>
<p>Block descriptors are currently 32 or 64 bytes depending on the word size (d = 5 or 6). The block descriptor itself is the structure</p>
<pre><code>bdescr` defined in [[GhcFile(includes/rts/storage/Block.h)]], and that file also defines the `Bdescr()</code></pre>
<p>macro.</p>
<p>The block allocator has a the following structure:</p>
<ul>
<li>At the bottom, talking to the OS, is the megablock allocator (<a href="GhcFile(rts/sm/MBlock.c)" class="uri" title="wikilink">GhcFile(rts/sm/MBlock.c)</a>, <a href="GhcFile(includes/rts/storage/MBlock.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/MBlock.h)</a>).</li>
</ul>
<p><code>  It is responsible for delivering megablocks, correctly aligned, to the upper layers.  It is also responsible for</code><br />
<code>  implementing [wiki:Commentary/HeapAlloced HEAP_ALLOCED()]: the predicate that tests whether a pointer points to dynamically allocated memory</code><br />
<code>  or not.  This is implemented as a simple bitmap lookup on a 32-bit machine, and something more complex on</code><br />
<code>  64-bit addressed machines.  See </code><a href="GhcFile(includes/rts/storage/MBlock.h)" title="wikilink"><code>GhcFile(includes/rts/storage/MBlock.h)</code></a><code> for details.</code><br />
<code>  </code><a href="br" title="wikilink"><code>br</code></a><a href="br" title="wikilink"><code>br</code></a><br />
<code>  Currently, megablocks are never freed back to the OS, except at the end of the program.  This is a potential</code><br />
<code>  improvement that could be made.</code></p>
<ul>
<li>Sitting on top of the megablock allocator is the block layer (<a href="GhcFile(includes/rts/storage/Block.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/Block.h)</a>, <a href="GhcFile(rts/sm/BlockAlloc.c)" class="uri" title="wikilink">GhcFile(rts/sm/BlockAlloc.c)</a>).</li>
</ul>
<p><code>  This layer is responsible for providing:</code></p>
<pre><code>* llocGroup(int)
** </code></pre>
<p><code> These functions allocate and deallocate a block </code><em><code>group</code></em><code>: a contiguous sequence of blocks (the degenerate, and common, case</code><br />
<code> is a single block).  The block allocator is responsible for keeping track of free blocks.  Currently it does this by</code><br />
<code> maintaining an ordered (by address) list of free blocks, with contiguous blocks coallesced.  However this is certanly</code><br />
<code> not optimal, and has been shown to be a bottleneck in certain cases - improving this allocation scheme would be good.</code></p>
<h1 id="ghc-commentary-garbage-collecting-cafs">GHC Commentary: Garbage Collecting CAFs</h1>
<p>Files: <a href="GhcFile(rts/sm/GC.c)" class="uri" title="wikilink">GhcFile(rts/sm/GC.c)</a>, function scavange_srt in <a href="GhcFile(rts/sm/Scav.h)" class="uri" title="wikilink">GhcFile(rts/sm/Scav.h)</a></p>
<p>Constant Applicative Forms, or CAFs for short, are top-level values defined in a program. Essentially, they are objects that are not allocated dynamically at run-time but, instead, are part of the static data of the program. Sometimes, a CAF may refer to many values in the heap. To avoid memory leaks in such situations, we need to know when a CAF is never going to be used again, and so we can deallocate the values that it refers to.</p>
<p>See Note [CAF management] in <a href="GhcFile(rts/sm/Storage.c)" class="uri" title="wikilink">GhcFile(rts/sm/Storage.c)</a> for more information.</p>
<h2 id="static-reference-tables">Static Reference Tables</h2>
<p>File: <a href="GhcFile(includes/rts/storage/InfoTables.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/InfoTables.h)</a></p>
<p>The info table of various closures may contain information about what static objects are referenced by the closure. This information is stored in two parts:</p>
<ol>
<li>a static reference table (SRT), which is an array of references to static objects</li>
<li>a bitmask which specifies which of the objects are actually used by the closure.</li>
</ol>
<p>There are two different ways to access this information depending on the size of the SRT:</p>
<ul>
<li>&quot;small&quot;: if
<pre><code>srt_bitmap</code></pre>
<p>is a small bitmap, not all 1s, then GET_FUN?_SRT contains the SRT.</p></li>
<li>&quot;large&quot;: if
<pre><code>srt_bitmap</code></pre>
<p>is all 1s, then GET_FUN?_SRT contains a large bitmap, and the actual SRT.</p></li>
</ul>
<h2 id="evacuating-static-objects">Evacuating Static Objects</h2>
<p>Files: <a href="GhcFile(rts/sm/GCThread.h)" class="uri" title="wikilink">GhcFile(rts/sm/GCThread.h)</a>, <a href="GhcFile(rts/sm/Evac.c)" class="uri" title="wikilink">GhcFile(rts/sm/Evac.c)</a>, <a href="GhcFile(rts/sm/GC.c)" class="uri" title="wikilink">GhcFile(rts/sm/GC.c)</a></p>
<p>While scavenging objects, we also process (aka &quot;evacuate&quot;) any static objects that need to be kept alive. When a GC thread discovers a live static object, it places it on its</p>
<pre><code>static_objects</code></pre>
<p>list. Later, this list is used to scavange the static objects, potentially finding more live objects. Note that this process might find more static objects, and thus further extend the</p>
<pre><code>static_objects</code></pre>
<p>list.</p>
<p>When a static object is scavenged, it is removed from</p>
<pre><code>static_objects</code></pre>
<p>and placed on another list, called</p>
<pre><code>scavenged_static_objects</code></pre>
<p>. Later, we use this list to &quot;clean up&quot; the liveness markers from these static objects, so that we can repeat the process on the next garbage collection. Note that we can't &quot;clean up&quot; the liveness markers as we go along because we use them to notice cycles among the static objects.</p>
<h1 id="calling-convention">Calling Convention</h1>
<p>Entry conventions are very conventional: the first N argumements in registers and the rest on the stack.</p>
<h1 id="return-convention">Return Convention</h1>
<p>All returns are now <em>direct</em>; that is, a return is made by jumping to the code associated with the [wiki:Commentary/Rts/Storage/HeapObjects#InfoTables info table] of the topmost [wiki:Commentary/Rts/Storage/Stack stack frame].</p>
<p>GHC used to have a more complex return convention called vectored returns in which some stack frames pointed to vectors of return addresses; this was dropped in GHC 6.8 after measurements that showed it was not (any longer) worthwhile.</p>
<h2 id="historical-page">Historical page</h2>
<p>This page is a bunch of notes on the new code generator. It is outdated and is here only for historical reasons.It should probably be removed. See [wiki:Commentary/Compiler/CodeGen Code Generator] page for a description of current code generator.</p>
<h1 id="cleanup-after-the-new-codegen-is-enabled">Cleanup after the new codegen is enabled</h1>
<p>The new codegen was enabled by default in 832077ca5393d298324cb6b0a2cb501e27209768. Now that the switch has been made, we can remove all the cruft associated with the old code generator. There are dependencies between some of the components, so we have to do things in the right order. Here is a list of the cleanup tasks, and notes about dependencies:</p>
<h2 id="independent-tasks">Independent tasks</h2>
<ul>
<li>Use
<pre><code>BlockId` or `Label` consistently, currently we use a mixture of the two.  Maybe get rid of the `BlockId</code></pre>
<p>module.</p></li>
</ul>
<ul>
<li>Remove live-var and CAF lists from
<pre><code>StgSyn`, and then clean up `CoreToStg</code></pre></li>
</ul>
<ul>
<li>DONE: Remove the SRT pass in
<pre><code>simplStg/SRT.lhs</code></pre></li>
</ul>
<ul>
<li>DONE: remove RET_DYN from the RTS</li>
</ul>
<ul>
<li>DONE: remove
<pre><code>-fnew-codegen`, related `HscMain` bits and the `CodeGen</code></pre>
<p>module.</p></li>
</ul>
<ul>
<li>DONE: remove
<pre><code>CmmOpt.cmmMiniInline</code></pre>
<p>, it is not used any more</p></li>
</ul>
<ul>
<li>Fix the layering:
<pre><code>cmm` modules should not depend on `codeGen/StgCmm*</code></pre></li>
</ul>
<h2 id="towards-removing-codegencg">Towards removing codeGen/Cg*</h2>
<ul>
<li>DONE:
<pre><code>CmmParse` should produce new `Cmm</code></pre>
<p>.</p>
<ul>
<li>We will probably want two kinds of
<pre><code>.cmm` file, one that is to be fed through `CmmLayoutStack</code></pre>
<p>and one that isn't.</p></li>
<li>primops will be fed through
<pre><code>CmmLayoutStack</code></pre>
<p>, and will use the native calling convention, with the code generator inserting the copyin/copyout for us.</p></li>
</ul></li>
</ul>
<ul>
<li>DONE: Remove all the
<pre><code>Cg*</code></pre>
<p>modules</p></li>
</ul>
<p>== Towards removing</p>
<pre><code>OldCmm</code></pre>
<p>==</p>
<ul>
<li>IN PROGRESS (Simon M): Change the NCG over to consume new
<pre><code>Cmm</code></pre>
<p>. We possibly also want the generated native code to use the Hoopl Block representation, although that will mean changing branch instructions to have both true and false targets, rather than true and fallthrough as we have now.</p></li>
</ul>
<ul>
<li>Remove
<pre><code>cmm/CmmCvt</code></pre>
<p>(this will save some compile-time too)</p></li>
</ul>
<ul>
<li>Remove
<pre><code>cmm/OldCmm*`, `cmm/PprOldCmm</code></pre>
<p>etc.</p></li>
</ul>
<h2 id="later">Later</h2>
<ul>
<li>Do the new SRT story (ToDo: write a wiki page about this)</li>
</ul>
<h1 id="cmm-implementing-exception-handling">Cmm: Implementing Exception Handling</h1>
<p>The IEEE 754 specification for floating point numbers defines exceptions for certain floating point operations, including:</p>
<ul>
<li>range violation (overflow, underflow);</li>
<li>rounding errors (inexact);</li>
<li>invalid operation (invalid operand, such as comparison with a
<pre><code>NaN</code></pre>
<p>value, the square root of a negative number or division of zero by zero); and,</p></li>
<li>zero divide (a special case of an invalid operation).</li>
</ul>
<p>Many architectures support floating point exceptions by including a special register as an addition to other exception handling registers. The IBM PPC includes the</p>
<pre><code>FPSCR` (&quot;Floating Point Status Control Register&quot;); the Intel x86 processors use the `MXCSR` register.  When the PPC performs a floating point operation it checks for possible errors and sets the `FPSCR</code></pre>
<p>. Some processors allow a flag in the Foating-Point Unit (FPU) status and control register to be set that will disable some exceptions or the entire FPU exception handling facility. Some processors disable the FPU after an exception has occurred while others, notably Intel's x86 and x87 processors, continue to perform FPU operations. Depending on whether quiet NaNs (QNaNs) or signaling NaNs (SNaNs) are used by the software, an FPU exception may signal an interrupt for the software to pass to its own exception handler.</p>
<p>Some higher level languages provide facilities to handle these exceptions, including Ada, Fortran (F90 and later), C++ and C (C99, fenv.h, float.h on certain compilers); others may handle such exceptions without exposing a low-level interface. There are three reasons to handle FPU exceptions, and these reasons apply similarly to other exceptions:</p>
<ul>
<li>the facilities provide greater control;</li>
<li>the facilities are efficient--more efficient than a higher-level software solution; and,</li>
<li>FPU exceptions may be unavoidable, especially if several FPU operations are serially performed at the machine level so the higher level software has no opportunity to check the results in between operations.</li>
</ul>
<h4 id="an-integral-exception-example">An Integral Exception Example</h4>
<p>There has been at least one problem in GHC that would benefit from exception handling--in some cases, for</p>
<pre><code>Integral`s.  See bug ticket #1042.  The bug occurs in `show`ing the number, in [GhcFile(libraries/base/GHC/Show.lhs) GHC.Show], `showSignedInt`, before conversion from base_2 to base_10, where a negative `Int` (always `Int32`) is negated in order to process it as a positive value when converting it to a string, base_10, causing an overflow error on some architectures.  (Bear in mind that it would show up here in the example for #1042 because the function would be evaluated in GHCi here; the negation is the problem and the exception shows up in the &#39;&#39;next&#39;&#39; instruction on that operand, here `DIV</code></pre>
<p>.)</p>
<p>The exception example in #1042 does not occur on PowerPC machines, which dutifully print the two's complement of</p>
<pre><code>(-2147483648::Int) &lt;pre&gt;div` (-1::Int)</code></pre>
<dl>

<dd>`0`. (`-2147483648` is the minimum bound for signed Ints, so negating it should properly become, bitwise, a positive `2147483647` (all but bit 31 set); once negated again when divided by `-1` this would be `0`; `-0` is converted to `0`.) On some architectures such as Intel 64 and IA-32, negating the minimum bound does not wrap around to `0` but overflows, which is reported as a floating point &quot;overflow&quot; (`#O`) exception: the `NEG` instruction modifies the `OF` flag (bit 11) in the `EFLAGS` register--curiously enough, the `DIV` and `IDIV` instructions have <em>undefined</em> effects on the `OF
</pre>
<p>flag.</p>
</dd>
</dl>
<p>The workaround was to avoid negating</p>
<pre><code>minBound` `Int`s; note that no Intel instructions allow one to modify the `OF</code></pre>
<p>flag directly. Alternative solutions might be to</p>
<ol>
<li>mask the &quot;exception&quot; by clearing the interrupt flag,
<pre><code>IF`, using the `CLI</code></pre>
<p>instruction; or,</p></li>
<li>conditionally unset the flag by using the
<pre><code>PUSHF` instruction on the `EFLAGS` register to push its lower word (bits 15-0, including the offending bit 11 (`OF`)) onto the stack, reset the `OF` bit, then push that back onto the stack and pop it into EFLAGS with `POPF</code></pre>
<p>. Depending on variable register used, the assembler output would look similar to:</p></li>
</ol>
<pre><code>    ; after NEG, MUL, other potential overflow operation ...
    jo  _reset_OF_flag  ; jump near if overflow (OF=1)
    ; continue rest of operation
    jmp _continue_operation_on_int:
_reset_OF_flag:
    pushf   %eflags     ; push low 16 bits of %eflags onto stack
    pop %ax     ; pop top of stack into low 16 bits of %eax
    and $0xF7FF, %ax    ; %ax = %ax &amp; 0xF7FF
    push    %ax         ; push %ax value (with bit 11 set to 0) onto stack
    popf            ; pop top of stack into lower 16 bits of %eflags
                ; OF bit now reset

_continue_operation_on_int: ; this is a 32-bit address (also works in 64-bit mode)
    ;...</code></pre>
<h4 id="a-floating-point-exception-example">A Floating Point Exception Example</h4>
<p>There was a long message thread on the Haskell-prime mailing list, &quot;realToFrac Issues,&quot; beginning with <a href="http://www.haskell.org/pipermail/haskell-prime/2006-February/000791.html">John Meacham's message</a> and ending with <a href="http://www.haskell.org/pipermail/haskell-prime/2006-March/000840.html">Simon Marlow's message</a>. The following code for converting a Float to a Double will <em>fail</em> to produce a floating point exception or NaN on x86 machines (recall that 0.0/0.0 is NaN <em>and</em> a definite FPU exception):</p>
<p>[in GHCi-6.6 on PowerPC, OS X]:</p>
<pre><code>Prelude&gt; 0.0/0.0
NaN

Prelude&gt; realToFrac (0.0/0.0) :: Double
Infinity

Prelude&gt; realToFrac (0.0/0.0 :: Float)
5.104235503814077e38

Prelude&gt; realToFrac (0.0/0.0 :: Float) :: Double
5.104235503814077e38

Prelude&gt; realToFrac (1.0/0.0)
Infinity
Prelude&gt; realToFrac (1.0/0.0 :: Float)
3.402823669209385e38</code></pre>
<p>This bug is not due to the lack of FPU exceptions in Cmm but bears mention as the internal conversion performed in 'realToFrac' on 'Float's would benefit from FPU exceptions: with Haskell-support for FPU exceptions this realToFrac would be able to issue an exception for NaN, Infinity or rounding errors when converting a Float to a Double and vice versa. There is a related problem with rounding errors in the functions 'encodeFloat', 'decodeFloat', 'encodeDouble' and 'decodeDouble', see [wiki:ReplacingGMPNotes/TheCurrentGMPImplementation].</p>
<p>On 5 May 2008, Isaac Dupree asked</p>
<p><code> Is there documentation (e.g. on the GHC Commentary somewhere I can't</code><br />
<code> find) an explanation of what C-- &quot;kinds&quot; are or how they're useful/used? </code></p>
<p>Probably not. GHC Cmm is a sort of pidgin version of C-- 2.0, and true C-- kinds are explained in the <a href="http://www.cminusminus.org/code.html">C-- specification, section 5.1</a>.</p>
<p><code> When I was portabilizing that code area a while ago I had ignorantly </code><br />
<code> changed some of the uses of &quot;kind&quot; to &quot;hint&quot; for consistency (both names </code><br />
<code> had been being used for the same thing via type-synonym.) and because I </code><br />
<code> could guess how the code make sense if it was, informally, a hint about </code><br />
<code> what to do.</code></p>
<p>Hint was the word used originally, and several people (including reviewers) objected to it on the grounds that the 'hints' are actually mandatory to get the compiler to do what you want (e.g., pass arguments in floating-point registers). So we changed the name to 'kind'.</p>
<p>If you like dense, indigestible academic papers full of formalism, there's <a href="http://www.cs.tufts.edu/~nr/pubs/staged-abstract.html">one I'm quite proud of</a>. It explains in detail how kinds are useful for specifying and implementing procedure calling conventions, which is the use to which they are put within GHC.</p>
<p>Norman Ramsey</p>
<p>= GHC Commentary: What the hell is a</p>
<pre><code>.cmm</code></pre>
<p>file? =</p>
<p>A</p>
<pre><code>.cmm` file is rather like C--.  The syntax is almost C-- (a few constructs are missing), and it is augmented with some macros that are expanded by GHC&#39;s code generator (eg. `INFO_TABLE()`).  A `.cmm</code></pre>
<p>file is compiled by GHC itself: the syntax is parsed by <a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a> and <a href="GhcFile(compiler/cmm/CmmLex.x)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmLex.x)</a> into the [wiki:Commentary/Compiler/CmmType Cmm] data type, where it is then passed through one of the [wiki:Commentary/Compiler/Backends back-ends].</p>
<p>We use the C preprocessor on</p>
<pre><code>.cmm` files, making extensive use of macros to make writing this low-level code a bit less tedious and error-prone.  Most of our C-- macros are in [[GhcFile(includes/Cmm.h)]]. One useful fact about the macros is `P_` is an alias for `gcptr</code></pre>
<p>, and you should not use it for non-garbage-collected pointers.</p>
<h2 id="reading-references">Reading references</h2>
<p>Reading material for learning Cmm is somewhat scattered, so I (Arash) have created a list of useful links. Since the Cmm language is changing as GHC changes, I have prioritized resources that are not too old. (<em>Feel free to add/remove/modify this list! :)</em>)</p>
<ul>
<li>An overview of Cmm is given in <a href="https://davidterei.com/downloads/papers/terei:2009:honours_thesis.pdf">David Terei's bachelor thesis</a> (chapter 2.4.3).</li>
<li>The comments in the beginning of <a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a> is super-useful and kept up to date. The rest of the file contains the <em>grammar</em> of the language. Afraid of grammars? Edward Yang wrote this fantastic <a href="http://blog.ezyang.com/2013/07/no-grammar-no-problem/">blog post</a> on how to understand the constructs of Cmm by using the grammar.</li>
<li>Cmm has a preprocessor like the one in C and many of the macros are defined in <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a>.</li>
<li>In 2012, Simon Marlow extended the Cmm language by adding a new high-level syntax which can be used when you don't need low-level access (like registers). The <a href="https://github.com/ghc/ghc/commit/a7c0387d20c1c9994d1100b14fbb8fb4e28a259e">commit</a> explains the details.</li>
<li>Cmm is also described [wiki:Commentary/Compiler/CmmType on this wiki], but it is written before the new syntax was introduced.</li>
<li>Stack frame types are created using
<pre><code>INFO_TABLE_RET</code></pre>
<p>, the syntax can be confusing since there are both <em>arguments</em> and <em>fields</em>, I (Arash) have not seen anything like it in other programming languages. I tried to explain it in my <a href="http://arashrouhani.com/papers/master-thesis.pdf">master thesis</a> (sections 4.2 and 4.2.1).</p></li>
</ul>
<h2 id="other-information">Other information</h2>
<p>It can take time to learn Cmm. One unintuitive thing to watch out for is that there are no function calls in low-level cmm code. The new syntax from 2012 allows function calls but you should know that they are kind of magical.</p>
<p>We say that <strong>Cmm</strong> is GHC's implementation of <strong>C--</strong>. This naming scheme is not done consistently everywhere, unfortunately. If you are interested in C-- (which have diverged from Cmm), you can check out the <a href="http://www.cminusminus.org/">website</a> and the <a href="http://www.cs.tufts.edu/~nr/c--/extern/man2.pdf">specification</a>.</p>
<h3 id="note-to-reader">Note To Reader</h3>
<p>This page was written with more detail than usual since you may need to know how to work with Cmm as a programming language. Cmm is the basis for the future of GHC, Native Code Generation, and if you are interested in hacking Cmm at least this page might help reduce your learning curve. As a finer detail, if you read the [wiki:Commentary/Compiler/HscMain Compiler pipeline] wiki page or glanced at the diagram there you may have noticed that whether you are working backward from an</p>
<pre><code>intermediate C` (Haskell-C &quot;HC&quot;, `.hc</code></pre>
<p>) file or an Assembler file you get to Cmm before you get to the STG language, the Simplifier or anything else. In other words, for really low-level debugging you may have an easier time if you know what Cmm is about. Cmm also has opportunities for implementing small and easy hacks, such as little optimisations and implementing new Cmm Primitive Operations.</p>
<p>A portion of the [wiki:Commentary/Rts RTS] is written in Cmm: <a href="GhcFile(rts/Apply.cmm)" class="uri" title="wikilink">GhcFile(rts/Apply.cmm)</a>, <a href="GhcFile(rts/Exception.cmm)" class="uri" title="wikilink">GhcFile(rts/Exception.cmm)</a>, <a href="GhcFile(rts/HeapStackCheck.cmm)" class="uri" title="wikilink">GhcFile(rts/HeapStackCheck.cmm)</a>, <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a>, <a href="GhcFile(rts/StgMiscClosures.cmm)" class="uri" title="wikilink">GhcFile(rts/StgMiscClosures.cmm)</a>, <a href="GhcFile(rts/StgStartup.cmm)" class="uri" title="wikilink">GhcFile(rts/StgStartup.cmm)</a> and <a href="GhcFile(StgStdThunks.cmm)" class="uri" title="wikilink">GhcFile(StgStdThunks.cmm)</a>. (For notes related to</p>
<pre><code>PrimOps.cmm</code></pre>
<p>see the [wiki:Commentary/PrimOps PrimOps] page; for much of the rest, see the [wiki:Commentary/Rts/HaskellExecution HaskellExecution] page.) Cmm is optimised before GHC outputs either HC or Assembler. The C compiler (from HC, pretty printed by <a href="GhcFile(compiler/cmm/PprC.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/PprC.hs)</a>) and the [wiki:Commentary/Compiler/Backends/NCG Native Code Generator] (NCG) [wiki:Commentary/Compiler/Backends Backends] are closely tied to data representations and transformations performed in Cmm. In GHC, Cmm roughly performs a function similar to the intermediate <a href="http://gcc.gnu.org/onlinedocs/gccint/RTL.html">Register Transfer Language (RTL)</a> in GCC.</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ol>
<li>[wiki:Commentary/Compiler/CmmType#AdditionsinCmm Additions in Cmm]</li>
<li>[wiki:Commentary/Compiler/CmmType#CompilingCmmwithGHC Compiling Cmm with GHC]</li>
<li>[wiki:Commentary/Compiler/CmmType#BasicCmm Basic Cmm]
<ol>
<li>[wiki:Commentary/Compiler/CmmType#CodeBlocksinCmm Code Blocks in Cmm]</li>
</ol></li>
</ol>
<ul>
<li>[wiki:Commentary/Compiler/CmmType#BasicBlocksandProcedures Basic Blocks and Procedures]</li>
</ul>
<ol>
<li><ol>
<li>[wiki:Commentary/Compiler/CmmType#VariablesRegistersandTypes Variables, Registers and Types]
<ol>
<li>[wiki:Commentary/Compiler/CmmType#LocalRegisters Local Registers]</li>
<li>[wiki:Commentary/Compiler/CmmType#GlobalRegistersandHints Global Registers and Hints]</li>
<li>[wiki:Commentary/Compiler/CmmType#DeclarationandInitialisation Declaration and Initialisation]</li>
<li>[wiki:Commentary/Compiler/CmmType#MemoryAccess Memory Access]</li>
</ol></li>
<li>[wiki:Commentary/Compiler/CmmType#LiteralsandLabels Literals and Labels]</li>
</ol></li>
</ol>
<ul>
<li>[wiki:Commentary/Compiler/CmmType#Labels Labels]</li>
</ul>
<ol>
<li><ol>
<li>[wiki:Commentary/Compiler/CmmType#SectionsandDirectives Sections and Directives]</li>
</ol></li>
</ol>
<ul>
<li>[wiki:Commentary/Compiler/CmmType#TargetDirective Target Directive]</li>
</ul>
<ol>
<li><ol>
<li>[wiki:Commentary/Compiler/CmmType#Expressions Expressions]</li>
</ol></li>
</ol>
<ul>
<li>[wiki:Commentary/Compiler/CmmType#QuasioperatorSyntax Quasi-operator Syntax]</li>
</ul>
<ol>
<li><ol>
<li>[wiki:Commentary/Compiler/CmmType#StatementsandCalls Statements and Calls]</li>
</ol></li>
</ol>
<ul>
<li>[wiki:Commentary/Compiler/CmmType#CmmCalls Cmm Calls]</li>
</ul>
<ol>
<li><ol>
<li>[wiki:Commentary/Compiler/CmmType#OperatorsandPrimitiveOperations Operators and Primitive Operations]
<ol>
<li>[wiki:Commentary/Compiler/CmmType#Operators Operators]</li>
<li>[wiki:Commentary/Compiler/CmmType#PrimitiveOperations Primitive Operations]</li>
</ol></li>
<li>[wiki:Commentary/Compiler/CmmType#CmmDesign:ObservationsandAreasforPotentialImprovement Cmm Design: Observations and Areas for Potential Improvement]</li>
</ol></li>
</ol>
<h1 id="the-cmm-language">The Cmm language</h1>
<pre><code>Cmm` is the GHC implementation of the `C--` language; it is also the extension of Cmm source code files: `.cmm` (see [wiki:Commentary/Rts/Cmm What the hell is a .cmm file?]).  The GHC [wiki:Commentary/Compiler/CodeGen Code Generator] (`CodeGen`) compiles the STG program into `C--` code, represented by the `Cmm` data type.  This data type follows the [http://www.cminusminus.org/ definition of `C--</code></pre>
<p>] pretty closely but there are some remarkable differences. For a discussion of the Cmm implementation noting most of those differences, see the [wiki:Commentary/Compiler/CmmType#BasicCmm Basic Cmm] section, below.</p>
<ul>
<li><a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>: the main data type definition.</li>
<li><a href="GhcFile(compiler/cmm/MachOp.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/MachOp.hs)</a>: data types defining the machine operations (e.g. floating point divide) provided by
<pre><code>Cmm</code></pre>
<p>.</p></li>
<li><a href="GhcFile(compiler/cmm/CLabel.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CLabel.hs)</a>: data type for top-level
<pre><code>Cmm</code></pre>
<p>labels.</p></li>
</ul>
<ul>
<li><a href="GhcFile(compiler/cmm/PprCmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/PprCmm.hs)</a>: pretty-printer for
<pre><code>Cmm</code></pre>
<p>.</p></li>
<li><a href="GhcFile(compiler/cmm/CmmUtils.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmUtils.hs)</a>: operations over
<pre><code>Cmm</code></pre></li>
</ul>
<ul>
<li><a href="GhcFile(compiler/cmm/CmmLint.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmLint.hs)</a>: a consistency checker.</li>
<li><a href="GhcFile(compiler/cmm/CmmOpt.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmOpt.hs)</a>: an optimiser for
<pre><code>Cmm</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a>, <a href="GhcFile(compiler/cmm/CmmLex.x)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmLex.x)</a>: parser and lexer for [wiki:Commentary/Rts/Cmm .cmm files].</li>
</ul>
<ul>
<li><a href="GhcFile(compiler/cmm/PprC.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/PprC.hs)</a>: pretty-print
<pre><code>Cmm</code></pre>
<p>in C syntax, when compiling via C.</p></li>
</ul>
<h2 id="additions-in-cmm">Additions in Cmm</h2>
<p>Although both Cmm and C-- allow foreign calls, the</p>
<pre><code>.cmm</code></pre>
<p>syntax includes the</p>
<pre><code>foreign &quot;C&quot; cfunctionname(R1) [R2];</code></pre>
<p>The [R2] part is the (set of) register(s) that you need to save over the call.</p>
<p>Other additions to C-- are noted throughout the [wiki:Commentary/Compiler/CmmType#BasicCmm Basic Cmm] section, below.</p>
<h2 id="compiling-cmm-with-ghc">Compiling Cmm with GHC</h2>
<p>GHC is able to compile</p>
<pre><code>.cmm` files with a minimum of user-effort.  To compile `.cmm</code></pre>
<p>files, simply invoke the main GHC driver but remember to:</p>
<ul>
<li>add the option
<pre><code>-dcmm-lint</code></pre>
<p>if you have handwritten Cmm code;</p></li>
<li>add appropriate includes, especially <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a> if you are using Cmm macros or GHC defines for certain types, such as
<pre><code>W_` for `bits32` or `bits64` (depending on the machine word size)--`Cmm.h` is in the `/includes` directory of every GHC distribution, i.e., `usr/local/lib/ghc-6.6/includes</code></pre>
<dl>
<dt>and,</dt>

</dl></li>
<li>if you do include GHC header files, remember to pass the code through the C preprocessor by adding the
<pre><code>-cpp</code></pre>
<p>option.</p></li>
</ul>
<p>For additional fun, you may pass GHC the</p>
<pre><code>-keep-s-file</code></pre>
<p>option to keep the temporary assembler file in your compile directory. For example:</p>
<pre><code>ghc -cpp -dcmm-lint -keep-s-file -c Foo.cmm -o Foo.o</code></pre>
<p>This will only work with very basic Cmm files. If you noticed that GHC currently provides no</p>
<pre><code>-keep-cmm-file` option and `-keep-tmp-files` does not save a `.cmm` file and you are thinking about redirecting output from `-ddump-cmm`, beware. The output from `-ddump-cmm` contains equal-lines and dash-lines separating Cmm Blocks and Basic Blocks; these are unparseable.  The parser also cannot handle `const` sections.  For example, the parser will fail on the first `0` or alphabetic token after `const</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>section &quot;data&quot; {
    rOG_closure:
        const rOG_info; // parse error `rOG_info&#39;
        const 0;    // parse error `0&#39;
        const 0;
        const 0;
}</code></pre>
<p>Although GHC's Cmm pretty printer outputs C-- standard parenthetical list of arguments after procedure names, i.e.,</p>
<pre><code>()`, the Cmm parser will fail at the `(</code></pre>
<p>token. For example:</p>
<pre><code>__stginit_Main_() { // parse error `(&#39;
    cUX:
        Sp = Sp + 4;
        jump (I32[Sp + (-4)]);
}</code></pre>
<p>The Cmm procedure names in <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a> are not followed by a (possibly empty) parenthetical list of arguments; all their arguments are Global (STG) Registers, anyway, see [wiki:Commentary/Compiler/CmmType#VariablesRegistersandTypes Variables, Registers and Types], below. Don't be confused by the procedure definitions in other handwritten</p>
<pre><code>.cmm` files in the RTS, such as [[GhcFile(rts/Apply.cmm)]]: all-uppercase procedure invocations are special reserved tokens in [[GhcFile(compiler/cmm/CmmLex.x)]] and [[GhcFile(compiler/cmm/CmmParse.y)]].  For example, `INFO_TABLE` is parsed as one of the tokens in the Alex `info</code></pre>
<p>predicate:</p>
<pre><code>info    :: { ExtFCode (CLabel, [CmmLit],[CmmLit]) }
    : &#39;INFO_TABLE&#39; &#39;(&#39; NAME &#39;,&#39; INT &#39;,&#39; INT &#39;,&#39; INT &#39;,&#39; STRING &#39;,&#39; STRING &#39;)&#39;
        -- ptrs, nptrs, closure type, description, type
        { stdInfo $3 $5 $7 0 $9 $11 $13 }</code></pre>
<p>GHC's Cmm parser also cannot parse nested code blocks. For example:</p>
<pre><code>s22Q_ret() {
    s22Q_info {     // parse error `{&#39;
        const Main_main_srt-s22Q_info+24;
        const 0;
        const 2228227;
    }
    c23f:
    R2 = base_GHCziHandle_stdout_closure;
    R3 = 10;
    Sp = Sp + 4;    /* Stack pointer */
    jump base_GHCziIO_zdwhPutChar_info;
}</code></pre>
<p>The C-- specification example in section 4.6.2, &quot;Procedures as section contents&quot; also will not parse in Cmm:</p>
<pre><code>section &quot;data&quot; { 
    const PROC = 3;     // parse error `PROC&#39; (no parse after &#39;const&#39;)
    bits32[] {p_end, PROC}; // parse error `[&#39; (only bits8[] is allowed)
                // parse error `{&#39; (no {...} variable initialisation)

    p (bits32 i) {  // parse error `{&#39; (Cmm thinks &quot;p (bits32 i)&quot; is a statement)
        loop: 
            i = i-1; 
        if (i &gt;= 0) { goto loop ; } // no parse error 
                        // (if { ... } else { ... } *is* parseable)
        return; 
    } 
    p_end: 
} </code></pre>
<p>Note that if</p>
<pre><code>p (bits32 i) { ... }` were written as a Cmm-parseable procedure, as `p { ... }`, the parse error would occur at the closing curly bracket for the `section &quot;data&quot; { ... p { ... } }&lt;/pre&gt;&lt;- here.


== Basic Cmm ==

FIXME: The links in this section are dead. But the files can be found here: [http://www.cs.tufts.edu/~nr/c--/index.html]. Relevant discussion about the documentations of C--: [https://mail.haskell.org/pipermail/ghc-devs/2014-September/006301.html]

Cmm is a high level assembler with a syntax style similar to C.  This section describes Cmm by working up from assembler--the C-- papers and specification work down from C.  At the least, you should know what a &quot;high level&quot; assembler is, see [http://webster.cs.ucr.edu/AsmTools/HLA/HLADoc/HLARef/HLARef3.html#1035157 &quot;What is a High Level Assembler?&quot;].  Cmm is different than other high level assembler languages in that it was designed to be a semi-portable intermediate language for compilers; most other high level assemblers are designed to make the tedium of assembly language more convenient and intelligible to humans.  If you are completely new to C--, I highly recommend these papers listed on the [http://cminusminus.org/papers.html C-- Papers] page:
* [http://cminusminus.org/abstracts/ppdp.html C--: A Portable Assembly Language that Supports Garbage Collection (1999)] (Paper page with Abstract)
* [http://cminusminus.org/abstracts/pal-ifl.html C--: A Portable Assembly Language (1997)] (Paper page with Abstract)
* [http://cminusminus.org/abstracts/c--pldi-00.html A Single Intermediate Language That Supports Multiple Implementations of Exceptions (2000)] (Paper page with Abstract)
* [http://cminusminus.org/extern/man2.pdf The C-- Language Specification Version 2.0 (CVS Revision 1.128, 23 February 2005)] (PDF)

Cmm is not a stand alone C-- compiler; it is an implementation of C-- embedded in the GHC compiler.  One difference between Cmm and a C-- compiler like [http://cminusminus.org/code.html Quick C--] is this: Cmm uses the C preprocessor (cpp).  Cpp lets Cmm &#39;&#39;integrate&#39;&#39; with C code, especially the C header defines in [[GhcFile(includes)]], and among many other consequences it makes the C-- &lt;pre&gt;import` and `export</code></pre>
<p>statements irrelevant; in fact, according to <a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a> they are ignored. The most significant action taken by the Cmm modules in the Compiler is to optimise Cmm, through <a href="GhcFile(compiler/cmm/CmmOpt.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmOpt.hs)</a>. The Cmm Optimiser generally runs a few simplification passes over primitive Cmm operations, inlines simple Cmm expressions that do not contain global registers (these would be left to one of the [wiki:Commentary/Compiler/Backends Backends], which currently cannot handle inlines with global registers) and performs a simple loop optimisation.</p>
<h3 id="code-blocks-in-cmm">Code Blocks in Cmm</h3>
<p>The Haskell representation of Cmm separates contiguous code into:</p>
<ul>
<li><em>modules</em> (compilation units; a
<pre><code>.cmm</code></pre>
<p>file); and</p></li>
<li><em>basic blocks</em></li>
</ul>
<p>Cmm modules contain static data elements (see [wiki:Commentary/Compiler/CmmType#LiteralsandLabels Literals and Labels]) and [wiki:Commentary/Compiler/CmmType#BasicBlocks:Procedures Basic Blocks], collected together in</p>
<pre><code>Cmm`, a type synonym for `GenCmm</code></pre>
<p>, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;newtype&lt;/font&gt; &lt;font color=Green&gt;GenCmm&lt;/font&gt; &lt;font color=Black&gt;d&lt;/font&gt; &lt;font color=Black&gt;i&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;Cmm&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;GenCmmTop&lt;/font&gt; &lt;font color=Black&gt;d&lt;/font&gt; &lt;font color=Black&gt;i&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;

&lt;font color=DarkOrchid&gt;type&lt;/font&gt; &lt;font color=Green&gt;Cmm&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;GenCmm&lt;/font&gt; &lt;font color=Green&gt;CmmStatic&lt;/font&gt; &lt;font color=Green&gt;CmmStmt&lt;/font&gt;


&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;GenCmmTop&lt;/font&gt; &lt;font color=Black&gt;d&lt;/font&gt; &lt;font color=Black&gt;i&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;CmmProc&lt;/font&gt;
     &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Black&gt;d&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;          &lt;font color=Crimson&gt;-- Info table, may be empty&lt;/font&gt;
     &lt;font color=Green&gt;CLabel&lt;/font&gt;            &lt;font color=Crimson&gt;-- Used to generate both info &amp;amp; entry labels&lt;/font&gt;
     &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;LocalReg&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;        &lt;font color=Crimson&gt;-- Argument locals live on entry (C-- procedure params)&lt;/font&gt;
     &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;GenBasicBlock&lt;/font&gt; &lt;font color=Black&gt;i&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt; &lt;font color=Crimson&gt;-- Code, may be empty.  The first block is&lt;/font&gt;
                       &lt;font color=Crimson&gt;-- the entry point.  The order is otherwise initially &lt;/font&gt;
                       &lt;font color=Crimson&gt;-- unimportant, but at some point the code gen will&lt;/font&gt;
                       &lt;font color=Crimson&gt;-- fix the order.&lt;/font&gt;

               &lt;font color=Crimson&gt;-- the BlockId of the first block does not give rise&lt;/font&gt;
               &lt;font color=Crimson&gt;-- to a label.  To jump to the first block in a Proc,&lt;/font&gt;
               &lt;font color=Crimson&gt;-- use the appropriate CLabel.&lt;/font&gt;

  &lt;font color=Crimson&gt;-- some static data.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmData&lt;/font&gt; &lt;font color=Green&gt;Section&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Black&gt;d&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;  &lt;font color=Crimson&gt;-- constant values only&lt;/font&gt;

&lt;font color=DarkOrchid&gt;type&lt;/font&gt; &lt;font color=Green&gt;CmmTop&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;GenCmmTop&lt;/font&gt; &lt;font color=Green&gt;CmmStatic&lt;/font&gt; &lt;font color=Green&gt;CmmStmt&lt;/font&gt;</code></pre>
</pre>
<pre><code>CmmStmt</code></pre>
<p>is described in [wiki:Commentary/Compiler/CmmType#StatementsandCalls Statements and Calls];<br />
</p>
<pre><code>Section</code></pre>
<p>is described in [wiki:Commentary/Compiler/CmmType#SectionsandDirectives Sections and Directives];<br />
the static data in</p>
<pre><code>[d]` is [`CmmStatic`] from the type synonym `Cmm</code></pre>
<dl>
<dt><br />
</dt>

</dl>
<pre><code>CmmStatic</code></pre>
<p>is described in [wiki:Commentary/Compiler/CmmType#LiteralsandLabels Literals and Labels].</p>
<h4 id="basic-blocks-and-procedures">Basic Blocks and Procedures</h4>
<p>Cmm procedures are represented by the first constructor in</p>
<pre><code>GenCmmTop d i</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>#!html
&lt;pre&gt;
    &lt;font color=Green&gt;CmmProc&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Black&gt;d&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;LocalReg&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;GenBasicBlock&lt;/font&gt; &lt;font color=Black&gt;i&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;</code></pre>
</pre>
<p>For a description of Cmm labels and the</p>
<pre><code>CLabel</code></pre>
<p>data type, see the subsection [wiki:Commentary/Compiler/CmmType#LiteralsandLabels Literals and Labels], below.</p>
<p>Cmm Basic Blocks are labeled blocks of Cmm code ending in an explicit jump. Sections (see [wiki:Commentary/Compiler/CmmType#SectionsandDirectives Sections and Directives]) have no jumps--in Cmm, Sections cannot contain nested Procedures (see, e.g., [wiki:Commentary/Compiler/CmmType#CompilingCmmwithGHC Compiling Cmm with GHC]). Basic Blocks encapsulate parts of Procedures. The data type</p>
<pre><code>GenBasicBlock` and the type synonym `CmmBasicBlock</code></pre>
<p>encapsulate Basic Blocks; they are defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;GenBasicBlock&lt;/font&gt; &lt;font color=Black&gt;i&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;BasicBlock&lt;/font&gt; &lt;font color=Green&gt;BlockId&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Black&gt;i&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;

&lt;font color=DarkOrchid&gt;type&lt;/font&gt; &lt;font color=Green&gt;CmmBasicBlock&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;GenBasicBlock&lt;/font&gt; &lt;font color=Green&gt;CmmStmt&lt;/font&gt;

&lt;font color=DarkOrchid&gt;newtype&lt;/font&gt; &lt;font color=Green&gt;BlockId&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;BlockId&lt;/font&gt; &lt;font color=Green&gt;Unique&lt;/font&gt;
  &lt;font color=DarkOrchid&gt;deriving&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;Eq&lt;/font&gt;&lt;font color=Blue&gt;,&lt;/font&gt;&lt;font color=Green&gt;Ord&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;

&lt;font color=DarkOrchid&gt;instance&lt;/font&gt; &lt;font color=Green&gt;Uniquable&lt;/font&gt; &lt;font color=Green&gt;BlockId&lt;/font&gt; &lt;font color=DarkOrchid&gt;where&lt;/font&gt;
  &lt;font color=Orange&gt;getUnique&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;BlockId&lt;/font&gt; &lt;font color=Black&gt;u&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Black&gt;u&lt;/font&gt;</code></pre>
</pre>
<p>The</p>
<pre><code>BlockId` data type simply carries a `Unique` with each Basic Block.  For descriptions of `Unique</code></pre>
<p>, see</p>
<ul>
<li>the [wiki:Commentary/Compiler/Renamer Renamer] page;</li>
<li>the [wiki:Commentary/Compiler/WiredIn#Knownkeythings Known Key Things] section of the [wiki:Commentary/Compiler/WiredIn Wired-in and Known Key Things] page; and,</li>
<li>the [wiki:Commentary/Compiler/EntityTypes#Typevariablesandtermvariables Type variables and term variables] section of the [wiki:Commentary/Compiler/EntityTypes Entity Types] page.</li>
</ul>
<h3 id="variables-registers-and-types">Variables, Registers and Types</h3>
<p>Like other high level assembly languages, all variables in C-- are machine registers, separated into different types according to bit length (8, 16, 32, 64, 80, 128) and register type (integral or floating point). The C-- standard specifies little more type information about a register than its bit length: there are no distinguishing types for signed or unsigned integrals, or for &quot;pointers&quot; (registers holding a memory address). A C-- standard compiler supports additional information on the type of a register value through compiler <em>hints</em>. In a foreign call, a</p>
<pre><code>&quot;signed&quot; bits8` would be sign-extended and may be passed as a 32-bit value.  Cmm diverges from the C-- specification on this point somewhat (see below).  C-- and Cmm do not represent special registers, such as a Condition Register (`CR`) or floating point unit (FPU) status and control register (`FPSCR` on the PowerPC, `MXCSR</code></pre>
<p>on Intel x86 processors), as these are a matter for the [wiki:Commentary/Compiler/Backends Backends].</p>
<p>C-- and Cmm hide the actual number of registers available on a particular machine by assuming an &quot;infinite&quot; supply of registers. A backend, such as the NCG or C compiler on GHC, will later optimise the number of registers used and assign the Cmm variables to actual machine registers; the NCG temporarily stores any overflow in a small memory stack called the <em>spill stack</em>, while the C compiler relies on C's own runtime system. Haskell handles Cmm registers with three data types:</p>
<pre><code>LocalReg`, `GlobalReg` and `CmmReg`.  `LocalReg`s and `GlobalRegs` are collected together in a single `Cmm</code></pre>
<p>data type:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CmmReg&lt;/font&gt; 
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;CmmLocal&lt;/font&gt;  &lt;font color=Green&gt;LocalReg&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmGlobal&lt;/font&gt; &lt;font color=Green&gt;GlobalReg&lt;/font&gt;
  &lt;font color=DarkOrchid&gt;deriving&lt;/font&gt;&lt;font color=Blue&gt;(&lt;/font&gt; &lt;font color=Green&gt;Eq&lt;/font&gt; &lt;font color=Blue&gt;)&lt;/font&gt;</code></pre>
</pre>
<h4 id="local-registers">Local Registers</h4>
<p>Local Registers exist within the scope of a Procedure:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;LocalReg&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;LocalReg&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Unique&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;</code></pre>
</pre>
<p>For a list of references with information on</p>
<pre><code>Unique</code></pre>
<p>, see the [wiki:Commentary/Compiler/CmmType#BasicBlocksandProcedures Basic Blocks and Procedures] section, above.</p>
<p>A</p>
<pre><code>MachRep</code></pre>
<p>, the type of a machine register, is defined in <a href="GhcFile(compiler/cmm/MachOp.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/MachOp.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;I8&lt;/font&gt;     &lt;font color=Crimson&gt;-- integral type, 8 bits wide (a byte)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;I16&lt;/font&gt;        &lt;font color=Crimson&gt;-- integral type, 16 bits wide&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;I32&lt;/font&gt;        &lt;font color=Crimson&gt;-- integral type, 32 bits wide&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;I64&lt;/font&gt;        &lt;font color=Crimson&gt;-- integral type, 64 bits wide&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;I128&lt;/font&gt;   &lt;font color=Crimson&gt;-- integral type, 128 bits wide (an integral vector register)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;F32&lt;/font&gt;        &lt;font color=Crimson&gt;-- floating point type, 32 bits wide (float)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;F64&lt;/font&gt;        &lt;font color=Crimson&gt;-- floating point type, 64 bits wide (double)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;F80&lt;/font&gt;        &lt;font color=Crimson&gt;-- extended double-precision, used in x86 native codegen only.&lt;/font&gt;
  &lt;font color=DarkOrchid&gt;deriving&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;Eq&lt;/font&gt;&lt;font color=Blue&gt;,&lt;/font&gt; &lt;font color=Green&gt;Ord&lt;/font&gt;&lt;font color=Blue&gt;,&lt;/font&gt; &lt;font color=Green&gt;Show&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;</code></pre>
</pre>
<p>There is currently no register for floating point vectors, such as</p>
<pre><code>F128`.  The types of Cmm variables are defined in the Happy parser file [[GhcFile(compiler/cmm/CmmParse.y)]] and the Alex lexer file [[GhcFile(compiler/cmm/CmmLex.x)]].  (Happy and Alex will compile these into `CmmParse.hs` and `CmmLex.hs`, respectively.)  Cmm recognises the following `C--</code></pre>
<p>types as parseable tokens, listed next to their corresponding</p>
<pre><code>define</code></pre>
<p>s in <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a> and their STG types:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p><strong>Cmm Token</strong></p></td>
<td align="left"><p><strong>Cmm.h #define</strong></p></td>
<td align="left"><p><strong>STG type</strong></p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>bits8</code></pre></td>
<td align="left"><pre><code>I8</code></pre></td>
<td align="left"><pre><code>StgChar` or `StgWord8</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>bits16</code></pre></td>
<td align="left"><pre><code>I16</code></pre></td>
<td align="left"><pre><code>StgWord16</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>bits32</code></pre></td>
<td align="left"><pre><code>I32`, `CInt`, `CLong</code></pre></td>
<td align="left"><pre><code>StgWord32`; `StgWord</code></pre>
<p>(depending on architecture)</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>bits64</code></pre></td>
<td align="left"><pre><code>I64`, `CInt`, `CLong`, `L_</code></pre></td>
<td align="left"><pre><code>StgWord64`; `StgWord</code></pre>
<p>(depending on architecture)</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>float32</code></pre></td>
<td align="left"><pre><code>F_</code></pre></td>
<td align="left"><pre><code>StgFloat</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>float64</code></pre></td>
<td align="left"><pre><code>D_</code></pre></td>
<td align="left"><pre><code>StgDouble</code></pre></td>
</tr>
</tbody>
</table>
<p><a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a> also defines</p>
<pre><code>L_` for `bits64`, so `F_`, `D_` and `L_` correspond to the `GlobalReg` data type constructors `FloatReg`, `DoubleReg` and `LongReg`.  Note that although GHC may generate other register types supported by the `MachRep` data type, such as `I128`, they are not parseable tokens.  That is, they are internal to GHC.  The special defines `CInt` and `CLong` are used for compatibility with C on the target architecture, typically for making `foreign &quot;C&quot;</code></pre>
<p>calls.</p>
<p><strong>Note</strong>: Even Cmm types that are not explicit variables (Cmm literals and results of Cmm expressions) have implicit</p>
<pre><code>MachRep</code></pre>
<p>s, in the same way as you would use temporary registers to hold labelled constants or intermediate values in assembler functions. See:</p>
<ul>
<li>[wiki:Commentary/Compiler/CmmType#LiteralsandLabels Literals and Labels] for information related to the Cmm literals
<pre><code>CmmInt` and `CmmFloat</code></pre>
<dl>
<dt>and,</dt>

</dl></li>
<li>[wiki:Commentary/Compiler/CmmType#Expressions Expressions], regarding the
<pre><code>cmmExprRep</code></pre>
<p>function defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>.</p></li>
</ul>
<h4 id="global-registers-and-hints">Global Registers and Hints</h4>
<p>These are universal both to a Cmm module and to the whole compiled program. Variables are global if they are declared at the top-level of a compilation unit (outside any procedure). Global Variables are marked as external symbols with the</p>
<pre><code>.globl` assembler directive.  In Cmm, global registers are used for special STG registers and specific registers for passing arguments and returning values.  The Haskell representation of Global Variables (Registers) is the `GlobalReg</code></pre>
<p>data type, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;GlobalReg&lt;/font&gt;
  &lt;font color=Crimson&gt;-- Argument and return registers&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;VanillaReg&lt;/font&gt;         &lt;font color=Crimson&gt;-- pointers, unboxed ints and chars&lt;/font&gt;
    &lt;font color=Crimson&gt;{-# UNPACK #-}&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Int&lt;/font&gt; &lt;font color=Crimson&gt;-- register number, such as R3, R11&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;FloatReg&lt;/font&gt;               &lt;font color=Crimson&gt;-- single-precision floating-point registers&lt;/font&gt;
    &lt;font color=Crimson&gt;{-# UNPACK #-}&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Int&lt;/font&gt; &lt;font color=Crimson&gt;-- register number&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;DoubleReg&lt;/font&gt;              &lt;font color=Crimson&gt;-- double-precision floating-point registers&lt;/font&gt;
    &lt;font color=Crimson&gt;{-# UNPACK #-}&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Int&lt;/font&gt; &lt;font color=Crimson&gt;-- register number&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;LongReg&lt;/font&gt;                    &lt;font color=Crimson&gt;-- long int registers (64-bit, really)&lt;/font&gt;
    &lt;font color=Crimson&gt;{-# UNPACK #-}&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Int&lt;/font&gt; &lt;font color=Crimson&gt;-- register number&lt;/font&gt;

  &lt;font color=Crimson&gt;-- STG registers&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;Sp&lt;/font&gt;         &lt;font color=Crimson&gt;-- Stack ptr; points to last occupied stack location.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;SpLim&lt;/font&gt;      &lt;font color=Crimson&gt;-- Stack limit&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;Hp&lt;/font&gt;         &lt;font color=Crimson&gt;-- Heap ptr; points to last occupied heap location.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;HpLim&lt;/font&gt;      &lt;font color=Crimson&gt;-- Heap limit register&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CurrentTSO&lt;/font&gt;     &lt;font color=Crimson&gt;-- pointer to current thread&#39;s TSO&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CurrentNursery&lt;/font&gt; &lt;font color=Crimson&gt;-- pointer to allocation area&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;HpAlloc&lt;/font&gt;        &lt;font color=Crimson&gt;-- allocation count for heap check failure&lt;/font&gt;

  &lt;font color=Crimson&gt;-- We keep the address of some commonly-called &lt;/font&gt;
  &lt;font color=Crimson&gt;-- functions in the register table, to keep code&lt;/font&gt;
  &lt;font color=Crimson&gt;-- size down:&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;GCEnter1&lt;/font&gt;       &lt;font color=Crimson&gt;-- stg_gc_enter_1&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;GCFun&lt;/font&gt;      &lt;font color=Crimson&gt;-- stg_gc_fun&lt;/font&gt;

  &lt;font color=Crimson&gt;-- Base offset for the register table, used for accessing registers&lt;/font&gt;
  &lt;font color=Crimson&gt;-- which do not have real registers assigned to them.  This register&lt;/font&gt;
  &lt;font color=Crimson&gt;-- will only appear after we have expanded GlobalReg into memory accesses&lt;/font&gt;
  &lt;font color=Crimson&gt;-- (where necessary) in the native code generator.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;BaseReg&lt;/font&gt;

  &lt;font color=Crimson&gt;-- Base Register for PIC (position-independent code) calculations&lt;/font&gt;
  &lt;font color=Crimson&gt;-- Only used inside the native code generator. It&#39;s exact meaning differs&lt;/font&gt;
  &lt;font color=Crimson&gt;-- from platform to platform  (see compiler/nativeGen/PositionIndependentCode.hs).&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;PicBaseReg&lt;/font&gt;</code></pre>
</pre>
<p>For a description of the</p>
<pre><code>Hp` and `Sp` &#39;&#39;virtual registers&#39;&#39;, see [wiki:Commentary/Rts/HaskellExecution The Haskell Execution Model] page.  General `GlobalReg</code></pre>
<p>s are clearly visible in Cmm code according to the following syntax defined in <a href="GhcFile(compiler/cmm/CmmLex.x)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmLex.x)</a>:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>'''</p>
<pre><code>GlobalReg</code></pre>
<p>Constructor'''</p></td>
<td align="left"><p><strong>Syntax</strong></p></td>
<td align="left"><p><strong>Examples</strong></p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>VanillaReg Int</code></pre></td>
<td align="left"><pre><code>R ++ Int</code></pre></td>
<td align="left"><pre><code>R1`, `R10</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>FloatReg Int</code></pre></td>
<td align="left"><pre><code>F ++ Int</code></pre></td>
<td align="left"><pre><code>F1`, `F10</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>DoubleReg Int</code></pre></td>
<td align="left"><pre><code>D ++ Int</code></pre></td>
<td align="left"><pre><code>D1`, `D10</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>LongReg Int</code></pre></td>
<td align="left"><pre><code>L ++ Int</code></pre></td>
<td align="left"><pre><code>L1`, `L10</code></pre></td>
</tr>
</tbody>
</table>
<p>General</p>
<pre><code>GlobalRegs` numbers are decimal integers, see the `parseInteger` function in [[GhcFile(compiler/utils/StringBuffer.lhs)]].  The remainder of the `GlobalReg` constructors, from `Sp` to `BaseReg` are lexical tokens exactly like their name in the data type; `PicBaseReg</code></pre>
<p>does not have a lexical token since it is used only inside the NCG. See [wiki:Commentary/PositionIndependentCode Position Independent Code and Dynamic Linking] for an in-depth description of PIC implementations in the NCG.</p>
<pre><code>GlobalRegs` are a very special case in Cmm, partly because they must conform to the STG register convention and the target C calling convention.  That the Cmm parser recognises `R1` and `F3` as `GlobalRegs</code></pre>
<p>is only the first step. The main files to look at for more information on this delicate topic are:</p>
<ul>
<li><a href="GhcFile(compiler/codeGen/CgCallConv.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/CgCallConv.hs)</a> (the section on &quot;Register assignment&quot;)</li>
<li><a href="GhcFile(includes/stg/Regs.h)" class="uri" title="wikilink">GhcFile(includes/stg/Regs.h)</a> (defining STG registers)</li>
<li><a href="GhcFile(includes/stg/MachRegs.h)" class="uri" title="wikilink">GhcFile(includes/stg/MachRegs.h)</a> (target-specific mapping of machine registers for <em>registerised</em> builds of GHC)</li>
<li><a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a> (examples of
<pre><code>GlobalReg</code></pre>
<p>register usage for out-of-line primops)</p></li>
</ul>
<p>All arguments to out-of-line PrimOps in <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a> are STG registers.</p>
<p>Cmm recognises all C-- syntax with regard to <em>hints</em>. For example:</p>
<pre><code>&quot;signed&quot; bits32 x;  // signed or unsigned int with hint &quot;signed&quot;

foreign &quot;C&quot; labelThread(R1 &quot;ptr&quot;, R2 &quot;ptr&quot;) [];

&quot;ptr&quot; info = foreign &quot;C&quot; lockClosure(mvar &quot;ptr&quot;) [];</code></pre>
<p>Hints are represented in Haskell as</p>
<pre><code>MachHint`s, defined near `MachRep</code></pre>
<p>in <a href="GhcFile(compiler/cmm/MachOp.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/MachOp.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;MachHint&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;NoHint&lt;/font&gt; &lt;font color=Crimson&gt;-- string: &quot;NoHint&quot; Cmm syntax: [empty]&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;PtrHint&lt;/font&gt;    &lt;font color=Crimson&gt;-- string: &quot;PtrHint&quot;    Cmm syntax: &quot;ptr&quot;    (C-- uses &quot;address&quot;)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;SignedHint&lt;/font&gt; &lt;font color=Crimson&gt;-- string: &quot;SignedHint&quot; Cmm syntax: &quot;signed&quot;&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;FloatHint&lt;/font&gt;  &lt;font color=Crimson&gt;-- string: &quot;FloatHint&quot;  Cmm syntax: &quot;float&quot; &lt;/font&gt;</code></pre>
</pre>
<p>Although the C-- specification does not allow the C-- type system to statically distinguish between floats, signed ints, unsigned ints or pointers, Cmm does. Cmm</p>
<pre><code>MachRep`s carry the float or int kind of a variable, either within a local block or in a global register.  `GlobalReg` includes separate constructors for `Vanilla`, `Float`, `Double` and `Long`.  Cmm still does not distinguish between signed ints, unsigned ints and pointers (addresses) at the register level, as these are given &#39;&#39;hint&#39;&#39; pseudo-types or their real type is determined as they run through primitive operations.  `MachHint</code></pre>
<p>s still follow the C-- specification and carry kind information as an aide to the backend optimisers.</p>
<p>Global Registers in Cmm currently have a problem with inlining: because neither <a href="GhcFile(compiler/cmm/PprC.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/PprC.hs)</a> nor the NCG are able to keep Global Registers from clashing with C argument passing registers, Cmm expressions that contain Global Registers cannot be inlined into an argument position of a foreign call. For more thorough notes on inlining, see the comments in <a href="GhcFile(compiler/cmm/CmmOpt.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmOpt.hs)</a>.</p>
<h4 id="declaration-and-initialisation">Declaration and Initialisation</h4>
<p>Cmm variables hold the same values registers do in assembly languages but may be declared in a similar way to variables in C. As in C--, they may actually be declared anywhere in the scope for which they are visible (a block or file)--for Cmm, this is done by the</p>
<pre><code>loopDecls</code></pre>
<p>function in <a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a>. In <a href="GhcFile(compiler/rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(compiler/rts/PrimOps.cmm)</a>, you will see Cmm variable declarations like this one:</p>
<pre><code>W_ w, code, val;  // W_ is a cpp #define for StgWord, 
          // a machine word (32 or 64-bit--general register size--unsigned int)</code></pre>
<p>Remember that Cmm code is run through the C preprocessor.</p>
<pre><code>W_` will be transformed into `bits32`, `bits64` or whatever is the `bits`&#39;&#39;size&#39;&#39; of the machine word, as defined in [[GhcFile(includes/Cmm.h)]].  In Haskell code, you may use the [[GhcFile(compiler/cmm/MachOp.hs)]] functions `wordRep` and `halfWordRep</code></pre>
<p>to dynamically determine the machine word size. For a description of word sizes in GHC, see the [wiki:Commentary/Rts/Word Word] page.</p>
<p>The variables</p>
<pre><code>w`, `code` and `val` should be real registers. With the above declaration the variables are uninitialised.  Initialisation requires an assignment &#39;&#39;statement&#39;&#39;.  Cmm does not recognise C-- &quot;`{` &#39;&#39;literal&#39;&#39;, ... `}`&quot; initialisation syntax, such as `bits32{10}` or `bits32[3] {1, 2, 3}</code></pre>
<p>. Cmm does recognise initialisation with a literal:</p>
<pre><code>string_name:    bits8[] &quot;twenty character string\n\0&quot;;

variable_num:   bits32 10::bits32;</code></pre>
<p>The typical method seems to be to declare variables and then initialise them just before their first use. (Remember that you may declare a variable anywhere in a procedure and use it in an expression before it is initialised but you must initialise it before using it anywhere else--statements, for example.)</p>
<h4 id="memory-access">Memory Access</h4>
<p>If the value in</p>
<pre><code>w</code></pre>
<p>were the address of a memory location, you would obtain the value at that location similar to Intel assembler syntax. In Cmm, you would write:</p>
<pre><code>code = W_[w];  // code is assigned the W_ value at memory address w</code></pre>
<p>compare the above statement to indirect addressing in Intel assembler:</p>
<pre><code>mov al, [eax]  ; move value in memory at indirect address in register eax, 
           ; into register al</code></pre>
<p>The code between the brackets (</p>
<pre><code>w` in `[w]</code></pre>
<p>, above) is an <em>expression</em>. See the [wiki:Commentary/Compiler/CmmType#Expressions Expressions] section. For now, consider the similarity between the Cmm-version of indexed memory addressing syntax, here:</p>
<pre><code>R1 = bits32[R2 + R3];   // R2 (memory address), R3 (index, offset), result: type bits32

// note: in Cmm &#39;R2&#39; and &#39;R3&#39; would be parsed as global registers
// this is generally bad form; instead, 
// declare a local variable and initialise it with a global, such as:
bits32 adr, ofs, res;
adr = R2;
ofs = R3;
res = bits32[adr + ofs];
R1 = res;

// using local variables will give the NCG some leeway to avoid clobbering the globals
// should you call another procedure somewhere in the same scope</code></pre>
<p>and the corresponding Intel assembler indexed memory addressing syntax, here:</p>
<pre><code>mov al, ebx[eax]    ; ebx (base), eax (index)
; or
mov al, [ebx + eax]</code></pre>
<p>You will generally not see this type of syntax in either handwritten or GHC-produced Cmm code, although it is allowed; it simply shows up in macros. C-- also allows the</p>
<pre><code>*` (multiplication) operator in addressing expressions, for an approximation of &#39;&#39;scaled&#39;&#39; addressing (`[base * (2^n)]`); for example, `n` (the &quot;scale&quot;) must be `0`, `1`, `2` or `4`.  C-- itself would not enforce alignment or limits on the scale.  Cmm, however, could not process it: since the NCG currently outputs GNU Assembler syntax, the Cmm or NCG optimisers would have to reduce `n` in (`* n`) to an absolute address or relative offset, or to an expression using only `+` or `-`.  This is not currently the case and would be difficult to implement where one of the operands to the `*</code></pre>
<p>is a relative address not visible in the code block. <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a> defines macros to perform the calculation with a constant. For example:</p>
<pre><code>/* Converting quantities of words to bytes */
#define WDS(n) ((n)*SIZEOF_W)  // SIZEOF_W is a constant</code></pre>
<p>is used in:</p>
<pre><code>#define Sp(n)  W_[Sp + WDS(n)]</code></pre>
<p>The function</p>
<pre><code>cmmMachOpFold` in [[GhcFile(compiler/cmm/CmmOpt.hs)]] will reduce the resulting expression `Sp + (n * SIZEOF_W)` to `Sp + N`, where `N` is a constant.  A very large number of macros for accessing STG struct fields and the like are produced by [[GhcFile(includes/mkDerivedConstants.c)]] and output into the file `includes/DerivedConstants.h</code></pre>
<p>when GHC is compiled.</p>
<p>Of course, all this also holds true for the reverse (when an assignment is made to a memory address):</p>
<pre><code>section &quot;data&quot; {
    num_arr: bits32[10];
}

proc1 {
    // ...
    bits32[num_arr + (2*3)] = 5::bits32;  // in C: num_arr[(2*3)] = 5;
    // ...
}</code></pre>
<p>or, for an example of a macro from</p>
<pre><code>DerivedConstants.h</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>StgAtomicallyFrame_code(frame) = R1;</code></pre>
<p>this will be transformed to:</p>
<pre><code>REP_StgAtomicallyFrame_code[frame + SIZEOF_StgHeader + OFFSET_StgAtomicallyFrame_code] = R1;
// further reduces to (on Darwin PPC arch):
I32[frame + SIZEOF_StgHeader + 0] = R1;</code></pre>
<h3 id="literals-and-labels">Literals and Labels</h3>
<p>Cmm literals are exactly like C-- literals, including the Haskell-style type syntax, for example:</p>
<pre><code>0x00000001::bits32`.  Cmm literals may be used for initialisation by assignment or in expressions. The `CmmLit` and `CmmStatic</code></pre>
<p>data types, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a> together represent Cmm literals, static information and Cmm labels:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CmmLit&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;CmmInt&lt;/font&gt; &lt;font color=Green&gt;Integer&lt;/font&gt;  &lt;font color=Green&gt;MachRep&lt;/font&gt;
    &lt;font color=Crimson&gt;-- Interpretation: the 2&#39;s complement representation of the value&lt;/font&gt;
    &lt;font color=Crimson&gt;-- is truncated to the specified size.  This is easier than trying&lt;/font&gt;
    &lt;font color=Crimson&gt;-- to keep the value within range, because we don&#39;t know whether&lt;/font&gt;
    &lt;font color=Crimson&gt;-- it will be used as a signed or unsigned value (the MachRep doesn&#39;t&lt;/font&gt;
    &lt;font color=Crimson&gt;-- distinguish between signed &amp;amp; unsigned).&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmFloat&lt;/font&gt;  &lt;font color=Green&gt;Rational&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmLabel&lt;/font&gt;    &lt;font color=Green&gt;CLabel&lt;/font&gt;            &lt;font color=Crimson&gt;-- Address of label&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmLabelOff&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt; &lt;font color=Green&gt;Int&lt;/font&gt;       &lt;font color=Crimson&gt;-- Address of label + byte offset&lt;/font&gt;
  
        &lt;font color=Crimson&gt;-- Due to limitations in the C backend, the following&lt;/font&gt;
        &lt;font color=Crimson&gt;-- MUST ONLY be used inside the info table indicated by label2&lt;/font&gt;
        &lt;font color=Crimson&gt;-- (label2 must be the info label), and label1 must be an&lt;/font&gt;
        &lt;font color=Crimson&gt;-- SRT, a slow entrypoint or a large bitmap (see the Mangler)&lt;/font&gt;
        &lt;font color=Crimson&gt;-- Don&#39;t use it at all unless tablesNextToCode.&lt;/font&gt;
        &lt;font color=Crimson&gt;-- It is also used inside the NCG during when generating&lt;/font&gt;
        &lt;font color=Crimson&gt;-- position-independent code. &lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmLabelDiffOff&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt; &lt;font color=Green&gt;Int&lt;/font&gt;   &lt;font color=Crimson&gt;-- label1 - label2 + offset&lt;/font&gt;</code></pre>
</pre>
<p>Note how the</p>
<pre><code>CmmLit` constructor `CmmInt Integer MachRep` contains sign information in the `Integer`, the representation of the literal itself: this conforms to the C-- specification, where integral literals contain sign information. For an example of a function using `CmmInt` sign information, see `cmmMachOpFold` in [[GhcFile(compiler/cmm/CmmOpt.hs)]], where sign-operations are performed on the `Integer</code></pre>
<p>.</p>
<p>The</p>
<pre><code>MachRep` of a literal, such as `CmmInt Integer MachRep` or `CmmFloat Rational MachRep` may not always require the size defined by `MachRep`.  The NCG optimiser, [[GhcFile(compiler/nativeGen/MachCodeGen.hs)]], will test a literal such as `1::bits32` (in Haskell, `CmmInt (1::Integer) I32`) for whether it would fit into the bit-size of Assembler instruction literals on that particular architecture with a function defined in [[GhcFile(compiler/nativeGen/MachRegs.lhs)]], such as `fits16Bits` on the PPC.  If the Integer literal fits, the function `makeImmediate` will truncate it to the specified size if possible and store it in a NCG data type, `Imm`, specifically `Maybe Imm</code></pre>
<p>. (These are also defined in <a href="GhcFile(compiler/nativeGen/MachRegs.lhs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/MachRegs.lhs)</a>.)</p>
<p>The Haskell representation of Cmm separates unchangeable Cmm values into a separate data type,</p>
<pre><code>CmmStatic</code></pre>
<p>, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CmmStatic&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;CmmStaticLit&lt;/font&gt; &lt;font color=Green&gt;CmmLit&lt;/font&gt;   
    &lt;font color=Crimson&gt;-- a literal value, size given by cmmLitRep of the literal.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmUninitialised&lt;/font&gt; &lt;font color=Green&gt;Int&lt;/font&gt;
    &lt;font color=Crimson&gt;-- uninitialised data, N bytes long&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmAlign&lt;/font&gt; &lt;font color=Green&gt;Int&lt;/font&gt;
    &lt;font color=Crimson&gt;-- align to next N-byte boundary (N must be a power of 2).&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmDataLabel&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt;
    &lt;font color=Crimson&gt;-- label the current position in this section.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmString&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;Word8&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;
    &lt;font color=Crimson&gt;-- string of 8-bit values only, not zero terminated.&lt;/font&gt;</code></pre>
</pre>
<p>Note the</p>
<pre><code>CmmAlign` constructor: this maps to the assembler directive `.align N` to set alignment for a data item (hopefully one you remembered to label).  This is the same as the `align` directive noted in Section 4.5 of the [http://cminusminus.org/extern/man2.pdf C-- specification (PDF)].  In the current implementation of Cmm the `align` directive seems superfluous because [[GhcFile(compiler/nativeGen/PprMach.hs)]] translates `Section</code></pre>
<p>s to assembler with alignment directives corresponding to the target architecture (see [wiki:Commentary/Compiler/CmmType#SectionsandDirectives Sections and Directives], below).</p>
<h4 id="labels">Labels</h4>
<p>Remember that C--/Cmm names consist of a string where the first character is:</p>
<ul>
<li>ASCII alphabetic (uppercase or lowercase);</li>
<li>an underscore:
<pre><code>_</code></pre>
<p>;</p></li>
<li>a period:
<pre><code>.</code></pre>
<p>;</p></li>
<li>a dollar sign:
<pre><code>$</code></pre>
<p>; or,</p></li>
<li>a commercial at:
<pre><code>@</code></pre>
<p>.</p></li>
</ul>
<p>Cmm labels conform to the C-- specification. C--/Cmm uses labels to refer to memory locations in code--if you use a data directive but do not give it a label, you will have no means of referring to the memory! For</p>
<pre><code>GlobalReg`s (transformed to assembler `.globl`), labels serve as both symbols and labels (in the assembler meaning of the terms).  The Haskell representation of Cmm Labels is contained in the `CmmLit` data type, see [wiki:Commentary/Compiler/CmmType#Literals Literals] section, above.  Note how Cmm Labels are `CLabel`s with address information.  The `Clabel</code></pre>
<p>data type, defined in <a href="GhcFile(compiler/cmm/CLabel.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CLabel.hs)</a>, is used throughout the Compiler for symbol information in binary files. Here it is:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;IdLabel&lt;/font&gt;                &lt;font color=Crimson&gt;-- A family of labels related to the&lt;/font&gt;
    &lt;font color=Green&gt;Name&lt;/font&gt;           &lt;font color=Crimson&gt;-- definition of a particular Id or Con&lt;/font&gt;
    &lt;font color=Green&gt;IdLabelInfo&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;DynIdLabel&lt;/font&gt;         &lt;font color=Crimson&gt;-- like IdLabel, but in a separate package,&lt;/font&gt;
    &lt;font color=Green&gt;Name&lt;/font&gt;           &lt;font color=Crimson&gt;-- and might therefore need a dynamic&lt;/font&gt;
    &lt;font color=Green&gt;IdLabelInfo&lt;/font&gt;        &lt;font color=Crimson&gt;-- reference.&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CaseLabel&lt;/font&gt;          &lt;font color=Crimson&gt;-- A family of labels related to a particular&lt;/font&gt;
                &lt;font color=Crimson&gt;-- case expression.&lt;/font&gt;
    &lt;font color=Crimson&gt;{-# UNPACK #-}&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Unique&lt;/font&gt;  &lt;font color=Crimson&gt;-- Unique says which case expression&lt;/font&gt;
    &lt;font color=Green&gt;CaseLabelInfo&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;AsmTempLabel&lt;/font&gt; 
    &lt;font color=Crimson&gt;{-# UNPACK #-}&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Unique&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;StringLitLabel&lt;/font&gt;
    &lt;font color=Crimson&gt;{-# UNPACK #-}&lt;/font&gt; &lt;font color=Blue&gt;&lt;nowiki&gt;&lt;/font&gt;&lt;font&lt;/nowiki&gt; color=Green&gt;Unique&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;ModuleInitLabel&lt;/font&gt; 
    &lt;font color=Green&gt;Module&lt;/font&gt;         &lt;font color=Crimson&gt;-- the module name&lt;/font&gt;
    &lt;font color=Green&gt;String&lt;/font&gt;         &lt;font color=Crimson&gt;-- its &quot;way&quot;&lt;/font&gt;
    &lt;font color=Green&gt;Bool&lt;/font&gt;           &lt;font color=Crimson&gt;-- True &amp;lt;=&amp;gt; is in a different package&lt;/font&gt;
    &lt;font color=Crimson&gt;-- at some point we might want some kind of version number in&lt;/font&gt;
    &lt;font color=Crimson&gt;-- the module init label, to guard against compiling modules in&lt;/font&gt;
    &lt;font color=Crimson&gt;-- the wrong order.  We can&#39;t use the interface file version however,&lt;/font&gt;
    &lt;font color=Crimson&gt;-- because we don&#39;t always recompile modules which depend on a module&lt;/font&gt;
    &lt;font color=Crimson&gt;-- whose version has changed.&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;PlainModuleInitLabel&lt;/font&gt;   &lt;font color=Crimson&gt;-- without the vesrion &amp;amp; way info&lt;/font&gt;
    &lt;font color=Green&gt;Module&lt;/font&gt;
    &lt;font color=Green&gt;Bool&lt;/font&gt;           &lt;font color=Crimson&gt;-- True &amp;lt;=&amp;gt; is in a different package&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;ModuleRegdLabel&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;RtsLabel&lt;/font&gt; &lt;font color=Green&gt;RtsLabelInfo&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;ForeignLabel&lt;/font&gt; &lt;font color=Green&gt;FastString&lt;/font&gt;   &lt;font color=Crimson&gt;-- a &#39;C&#39; (or otherwise foreign) label&lt;/font&gt;
    &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;Maybe&lt;/font&gt; &lt;font color=Green&gt;Int&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;       &lt;font color=Crimson&gt;-- possible &#39;@n&#39; suffix for stdcall functions&lt;/font&gt;
        &lt;font color=Crimson&gt;-- When generating C, the &#39;@n&#39; suffix is omitted, but when&lt;/font&gt;
        &lt;font color=Crimson&gt;-- generating assembler we must add it to the label.&lt;/font&gt;
    &lt;font color=Green&gt;Bool&lt;/font&gt;           &lt;font color=Crimson&gt;-- True &amp;lt;=&amp;gt; is dynamic&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CC_Label&lt;/font&gt;  &lt;font color=Green&gt;CostCentre&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CCS_Label&lt;/font&gt; &lt;font color=Green&gt;CostCentreStack&lt;/font&gt;

      &lt;font color=Crimson&gt;-- Dynamic Linking in the NCG:&lt;/font&gt;
      &lt;font color=Crimson&gt;-- generated and used inside the NCG only,&lt;/font&gt;
      &lt;font color=Crimson&gt;-- see module PositionIndependentCode for details.&lt;/font&gt;
      
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;DynamicLinkerLabel&lt;/font&gt; &lt;font color=Green&gt;DynamicLinkerLabelInfo&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt;
        &lt;font color=Crimson&gt;-- special variants of a label used for dynamic linking&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;PicBaseLabel&lt;/font&gt;                &lt;font color=Crimson&gt;-- a label used as a base for PIC calculations&lt;/font&gt;
                                &lt;font color=Crimson&gt;-- on some platforms.&lt;/font&gt;
                                &lt;font color=Crimson&gt;-- It takes the form of a local numeric&lt;/font&gt;
                                &lt;font color=Crimson&gt;-- assembler label &#39;1&#39;; it is pretty-printed&lt;/font&gt;
                                &lt;font color=Crimson&gt;-- as 1b, referring to the previous definition&lt;/font&gt;
                                &lt;font color=Crimson&gt;-- of 1: in the assembler source file.&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;DeadStripPreventer&lt;/font&gt; &lt;font color=Green&gt;CLabel&lt;/font&gt;
    &lt;font color=Crimson&gt;-- label before an info table to prevent excessive dead-stripping on darwin&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;HpcTicksLabel&lt;/font&gt; &lt;font color=Green&gt;Module&lt;/font&gt;       &lt;font color=Crimson&gt;-- Per-module table of tick locations&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;HpcModuleNameLabel&lt;/font&gt;         &lt;font color=Crimson&gt;-- Per-module name of the module for Hpc&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;HpcModuleOffsetLabel&lt;/font&gt; &lt;font color=Green&gt;Module&lt;/font&gt;&lt;font color=Crimson&gt;-- Per-module offset of the module for Hpc (dynamically generated)&lt;/font&gt;

  &lt;font color=DarkOrchid&gt;deriving&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;Eq&lt;/font&gt;&lt;font color=Blue&gt;,&lt;/font&gt; &lt;font color=Green&gt;Ord&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;</code></pre>
</pre>
<h3 id="sections-and-directives">Sections and Directives</h3>
<p>The Haskell representation of Cmm Section directives, in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a> as the first part of the &quot;Static Data&quot; section, is:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;Section&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;Text&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;Data&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;ReadOnlyData&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;RelocatableReadOnlyData&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;UninitialisedData&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;ReadOnlyData16&lt;/font&gt; &lt;font color=Crimson&gt;-- .rodata.cst16 on x86_64, 16-byte aligned&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;OtherSection&lt;/font&gt; &lt;font color=Green&gt;String&lt;/font&gt;</code></pre>
</pre>
<p>Cmm supports the following directives, corresponding to the assembler directives pretty-printed by the</p>
<pre><code>pprSectionHeader</code></pre>
<p>function in <a href="GhcFile(compiler/nativeGen/PprMach.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/PprMach.hs)</a>:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>'''</p>
<pre><code>Section</code></pre>
<p>Constructor'''</p></td>
<td align="left"><p><strong>Cmm section directive</strong></p></td>
<td align="left"><p><strong>Assembler Directive</strong></p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>Text</code></pre></td>
<td align="left"><pre><code>&quot;text&quot;</code></pre></td>
<td align="left"><pre><code>.text</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>Data</code></pre></td>
<td align="left"><pre><code>&quot;data&quot;</code></pre></td>
<td align="left"><pre><code>.data</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>ReadOnlyData</code></pre></td>
<td align="left"><pre><code>&quot;rodata&quot;</code></pre></td>
<td align="left"><pre><code>.rodata</code></pre>
<p><br />
(generally; varies by arch,OS)</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>RelocatableReadOnlyData</code></pre></td>
<td align="left"><p>no parse (GHC internal), output:</p>
<pre><code>&quot;relreadonly&quot;</code></pre></td>
<td align="left"><pre><code>.const_data`&lt;br/&gt;`.section .rodata</code></pre>
<p><br />
(generally; varies by arch,OS)</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>UninitialisedData</code></pre></td>
<td align="left"><pre><code>&quot;bss&quot;`, output: `&quot;uninitialised&quot;</code></pre></td>
<td align="left"><pre><code>.bss</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>ReadOnlyData16</code></pre></td>
<td align="left"><p>no parse (GHC internal), output: none</p></td>
<td align="left"><pre><code>.const`&lt;br/&gt;`.section .rodata`&lt;br/&gt;(generally; on x86_64:&lt;br/&gt;`.section .rodata.cst16</code></pre>
<p>)</p></td>
</tr>
</tbody>
</table>
<p>You probably already noticed I omitted the alignment directives (for clarity). For example,</p>
<pre><code>pprSectionHeader` would pretty-print `ReadOnlyData</code></pre>
<p>as</p>
<pre><code>.const
.align 2</code></pre>
<p>on an i386 with the Darwin OS. If you are really on the ball you might have noticed that the</p>
<pre><code>PprMach.hs` output of &quot;`.section .data`&quot; and the like is really playing it safe since on most OS&#39;s, using GNU Assembler, the `.data` directive is equivalent to `.section __DATA .data`, or simply `.section .data`.  Note that `OtherSection String</code></pre>
<p>is not a catch-all for the Cmm parser. If you wrote:</p>
<pre><code>section &quot;.const\n.align 2\n\t.section .rodata&quot; { ... }</code></pre>
<p>The Cmm parser (through GHC) would panic, complaining, &quot;</p>
<pre><code>PprMach.pprSectionHeader: unknown section</code></pre>
<p>.&quot;</p>
<p>While the C-- specification allows a bare</p>
<pre><code>data</code></pre>
<p>keyword directive, Cmm does not:</p>
<pre><code>// this is valid C--, not Cmm!
data { }

// all Cmm directives use this syntax:
section [Cmm section directive] { }</code></pre>
<p>Cmm does not recognise the C-- &quot;</p>
<pre><code>stack</code></pre>
<p>&quot; declaration for allocating memory on the system stack.</p>
<p>GHC-produced Cmm code is replete with</p>
<pre><code>data` sections, each of which is stored in `.data</code></pre>
<p>section of the binary code. This contributes significantly to the large binary size for GHC-compiled code.</p>
<p><code> ==== Target Directive ====</code></p>
<p>The C-- specification defines a special</p>
<pre><code>target` directive, in section 4.7.  The `target</code></pre>
<p>directive is essentially a code block defining the properties of the target architecture:</p>
<pre><code>target
    memsize N   // bit-size of the smallest addressable unit of memory
    byteorder   [big,little]    // endianness
    pointersize N   // bit-size of the native pointer type
    wordsize    N   // bit-size of the native word type</code></pre>
<p>This is essentially a custom-coded version of the GNU Assembler (</p>
<pre><code>as`) `.machine` directive, which is essentially the same as passing the `-arch [cpu_type]` option to `as</code></pre>
<p>.</p>
<p>Cmm does not support the</p>
<pre><code>target` directive.  This is partly due GHC generally lacking cross-compiler capabilities.  Should GHC move toward adding cross-compilation capabilities, the `target</code></pre>
<p>might not be a bad thing to add. Target architecture parameters are currently handled through the [wiki:Attic/Building/BuildSystem Build System], which partly sets such architectural parameters through <a href="GhcFile(includes/mkDerivedConstants.c)" class="uri" title="wikilink">GhcFile(includes/mkDerivedConstants.c)</a> and <a href="GhcFile(includes/ghcconfig.h)" class="uri" title="wikilink">GhcFile(includes/ghcconfig.h)</a>.</p>
<h3 id="expressions">Expressions</h3>
<p>Expressions in Cmm follow the C-- specification. They have:</p>
<ul>
<li>no side-effects; and,</li>
<li>one result:
<ul>
<li>a <em>k</em>-bit value<br />
--these expressions map to the
<pre><code>MachOp</code></pre>
<p>data type, defined in <a href="GhcFile(compiler/cmm/MachOp.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/MachOp.hs)</a>, see [wiki:Commentary/Compiler/CmmType#OperatorsandPrimitiveOperations Operators and Primitive Operations], the <em>k</em>-bit value may be:</p>
<ul>
<li>a Cmm literal (
<pre><code>CmmLit</code></pre>
<p>); or,</p></li>
<li>a Cmm variable (
<pre><code>CmmReg</code></pre>
<p>, see [wiki:Commentary/Compiler/CmmType#VariablesRegistersandTypes Variables, Registers and Types]);<br />
or,</p></li>
</ul></li>
<li>a boolean condition.</li>
</ul></li>
</ul>
<p>Cmm expressions may include</p>
<ul>
<li>a literal or a name (
<pre><code>CmmLit</code></pre>
<p>contains both, see [wiki:Commentary/Compiler/CmmType#LiteralsandLabels Literals and Labels], above);</p></li>
<li>a memory reference (
<pre><code>CmmLoad` and `CmmReg</code></pre>
<p>, see [wiki:Commentary/Compiler/CmmType#MemoryAccess Memory Access], above);</p></li>
<li>an operator (a
<pre><code>MachOp`, in `CmmMachOp</code></pre>
<p>, below); or,</p></li>
<li>another expression (a
<pre><code>[CmmExpr]`, in `CmmMachOp</code></pre>
<p>, below).</p></li>
</ul>
<p>These are all included as constructors in the</p>
<pre><code>CmmExpr</code></pre>
<p>data type, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;CmmLit&lt;/font&gt; &lt;font color=Green&gt;CmmLit&lt;/font&gt;               &lt;font color=Crimson&gt;-- Literal or Label (name)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmLoad&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;     &lt;font color=Crimson&gt;-- Read memory location (memory reference)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmReg&lt;/font&gt; &lt;font color=Green&gt;CmmReg&lt;/font&gt;     &lt;font color=Crimson&gt;-- Contents of register&lt;/font&gt;
*  etc.)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmRegOff&lt;/font&gt; &lt;font color=Green&gt;CmmReg&lt;/font&gt; &lt;font color=Green&gt;Int&lt;/font&gt;</code></pre>
</pre>
<p>Note that</p>
<pre><code>CmmRegOff reg i` is only shorthand for a specific `CmmMachOp</code></pre>
<p>application:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=Green&gt;CmmMachOp&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;MO_Add&lt;/font&gt; rep&lt;font color=Blue&gt;) [(&lt;/font&gt;&lt;font color=Green&gt;CmmReg&lt;/font&gt; reg&lt;font color=Blue&gt;)&lt;/font&gt;,&lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmLit&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmInt&lt;/font&gt; i rep&lt;font color=Blue&gt;))]&lt;/font&gt;
    &lt;font color=DarkOrchid&gt;where&lt;/font&gt; rep &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Orange&gt;cmmRegRep&lt;/font&gt; reg</code></pre>
</pre>
<p>The function</p>
<pre><code>cmmRegRep` is described below.  Note: the original comment following `CmmExpr` in [[GhcFile(compiler/cmm/Cmm.hs)]] is erroneous (cf., `mangleIndexTree` in [[GhcFile(compiler/nativeGen/MachCodeGen.hs)]]) but makes the same point described here.  The offset, `(CmmLit (CmmInt i rep))`, is a literal (`CmmLit`), not a name (`CLabel`).  A `CmmExpr` for an offset must be reducible to a `CmmInt</code></pre>
<p><em>in Haskell</em>; in other words, offsets in Cmm expressions may not be external symbols whose addresses are not resolvable in the current context.</p>
<p>Boolean comparisons are not boolean conditions. Boolean comparisons involve relational operators, such as</p>
<pre><code>&gt;`, `&lt;` and `==`, and map to `MachOp`s that are converted to comparison followed by branch instructions.  For example, `&lt;` would map to `MO_S_Lt` for signed operands, [[GhcFile(compiler/nativeGen/MachCodeGen.hs)]] would transform `MO_S_Lt` into the `LTT` constructor of the `Cond` union data type defined in [[GhcFile(compiler/nativeGen/MachInstrs.hs)]] and [[GhcFile(compiler/nativeGen/PprMach.hs)]] would transform `LTT</code></pre>
<p>to the distinguishing comparison type for an assembler comparison instruction. You already know that the result of a comparison instruction is actually a change in the state of the Condition Register (CR), so Cmm boolean expressions do have a kind of side-effect but that is to be expected. In fact, it is necessary since at the least a conditional expression becomes two assembler instructions, in PPC Assembler:</p>
<pre><code>cmplwi   r3, 0  ; condition test
blt      Lch    ; branch instruction</code></pre>
<p>This condition mapping does have an unfortunate consequence: conditional expressions do not fold into single instructions. In Cmm, as in C--, expressions with relational operators may evaluate to an integral (</p>
<pre><code>0`, nonzero) instead of evaluating to a boolean type.  For certain cases, such as an arithmetic operation immediately followed by a comparison, extended mnemonics such as `addi.</code></pre>
<p>might eliminate the comparison instruction. See [wiki:Commentary/Compiler/CmmType#CmmDesignObservationsandAreasforPotentialImprovement Cmm Design: Observations and Areas for Potential Improvement] for more discussion and potential solutions to this situation.</p>
<p>Boolean conditions include:</p>
<pre><code>&amp;&amp;`, `||`, `&lt;nowiki&gt;`&lt;/nowiki&gt; and parenthetical combinations of boolean conditions.  The `if expr { }` and `if expr { } else { }` statements contain boolean conditions.  The C-- type produced by conditional expressions is `bool`, in Cmm, type `BoolExpr</code></pre>
<p>in <a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;BoolExpr&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;BoolExpr&lt;/font&gt; &lt;font color=Blue&gt;&lt;pre&gt;&lt;/font&gt;&lt;font color=Green&gt;BoolAnd&lt;/font&gt;&lt;font color=Blue&gt;</code></pre>
<p></font> <font color=Green>BoolExpr</font></p>
<p><code> </code><font color=Blue><code>|</code></font><code> </code><font color=Green><code>BoolExpr</code></font><code> </code><font color=Blue></p>
<pre><code>&lt;/font&gt;&lt;font color=Green&gt;BoolOr&lt;/font&gt;&lt;font color=Blue&gt;</code></pre>
<p></font> <font color=Green>BoolExpr</font></p>
<p><code> </code><font color=Blue><code>|</code></font><code> </code><font color=Green><code>BoolNot</code></font><code> </code><font color=Green><code>BoolExpr</code></font><br />
<code> </code><font color=Blue><code>|</code></font><code> </code><font color=Green><code>BoolTest</code></font><code> </code><font color=Green><code>CmmExpr</code></font></p>
</pre>
</pre>
<p>The type</p>
<pre><code>BoolExpr` maps to the `CmmCondBranch` or `CmmBranch` constructors of type `CmmStmt</code></pre>
<p>, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>, see [wiki:Commentary/Compiler/CmmType#StatementsandCalls Statements and Calls].</p>
<p>The</p>
<pre><code>CmmExpr` constructor `CmmMachOp MachOp [CmmExpr]` is the core of every operator-based expression; the key here is `MachOp`, which in turn depends on the type of `MachRep` for each operand.  See [wiki:Commentary/Compiler/CmmType#FundamentalandPrimitiveOperators Fundamental and PrimitiveOperators].  In order to process `CmmExpr`s, the data type comes with a deconstructor function to obtain the relevant `MachRep</code></pre>
<p>s, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=Orange&gt;cmmExprRep&lt;/font&gt; &lt;font color=Blue&gt;::&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt; &lt;font color=Blue&gt;-&amp;gt;&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
&lt;font color=Orange&gt;cmmExprRep&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmLit&lt;/font&gt; &lt;font color=Black&gt;lit&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;      &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Orange&gt;cmmLitRep&lt;/font&gt; &lt;font color=Black&gt;lit&lt;/font&gt;
&lt;font color=Orange&gt;cmmExprRep&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmLoad&lt;/font&gt; &lt;font color=Magenta&gt;_&lt;/font&gt; &lt;font color=Black&gt;rep&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;   &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Black&gt;rep&lt;/font&gt;
&lt;font color=Orange&gt;cmmExprRep&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmReg&lt;/font&gt; &lt;font color=Black&gt;reg&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;      &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Orange&gt;cmmRegRep&lt;/font&gt; &lt;font color=Black&gt;reg&lt;/font&gt;
&lt;font color=Orange&gt;cmmExprRep&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmMachOp&lt;/font&gt; &lt;font color=Black&gt;op&lt;/font&gt; &lt;font color=Magenta&gt;_&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Black&gt;resultRepOfMachOp&lt;/font&gt; &lt;font color=Black&gt;op&lt;/font&gt;
&lt;font color=Orange&gt;cmmExprRep&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmRegOff&lt;/font&gt; &lt;font color=Black&gt;reg&lt;/font&gt; &lt;font color=Magenta&gt;_&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt; &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Orange&gt;cmmRegRep&lt;/font&gt; &lt;font color=Black&gt;reg&lt;/font&gt;</code></pre>
</pre>
<p>The deconstructors</p>
<pre><code>cmmLitRep` and `cmmRegRep` (with its supporting deconstructor `localRegRep</code></pre>
<p>) are also defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>.</p>
<p>In PPC Assembler you might add two 32-bit integrals by:</p>
<pre><code>add r3, r1, r2  ; r3 = r1 + r2</code></pre>
<p>while in Cmm you might write:</p>
<pre><code>res = first + second;</code></pre>
<p>Remember that the assignment operator,</p>
<pre><code>=`, is a statement since it has the &quot;side effect&quot; of modifying the value in `res`.  The `+</code></pre>
<p>expression in the above statement, for a 32-bit architecture, would be represented in Haskell as:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=Green&gt;CmmMachOp&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;MO_Add&lt;/font&gt; &lt;font color=Green&gt;I32&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;CmmReg&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmLocal&lt;/font&gt; &lt;font color=Black&gt;uniq&lt;/font&gt; &lt;font color=Green&gt;I32&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;&lt;font color=Blue&gt;,&lt;/font&gt; &lt;font color=Green&gt;CmmReg&lt;/font&gt; &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmLocal&lt;/font&gt; &lt;font color=Black&gt;uniq&lt;/font&gt; &lt;font color=Green&gt;I32&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;</code></pre>
</pre>
<p>The</p>
<pre><code>expr` production rule in the Cmm Parser [[GhcFile(compiler/cmm/CmmParse.y)]] maps tokens to &quot;values&quot;, such as `+` to an addition operation, `MO_Add`.  The `mkMachOp` function in the Parser determines the `MachOp` type in `CmmMachOp MachOp [CmmExpr]` from the token value and the `MachRep` type of the `head` variable.  Notice that the simple `+` operator did not contain sign information, only the `MachRep`.  For `expr`, signed and other `MachOps`, see the `machOps` function in [[GhcFile(compiler/cmm/CmmParse.y)]].  Here is a table of operators and the corresponding `MachOp</code></pre>
<p>s recognised by Cmm (listed in order of precedence):</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p><strong>Operator</strong></p></td>
<td align="left"><p>'''</p>
<pre><code>MachOp</code></pre>
<p>'''</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>/</code></pre></td>
<td align="left"><pre><code>MO_U_Quot</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>*</code></pre></td>
<td align="left"><pre><code>MO_Mul</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>%</code></pre></td>
<td align="left"><pre><code>MO_U_Rem</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>-</code></pre></td>
<td align="left"><pre><code>MO_Sub</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>+</code></pre></td>
<td align="left"><pre><code>MO_Add</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>&gt;&gt;</code></pre></td>
<td align="left"><pre><code>MO_U_Shr</code></pre></td>
</tr>
<tr class="even">
<td align="left"><p>&lt;pre&gt;&lt;&lt;</p>
</pre></td>
<td align="left"><pre><code>MO_Shl</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>&amp;</code></pre></td>
<td align="left"><pre><code>MO_And</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>^</code></pre></td>
<td align="left"><pre><code>MO_Xor</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>|</code></pre></td>
<td align="left"><pre><code>MO_Or</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>&gt;=</code></pre></td>
<td align="left"><pre><code>MO_U_Ge</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>&gt;</code></pre></td>
<td align="left"><pre><code>MO_U_Gt</code></pre></td>
</tr>
<tr class="even">
<td align="left"><p>&lt;pre&gt;&lt;=</p>
</pre></td>
<td align="left"><pre><code>MO_U_Le</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><p>&lt;pre&gt;&lt;</p>
</pre></td>
<td align="left"><pre><code>MO_U_Lt</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>&lt;nowiki&gt;=</code></pre>
<p></nowiki></p></td>
<td align="left"><pre><code>MO_Ne</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>==</code></pre></td>
<td align="left"><pre><code>MO_Eq</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>~</code></pre></td>
<td align="left"><pre><code>MO_Not</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>-</code></pre></td>
<td align="left"><pre><code>MO_S_Neg</code></pre></td>
</tr>
</tbody>
</table>
<h4 id="quasi-operator-syntax">Quasi-operator Syntax</h4>
<p>If you read to the end of</p>
<pre><code>expr` in [[GhcFile(compiler/cmm/CmmParse.y)]], in the next production rule, `expr0`, you will notice that Cmm expressions also recognise a set of name (not symbol) based operators that would probably be better understood as &#39;&#39;quasi-operators&#39;&#39;.  The syntax for these quasi-operators is in some cases similar to syntax for Cmm statements and generally conform to the C-- specification, sections 3.3.2 (`expr</code></pre>
<p>) and 7.4.1 (syntax of primitive operators), <em>except that</em> 3. <em>and, by the equivalence of the two,</em> 1. <em>may return</em> <strong>multiple</strong> '' arguments''. In Cmm, quasi-operators may have side effects. The syntax for quasi-operators may be:</p>
<ol>
<li><pre><code>expr0` &lt;pre&gt;`name`</code></pre>
<p>`expr0</p>
</pre>
<p><br />
(just like infix-functions in Haskell);</p></li>
<li><pre><code>type[ expression ]`&lt;br/&gt;(the memory access quasi-expression described in [wiki:Commentary/Compiler/CmmType#MemoryAccess Memory Access]; the Haskell representation of this syntax is `CmmLoad CmmExpr MachRep</code></pre>
<p>);</p></li>
<li><pre><code>%name( exprs0 )`&lt;br/&gt;(standard prefix form, similar to C-- &#39;&#39;statement&#39;&#39; syntax for procedures but with the distinguishing prefix `%</code></pre>
<dl>
<dt>in Cmm this is <em>also used as statement syntax for calls, which are really built-in procedures</em>, see [wiki:Commentary/Compiler/CmmType#CmmCalls Cmm Calls])</dt>

</dl></li>
</ol>
<p>A</p>
<pre><code>expr0` may be a literal (`CmmLit`) integral, floating point, string or a `CmmReg` (the production rule `reg`: a `name` for a local register (`LocalReg`) or a `GlobalReg</code></pre>
<p>).</p>
<p>Note that the</p>
<pre><code>name` in `expr0</code></pre>
<p>syntax types 1. and 3. must be a known <em>primitive</em> (primitive operation), see [wiki:Commentary/Compiler/CmmType#OperatorsandPrimitiveOperations Operators and Primitive Operations]. The first and third syntax types are interchangeable:</p>
<pre><code>bits32 one, two, res;
one = 1::bits32;
two = 2::bits32;

res = one &lt;pre&gt;lt</code></pre>
<p>two;</p>
<p>// is equivalent to:</p>
<p>res = %lt(one, two);</p>
</pre>
<p>The primitive operations allowed by Cmm are listed in the</p>
<pre><code>machOps` production rule, in [[GhcFile(compiler/cmm/CmmParse.y)]], and largely correspond to `MachOp</code></pre>
<p>data type constructors, in <a href="GhcFile(compiler/cmm/MachOp.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/MachOp.hs)</a>, with a few additions. The primitive operations distinguish between signed, unsigned and floating point types.</p>
<p>Cmm adds some expression macros that map to Haskell Cmm functions. They are listed under</p>
<pre><code>exprMacros</code></pre>
<p>in <a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a> and include:</p>
<ul>
<li><pre><code>ENTRY_CODE</code></pre></li>
<li><pre><code>INFO_PTR</code></pre></li>
<li><pre><code>STD_INFO</code></pre></li>
<li><pre><code>FUN_INFO</code></pre></li>
<li><pre><code>GET_ENTRY</code></pre></li>
<li><pre><code>GET_STD_INFO</code></pre></li>
<li><pre><code>GET_FUN_INFO</code></pre></li>
<li><pre><code>INFO_TYPE</code></pre></li>
<li><pre><code>INFO_PTRS</code></pre></li>
<li><pre><code>INFO_NPTRS</code></pre></li>
<li><pre><code>RET_VEC</code></pre></li>
</ul>
<h3 id="statements-and-calls">Statements and Calls</h3>
<p>Cmm Statements generally conform to the C-- specification, with a few exceptions noted below. Cmm Statements implement:</p>
<ul>
<li>no-op; the empty statement:
<pre><code>;</code></pre></li>
<li>C-- (C99/C++ style) comments:
<pre><code>// ... \n` and `/* ... */</code></pre></li>
<li>the assignment operator:
<pre><code>=</code></pre></li>
<li>store operation (assignment to a memory location):
<pre><code>type[expr] =</code></pre></li>
<li>control flow within procedures (
<pre><code>goto`) and between procedures (`jump</code></pre>
<p>, returns) (note: returns are <em>only</em> Cmm macros)</p></li>
<li>foreign calls (
<pre><code>foreign &quot;C&quot; ...`) and calls to Cmm Primitive Operations (`%</code></pre>
<p>)</p></li>
<li>procedure calls and tail calls</li>
<li>conditional statement (
<pre><code>if ... { ... } else { ... }</code></pre>
<p>)</p></li>
<li>tabled conditional (
<pre><code>switch</code></pre>
<p>)</p></li>
</ul>
<p>Cmm does not implement the C-- specification for Spans (sec. 6.1) or Continuations (sec. 6.7).<br />
Although Cmm supports primitive operations that may have side effects (see [wiki:Commentary/Compiler/CmmType#PrimitiveOperations Primitive Operations], below), it does not parse the syntax</p>
<pre><code>%%` form mentioned in section 6.3 of the C-- specification.  Use the `%name(arg1,arg2)</code></pre>
<p>expression-syntax instead.<br />
Cmm does not implement the</p>
<pre><code>return` statement (C-- spec, sec. 6.8.2) but provides a set of macros that return a list of tuples of a `CgRep` and a `CmmExpr`: `[(CgRep,CmmExpr)]`.  For a description of `CgRep`, see comments in [[GhcFile(compiler/codeGen/SMRep.lhs)]].  The return macros are defined at the end of the production rule `stmtMacros</code></pre>
<p>in <a href="GhcFile(compiler/cmm/CmmParse.y)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmParse.y)</a>:</p>
<ul>
<li><pre><code>RET_P</code></pre></li>
<li><pre><code>RET_N</code></pre></li>
<li><pre><code>RET_PP</code></pre></li>
<li><pre><code>RET_NN</code></pre></li>
<li><pre><code>RET_NP</code></pre></li>
<li><pre><code>RET_PPP</code></pre></li>
<li><pre><code>RET_NNP</code></pre></li>
<li><pre><code>RET_NNNP</code></pre></li>
<li><pre><code>RET_NPNP</code></pre></li>
</ul>
<p>In the above macros,</p>
<pre><code>P` stands for `PtrArg` and `N` stands for `NonPtrArg`; both are `CgRep` constructors.  These return macros provide greater control for the [wiki:Commentary/Compiler/CodeGen CodeGen] and integrate with the RTS but limit the number and type of return arguments in Cmm: you may only return according to these macros!  The returns are processed by the `emitRetUT` function in [[GhcFile(compiler/cmm/CmmParse.y)]], which in turn calls several functions from [[GhcFile(compiler/codeGen/CgMonad.lhs)]], notably `emitStmts`, which is the core Code Generator function for emitting `CmmStmt</code></pre>
<p>data.</p>
<p>The Haskell representation of Cmm Statements is the data type</p>
<pre><code>CmmStmt</code></pre>
<p>, defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a>:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CmmStmt&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;CmmNop&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmComment&lt;/font&gt; &lt;font color=Green&gt;FastString&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmAssign&lt;/font&gt; &lt;font color=Green&gt;CmmReg&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt;  &lt;font color=Crimson&gt;-- Assign to register&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmStore&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt;     &lt;font color=Crimson&gt;-- Assign to memory location.  Size is&lt;/font&gt;
                                 &lt;font color=Crimson&gt;-- given by cmmExprRep of the rhs.&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmCall&lt;/font&gt;             &lt;font color=Crimson&gt;-- A foreign call, with &lt;/font&gt;
     &lt;font color=Green&gt;CmmCallTarget&lt;/font&gt;
     &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmReg&lt;/font&gt;&lt;font color=Blue&gt;,&lt;/font&gt;&lt;font color=Green&gt;MachHint&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;   &lt;font color=Crimson&gt;-- zero or more results&lt;/font&gt;
     &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;CmmExpr&lt;/font&gt;&lt;font color=Blue&gt;,&lt;/font&gt;&lt;font color=Green&gt;MachHint&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;  &lt;font color=Crimson&gt;-- zero or more arguments&lt;/font&gt;
     &lt;font color=Blue&gt;(&lt;/font&gt;&lt;font color=Green&gt;Maybe&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;GlobalReg&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;&lt;font color=Blue&gt;)&lt;/font&gt;   &lt;font color=Crimson&gt;-- Global regs that may need to be saved&lt;/font&gt;
                 &lt;font color=Crimson&gt;-- if they will be clobbered by the call.&lt;/font&gt;
                 &lt;font color=Crimson&gt;-- Nothing &amp;lt;=&amp;gt; save *all* globals that&lt;/font&gt;
                 &lt;font color=Crimson&gt;-- might be clobbered.&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmBranch&lt;/font&gt; &lt;font color=Green&gt;BlockId&lt;/font&gt;             &lt;font color=Crimson&gt;-- branch to another BB in this fn&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmCondBranch&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt; &lt;font color=Green&gt;BlockId&lt;/font&gt; &lt;font color=Crimson&gt;-- conditional branch&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmSwitch&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;Maybe&lt;/font&gt; &lt;font color=Green&gt;BlockId&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;   &lt;font color=Crimson&gt;-- Table branch&lt;/font&gt;
    &lt;font color=Crimson&gt;-- The scrutinee is zero-based; &lt;/font&gt;
    &lt;font color=Crimson&gt;--  zero -&amp;gt; first block&lt;/font&gt;
    &lt;font color=Crimson&gt;--  one  -&amp;gt; second block etc&lt;/font&gt;
    &lt;font color=Crimson&gt;-- Undefined outside range, and when there&#39;s a Nothing&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmJump&lt;/font&gt; &lt;font color=Green&gt;CmmExpr&lt;/font&gt; &lt;font color=Blue&gt;[&lt;/font&gt;&lt;font color=Green&gt;LocalReg&lt;/font&gt;&lt;font color=Blue&gt;]&lt;/font&gt;    &lt;font color=Crimson&gt;-- Jump to another function, with these &lt;/font&gt;
                  &lt;font color=Crimson&gt;-- parameters.&lt;/font&gt;</code></pre>
</pre>
<p>Note how the constructor</p>
<pre><code>CmmJump` contains `[LocalReg]`: this is the Cmm implementation of the C-- `jump` statement for calling another procedure where the parameters are the arguments passed to the other procedure. None of the parameters contain the address--in assembler, a label--of the caller, to return control to the caller.  The `CmmCall` constructor also lacks a parameter to store the caller&#39;s address.  Cmm implements C-- jump nesting and matching returns by &#39;&#39;tail calls&#39;&#39;, as described in section 6.8 of the C-- specification.  Tail calls are managed through the [wiki:Commentary/Compiler/CodeGen CodeGen], see [[GhcFile(compiler/codeGen/CgTailCall.lhs)]].  You may have already noticed that the call target of the `CmmJump` is a `CmmExpr</code></pre>
<dl>

<dd>this is the Cmm implementation of computed procedure addresses, for example:
</dd>
</dl>
<pre><code>proc1 {
...

 jump (bits32[x+4])( ... );

}</code></pre>
<p>The computed procedure address, in this case</p>
<pre><code>(bits32[x+4])`, should always be the first instruction of a `Cmm` procedure.  You cannot obtain the address of a code block &#39;&#39;within&#39;&#39; a procedure and `jump</code></pre>
<p>to it, as an alternative way of computing a <em>continuation</em>.</p>
<pre><code>CmmBranch BlockId</code></pre>
<p>represents an unconditional branch to another [wiki:Commentary/Compiler/CmmType#BasicBlocksandProcedures Basic Block] in the same procedure. There are two unconditional branches in Cmm/C--:</p>
<ol>
<li><pre><code>goto</code></pre>
<p>statement; and</p></li>
<li>a branch from the
<pre><code>else` portion of an `if-then-else</code></pre>
<p>statement.</p></li>
</ol>
<pre><code>CmmCondBranch CmmExpr BlockId` represents a conditional branch to another [wiki:Commentary/Compiler/CmmType#BasicBlocksandProcedures Basic Block] in the same procedure.  This is the `if expr` statement where `expr` is a `CmmExpr`, used in both the unary `if` and `if-then-else` statements.  `CmmCondBranch` maps to more complex Assembler instruction sets or HC code ([[GhcFile(compiler/cmm/PprC.hs)]]).  For assembler, labels are created for each new Basic Block.  During parsing, conditional statements map to the `BoolExpr</code></pre>
<p>data type which guides the encoding of assembler instruction sets.</p>
<pre><code>CmmSwitch` represents the `switch` statement.  It is parsed and created as with the `doSwitch` function in [[GhcFile(compiler/cmm/CmmParse.y)]] or created from `case` expressions with the `emitSwitch` and `mk_switch` functions in [[GhcFile(compiler/codeGen/CgUtils.hs)]].  In the NCG, a `CmmSwitch` is generated as a jump table using the `genSwitch</code></pre>
<p>function in <a href="GhcFile(compiler/nativeGen/MachCodeGen.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/MachCodeGen.hs)</a>. There is currently no implementation of any optimisations, such as a cascade of comparisons for switches with a wide deviation in values or binary search for very wide value ranges--for output to HC, earlier versions of GCC could not handle large if-trees, anyway.</p>
<h4 id="cmm-calls">Cmm Calls</h4>
<p>Cmm calls include both calls to foreign functions and calls to Cmm quasi-operators using expression syntax (see [wiki:Commentary/Compiler/CmmType#QuasioperatorSyntax Quasi-operator Syntax]). Although Cmm does not implement any of the control flow statements of C-- specification (section 6.8.1), foreign calls from Cmm are one of the most complex components of the system due to various differences between the Cmm and C calling conventions.</p>
<p>The data type,</p>
<pre><code>CmmCallTarget</code></pre>
<p>is defined in <a href="GhcFile(compiler/cmm/Cmm.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/Cmm.hs)</a> as:</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CmmCallTarget&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;CmmForeignCall&lt;/font&gt;     &lt;font color=Crimson&gt;-- Call to a foreign function&lt;/font&gt;
    &lt;font color=Green&gt;CmmExpr&lt;/font&gt;        &lt;font color=Crimson&gt;-- literal label &amp;lt;=&amp;gt; static call&lt;/font&gt;
                &lt;font color=Crimson&gt;-- other expression &amp;lt;=&amp;gt; dynamic call&lt;/font&gt;
    &lt;font color=Green&gt;CCallConv&lt;/font&gt;      &lt;font color=Crimson&gt;-- The calling convention&lt;/font&gt;

  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;CmmPrim&lt;/font&gt;            &lt;font color=Crimson&gt;-- Call to a &quot;primitive&quot; (eg. sin, cos)&lt;/font&gt;
    &lt;font color=Green&gt;CallishMachOp&lt;/font&gt;      &lt;font color=Crimson&gt;-- These might be implemented as inline&lt;/font&gt;
                &lt;font color=Crimson&gt;-- code by the backend.&lt;/font&gt;</code></pre>
</pre>
<pre><code>CCallConv</code></pre>
<p>is defined in <a href="GhcFile(compiler/prelude/ForeignCall.lhs)" class="uri" title="wikilink">GhcFile(compiler/prelude/ForeignCall.lhs)</a>; for information on register assignments, see comments in <a href="GhcFile(compiler/codeGen/CgCallConv.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/CgCallConv.hs)</a>.</p>
<pre><code>CallishMachOp` is defined in [[GhcFile(compiler/cmm/MachOp.hs)]]; see, also, below [wiki:Commentary/Compiler/CmmType#PrimitiveOperations Primitive Operations].  `CallishMachOp`s are generally used for floating point computations (without implementing any floating point exceptions).  Here is an example of using a `CallishMachOp</code></pre>
<p>(not yet implemented):</p>
<pre><code>  add, carry = %addWithCarry(x, y);</code></pre>
<h3 id="operators-and-primitive-operations">Operators and Primitive Operations</h3>
<p>Cmm generally conforms to the C-- specification for operators and &quot;primitive operations&quot;. The C-- specification, in section 7.4, refers to both of these as &quot;primitive operations&quot; but there are really two different types:</p>
<ul>
<li><em>operators</em>, as I refer to them, are:
<ul>
<li>parseable tokens, such as
<pre><code>+`,`-`,`*` or `/</code></pre>
<p>;</p></li>
<li>generally map to a single machine instruction or part of a machine instruction;</li>
<li>have no side effects; and,</li>
<li>are represented in Haskell using the
<pre><code>MachOp</code></pre>
<p>data type;</p></li>
</ul></li>
<li><em>primitive operations</em> (Cmm <em>quasi-operators</em>) are special, usually inlined, procedures, represented in Haskell using the
<pre><code>CallishMachOp</code></pre>
<p>data type; primitive operations may have side effects.</p></li>
</ul>
<p>The</p>
<pre><code>MachOp` and `CallishMachOp</code></pre>
<p>data types are defined in <a href="GhcFile(compiler/cmm/MachOp.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/MachOp.hs)</a>.</p>
<p>Both Cmm Operators and Primitive Operations are handled in Haskell as [wiki:Commentary/PrimOps#InlinePrimOps Inline PrimOps], though what I am calling Cmm <em>primitive operations</em> may be implemented as out-of-line foreign calls.</p>
<h4 id="operators">Operators</h4>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;MachOp&lt;/font&gt;

  &lt;font color=Crimson&gt;-- Integer operations&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;MO_Add&lt;/font&gt;    &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Sub&lt;/font&gt;    &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Eq&lt;/font&gt;     &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Ne&lt;/font&gt;     &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Mul&lt;/font&gt;    &lt;font color=Green&gt;MachRep&lt;/font&gt;     &lt;font color=Crimson&gt;-- low word of multiply&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_MulMayOflo&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;   &lt;font color=Crimson&gt;-- nonzero if signed multiply overflows&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Quot&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;     &lt;font color=Crimson&gt;-- signed / (same semantics as IntQuotOp)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Rem&lt;/font&gt;  &lt;font color=Green&gt;MachRep&lt;/font&gt;     &lt;font color=Crimson&gt;-- signed % (same semantics as IntRemOp)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Neg&lt;/font&gt;  &lt;font color=Green&gt;MachRep&lt;/font&gt;     &lt;font color=Crimson&gt;-- unary -&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_MulMayOflo&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;   &lt;font color=Crimson&gt;-- nonzero if unsigned multiply overflows&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Quot&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;     &lt;font color=Crimson&gt;-- unsigned / (same semantics as WordQuotOp)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Rem&lt;/font&gt;  &lt;font color=Green&gt;MachRep&lt;/font&gt;     &lt;font color=Crimson&gt;-- unsigned % (same semantics as WordRemOp)&lt;/font&gt;

  &lt;font color=Crimson&gt;-- Signed comparisons (floating-point comparisons also use these)&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Ge&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Le&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Gt&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Lt&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;

  &lt;font color=Crimson&gt;-- Unsigned comparisons&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Ge&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Le&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Gt&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Lt&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;

  &lt;font color=Crimson&gt;-- Bitwise operations.  Not all of these may be supported at all sizes,&lt;/font&gt;
  &lt;font color=Crimson&gt;-- and only integral MachReps are valid.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_And&lt;/font&gt;   &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Or&lt;/font&gt;    &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Xor&lt;/font&gt;   &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Not&lt;/font&gt;   &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Shl&lt;/font&gt;   &lt;font color=Green&gt;MachRep&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Shr&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;  &lt;font color=Crimson&gt;-- unsigned shift right&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Shr&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;  &lt;font color=Crimson&gt;-- signed shift right&lt;/font&gt;

  &lt;font color=Crimson&gt;-- Conversions.  Some of these will be NOPs.&lt;/font&gt;
  &lt;font color=Crimson&gt;-- Floating-point conversions use the signed variant.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_S_Conv&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;&lt;font color=Crimson&gt;{-from-}&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;&lt;font color=Crimson&gt;{-to-}&lt;/font&gt;    &lt;font color=Crimson&gt;-- signed conversion&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_U_Conv&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;&lt;font color=Crimson&gt;{-from-}&lt;/font&gt; &lt;font color=Green&gt;MachRep&lt;/font&gt;&lt;font color=Crimson&gt;{-to-}&lt;/font&gt;    &lt;font color=Crimson&gt;-- unsigned conversion&lt;/font&gt;</code></pre>
</pre>
<p>Each</p>
<pre><code>MachOp</code></pre>
<p>generally corresponds to a machine instruction but may have its value precomputed in the Cmm, NCG or HC optimisers.</p>
<h4 id="primitive-operations">Primitive Operations</h4>
<p>Primitive Operations generally involve more than one machine instruction and may not always be inlined.</p>
<pre><code>#!html
&lt;pre&gt;
&lt;font color=Crimson&gt;-- These MachOps tend to be implemented by foreign calls in some backends,&lt;/font&gt;
&lt;font color=Crimson&gt;-- so we separate them out.  In Cmm, these can only occur in a&lt;/font&gt;
&lt;font color=Crimson&gt;-- statement position, in contrast to an ordinary MachOp which can occur&lt;/font&gt;
&lt;font color=Crimson&gt;-- anywhere in an expression.&lt;/font&gt;
&lt;font color=DarkOrchid&gt;data&lt;/font&gt; &lt;font color=Green&gt;CallishMachOp&lt;/font&gt;
  &lt;font color=Blue&gt;=&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Pwr&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Sin&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Cos&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Tan&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Sinh&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Cosh&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Tanh&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Asin&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Acos&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Atan&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Log&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Exp&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F64_Sqrt&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Pwr&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Sin&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Cos&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Tan&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Sinh&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Cosh&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Tanh&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Asin&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Acos&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Atan&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Log&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Exp&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_F32_Sqrt&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_WriteBarrier&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Touch&lt;/font&gt;         &lt;font color=Crimson&gt;-- Keep variables live (when using interior pointers)&lt;/font&gt;
  
  &lt;font color=Crimson&gt;-- Note that these three MachOps all take 1 extra parameter than the&lt;/font&gt;
  &lt;font color=Crimson&gt;-- standard C lib versions. The extra (last) parameter contains&lt;/font&gt;
  &lt;font color=Crimson&gt;-- alignment of the pointers. Used for optimisation in backends.&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Memcpy&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Memset&lt;/font&gt;
  &lt;font color=Blue&gt;|&lt;/font&gt; &lt;font color=Green&gt;MO_Memmove&lt;/font&gt;</code></pre>
</pre>
<p>For an example, the floating point sine function,</p>
<pre><code>sinFloat#` in [[GhcFile(compiler/prelude/primops.txt.pp)]] is piped through the `callishOp` function in [[GhcFile(compiler/codeGen/CgPrimOp.hs)]] to become `Just MO_F32_Sin`.  The `CallishMachOp` constructor `MO_F32_Sin` is piped through a platform specific function such as [[GhcFile(compiler/nativeGen/X86/CodeGen.hs)]] on X86, where the function `genCCall` will call `outOfLineFloatOp` to issue a call to a C function such as `sin</code></pre>
<p>.</p>
<h2 id="cmm-design-observations-and-areas-for-potential-improvement">Cmm Design: Observations and Areas for Potential Improvement</h2>
<p>&quot;If the application of a primitive operator causes a system exception, such as division by zero, this is an unchecked run-time error. (A future version of this specification may provide a way for a program to recover from such an exception.)&quot; C-- spec, Section 7.4. Cmm may be able to implement a partial solution to this problem, following the paper: <a href="http://cminusminus.org/abstracts/c--pldi-00.html">A Single Intermediate Language That Supports Multiple Implementations of Exceptions (2000)</a>. (TODO: write notes to wiki and test fix.)</p>
<p>The IEEE 754 specification for floating point numbers defines exceptions for certain floating point operations, including:</p>
<ul>
<li>range violation (overflow, underflow);</li>
<li>rounding errors (inexact);</li>
<li>invalid operation (invalid operand, such as comparison with a
<pre><code>NaN</code></pre>
<p>value, the square root of a negative number or division of zero by zero); and,</p></li>
<li>zero divide (a special case of an invalid operation).</li>
</ul>
<p>Many architectures support floating point exceptions by including a special register as an addition to other exception handling registers. The IBM PPC includes the</p>
<pre><code>FPSCR` (&quot;Floating Point Status Control Register&quot;); the Intel x86 processors use the `MXCSR` register.  When the PPC performs a floating point operation it checks for possible errors and sets the `FPSCR</code></pre>
<p>. Some processors allow a flag in the Foating-Point Unit (FPU) status and control register to be set that will disable some exceptions or the entire FPU exception handling facility. Some processors disable the FPU after an exception has occurred while others, notably Intel's x86 and x87 processors, continue to perform FPU operations. Depending on whether quiet NaNs (QNaNs) or signaling NaNs (SNaNs) are used by the software, an FPU exception may signal an interrupt for the software to pass to its own exception handler.</p>
<p>Some higher level languages provide facilities to handle these exceptions, including Ada, Fortran (F90 and later), C++ and C (C99, fenv.h, float.h on certain compilers); others may handle such exceptions without exposing a low-level interface. There are three reasons to handle FPU exceptions, and these reasons apply similarly to other exceptions:</p>
<ul>
<li>the facilities provide greater control;</li>
<li>the facilities are efficient--more efficient than a higher-level software solution; and,</li>
<li>FPU exceptions may be unavoidable, especially if several FPU operations are serially performed at the machine level so the higher level software has no opportunity to check the results in between operations.</li>
</ul>
<p>A potential solution to the problem of implementing Cmm exceptions, especially for floating point operations, is at [wiki:Commentary/CmmExceptions Cmm: Implementing Exception Handling].</p>
<p>The C-- Language Specification mentions over 75 primitive operators. The Specification lists separate operators for integral and floating point (signed) arithmetic (including carry, borrow and overflow checking), logical comparisons and conversions (from one size float to another, from float to integral and vice versa, etc.). C-- also includes special operators for floating point number values, such as</p>
<pre><code>NaN`, `mzero`&#39;&#39;k&#39;&#39; and `pzero</code></pre>
<p><em>k</em>, and rounding modes; integral kinds also include bitwise operators, unsigned variants, and bit extraction for width changing and sign or zero-extension. A C-- implementation may conveniently map each of these operators to a machine instruction, or to a simulated operation on architectures that do not support a single instruction. There seem to be two main problems with the current GHC-implementation of Cmm:</p>
<ol>
<li>not enough operators</li>
<li>no implementation of vector (SIMD) registers (though there is a
<pre><code>I128` `MachRep</code></pre>
<p>)</p></li>
</ol>
<p>If a particular architecture supports it, assembler includes instructions such as mnemonics with the</p>
<pre><code>.` (&quot;dot&quot;) suffix (`add., fsub.`), which set the Condition Register (CR) thereby saving you at least one instruction.  (Extended mnemonics can save you even more.)  Extended mnemonics with side effects may be implemented as new `CallishMachOps</code></pre>
<p>, see [wiki:Commentary/Compiler/CmmType#PrimitiveOperations Primitive Operations] and [wiki:Commentary/Compiler/CmmType#CmmCalls Cmm Calls]. Assembler also supports machine exceptions, especially exceptions for floating-point operations, invalid storage access or misalignment (effective address alignment). The current implementation of Cmm cannot model such exceptions through flow control because no flow control is implemented, see [wiki:Commentary/Compiler/CmmType#CmmCalls Cmm Calls].</p>
<p>Hiding the kinds of registers on a machine eliminates the ability to handle floating point exceptions at the Cmm level and to explicitly vectorize (use SIMD extensions). The argument for exposing vector types may be a special case since such low-level operations are exposed at the C-level, as new types of variables or &quot;intrinsics,&quot; that are C-language extensions provided by special header files and compiler support (</p>
<pre><code>vector unsigned int` or `&lt;ul&gt;m128i`, `vector float` or `&lt;/ul&gt;m128`) and operations (`vec_add()`, `+` (with at least one vector operand), `_mm_add_epi32()</code></pre>
<p>).</p>
<h1 id="code-generator">Code Generator</h1>
<p>This page describes code generator (&quot;codegen&quot;) in GHC. It is meant to reflect current state of the implementation. If you notice any inaccuracies please update the page (if you know how) or complain on ghc-devs.</p>
<h2 id="a-brief-history-of-code-generator">A brief history of code generator</h2>
<p>You might occasionally hear about &quot;old&quot; and &quot;new&quot; code generator. GHC 7.6 and earlier used the old code generator. New code generator was being developed since 2007 and it was [changeset:832077ca5393d298324cb6b0a2cb501e27209768/ghc enabled by default on 31 August 2012] after the release of GHC 7.6.1. The first stable GHC to use the new code generator is 7.8.1 released in early 2014. The commentary on the old code generator can be found [wiki:Commentary/Compiler/OldCodeGen here]. Notes from the development process of the new code generator are located in a couple of pages on the wiki - to find them go to [wiki:TitleIndex Index] and look for pages starting with &quot;NewCodeGen&quot;.</p>
<p>There are some plans for the future development of code generator. One plan is to expand the capability of the pipeline so that it does native code generation too so that existing backends can be discarded - see [wiki:Commentary/Compiler/IntegratedCodeGen IntegratedCodeGen] for discussion of the design. It is hard to say if this will ever happen as currently there is no work being done on that subject and in the meanwhile there was an alternative proposal to [wiki:Commentary/Compiler/Backends/LLVM/ReplacingNCG replace native code generator with LLVM].</p>
<h2 id="overview">Overview</h2>
<p>The goal of the code generator is to convert program from [wiki:Commentary/Compiler/GeneratedCode STG] representation to [wiki:Commentary/Compiler/CmmType Cmm] representation. STG is a functional language with explicit stack. Cmm is a low-level imperative language - something between C and assembly - that is suitable for machine code generation. Note that terminology might be a bit confusing here: the term &quot;code generator&quot; can refer both to STG-&gt;Cmm pass and the whole STG-&gt;Cmm-&gt;assembly pass. The Cmm-&gt;assembly conversion is performed by one the backends, eg. NCG (Native Code Generator or LLVM.</p>
<p>The top-most entry point to the codegen is located in <a href="GhcFile(compiler/main/HscMain.hs)" class="uri" title="wikilink">GhcFile(compiler/main/HscMain.hs)</a> in the</p>
<pre><code>tryNewCodegen</code></pre>
<p>function. Code generation is done in two stages:</p>
<ol>
<li>Convert STG to Cmm with implicit stack, and native Cmm calls. This whole stage lives in <a href="GhcFile(compiler/codeGen)" class="uri" title="wikilink">GhcFile(compiler/codeGen)</a> directory with the entry point being
<pre><code>codeGen</code></pre>
<p>function in <a href="GhcFile(compiler/codeGen/StgCmm.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmm.hs)</a> module.</p></li>
<li>Optimise the Cmm, and CPS-convert it to have an explicit stack, and no native calls. This lives in <a href="GhcFile(compiler/cmm)" class="uri" title="wikilink">GhcFile(compiler/cmm)</a> directory with the
<pre><code>cmmPipeline</code></pre>
<p>function from <a href="GhcFile(compiler/cmm/CmmPipeline.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmPipeline.hs)</a> module being the entry point.</p></li>
</ol>
<p>The CPS-converted Cmm is fed to one of the backends. This is done by</p>
<pre><code>codeOutput` function ([[GhcFile(compiler/main/CodeOutput.lhs)]] called from `hscGenHardCode` after returning from `tryNewCodegen</code></pre>
<p>.</p>
<h2 id="first-stage-stg-to-cmm-conversion">First stage: STG to Cmm conversion</h2>
<ul>
<li><strong>Code generator</strong> converts STG to
<pre><code>CmmGraph`.  Implemented in `StgCmm*` modules (in directory `codeGen</code></pre>
<p>).</p>
<ul>
<li><pre><code>Cmm.CmmGraph` is pretty much a Hoopl graph of `CmmNode.CmmNode</code></pre>
<p>nodes. Control transfer instructions are always the last node of a basic block.</p></li>
<li>Parameter passing is made explicit; the calling convention depends on the target architecture. The key function is
<pre><code>CmmCallConv.assignArgumentsPos</code></pre>
<p>.</p>
<ul>
<li>Parameters are passed in virtual registers R1, R2 etc. [These map 1-1 to real registers.]</li>
<li>Overflow parameters are passed on the stack using explicit memory stores, to locations described abstractly using the [wiki:Commentary/Compiler/StackAreas <em>Stack Area</em> abstraction].</li>
<li>Making the calling convention explicit includes an explicit store instruction of the return address, which is stored explicitly on the stack in the same way as overflow parameters. This is done (obscurely) in
<pre><code>StgCmmMonad.mkCall</code></pre>
<p>.</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="second-stage-the-cmm-pipeline">Second stage: the Cmm pipeline</h2>
<p>The core of the Cmm pipeline is implemented by the</p>
<pre><code>cpsTop</code></pre>
<p>function in <a href="GhcFile(compiler/cmm/CmmPipeline.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CmmPipeline.hs)</a> module. Below is a high-level overview of the pipeline. See source code comments in respective modules for a more in-depth explanation of each pass.</p>
<ul>
<li><strong>Control Flow Optimisations</strong>, implemented in
<pre><code>CmmContFlowOpt</code></pre>
<p>, simplifies the control flow graph by:</p>
<ul>
<li>Eliminating blocks that have only one predecessor by concatenating them with that predecessor</li>
<li>Shortcuting targets of branches and calls (see Note [What is shortcutting])</li>
</ul></li>
</ul>
<p><code>If a block becomes unreachable because of shortcutting it is eliminated from the graph. However, </code><strong><code>it</code> <code>is</code> <code>theoretically</code> <code>possible</code> <code>that</code> <code>this</code> <code>pass</code> <code>will</code> <code>produce</code> <code>unreachable</code> <code>blocks</code></strong><code>. The reason is the label renaming pass performed after block concatenation has been completed.</code></p>
<p><code>This pass might be optionally called for the second time at the end of the pipeline.</code></p>
<ul>
<li><strong>Common Block Elimination</strong>, implemented in
<pre><code>CmmCommonBlockElim</code></pre>
<p>, eliminates blocks that are identical (except for the label on their first node). Since this pass traverses blocks in depth-first order any unreachable blocks introduced by Control Flow Optimisations are eliminated. <strong>This pass is optional.</strong></p></li>
</ul>
<ul>
<li><strong>Determine proc-points</strong>, implemented in
<pre><code>CmmProcPoint`. The idea behind the &quot;proc-point splitting&quot; is that we first determine proc-points, ie. blocks in the graph that can be turned into entry points of procedures, and then split a larger function into many smaller ones, each having a proc-point as its entry point. This is required for the LLVM backend. The proc-point splitting itself is done later in the pipeline, but here we only determine the set of proc-points. We first call `callProcPoints`, which assumes that entry point to a Cmm graph and every continuation of a call is a procpoint. If we are splitting proc-points we update the list of proc-points by calling `minimalProcPointSet</code></pre>
<p>, which adds all blocks reachable from more than one block in the graph. The set of proc-points is required by the stack layout pass.</p></li>
</ul>
<ul>
<li><strong>Figure out the stack layout</strong>, implemented in
<pre><code>CmmStackLayout</code></pre>
<p>. The job of this pass is to:</p>
<ul>
<li>replace references to abstract stack Areas with fixed offsets from Sp.</li>
<li>replace the CmmHighStackMark constant used in the stack check with</li>
</ul></li>
</ul>
<p><code>    the maximum stack usage of the proc.</code></p>
<ul>
<li>save any variables that are live across a call, and reload them as</li>
</ul>
<p><code>  necessary.</code><br />
<strong><code>Important</code></strong><code>: It may happen that stack layout will invalidate the computed set of proc-points by making a proc-point unreachable. This unreachable block is eliminated by one of subsequent passes that performs depth-first traversal of a graph: sinking pass (if optimisations are enabled), proc-point analysis (if optimisations are disabled and we're doing proc-point splitting) or at the very end of the pipeline (if optimisations are disabled and we're not doing proc-point splitting). This means that starting from this point in the pipeline we have inconsistent data and subsequent steps must be prepared for it.</code><br />
</p>
<ul>
<li><strong>Sinking assignments</strong>, implemented in
<pre><code>CmmSink</code></pre>
<p>, performs these optimizations:</p>
<ul>
<li>moves assignments closer to their uses, to reduce register pressure</li>
<li>pushes assignments into a single branch of a conditional if possible</li>
<li>inlines assignments to registers that are mentioned only once</li>
<li>discards dead assignments</li>
</ul></li>
</ul>
<p><strong><code>This</code> <code>pass</code> <code>is</code> <code>optional.</code></strong><code> It currently does not eliminate dead code in loops (#8327) and has some other minor deficiencies (eg. #8336).</code></p>
<ul>
<li><strong>CAF analysis</strong>, implemented in
<pre><code>CmmBuildInfoTables`. Computed CAF information is returned from `cmmPipeline</code></pre>
<p>and used to create Static Reference Tables (SRT). See [wiki:Commentary/Rts/Storage/GC/CAFs here] for some more detail on CAFs and SRTs. This pass is implemented using Hoopl (see below).</p></li>
</ul>
<ul>
<li><strong>Proc-point analysis and splitting</strong> (only when splitting proc-points), implemented by
<pre><code>procPointAnalysis` in `CmmProcPoint</code></pre>
<p>, takes a list of proc-points and for each block and determines from which proc-point the block is reachable. This is implemented using Hoopl.</p></li>
</ul>
<p><code> Then the call to </code></p>
<pre><code>splitAtProcPoints</code></pre>
<p>splits the Cmm graph into multiple Cmm graphs (each represents a single function) and build info tables to each of them.</p>
<p><code> When doing this we must be prepared for the fact that a proc-point does not actually exist in the graph since it was removed by stack layout pass (see #8205).</code></p>
<ul>
<li><strong>Attach continuations' info tables</strong> (only when NOT splitting proc-points), implemented by
<pre><code>attachContInfoTables` in `CmmProcPoint</code></pre>
<p>attaches info tables for the continuations of calls in the graph. ''[PLEASE WRITE MORE IF YOU KNOW WHY THIS IS DONE]''</p></li>
</ul>
<ul>
<li><strong>Update info tables to include stack liveness</strong>, implemented by
<pre><code>setInfoTableStackMap` in `CmmLayoutStack</code></pre>
<p>. Populates info tables of each Cmm function with stack usage information. Uses stack maps created by the stack layout pass.</p></li>
</ul>
<ul>
<li><strong>Control Flow Optimisations</strong>, same as the beginning of the pipeline, but this pass runs only with
<pre><code>-O1` and `-O2`. Since this pass might produce unreachable blocks it is followed by a call to `removeUnreachableBlocksProc` (also in `CmmContFlowOpt.hs</code></pre>
<p>)</p></li>
</ul>
<h2 id="dumping-and-debugging-cmm">Dumping and debugging Cmm</h2>
<p>You can dump the generated Cmm code using</p>
<pre><code>-ddump-cmm</code></pre>
<p>flag. This is helpful for debugging Cmm problems. Cmm dump is divided into several sections:</p>
<pre><code>==================== Cmm produced by new codegen ====================
...

==================== Post control-flow optimisations ====================
...

==================== Post common block elimination ====================
...

==================== Layout Stack ====================
...

==================== Sink assignments ====================
...

==================== CAFEnv ====================
...

==================== after setInfoTableStackMap ====================
...

==================== Post control-flow optimisations ====================
...

==================== Post CPS Cmm ====================
...

==================== Output Cmm ====================
...</code></pre>
<p>&quot;Cmm produced by new codegen&quot; is emited in</p>
<pre><code>HscMain` module after converting STG to Cmm. This Cmm has not been processed in any way by the Cmm pipeline. If you see that something is incorrect in that dump it means that the problem is located in the STG-&gt;Cmm pass. The last section, &quot;Output Cmm&quot;, is also dumped in `HscMain` but this is done after the Cmm has been processed by the whole Cmm pipeline. All other sections are dumped by the Cmm pipeline. You can dump only selected passes with more specific flags. For example, if you know (or suspect) that the sinking pass is performing some incorrect transformations you can make the dump shorter by adding `-ddump-cmm-sp -ddump-cmm-sink</code></pre>
<p>flags. This will produce only the &quot;Layout Stack&quot; dump (just before sinking pass) and &quot;Sink assignments&quot; dump (just after the sinking pass) allowing you to focus on the changes introduced by the sinking pass.</p>
<h2 id="register-allocator-code">Register Allocator Code</h2>
<p>The register allocator code is split into two main sections, the register allocator proper and a generic graph coloring library. The graph coloring library is also used by the Stg-&gt;Cmm converter.</p>
<h3 id="the-register-allocator">The register allocator</h3>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegLiveness.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegLiveness.hs)</a><br />
</li>
</ul>
<p><code>  Defines </code></p>
<pre><code>LiveInstr</code></pre>
<p>and</p>
<pre><code>LiveCmmTop</code></pre>
<p>which carry native machine instructions annotated with register liveness information. It also provides functions to annotate native code (</p>
<pre><code>NatCmmTop</code></pre>
<p>) with this liveness information, and to slurp out sets of register conflicts for feeding into the coloring allocator.</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegAllocColor.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegAllocColor.hs)</a><br />
</li>
</ul>
<p><code>  Defines </code></p>
<pre><code>regAlloc</code></pre>
<p>, the main driver function for the graph coloring allocator. The driver accepts</p>
<pre><code>LiveCmmTop</code></pre>
<p>s which use virtual regs, and produces</p>
<pre><code>NatCmmTops</code></pre>
<p>which use real machine regs. This module also provides functions to help build and deep seq the register conflict graph.</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegAllocLinear.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegAllocLinear.hs)</a><br />
</li>
</ul>
<p><code>  Defines the linear scan allocator. Its interface is identical to the coloring allocator.</code></p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegAllocInfo.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegAllocInfo.hs)</a><br />
</li>
</ul>
<p><code>  Defines the register information function, </code></p>
<pre><code>regUsage</code></pre>
<p>, which takes a set of real and virtual registers and returns the actual registers used by a particular</p>
<pre><code>Instr</code></pre>
<p>; register allocation is in AT&amp;T syntax order (source, destination), in an internal function,</p>
<pre><code>usage</code></pre>
<p>; defines the</p>
<pre><code>RegUsage</code></pre>
<p>data type<br />
<br />
</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegSpillCost.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegSpillCost.hs)</a><br />
</li>
</ul>
<p><code>  Defines </code></p>
<pre><code>chooseSpill</code></pre>
<p>which is responsible for selecting a virtual reg to spill to the stack when not enough real regs are available.</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegSpill.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegSpill.hs)</a><br />
</li>
</ul>
<p><code>  Defines </code></p>
<pre><code>regSpill</code></pre>
<p>which takes</p>
<pre><code>LiveCmmTop</code></pre>
<p>s and inserts spill/reload instructions virtual regs that wouldn't fit in real regs.</p>
<pre><code>regSpill</code></pre>
<p>'s strategy is to simply inserts spill/reloads for every use/def of a particular virtual reg. This inefficient code is cleaned up by the spill cleaner after allocation.</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegSpillClean.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegSpillClean.hs)</a><br />
</li>
</ul>
<p><code>  The spill cleaner is run after real regs have been allocated. It erases spill/reload instructions inserted by </code></p>
<pre><code>regSpill</code></pre>
<p>that weren't strictly nessesary.</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegAllocStats.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegAllocStats.hs)</a><br />
</li>
</ul>
<p><code>  Defines data types and pretty printers used for collecting statistics and debugging info from the coloring allocator.</code></p>
<h3 id="graph-coloring">Graph coloring</h3>
<ul>
<li><a href="GhcFile(compiler/utils/GraphBase.hs)" class="uri" title="wikilink">GhcFile(compiler/utils/GraphBase.hs)</a><br />
</li>
</ul>
<p><code>  Defines the basic </code></p>
<pre><code>Graph</code></pre>
<p>,</p>
<pre><code>Node</code></pre>
<p>and</p>
<pre><code>Triv</code></pre>
<p>types used by the coloring algorithm.</p>
<ul>
<li><a href="GhcFile(compiler/utils/GraphColor.hs)" class="uri" title="wikilink">GhcFile(compiler/utils/GraphColor.hs)</a><br />
</li>
</ul>
<p><code>  Defines the function </code></p>
<pre><code>colorGraph</code></pre>
<p>which is responsible for assigning colors (real regs) to nodes (virtual regs) in the register conflict graph.</p>
<ul>
<li><a href="GhcFile(compiler/utils/GraphOps.hs)" class="uri" title="wikilink">GhcFile(compiler/utils/GraphOps.hs)</a><br />
</li>
</ul>
<p><code>  Defines functions to perform basic operations on the graphs such as adding, deleting, and coalescing nodes.</code></p>
<ul>
<li><a href="GhcFile(compiler/utils/GraphPps.hs)" class="uri" title="wikilink">GhcFile(compiler/utils/GraphPps.hs)</a><br />
</li>
</ul>
<p><code>  Defines functions for pretty print graphs in human readable-ish and graphviz format.</code></p>
<h3 id="miscellanea">Miscellanea</h3>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegCoalesce.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegCoalesce.hs)</a><br />
</li>
</ul>
<p><code>  Defines a function </code></p>
<pre><code>regCoalesce</code></pre>
<p>that does aggressive coalescing directly on</p>
<pre><code>LiveCmmTops</code></pre>
<p>, without using the graph. This isn't used at the moment but has been left in incase we want to rejig the allocator when the new CPS converter comes online.</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegArchBase.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegArchBase.hs)</a><br />
</li>
</ul>
<p><code>  Defines utils for calculating whether a register in the conflict graph is trivially colorable, in a generic way which handles aliasing between register classes. This module is not used directly by GHC.</code></p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/RegArchX86.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegArchX86.hs)</a><br />
</li>
</ul>
<p><code>  Contains a description of the aliasing constraints between the register sets on x86. This module is not used directly by GHC.</code></p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="the-ghc-commentary---coding-style-guidelines-for-the-compiler">The GHC Commentary - Coding Style Guidelines for the compiler</h1>
<p>This is a rough description of some of the coding practices and style that we use for Haskell code inside</p>
<pre><code>compiler</code></pre>
<p>. For run-time system code see the [wiki:Commentary/Rts/Conventions Coding Style Guidelines for RTS C code]. Also see the wiki page on [wiki:WorkingConventions Working Conventions] for issues related to version control, workflow, testing, bug tracking and other miscellany.</p>
<h2 id="general-style">General Style</h2>
<p>The general rule is to stick to the same coding style as is already used in the file you're editing. If you must make stylistic changes, commit them separately from functional changes, so that someone looking back through the change logs can easily distinguish them.</p>
<p>It's much better to write code that is transparent than to write code that is short.</p>
<p>Often it's better to write out the code longhand than to reuse a generic abstraction (not always, of course). Sometimes it's better to duplicate some similar code than to try to construct an elaborate generalisation with only two instances. Remember: other people have to be able to quickly understand what you've done, and overuse of abstractions just serves to obscure the <em>really</em> tricky stuff, and there's no shortage of that in GHC.</p>
<h2 id="comments">Comments</h2>
<p>There are two kinds of comments in source code, comments that describe the interface (i.e. how is this supposed to be used) and comments that describe the implementation (e.g. subtle gotchas).</p>
<h3 id="comments-on-top-level-entities">Comments on top-level entities</h3>
<p>Every top-level entity should have a Haddock comment that describes what it does and, if needed, why it's there. Example:</p>
<pre><code>-- | Returns which registers are read and written by this 
-- instruction, as a (read, written) pair. This info is used
-- by the register allocator.
x86_regUsageOfInstr :: Platform -&gt; Instr -&gt; RegUsage</code></pre>
<p>We use Haddock so that the comment is included in the generated HTML documentation.</p>
<p>There's a bit of a broken window effect going on, but please try to follow this rule for new functions you add.</p>
<h3 id="comments-in-the-source-code">Comments in the source code</h3>
<p>Commenting is good but</p>
<ul>
<li>long comments <em>interleaved with the code</em> can make the code itself incredibly hard to read, and</li>
<li>long comments <em>detached from the code</em> are easy to miss when you are editing the code itself, and soon become out of date or even misleading.</li>
</ul>
<p>We have adopted a style that seems to help. Here's an example:</p>
<pre><code>prepareRhs :: SimplEnv -&gt; OutExpr -&gt; SimplM (SimplEnv, OutExpr)
-- Adds new floats to the env iff that allows us to return a good RHS
prepareRhs env (Cast rhs co)    -- Note [Float coercions]
* ot* do this if rhs is unlifted 
  , not (isUnLiftedType ty1)            -- see Note [Float coercions (unlifted)]
  = do  { (env&#39;, rhs&#39;) &lt;- makeTrivial env rhs
        ; return (env&#39;, Cast rhs&#39; co) }

        ...more equations for prepareRhs....

{- Note [Float coercions]
&lt;strike&gt;~~~~~~~~~~~~~~~~~~&lt;/strike&gt;
When we find the binding
        x = e &lt;pre&gt;cast</code></pre>
<p>co we'd like to transform it to</p>
<p><code>       x' = e</code><br />
<code>       x = x </code></p>
<pre><code>cast</code></pre>
<p>co -- A trivial binding There's a chance that e will be a constructor application or function, or something like that, so moving the coerion to the usage site may well cancel the coersions and lead to further optimisation.</p>
<p><code>       ...more stuff about coercion floating...</code></p>
<p>-}</p>
</pre>
<p>Notice that</p>
<ul>
<li><strong>Interleaved with the code</strong> is a short link
<pre><code>Note [Float coercions]</code></pre>
<p>. You can't miss it when you are editing the code, but you can still see the code itself.</p></li>
<li><strong>Detached from the code</strong> is the linked comment, starting with the same string
<pre><code>Note [Float coercions]</code></pre>
<p>. It can be long, and often includes examples.</p></li>
</ul>
<p>The standard format &quot;</p>
<pre><code>Note [Float coercions]</code></pre>
<p>&quot; serves like an URL, to point to an out-of-line comment. Usually the target is in the same module, but not always. Sometimes we say</p>
<pre><code>    -- See Note [Float coercions] in SpecConstr.lhs</code></pre>
<p>Please use this technique. It's robust, and survives successive changes to the same lines of code. When you are changing code, it draws attention to non-obvious things you might want to bear in mind. When you encounter the note itself you can search for the string to find the code that implements the thoughts contained in the comment.</p>
<h3 id="comments-and-examples">Comments and examples</h3>
<p>When writing a comment to explain a subtle point, consider including an example code snippet that illustrates the point. For example, the above</p>
<pre><code>Note [Float coercions]</code></pre>
<p>continues thus:</p>
<pre><code>There&#39;s a chance that e will be a constructor application or function, or something
like that, so moving the coerion to the usage site may well cancel the coersions
and lead to further optimisation.  Example:

* 
     data instance T Int = T Int

     foo :: Int -&gt; Int -&gt; Int
     foo m n = ...
        where
          x = T m
          go 0 = 0
          go n = case x of { T m -&gt; go (n-m) }
                -- This case should optimise</code></pre>
<p>These kind of code snippets are extremely helpful to illustrate the point in a concrete way. Other ways of making the comment concrete are:</p>
<ul>
<li>Cite a particular Trac ticket that this bit of code deals with</li>
<li>Cite a test case in the test suite that illustrates it</li>
</ul>
<h3 id="longer-comments-or-architectural-commentary">Longer comments or architectural commentary</h3>
<p>Comments with a broad scope, describing the architecture or workings of more than one module, belong here in the commentary rather than in the code. Put the URL for the relevant commentary page in a comment in the code itself, and also put URLs for all relevant commentary pages in a comment at the top of each module.</p>
<h3 id="commit-messages">Commit messages</h3>
<p>Please do not use commit messages to describe how something works, or give examples, <em>even if the patch is devoted to a single change</em>. The information is harder to find in a commit message, and (much worse) there is no explicit indication in the code that there is carefully-written information available about that particular line of code. Instead, you can refer to the Note from the commit message.</p>
<p>Commit messages can nevertheless contain substantial information, but it is usually of a global nature. E.g. &quot;This patch modifies 20 files to implement a new form of inlining pragma&quot;. They are also a useful place to say which ticket is fixed by the commit, summarise the changes embodied in the commit etc.</p>
<p>In short, commit messages describe <em>changes</em>, whereas comment explain the code <em>as it now is</em>.</p>
<h2 id="warnings">Warnings</h2>
<p>We are aiming to make the GHC code warning-free, for all warnings turned on by</p>
<pre><code>-Wall</code></pre>
<p>The build automatically sets these flags for all source files (see</p>
<pre><code>mk/warnings.mk</code></pre>
<p>).</p>
<p>The [wiki:TestingPatches validate script], which is used to test the build before commiting, additionally sets the</p>
<pre><code>-Werror` flag, so that the code &#39;&#39;&#39;must&#39;&#39;&#39; be warning-free to pass validation. The `-Werror</code></pre>
<p>flag is not set during normal builds, so warnings will be printed but won't halt the build.</p>
<p>Currently we are some way from our goal, so some modules have a</p>
<pre><code>{-# OPTIONS_GHC -fno-warn-... #-}</code></pre>
<p>pragma; you are encouraged to remove this pragma and fix any warnings when working on a module.</p>
<h2 id="exports-and-imports">Exports and Imports</h2>
<h3 id="exports">Exports</h3>
<pre><code>module Foo (
   T(..),
   foo,      -- :: T -&gt; T
 ) where</code></pre>
<p>We usually (99% of the time) include an export list. The only exceptions are perhaps where the export list would list absolutely everything in the module, and even then sometimes we do it anyway.</p>
<p>It's helpful to give type signatures inside comments in the export list, but hard to keep them consistent, so we don't always do that.</p>
<h3 id="imports">Imports</h3>
<p>List imports in the following order:</p>
<ul>
<li>Local to this subsystem (or directory) first</li>
<li>Compiler imports, generally ordered from specific to generic (ie. modules from utils/ and basicTypes/ usually come last)</li>
<li>Library imports</li>
<li>Standard Haskell 98 imports last</li>
</ul>
<pre><code>-- friends
import SimplMonad

-- GHC
import CoreSyn
import Id
import BasicTypes

-- libraries
import Data.IORef

-- std
import Data.List
import Data.Maybe</code></pre>
<p>Import library modules from the [wiki:Commentary/Libraries boot packages] only (boot packages are those packages in the file [source:packages] that have a '-' in the &quot;tag&quot; column). Use</p>
<pre><code>#defines `in `HsVersions.h` when the modules names differ between versions of GHC.  For code inside `#ifdef GHCI</code></pre>
<p>, don't worry about GHC versioning issues, because this code is only ever compiled by the this very version of GHC.</p>
<p><strong>Do not use explicit import lists</strong>, except to resolve name clashes. There are several reasons for this:</p>
<ul>
<li>They slow down development: almost every change is accompanied by an import list change.</li>
</ul>
<ul>
<li>They cause spurious conflicts between developers.</li>
</ul>
<ul>
<li>They lead to useless warnings about unused imports, and time wasted trying to</li>
</ul>
<p><code>  keep the import declarations &quot;minimal&quot;.</code></p>
<ul>
<li>GHC's warnings are useful for detecting unnecessary imports: see
<pre><code>-fwarn-unused-imports</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>TAGS is a good way to find out where an identifier is defined (use
<pre><code>make tags` in `ghc/compiler</code></pre>
<p>,</p></li>
</ul>
<p><code>  and hit </code></p>
<pre><code>M-.</code></pre>
<p>in emacs).</p>
<p>If the module can be compiled multiple ways (eg. GHCI vs. non-GHCI), make sure the imports are properly</p>
<pre><code>#ifdefed</code></pre>
<p>too, so as to avoid spurious unused import warnings.</p>
<h2 id="compiler-versions-and-language-extensions">Compiler versions and language extensions</h2>
<p>GHC must be compilable and validate by the previous two major GHC releases, and itself. It isn't necessary for it to be compilable by every intermediate development version.</p>
<p>To maintain compatibility, use [wiki:Commentary/CodingStyle#HsVersions.h HsVersions.h] (see below) where possible, and try to avoid using #ifdef in the source itself.</p>
<p>===</p>
<pre><code>HsVersions.h</code></pre>
<p>===</p>
<pre><code>HsVersions.h</code></pre>
<p>is a CPP header file containing a number of macros that help smooth out the differences between compiler versions. It defines, for example, macros for library module names which have moved between versions. Take a look <a href="GhcFile(compiler/HsVersions.h)" class="uri" title="wikilink">GhcFile(compiler/HsVersions.h)</a>.</p>
<pre><code>#include &quot;HsVersions.h&quot;</code></pre>
<h3 id="literate-haskell">Literate Haskell</h3>
<p>In GHC we use a mixture of literate (</p>
<pre><code>.lhs</code></pre>
<p>) and non-literate (</p>
<pre><code>.hs</code></pre>
<p>) source. I (Simon M.) prefer to use non-literate style, because I think the</p>
<pre><code>\begin{code}..\end{code</code></pre>
<p>} clutter up the source too much, and I like to use Haddock-style comments (we haven't tried processing the whole of GHC with Haddock yet, though).</p>
<h3 id="the-c-preprocessor-cpp">The C Preprocessor (CPP)</h3>
<p>Whenever possible we try to avoid using CPP, as it can hide code from the compiler (which means changes that work on one platform can break the build on another) and code using CPP can be harder to understand.</p>
<p>The following CPP symbols are used throughout the compiler:</p>
<p><strong><code>DEBUG</code></strong><code>:: </code><br />
<code> Used to enables extra checks and debugging output in the compiler. The ASSERT macro (see </code></p>
<pre><code>HsVersions.h</code></pre>
<p>) provides assertions which disappear when DEBUG is not defined.</p>
<p><code>However, whenever possible, it is better to use </code></p>
<pre><code>debugIsOn` from the `Util` module, which is defined to be `True` when `DEBUG` is defined and `False` otherwise.  The ideal way to provide debugging output is to use a Haskell expression &quot;`when debugIsOn $ ...`&quot; to arrange that the compiler will be silent when `DEBUG` is off (unless of course something goes wrong or the verbosity level is nonzero). When option `-O</code></pre>
<p>is used, GHC will easily sweep away the unreachable code.</p>
<p><code>As a last resort, debugging code can be placed inside </code></p>
<pre><code>#ifdef DEBUG</code></pre>
<p>, but since this strategy guarantees that only a fraction of the code is seen be the compiler on any one compilation, it is to be avoided when possible.</p>
<p><code>Regarding performance, a good rule of thumb is that </code></p>
<pre><code>DEBUG` shouldn&#39;t add more than about 10-20% to the compilation time. This is the case at the moment. If it gets too expensive, we won&#39;t use it. For more expensive runtime checks, consider adding a flag - see for example `-dcore-lint</code></pre>
<p>.</p>
<p><strong>Trap, pitfall for using the ASSERT macro</strong>:</p>
<p>The ASSERT macro uses CPP, and if you are unwise enough to try to write assertions using primed variables (</p>
<pre><code>ASSERT (not $ intersectsBlockEnv b b&#39;)</code></pre>
<p>), one possible outcome is that CPP silently fails to expand the ASSERT, and you get this very baffling error message:</p>
<pre><code>Not in scope: data constructor `ASSERT&#39;</code></pre>
<p>Now you can Google for this error message :-)</p>
<p><strong><code>GHCI</code></strong><code>:: </code><br />
<code> Enables GHCi support, including the byte code generator and interactive user interface. This isn't the default, because the compiler needs to be bootstrapped with itself in order for GHCi to work properly. The reason is that the byte-code compiler and linker are quite closely tied to the runtime system, so it is essential that GHCi is linked with the most up-to-date RTS. Another reason is that the representation of certain datatypes must be consistent between GHCi and its libraries, and if these were inconsistent then disaster could follow. </code></p>
<h3 id="platform-tests">Platform tests</h3>
<p>Please refer to [wiki:Commentary/PlatformNaming Platforms and Conventions] wiki page for an overview of how to handle target specific code in GHC.</p>
<h2 id="tabs-vs-spaces">Tabs vs Spaces</h2>
<p>GHCs source code is indented with a mixture of tabs and spaces, and is standardised on a tabstop of 8.</p>
<p>Most of the Haskell source code in GHC is free of tabs. We'd like to move away from tabs in the long term, and so a git hook on darcs.haskell.org will reject series of commits that add tabs to a file that is currently tab-free. (Note that there are no restrictions on adding tabs to a file already containing them.)</p>
<p>In order to avoid angering this git hook, you should set your editor to indent using spaces rather than tabs:</p>
<ul>
<li>In Emacs, add
<pre><code>(setq-default indent-tabs-mode nil)` to your `.emacs</code></pre>
<p>file (<a href="http://cscs.umich.edu/~rlr/Misc/emacs_tabs.htm">more discussion</a>)</p></li>
<li>In Sublime Text, save the following to files at
<pre><code>Packages/User/Haskell.sublime-settings` and `Packages/User/Literate Haskell.sublime-settings</code></pre>
<dl>

<dd>
</dd>
</dl></li>
</ul>
<pre><code>{
    &quot;tab_size&quot;: 8,
    &quot;translate_tabs_to_spaces&quot;: true
}</code></pre>
<ul>
<li>In TextMate, in the tabs pop-up menu at the bottom of the window, select &quot;Soft Tabs&quot;, as show in the following screenshot where the blue rectangle is:</li>
</ul>
<p><code> </code><a href="Image(TextMate-tabs-menu.png)" title="wikilink"><code>Image(TextMate-tabs-menu.png)</code></a><code>  </code></p>
<p><code>Alternatively, open the Bundle Editor and add a new Preference called Indentation to the bundle editor. Give it the following contents:</code></p>
<pre><code>{   shellVariables = (
        {   name = &#39;TM_SOFT_TABS&#39;;
            value = &#39;YES&#39;;
        },
    );
}</code></pre>
<h1 id="coercions-in-ghcs-core-language">Coercions in GHC's core language</h1>
<p>Ever since coercions were introduced into GHC's Core language I have treated</p>
<ul>
<li>Coercions like types</li>
<li>Coercion variables like type variables</li>
</ul>
<p>In particular, casts, coercion applications, and coercion abstractoins are all erased before we generate code.</p>
<p>I now think that this is the wrong approach. This note describes why.</p>
<h2 id="difficulties-with-the-current-approach">Difficulties with the current approach</h2>
<p>Ther are two problems with the current approach</p>
<ul>
<li>Equality evidence variables (&quot;type variables&quot;) are treated differently to dictionary evidence variables (&quot;term varaibles&quot;). This leads to lots of tiresome non-uniformities.</li>
<li>In an abstraction
<pre><code>/\a\x:a.e` the type variable `a` can appear in the type of a term-variable binder `x`.  In contrast `x</code></pre>
<p>can't appear in the type of another binder. Coercion binders behave exactly like term binders in this way, and quite unlike type binders.</p></li>
<li>More seriously, we don't have a decent way to handle superclass equalities.</li>
</ul>
<p>The last problem is the one that triggered this note, and needs a bit more explanation. Consider</p>
<pre><code>class (F a ~ b, Eq a) =&gt; C a b where
  op :: a -&gt; b</code></pre>
<p>The dictionary for C looks like this:</p>
<pre><code>data C a b where
  MkC :: (F a ~ b, Num a) =&gt; (a-&gt;b) -&gt; C a b</code></pre>
<p>Now imagine typechecking a function like this</p>
<pre><code>f :: C a b =&gt; a -&gt; a 
f x = x + 1</code></pre>
<p>The Core program we generate looks something like this:</p>
<pre><code>f = /\a b. \(d:C a b).
    let (nd : Num a) = case d of { MkC _ d _ -&gt; d }
    in (+) nd x (fromInteger nd 1)</code></pre>
<p>The</p>
<pre><code>nd` binding extracts the `Num</code></pre>
<p>superclass dictionary from the</p>
<pre><code>C</code></pre>
<p>dictionary; the case expression is called a <em>superclass selector</em>.</p>
<p>Now suppose that we needed to use the equality superclass rather than the</p>
<pre><code>Num</code></pre>
<p>superclass:</p>
<pre><code>g :: C a b =&gt; [F a] -&gt; [b]
g xs = xs</code></pre>
<p>The obvious translation would look like this:</p>
<pre><code>g = /\ab. \(d:C a b).
    let (eq : F a ~ b) = case d of { MkC eq _ _ -&gt; eq }
    in xs |&gt; [eq]</code></pre>
<p>But Core doesn't (currently) have a let-binding form that binds a coercion variable, and whose right-hand side is a term (in this example, a case expression) rather than a literal coercion! So the current plan is to generate this instead:</p>
<pre><code>g = /\ab. \(d:C a b).
    case d of { MkC eq _ _ -&gt; 
    in xs |&gt; [eq] }</code></pre>
<p>This non-uniformity of equality and dictionary evidence is extremely awkward in the desugarer. Moreover, it means that we can't abstract the superclass selector; we'd really like to have:</p>
<pre><code>g = /\ab. \(d:C a b).
    let (eq : F a ~ b) = sc_sel1 d
    in xs |&gt; [eq]</code></pre>
<p>And it interacts poorly with the class-op rules that GHC uses to simplify dictinary selectors. Imagine the call</p>
<pre><code>dIB :: C Int Bool
dIB
  g Int Bool d</code></pre>
<p>...unfinished...</p>
<h2 id="main-proposal">Main proposal</h2>
<p>Recall our basic types</p>
<pre><code>type Id    = Var   -- in Var.lhs
type TyVar = Var

data CoreExpr      -- in CoreSyn.lhs
  = Var Var 
  | Lit Lit
  | Type Type
  | Coercion Coercion
  | App CoreExpr CoreExpr
  | Lam Var CoreExpr
  | Cast CoreExpr Coercion
  | Let CoreBind CoreExpr
  | Case... | Note ...


data CoreBind = NonRec Var CoreExpr
              | Rec [(Id,CoreExpr)]

data Type          -- in TypeRep.lhs
  = TyVar TyVar
  | AppTy Type Type
  | FunTy Type Type
  | ForAllTy Var Type
  | PredTy PredType
  | TyConApp TyCon [Type]

data PredType
  = EqPred Type Type
  | ClassP Class [Type]
  | IParam Name Type </code></pre>
<p>Note that</p>
<ul>
<li><pre><code>Var` can be a type variable, coercion variable, or term variable.  You can tell which with a dynamic test (e.g. `isId :: Var -&gt; Bool</code></pre>
<p>).</p></li>
</ul>
<ul>
<li><pre><code>Lam` is used for type abstractions, coercion abstractions, and value abstractions.  The `Var</code></pre>
<p>can tell you which.</p></li>
</ul>
<ul>
<li>Type applications (in a term) look like
<pre><code>(App f (Type t))`.  The `(Type t)` part must literally appear there,  with no intervening junk.  This is not statically enforced, but it turns out to be much more convenient than having a constructor `TyApp CoreExpr Type</code></pre>
<p>.</p></li>
</ul>
<p>OK now the new proposal is to <em>treat equality evidence just like any other sort of evidence</em>.</p>
<ul>
<li>A coercion variable is treated like term-level identifier, not a type-level identifier. (More on what that means below.)</li>
</ul>
<ul>
<li>A coercion is an
<pre><code>CoreExpr`, of form `Coercion g`, whose type is `(s ~ t)`, of form `PredTy (EqPred s t)</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>Unlike type applications, coercion applications are not required to have a
<pre><code>(Coercion g)</code></pre>
<p>as the argument. For example, suppose we have</p></li>
</ul>
<pre><code>f :: forall a. (a~Int) =&gt; a -&gt; Int
id :: forall b. b-&gt;b
c :: x~Int</code></pre>
<p><code>  Then the term </code></p>
<pre><code>(f x (id (x~Int) c))` would be fine. Notice that the coercion argument is an appplication of the identity function.  (Yes it&#39;s a bit contrived.)  In `CoreExpr</code></pre>
<p>form it would look like:</p>
<pre><code> 
  App (App (Var f) (Type x))
      (App (App (Var id) (Type (PredTy (EqPred x Int))))
           (Var c))</code></pre>
<ul>
<li>Similarly a let-binding can bind a coercion</li>
</ul>
<pre><code>  Let (NonRec c (...a coercion-valued term..)) (...body...)</code></pre>
<ul>
<li>Coercion application is call-by value. Ditto let-bindings. You must have the evidence before calling the function.</li>
</ul>
<ul>
<li>So it doesn't make sense to have recursive coercion bindings.</li>
</ul>
<ul>
<li>If we see
<pre><code>Let (NonRec c (Coercion g)) e` we can substitute `(Coercion g)` for any term-level occurrences of `c` in the term `e`, and `g` for `c` in any occurrences of `c` in coercions inside `e</code></pre>
<p>. (This seems a bit messy.)</p></li>
</ul>
<h1 id="parsing-of-command-line-arguments">Parsing of command line arguments</h1>
<p>GHC's many flavours of command line flags make the code interpreting them rather involved. The following provides a brief overview of the processing of these options. Since the addition of the interactive front-end to GHC, there are two kinds of flags: static and dynamic. Static flags can only be set once on the command line. They remain the same throughout the whole GHC session (so for example you cannot change them within GHCi using</p>
<pre><code>:set` or with `OPTIONS_GHC` pragma in the source code). Dynamic flags are the opposite: they can be changed in GHCi sessions using `:set` command or `OPTIONS_GHC</code></pre>
<p>pragma in the source code. There are few static flags and it is likely that in the future there will be even less. Thus, you won't see many static flag references in the source code, but you will see a lot of functions that use dynamic flags.</p>
<p>Command line flags are described by Flag data type defined in <a href="GhcFile(compiler/main/CmdLineParser.hs)" class="uri" title="wikilink">GhcFile(compiler/main/CmdLineParser.hs)</a>:</p>
<pre><code>data Flag m = Flag
    {   flagName    :: String,   -- Flag, without the leading &quot;-&quot;
        flagOptKind :: OptKind m -- What to do if we see it
    }</code></pre>
<p>This file contains functions that actually parse the command line parameters.</p>
<h2 id="static-flags">Static flags</h2>
<p>Static flags are managed by functions in <a href="GhcFile(compiler/main/StaticFlags.hs)" class="uri" title="wikilink">GhcFile(compiler/main/StaticFlags.hs)</a>.</p>
<p>Function</p>
<pre><code>parseStaticFlags ::` is an entry point for parsing static flags. It is called by the `main :: IO ()` function of GHC in [[GhcFile(ghc/Main.hs)]]. Two global IORefs are used to parse static flags: `v_opt_C_ready` and `v_opt_C`. These are defined using `GLOBAL_VAR` macro from [[GhcFile(compiler/HsVersions.h)]]. First IORef is a flag that checks whether the static flags are parsed at the right time. Initialized to `False`, it is set to `True` after the parsing is done. `v_opt_C` is a `[String]` used to store parsed flags (see `addOpt` and `removeOpt</code></pre>
<p>functions).</p>
<p>In <a href="GhcFile(compiler/main/StaticFlags.hs)" class="uri" title="wikilink">GhcFile(compiler/main/StaticFlags.hs)</a>,</p>
<pre><code>flagsStatic :: [Flag IO]` defines a list of static flags and what actions should be taken when these flags are encountered (see `Flag` data type above). It also contains some helper functions to check whether particular flags have been set. Functions `staticFlags :: [String]` and `packed_staticFlags :: [FastString]` return a list of parsed command line static flags, provided that parsing has been done (checking the value of `v_opt_C_ready</code></pre>
<p>).</p>
<h2 id="dynamic-flags">Dynamic flags</h2>
<p>They are managed by functions in <a href="GhcFile(compiler/main/DynFlags.hs)" class="uri" title="wikilink">GhcFile(compiler/main/DynFlags.hs)</a> file. Looking from the top you will find data types used to described enabled dynamic flags:</p>
<pre><code>DumpFlag`, `GeneralFlag`, `WarningFlag`, `Language`, `SafeHaskellMode`, `ExtensionFlag` and finally `DynFlags`. Function `defaultDynFlags :: Settings -&gt; DynFlags` initializes some of the flags to default values. Available dynamic flags and their respective actions are defined by `dynamic_flags :: [Flag (CmdLineP DynFlags)]`. Also, `fWarningFlags :: [FlagSpec WarningFlag]`, `fFlags :: [FlagSpec GeneralFlag]`, `xFlags :: [FlagSpec ExtensionFlag]` and a few more smaller functions define even more flags needed for example for language extensions, warnings and other things. These flags are descibred by the data type `FlagSpec f</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>type FlagSpec flag
   = ( String   -- Flag in string form
     , flag     -- Flag in internal form
     , TurnOnFlag -&gt; DynP ())    -- Extra action to run when the flag is found
                                 -- Typically, emit a warning or error</code></pre>
<p>Flags described by</p>
<pre><code>FlagSpec` can be reversed, e.g. flags that start with `-f` prefix are reversed by using `-fno-</code></pre>
<p>prefix instead.</p>
<h1 id="the-ghc-commentary">The GHC Commentary</h1>
<p>This tree of wiki pages is a &quot;commentary&quot; on the GHC source code. It contains all the explanatory material that doesn't belong in comments in the source code itself, because the material is wide-ranging, usually covers multiple source files, and is more architectural in nature. The commentary can also be considered a design document for GHC.</p>
<p>For the beginners there is [wiki:Newcomers a short getting started guide].</p>
<p>For the dedicated, there are [wiki:AboutVideos videos of Simon and Simon giving an overview of GHC], at the 2006 [wiki:Hackathon GHC Hackathon].</p>
<p>Also check out the [wiki:ReadingList GHC Reading List], which gives lots of background reading that will help you understand the actual implementation. Here's <a href="http://www.stephendiehl.com/posts/essential_compilers.html">another reading list</a> from Stephen Diehl.</p>
<h2 id="editing-the-commentary">Editing the Commentary</h2>
<p>Please feel free to add material to the rest of the wiki: don't worry too much about accuracy (in due course someone will edit your contribution). When unsure though please indicate this and its best to ask on the GHC mailing list so you can correct the commentary. Please give some thought to where in the commentary your contribution belongs. GHC has an older commentary (non wiki based) that read like a single coherent narrative, made sure to define terms before using them, and introduced concepts in the order which made them easiest to understand. Please do try to preserve those properties in this wiki commentary. If you're unsure or in a hurry, consider creating a wiki page outside the commentary and linking to it from the commentary (or the &quot;contributed documentation&quot; section below).</p>
<p>Try to link to source files as much as possible by using this macro:</p>
<pre><code>[[GhcFile(compiler/Makefile)]]</code></pre>
<p>. Also try to add appropriate links to other parts of the commentary.</p>
<h2 id="contents">Contents</h2>
<ul>
<li>[wiki:Commentary/GettingStarted Getting Started]
<ul>
<li>[wiki:Commentary/SourceTree Source Tree Roadmap]</li>
<li>[wiki:Commentary/ModuleStructure Module Structure]</li>
<li>[wiki:Commentary/CodingStyle Coding Style]</li>
<li>[wiki:Commentary/Abbreviations Abbreviations in GHC]</li>
<li>[wiki:Commentary/PlatformNaming Platforms and their Naming Convention]</li>
</ul></li>
</ul>
<ul>
<li>[wiki:Commentary/Compiler The Compiler]</li>
</ul>
<ul>
<li>[wiki:Commentary/Libraries The Libraries on which GHC depends]
<ul>
<li>[wiki:Commentary/Libraries/Integer The Integer libraries (
<pre><code>integer-gmp` and `integer-simple</code></pre>
<p>)]</p></li>
</ul></li>
</ul>
<ul>
<li>[wiki:Commentary/Rts The Runtime System (RTS)]
<ul>
<li>[wiki:Commentary/Rts/Conventions RTS Coding Conventions]</li>
<li>[wiki:Commentary/Rts/HaskellExecution The Haskell Execution Model]</li>
<li>[wiki:Commentary/Rts/Storage The memory layout of heap and stack objects]</li>
</ul></li>
</ul>
<ul>
<li>Cross-cutting concerns: topics which span both the compiler and the runtime system
<ul>
<li>[wiki:Commentary/Profiling Profiling]</li>
<li>[wiki:Commentary/Compiler/WiredIn Wired-in and known-key things]</li>
<li>[wiki:Commentary/PrimOps Primitive Operations (PrimOps)]</li>
<li>[wiki:Commentary/Packages The Package System]</li>
</ul></li>
</ul>
<ul>
<li>[wiki:Commentary/UserManual The User Manual] (formatting guidelines etc)</li>
</ul>
<h2 id="contributed-documentation">Contributed Documentation</h2>
<p>The above commentary covers the source code of GHC. For material that doesn't concern this topic (such as proposals, work-in-progress and status reports) or that don't fit into the existing structure, you will find them below. Feel free to add new material here but please categorise it correctly.</p>
<ul>
<li>General Notes on the GHC compiler
<ul>
<li>Edward Yang's blog post about [<a href="http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/" class="uri">http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/</a> the entire complilation pipeline for
<pre><code>factorial</code></pre>
<p>]</p></li>
<li>[wiki:AddingNewPrimitiveOperations New Prim Ops]: How to add new primitive operations to GHC Haskell.</li>
<li>[wiki:ReplacingGMPNotes Replacing GMP]: Notes from an effort to replace GMP with another Bignum library.</li>
<li>[wiki:ExternalCore External Core]: Describes the process of bringing External Core up to speed. Once finished, this will simply describe what External Core is, and how it works.</li>
<li><a href="http://sourceforge.net/apps/mediawiki/developers/index.php?title=ScrapYourBoilerplate">The Scrap your boilerplate homepage</a>.</li>
<li>[wiki:Commentary/Compiler/OptOrdering Optimisation Ordering] Describe the ordering and interaction of optimisation passes (Old).</li>
<li><a href="https://github.com/takenobu-hs/haskell-ghc-illustrated">GHC Illustrated</a> (follow the PDF link), a very insightful tutorial on GHC's internals.</li>
<li><a href="https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html">Ollie Charles's 24 days of GHC Extensions</a>, and <a href="http://augustss.blogspot.com/2014/12/a-commentary-on-24-days-of-ghc.html">Lennart Augstsson's commentary</a>
<ul>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-01-24-days-of-ghc-extensions.html">Welcome</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-23-static-pointers.html">Static Pointers</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-22-template-haskell.html">Template Haskell</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-21-arrows.html">Arrows</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-20-scoped-type-variables.html">Scoped Type Variables</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-19-existential-quantification.html">Existential Quantification</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html">Rank N Types</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-17-overloaded-strings.html">Overloaded Strings</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-16-derive-generic.html">DeriveGeneric</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-15-deriving.html">Deriving</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-14-functional-dependencies.html">Functional Dependencies</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-13-multi-param-type-classes.html">Multi-parameter Type Classes</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html">Type Families</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-11-implicit-params.html">Implicit Parameters</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-10-nullary-type-classes.html">Nullary Type Classes</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-09-recursive-do.html">Recursive Do</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-08-type-operators.html">Type Operators</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-07-list-comprehensions.html">List Comprehensions</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html">Rebindable Syntax</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-05-bang-patterns.html">Bang Patterns</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html">Record Wildcards</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html">Pattern Synonyms</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html">View Patterns</a></li>
<li><a href="https://ocharles.org.uk/blog/posts/2014-12-24-conclusion.html">Thanks</a></li>
</ul></li>
<li>[wiki:Commentary/Rts/CompilerWays]: Compiler <em>ways</em> in GHC, what, how, and where</li>
</ul></li>
</ul>
<ul>
<li>Notes on implemented GHC features:
<ul>
<li><a href="https://www.fpcomplete.com/tutorial-preview/4431/z0KpB0ai2R">Evaluation order and state tokens</a>: notes written by Michael Snoyberg in response to #9390.</li>
<li>[wiki:FoldrBuildNotes Notes on fusion] (eg foldr/build)</li>
<li>[wiki:OverloadedLists Overloaded list syntax] allows you to use list notation for things other than lists.</li>
<li>[wiki:GhcKinds Kind polymorphism and data type promotion]</li>
<li>[wiki:KindFact A kind for class constraints. Implemented as ConstraintKinds]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM LLVM back end]</li>
<li>[wiki:Commentary/Compiler/GenericDeriving Support for generic programming]</li>
<li>[wiki:TemplateHaskell Notes about Template Haskell]</li>
<li>[wiki:RewriteRules Rewrite Rules]: Notes about the implementation of RULEs in GHC</li>
<li>[wiki:MonadComprehensions Monad Comprehensions]: Translation rules and some implementation details</li>
<li>[wiki:HaddockComments Haddock]: Some notes about how the Haddock comment support is implemented.</li>
<li>[wiki:IntermediateTypes Intermediate Types]: Notes about the type system of GHC's new intermediate language (in the HEAD since ICFP'06)</li>
<li>[wiki:TypeFunctions Type families/type functions]: Notes concerning the implementation of type families, associated types, and equality constraints as well as the extension of the type checker with a contraint solver for equality constraints.</li>
<li>[wiki:Commentary/Compiler/SeqMagic Magic to do with
<pre><code>seq</code></pre>
<p>and friends]</p></li>
<li>[wiki:NewPlugins Compiler plug-ins]</li>
<li>[wiki:MemcpyOptimizations memcpy/memmove/memset optimizations]</li>
<li>[wiki:BackEndNotes Backend Ideas]: Some ideas and notes about the back end.</li>
<li>[wiki:Commentary/Compiler/NewCodeGen Notes about the new code generator]</li>
<li>[wiki:Commentary/Compiler/HooplPerformance A record of improvements made to the performance of the Hoopl library for dataflow optimisation]</li>
<li>[wiki:DataParallel DPH]: Notes about the implementation of Data Parallel Haskell</li>
<li>[wiki:SafeHaskell Safe Haskell]: The design of the GHC Safe Haskell extension</li>
<li>[wiki:SQLLikeComprehensions SQL-Like Comprehensions]: Notes on SPJs &quot;Comprehensive Comprehensions&quot; (TransformComprehensions)</li>
<li>[wiki:DeferErrorsToRuntime Deferring compilation type errors to runtime (
<pre><code>-fdefer-type-errors</code></pre>
<p>)]</p></li>
<li>[wiki:Commentary/Compiler/Demand Demand analyser] Notes on the meanings, worker-wrapper splitting of demand signatures and relevant components of the compiler</li>
<li>[wiki:NewAxioms Closed type families]</li>
<li>[wiki:OneShot] The magic
<pre><code>oneShot</code></pre>
<p>function.</p></li>
<li>[wiki:Commentary/Compiler/DeriveFunctor Deriving Functor, Foldable, and Traversable]</li>
</ul></li>
</ul>
<ul>
<li>Notes on proposed or in progress (but out of tree) GHC compiler features:
<ul>
<li>[wiki:LanguageStrict Making Haskell strict]</li>
<li>[wiki:PatternMatchCheck Improving pattern-match overlap and exhaustiveness checks]</li>
<li>[wiki:GhcAstAnnotations Source-locations on HsSyn]</li>
<li>[wiki:CabalDependency How GHC inter-operates with Cabal] and [wiki:Backpack]</li>
<li>[wiki:StaticValues] and ticket #7015</li>
<li>[wiki:PartialTypeSignatures Partial type signatures] and its ticket #9478</li>
<li>[wiki:LateLamLift Late lambda-lifting], and its ticket #9476</li>
<li>[wiki:Roles Roles in Haskell]</li>
<li>[wiki:DependentHaskell Dependent types in Haskell]</li>
<li>[wiki:NestedCPR Nested CPR analysis]</li>
<li>[wiki:TemplateHaskell/Annotations Giving Template Haskell full access to annotations]</li>
<li>[wiki:FunDeps Checking consistency of functional dependencies]</li>
<li>[wiki:Commentary/GSoCMultipleInstances Allowing multiple instances of the same package to be installed], each instance having different dependencies</li>
<li>[wiki:Commentary/Contracts Contracts in Haskell]</li>
<li>[wiki:Holes Agda-style holes in terms] which supports writing partial programs.</li>
<li>[wiki:Records Records]</li>
<li><a href="http://haskell.org/haskellwiki/GHC/CouldAndHPCHaskell">Cloud Haskell</a></li>
<li>[wiki:PackageLanguage A modular package language for Haskell] Scott Kilpatrick and Derek Dreyer are designing a new</li>
</ul></li>
</ul>
<h1 id="ghc-commentary-the-compiler">GHC Commentary: The Compiler</h1>
<p>The compiler itself is written entirely in Haskell, and lives in the many sub-directories of the <a href="GhcFile(compiler)" class="uri" title="wikilink">GhcFile(compiler)</a> directory.</p>
<ul>
<li>[wiki:ModuleDependencies Compiler Module Dependencies] (deals with the arcane mutual recursions among GHC's many data types)</li>
<li>[wiki:Commentary/CodingStyle Coding guidelines]</li>
</ul>
<ul>
<li>[wiki:Commentary/Compiler/CommandLineArgs Command line arguments]</li>
<li>[wiki:Commentary/Pipeline The compilation pipeline]</li>
</ul>
<ul>
<li>'''Compiling one module: HscMain'''
<ul>
<li>[wiki:Commentary/Compiler/HscMain Overview] gives the big picture.</li>
<li>Some details of the [wiki:Commentary/Compiler/Parser parser]</li>
<li>Some details of the [wiki:Commentary/Compiler/Renamer renamer]</li>
<li>Some details of the [wiki:Commentary/Compiler/TypeChecker typechecker]</li>
<li>Some details of the [wiki:Commentary/Compiler/Core2CorePipeline simplifier]</li>
<li>Some details of the [wiki:Commentary/Compiler/CodeGen code generator] converts STG to Cmm</li>
<li>[wiki:Commentary/Compiler/Backends Backends] convert Cmm to native code:
<ul>
<li>[wiki:Commentary/Compiler/Backends/PprC C code generator]</li>
<li>[wiki:Commentary/Compiler/Backends/NCG Native code generator]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM LLVM backend]</li>
<li>[wiki:Commentary/Compiler/Backends/GHCi GHCi backend]</li>
</ul></li>
<li>A guide to the [wiki:Commentary/Compiler/GeneratedCode generated assembly code]</li>
</ul></li>
</ul>
<ul>
<li>[wiki:Commentary/Compiler/KeyDataTypes Key data types]
<ul>
<li>[wiki:Commentary/Compiler/HsSynType The source language: HsSyn]</li>
<li>[wiki:Commentary/Compiler/RdrNameType RdrNames, Modules, and OccNames]</li>
<li>[wiki:Commentary/Compiler/ModuleTypes ModIface, ModDetails, ModGuts]</li>
<li>[wiki:Commentary/Compiler/NameType Names]</li>
<li>[wiki:Commentary/Compiler/EntityTypes Entities]: variables, type constructors, data constructors, and classes.</li>
<li>Types:
<ul>
<li>[wiki:Commentary/Compiler/TypeType Types]</li>
<li>[wiki:Commentary/Compiler/Kinds Kinds]</li>
<li>[wiki:Commentary/Compiler/FC Equality types and coercions]</li>
</ul></li>
<li>[wiki:Commentary/Compiler/CoreSynType The core language]</li>
<li>[wiki:Commentary/Compiler/StgSynType The STG language]</li>
<li>[wiki:Commentary/Compiler/CmmType The Cmm language]</li>
<li>[wiki:Commentary/Compiler/BackEndTypes Back end types]</li>
</ul></li>
</ul>
<ul>
<li>[wiki:Commentary/Compiler/Driver Compiling more than one module at once]</li>
<li>[wiki:Commentary/Compiler/DataTypes How data type declarations are compiled]</li>
<li>[wiki:Commentary/Compiler/API The GHC API]</li>
<li>[wiki:Commentary/Compiler/SymbolNames Symbol names and the Z-encoding]</li>
<li>[wiki:TemplateHaskell/Conversions Template Haskell]</li>
<li>[wiki:Commentary/Compiler/WiredIn Wired-in and known-key things]</li>
<li>[wiki:Commentary/Compiler/Packages Packages]</li>
<li>[wiki:Commentary/Compiler/RecompilationAvoidance Recompilation Avoidance]</li>
</ul>
<p>Case studies:</p>
<ul>
<li>[wiki:Commentary/Compiler/CaseStudies/Bool Implementation of wired-in Bool data type]</li>
</ul>
<h2 id="overall-structure">Overall Structure</h2>
<p>Here is a block diagram of its top-level structure:</p>
<p><a href="Image(ghc-top.png)" class="uri" title="wikilink">Image(ghc-top.png)</a></p>
<p>The part called [wiki:Commentary/Compiler/HscMain HscMain] deals with compiling a single module. On top of this is built the <strong>compilation manager</strong> (in blue) that manages the compilation of multiple modules. It exports an interface called the <strong>GHC API</strong>. On top of this API are four small front ends:</p>
<ul>
<li>GHCi, the interactive environment, is implemented in <a href="GhcFile(ghc/InteractiveUI.hs)" class="uri" title="wikilink">GhcFile(ghc/InteractiveUI.hs)</a> and <a href="GhcFile(compiler/main/InteractiveEval.hs)" class="uri" title="wikilink">GhcFile(compiler/main/InteractiveEval.hs)</a>. It sits squarely on top of the GHC API.</li>
</ul>
<ul>
<li><pre><code>--make</code></pre>
<p>is almost a trivial client of the GHC API, and is implemented in <a href="GhcFile(compiler/main/GhcMake.hs)" class="uri" title="wikilink">GhcFile(compiler/main/GhcMake.hs)</a>.</p></li>
</ul>
<ul>
<li><pre><code>-M</code></pre>
<p>, the Makefile dependency generator, is also a client of the GHC API and is implemented in <a href="GhcFile(compiler/main/DriverMkDepend.hs)" class="uri" title="wikilink">GhcFile(compiler/main/DriverMkDepend.hs)</a>.</p></li>
</ul>
<ul>
<li>The &quot;one-shot&quot; mode, where GHC compiles each file on the command line separately (eg.
<pre><code>ghc -c Foo.hs</code></pre>
<p>). This mode bypasses the GHC API, and is implemented</p></li>
</ul>
<p><code>  directly on top of [wiki:Commentary/Compiler/HscMain HscMain], since it compiles only one file at a time. In fact, this is all that   </code><br />
<code>  GHC consisted of prior to version 5.00 when GHCi and </code></p>
<pre><code>--make</code></pre>
<p>were introduced.</p>
<p>GHC is packaged as a single binary in which all of these front-ends are present, selected by the command-line flags indicated above. There is a single command-line interface implemented in <a href="GhcFile(ghc/Main.hs)" class="uri" title="wikilink">GhcFile(ghc/Main.hs)</a>.</p>
<p>In addition, GHC is compiled, without its front ends, as a <em>library</em> which can be imported by any Haskell program; see [wiki:Commentary/Compiler/API the GHC API].</p>
<h1 id="compiler-and-runtime-system-ways-in-ghc">Compiler and runtime system ways in GHC</h1>
<p>GHC can compile programs in different <em>ways</em>. For instance, a program might be compiled with profiling enabled (</p>
<pre><code>-prof`), or for multithreaded execution (`-threaded`), or maybe making some debugging tools available (`-debug</code></pre>
<p>, see Debugging/RuntimeSystem for a description).</p>
<p>There are two types of GHC ways, RTS-only ways and full ways.</p>
<ul>
<li><strong>Runtime system (RTS) ways</strong> affect the way that the runtime system is built. As an example,
<pre><code>-threaded` is a runtime system way. When you compile a program with `-threaded</code></pre>
<p>, it will be linked to a (precompiled) version of the RTS with multithreading enabled.</p></li>
</ul>
<p>Obviously, the compiler's RTS must have been built for this way (the threaded RTS is activated by default BTW). In customised builds, an RTS way can be added in the build configuration</p>
<pre><code>mk/build.mk` (see [[GhcFile(mk/build.mk.sample)]]), by adding its &#39;&#39;short name&#39;&#39; to the variable `GhcRTSWays</code></pre>
<p>.</p>
<ul>
<li><strong>Full ways</strong></li>
</ul>
<p>Full compiler ways are ways which affect both the generated code and the runtime system that runs it.</p>
<p>The profiling way</p>
<pre><code>-prof` is such a way. The machine code of a program compiled for profiling differs from a normal version&#39;s code by all code that gathers the profiling information, and the runtime system has additional functionality to access and report this information. Therefore, all libraries used in a profiling-enabled program need to also have profiling enabled, i.e. a separate library version for profiling needs to be installed to compile the program with `prof</code></pre>
<p>. (If the library was installed without this profiling version, the program cannot be linked).</p>
<p>In customised builds, a full way is added in the build configuration</p>
<pre><code>mk/build.mk` by adding its tag to the variable `GhcLibWays</code></pre>
<p>.</p>
<h2 id="available-ways-in-a-standard-ghc">Available ways in a standard GHC</h2>
<p>Ways are identified internally by a way name, and enabled by specific compilation flags. In addition, there are short names (tags) for the available ways, mainly used by the build system.</p>
<p>Here is a table of available ways in a standard GHC, as of May 2015.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><h1 id="way-flag">Way flag</h1></td>
<td align="left"><h1 id="way-name">Way name</h1></td>
<td align="left"><h1 id="tag">Tag</h1></td>
<td align="left"><h1 id="type">Type</h1></td>
<td align="left"><h1 id="description">Description</h1></td>
</tr>
<tr class="even">
<td align="left"><h1 id="section">-</h1></td>
<td align="left"><p>-</p></td>
<td align="left"><pre><code>v</code></pre></td>
<td align="left"><p>Full</p></td>
<td align="left"><p>(vanilla way) default</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>-threaded</code></pre>
<p>=</p></td>
<td align="left"><p>WayThreaded</p></td>
<td align="left"><pre><code>thr</code></pre></td>
<td align="left"><p>RTS</p></td>
<td align="left"><p>multithreaded runtime system</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>-debug</code></pre>
<p>=</p></td>
<td align="left"><p>WayDebug</p></td>
<td align="left"><pre><code>debug</code></pre></td>
<td align="left"><p>RTS</p></td>
<td align="left"><p>debugging, enables trace messages and extra checks</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>-prof</code></pre>
<p>=</p></td>
<td align="left"><p>WayProf</p></td>
<td align="left"><pre><code>p</code></pre></td>
<td align="left"><p>Full</p></td>
<td align="left"><p>profiling, enables cost centre stacks and profiling reports</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>-eventlog</code></pre>
<p>=</p></td>
<td align="left"><p>WayEventLog</p></td>
<td align="left"><pre><code>l</code></pre></td>
<td align="left"><p>RTS</p></td>
<td align="left"><p>Event logging (for ghc-events, threadscope, and EdenTV)</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>-dyn</code></pre>
<p>=</p></td>
<td align="left"><p>WayDyn</p></td>
<td align="left"><pre><code>dyn</code></pre></td>
<td align="left"><p>Full</p></td>
<td align="left"><p>Dynamic linking</p></td>
</tr>
</tbody>
</table>
<p>The standard (<em>vanilla</em>) way of GHC has a name (<em>vanilla</em>), but it could (probably?) even be switched off in a custom build if desired. Obviously, the libraries would still need to be built in the vanilla way for all RTS-only ways, so one would need</p>
<pre><code>GhcLibWays=v</code></pre>
<p>when building any other RTS-only way.</p>
<p>The code (see below) contains another way, for Glasgow parallel Haskell, which is currently unmaintained (</p>
<pre><code>WayPar</code></pre>
<p>).</p>
<h3 id="ways-for-parallel-execution-on-clusters-and-multicores">Ways for parallel execution on clusters and multicores</h3>
<p>The parallel Haskell runtime system for Eden (available from <a href="http://github.com/jberthold/ghc" class="uri">http://github.com/jberthold/ghc</a>) defines several RTS-only ways for Eden. All these ways execute the RTS in multiple instances with distributed heaps, they differ in the communication substrate (and consequently in the platform).</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><h1 id="way-flag-1">Way flag</h1></td>
<td align="left"><h1 id="way-name-1">Way name</h1></td>
<td align="left"><h1 id="tag-1">Tag</h1></td>
<td align="left"><h1 id="type-1">Type</h1></td>
<td align="left"><h1 id="communication-os">communication (OS)</h1></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>-parpvm</code></pre>
<p>=</p></td>
<td align="left"><p>WayParPvm</p></td>
<td align="left"><pre><code>pp</code></pre></td>
<td align="left"><p>RTS</p></td>
<td align="left"><p>PVM (Linux)</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>-parmpi</code></pre>
<p>=</p></td>
<td align="left"><p>WayParMPI</p></td>
<td align="left"><pre><code>pm</code></pre></td>
<td align="left"><p>RTS</p></td>
<td align="left"><p>MPI (Linux)</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>-parcp</code></pre>
<p>=</p></td>
<td align="left"><p>WayParCp</p></td>
<td align="left"><pre><code>pc</code></pre></td>
<td align="left"><p>RTS</p></td>
<td align="left"><p>OS-native shared memory (Windows/Linux)</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>-parms</code></pre>
<p>=</p></td>
<td align="left"><p>WayParMSlot</p></td>
<td align="left"><pre><code>ms</code></pre></td>
<td align="left"><p>RTS</p></td>
<td align="left"><p>Windows mail slots (Windows)</p></td>
</tr>
</tbody>
</table>
<h2 id="combining-ways">Combining ways</h2>
<p>The alert reader might have noticed that combinations like &quot;threaded with dynamic linking&quot; or &quot;profiled with eventlog&quot; are not covered in the table. Some ways can be used together (most prominently, debugging can be used together with any other way), others are mutually excluding each other (like profiling with eventlog).</p>
<p>The allowed combinations are defined inside the compiler, in <a href="GhcFile(compiler/main/DynFlags.hs)" class="uri" title="wikilink">GhcFile(compiler/main/DynFlags.hs)</a>. Which brings us to discussing some of the internals.</p>
<h1 id="internals">Internals</h1>
<p>Ways are defined in <a href="GhcFile(compiler/main/DynFlags.hs)" class="uri" title="wikilink">GhcFile(compiler/main/DynFlags.hs)</a> as a Haskell data structure</p>
<pre><code>Way</code></pre>
<p>.</p>
<p>Function</p>
<pre><code>dynamic_flags` defines the actual flag strings for the ghc invocation (like `-prof`, `-threaded`), which activate the respective `Way</code></pre>
<p>.</p>
<p>The short name tags for ways are defined in</p>
<pre><code>wayTag`. The tags are used in the suffixes of *.o and *.a files for RTS and libraries, for instance `*.p_o` for profiling, `*.l_o</code></pre>
<p>for eventlog.</p>
<p>A number of other functions in there customise behaviour depending on the ways. Note</p>
<pre><code>wayOptc` which sets some options for the C compiler, like `-DTRACING` for the `-eventlog</code></pre>
<p>way.</p>
<p>However, this is not the full truth. For instance, there is no</p>
<pre><code>-DDEBUG` for the debug way here, but the RTS is full of `#ifdef DEBUG</code></pre>
<p>.</p>
<p>In <a href="GhcFile(mk/ways.mk)" class="uri" title="wikilink">GhcFile(mk/ways.mk)</a>, we find all the short names and all combinations enumerated, and some more options are defined here (</p>
<pre><code>WAY_*_HC_OPTS</code></pre>
<p>). These definitions are for the driver script, and pass on the right (long-name) options to the Haskell compiler to activate what is inside DynFlags (like -prof for WAY_p_HC_OPTS). Here we find</p>
<pre><code>``WAY_debug_HC_OPTS= -static -optc-DDEBUG -ticky -DTICKY_TICKY``</code></pre>
<p>so we can learn that ticky profiling is activated by compiling with</p>
<pre><code>debug</code></pre>
<p>.</p>
<p>(TODO be more precise on where the options from ways.mk are used.)</p>
<p>Package keys, installed package IDs, ABI hashes, package names and versions, Nix-style hashes, ... there's so many different identifiers, what do they all mean? I think the biggest source of confusion (for myself included) is keeping straight not only what these terms mean, but also what people want them to mean in the future, and what we //actually// care about. So I want to help clarify this a bit, by clearly separating the //problem you are trying to solve// from //how you are solving the problem//.</p>
<p>The content here overlaps with wiki:Commentary/Packages but is looking at the latest iteration of the multi-instances and Backpack work.</p>
<p>See also</p>
<pre><code>Note [The identifier lexicon]` in `compiler/basicTypes/Module.hs</code></pre>
<p>.</p>
<p>Some relevant tickets: #10622</p>
<h2 id="what-problems-do-we-need-to-solve">What problems do we need to solve?</h2>
<p>When we come up with identification schemes for packages, we are trying to solve a few problems:</p>
<dl>
<dt>[SYMBOL]</dt>
<dd>What symbol names should we put in the binary? (e.g., the &quot;foozm0zi1&quot; in &quot;foozm0zi1_A_DZCF_closure&quot;)
</dd>
</dl>
<p><code>       - It must be unique enough that for all libraries we would</code><br />
<code>         like to be able to link together, there should not be</code><br />
<code>         conflicts.</code><br />
<code>       - HOWEVER, it must be stable enough that if we make a minor</code><br />
<code>         source code change, we don't have to gratuitously recompile</code><br />
<code>         every dependency.</code></p>
<dl>
<dt>[ABI]</dt>
<dd>When can I swap out one compiled package with another WITHOUT recompiling, i.e. what is the ABI of the package? Equal ABIs implies equal symbols, though not vice versa. ABI is usually computed after compilation is complete.
</dd>
</dl>
<p><code>       - ABI can serve as correctness condition: if we link against a specific ABI, we can be sure that anything with an equivalent ABI won't cause our package to segfault.</code><br />
<code>       - ABI can also serve as an indirection: we linked against an ABI, anything that is compatible can be hotswapped in without compilation. In practice, this capability is rarely used by users because it's quite hard to compile a package multiple times with the same ABI, because (1) compilation is nondeterministic, and (2) even if no types change, a change in implementation can cause a different exported unfolding, which is ABI relevant.</code></p>
<dl>
<dt>[SOURCE]</dt>
<dd>What is the unit of distribution? In other words, when a maintainer uploads an sdist to Hackage, how do you identify that source tarball?
</dd>
</dl>
<p><code>       - On Hackage, a package name plus version uniquely identifies an</code><br />
<code>         sdist.  This is enforced by community standards; in a local</code><br />
<code>         development environment, this may not hold since devs will edit</code><br />
<code>         code without updating the version number. Call this [WEAK SOURCE].</code><br />
<code>       - Alternately, a cryptographic hash of the source code uniquely</code><br />
<code>         identifies the stream of bytes.  This is enforced by math. Call this [STRONG SOURCE].</code></p>
<dl>
<dt>[LIBRARY]</dt>
<dd>When you build a library, you get an
<pre><code>libfoo.so</code></pre>
<p>file. What identifies an OS level library?</p>
</dd>
</dl>
<dl>
<dt>[NIX]</dt>
<dd>What is the full set of source which I can use to reproduceably build a build product?
</dd>
</dl>
<p><code>       - In today's Cabal, you could approximate this by taking [WEAK SOURCE] of a package, as well as all of its transitive dependencies. Call this [WEAK NIX].</code><br />
<code>       - The Nix approach is to ensure deterministic builds by taking the hash of the source [STRONG SOURCE] and also recursively including the [NIX] of each direct dependency. Call this [STRONG NIX].</code><br />
<code>       - Note that [ABI] does NOT imply [NIX]; a package might be binary compatible but do something different, and in a Nix model they should be recorded differently.</code></p>
<dl>
<dt>[TYPES]</dt>
<dd>When are two types the same? If there are from differing packages, they are obviously different; if they are from the same package, they might still be different if the dependencies were different in each case.
</dd>
</dl>
<p><code>       - Types show up in error message, so this is a USER VISIBLE</code><br />
<code>         notion.  Many people have (cogently) argued that this should</code><br />
<code>         be AS SIMPLE as possible, because there's nothing worse</code><br />
<code>         than being told that Data.ByteString.ByteString is not</code><br />
<code>         equal to Data.ByteString.ByteString (because they were from</code><br />
<code>         different packages.)</code></p>
<h2 id="current-mechanisms">Current mechanisms</h2>
<p>Today, we have a lot of different MECHANISMS for identifying these:</p>
<dl>
<dt>Package Name</dt>
<dd>Something like &quot;lens&quot;
</dd>
</dl>
<dl>
<dt>Package Version</dt>
<dd>Something like &quot;0.1.2&quot;
</dd>
</dl>
<dl>
<dt>(Source) Package ID</dt>
<dd>Package name plus version. With Hackage today, this identifies a unit of distribution: given a package ID you can download a source tarball [SOURCE] of a package (but not build it). Pre-GHC 7.10, the package ID was used for library identification, symbols and type-checking ([LIBRARY], [SYMBOL] and [TYPES]), but this is no longer the case.
</dd>
</dl>
<dl>
<dt>Installed Package ID</dt>
<dd>Package name, package version, and the output of ghc --abi-hash. This is currently used to uniquely identify a built package, although technically it only identifies [ABI].
</dd>
</dl>
<dl>
<dt>Package Key (new in 7.10)</dt>
<dd>Hash of package name, package version, the package keys of all
</dd>
</dl>
<p><code>       textual dependencies the package included, and in Backpack</code><br />
<code>       a mapping from hole name to module by package key.</code><br />
<code>       In GHC 7.10 this is used for library identification, symbols and type-checking ([LIBRARY], [SYMBOL] and [TYPES]).  Because it includes package keys of textual dependencies, it also distinguishes between different dependency resolutions, ala [WEAK NIX].</code></p>
<h2 id="new-concepts-for-backpack">New concepts for Backpack</h2>
<p>First, we have to take the concept of an InstalledPackageId and make it more precise, having it identity components rather than packages.</p>
<dl>
<dt>Component ID</dt>
<dd>The package name, the package version, the name of the component (blank in the case of the default library component), and the hash of source code sdist tarball, selected Cabal flags (not the command line flags), GHC flags, hashes of direct dependencies of the component (the
<pre><code>build-depends</code></pre>
<p>of the library in the Cabal file).</p>
</dd>
</dl>
<p>Then in Backpack we have these concepts:</p>
<dl>
<dt>Indefinite/definite unit</dt>
<dd>An indefinite unit is a single unit which hasn't been instantiated; a definite unit is one that has an instantiation of its holes. Units without holes are both definite and indefinite (they can be used for both contexts).
</dd>
</dl>
<dl>
<dt>Indefinite unit record (in &quot;logical&quot; indefinite unit database)</dt>
<dd>An indefinite unit record is the most general result of type-checking a unit without any of its holes instantiated. It consists of the types of the modules in the unit (ModIfaces) as well as the source code of the unit (so that it can be recompiled into a definite unit). Indefinite unit records can be installed in the &quot;indefinite unit database.&quot;
</dd>
</dl>
<dl>
<dt>Definite unit record (previously installed package record, in the definite unit database, previously the installed package database)</dt>
<dd>A definite unit record is a fully-instantiated unit with its associated library. It consists of the types and objects of the compiled unit; they also contain metadata for their associated package. Definite unit records can be installed in the &quot;definite unit database&quot; (previously known as the &quot;installed package database.&quot;)
</dd>
</dl>
<p>To handle these, we need some new identifiers:</p>
<dl>
<dt>Unit Id (previously named Package Key)</dt>
<dd>For Backpack units, the unit ID is the component ID plus a mapping from holes to modules (unit key plus module name). For non-Backpack units, the unit ID is equivalent to the component source hash (the hole mapping is empty). These serve the role of [SYMBOL, LIBRARY, TYPES]. (Partially definite unit keys can occur on-the-fly during type checking.) When all of the requirements are filled (so there is no occurrence of HOLE), the unit key serves as the primary key for the installed unit database. (We might call this an &quot;installed unit ID&quot; in this context) The unit ID &quot;HOLE&quot; is a distinguished unit ID, which is for the &quot;hole package&quot;, representing modules which are not yet implemented (there is not actually a unit named hole, it's just a notational convention).
</dd>
</dl>
<dl>
<dt>Module</dt>
<dd>A unit ID plus a module name.
</dd>
</dl>
<h2 id="features">Features</h2>
<p>There are a number of enhancements proposed for how Cabal handles packages, which have often been conflated together. I want to clearly separate them out here:</p>
<dl>
<dt>Non-destructive installs</dt>
<dd>If I have package foo-0.2 compiled against bar-0.1, and a different build compiled against bar-0.2, I should be able to put them in the same installed package database. THIS IS HIGH PRIORITY.
</dd>
</dl>
<dl>
<dt>Views</dt>
<dd>If I have package foo compiled against bar-0.1, and baz compiled against bar-0.2, these two packages aren't usable together (modulo private dependencies, see below). Views are a UI paradigm making it easier for users to work in a universe where foo is available, or a universe where baz is available, but not both simultaneously. Cabal sandboxes are views but without a shared installed package database. This is lower priority, because if you use cabal-install to get a coherent dependency set, you'll never see both foo and baz at the same time; the primary benefit of this is to assist with direct use of GHC/GHCi, however, it is generally believed that non-destructive installs will make it difficult to use GHC/GHCi by itself.
</dd>
</dl>
<dl>
<dt>Private dependencies</dt>
<dd>If I have a package foo-0.2 which depends on a library bar-0.1, but not in any externally visible way, it should be allowed for a client to separately use bar-0.2. This is LOW priority; amusingly, in 7.10, this is already supported by GHC, but not by Cabal.
</dd>
</dl>
<dl>
<dt>Hot swappable libraries</dt>
<dd>If I install a library and it's assigned ABI hash 123abc, and then I install a number of libraries that depend on it, hot swappable library means that I can replace that installed library with another version with the same ABI hash, and everything will keep working. This feature is accidentally supported by GHC today, but no one uses it (because ABIs are not stable enough); we are willing to break this mode of use to support other features.
</dd>
</dl>
<h2 id="constraints">Constraints</h2>
<p>For an implementer, it is best if each problem is solved separately. However, Simon has argued strongly it is best if we REDUCE the amount of package naming concepts. You can see this in pre-7.10 GHC, where the package ID (package name + version) was used fulfill many functions: linker symbols, type identity as well as being a unit of distribution.</p>
<p>So the way I want to go about arguing for the necessity of a given identifier is by showing that it is IMPOSSIBLE (by the intended functions) for a single identifier to serve both roles. Here are the main constraints:</p>
<p><code>- [SYMBOL] and [STRONG NIX]/[STRONG SOURCE] don't play nicely together.  If you modify your source code, a [STRONG NIX/SOURCE] identifier must change; if this means [SYMBOL] changes too, you will have to recompile everything. However, you can work around this problem by using fake identifiers during development to avoid recompilation, recompiling with the correct NIX identifier when it's finally time to install.</code></p>
<p><code>- [SOURCE] and [TYPES] are incompatible under non-destructive installs and private dependencies. With private dependencies (which GHC supports), I may link against the multiple instances of the same source but compiled against different dependencies; we MUST NOT consider these types to be the same. Note: GHC used to use package ID for both of these; so coherence was guaranteed by requiring destructive installs.</code></p>
<p><code>- [NIX] and [TYPES] are incompatible under Backpack.  In Backpack, a library author may distribute a package with the explicit intent that it may be used in the same client multiple times with different instantiations of its holes; these types must be kept distinct.</code></p>
<h1 id="rts-configurations">RTS Configurations</h1>
<p>The RTS can be built in several different ways, corresponding to global CPP defines. The flavour of the RTS is chosen by GHC when compiling a Haskell program, in response to certain command-line options:</p>
<pre><code>-prof</code></pre>
<p>,</p>
<pre><code>-threaded</code></pre>
<p>, etc.</p>
<p>The CPP symbols and their corresponding command-line flags are:</p>
<p>;</p>
<pre><code>PROFILING</code></pre>
<dl>

<dd>Enables profiling.<a href="br" class="uri" title="wikilink">br</a>
</dd>
</dl>
<p><code> GHC option: </code></p>
<pre><code>-prof</code></pre>
<p><a href="br" class="uri" title="wikilink">br</a></p>
<p><code> RTS suffix: </code></p>
<pre><code>p</code></pre>
<p>;</p>
<pre><code>THREADED_RTS</code></pre>
<dl>

<dd>Enables multithreading in the RTS, bound threads, and SMP execution.<a href="br" class="uri" title="wikilink">br</a>
</dd>
</dl>
<p><code> GHC option: </code></p>
<pre><code>-threaded</code></pre>
<p><a href="br" class="uri" title="wikilink">br</a></p>
<p><code> RTS suffix: </code></p>
<pre><code>thr</code></pre>
<p>;</p>
<pre><code>DEBUG</code></pre>
<dl>

<dd>Enables extra debugging code, assertions, traces, and the
<pre><code>+RTS -D</code></pre>
<p>options.<a href="br" class="uri" title="wikilink">br</a></p>
</dd>
</dl>
<p><code> GHC option: </code></p>
<pre><code>-debug</code></pre>
<p><a href="br" class="uri" title="wikilink">br</a></p>
<p><code> RTS suffix: </code></p>
<pre><code>debug</code></pre>
<p>;</p>
<pre><code>TRACING</code></pre>
<dl>

<dd>Enables RTS tracing and event logging, see <a href="GhcFile(rts/Trace.c)" class="uri" title="wikilink">GhcFile(rts/Trace.c)</a>. Implied by
<pre><code>DEBUG</code></pre>
<p>.<a href="br" class="uri" title="wikilink">br</a></p>
</dd>
</dl>
<p><code> GHC option: </code></p>
<pre><code>-eventlog</code></pre>
<p><a href="br" class="uri" title="wikilink">br</a></p>
<p><code> RTS suffix: </code></p>
<pre><code>l</code></pre>
<p>So for example,</p>
<pre><code>libHSrts_thr_debug.a</code></pre>
<p>is the version of the runtime compiled with</p>
<pre><code>THREADED_RTS</code></pre>
<p>and</p>
<pre><code>DEBUG</code></pre>
<p>, and will be linked in if you use the</p>
<pre><code>-threaded</code></pre>
<p>and</p>
<pre><code>-debug</code></pre>
<p>options to GHC.</p>
<p>The ways that the RTS is built in are controlled by the</p>
<pre><code>GhcRTSWays</code></pre>
<p>Makefile variable.</p>
<h2 id="combinations">Combinations</h2>
<p>All combinations are allowed. Only some are built by default though; see [source:mk/config.mk.in] to see how the</p>
<pre><code>GhcRTSWays</code></pre>
<p>variable is set.</p>
<h2 id="other-configuration-options">Other configuration options</h2>
<p>;</p>
<pre><code>NO_REGS</code></pre>
<dl>

<dd>Disabled the use of hardware registers for the stack pointer (
<pre><code>Sp`), heap pointer (`Hp</code></pre>
<p>), etc. This is</p>
</dd>
</dl>
<p><code> enabled when building &quot;unregisterised&quot; code, which is controlled by the </code></p>
<pre><code>GhcUnregisterised</code></pre>
<p>build option.</p>
<p><code> Typically this is necessary when building GHC on a platform for which there is no native code generator</code><br />
<code> and LLVM does not have a GHC calling convention.</code></p>
<p>;</p>
<pre><code>USE_MINIINTERPRETER</code></pre>
<dl>

<dd>Enables the use of the RTS &quot;mini-interpreter&quot;, which simulates tail-calls. Again, this is enabled by
</dd>
</dl>
<pre><code>GhcUnregisterised</code></pre>
<p>in the build system.</p>
<p>;</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<dl>

<dd>Controls whether the info table is placed directly before the entry code for a closure or return continuation.
</dd>
</dl>
<p><code> This is normally turned on if the platform supports it, but is turned off by </code></p>
<pre><code>GhcUnregisterised</code></pre>
<p>.</p>
<h1 id="contracts-for-haskell">Contracts for Haskell</h1>
<h2 id="involved">Involved</h2>
<ul>
<li>Simon Peyton-Jones</li>
<li>Dimitrios Vytiniotis</li>
<li>Koen Claessen</li>
<li>Charles-Pierre Astolfi</li>
</ul>
<h2 id="overview-1">Overview</h2>
<p>Contracts, just as types, give a specification of the arguments and return values of a function. For example we can give to head the following contract:</p>
<pre><code>head ::: {x | not (null x)} -&gt; Ok</code></pre>
<p>Where Ok means that the result of head is not an error/exception as long as the argument isn't.</p>
<p>Any Haskell boolean expression can be used in a contract, for example</p>
<pre><code>fac ::: a:Ok -&gt; {x | x &gt;= a}</code></pre>
<p>is a contract that means that for every a which is an actual integer (not an error), then fac a &gt;= a</p>
<p>We can also use a higher-order contracts:</p>
<pre><code>map ::: ({x | x &gt;= 0} -&gt; {x | x &gt; 0}) -&gt; {xs | not (null xs)} -&gt; Ok</code></pre>
<p>This contract means that if we apply map to a non-empty list with a function that takes a non-negative integer and returns an positive integer then map returns a list of values without errors.</p>
<p>For a formal introduction, one can read [1].</p>
<h2 id="the-plan">The plan</h2>
<p>Verifying that a function satisfies a given contract is obviously undecidable, but that does not mean that we can't prove anything interesting. Our plan is to translate Haskell programs to first-order logic (with equality) and then use Koen's automated theorem prover to check contract satisfaction. Given that first-order logic is only semi-decidable, the theorem prover can (and in fact does) hang when fed with contracts that are in contradiction with the function definition.</p>
<h2 id="current-status">Current status</h2>
<p>The current status is described in [3] and some code and examples can be found in [2]. Note that given it's just a prototype the input syntax is slightly different from Haskell. In the end, we should get a ghc extension for contracts.</p>
<h2 id="questions">Questions</h2>
<ul>
<li>Do we need cfness predicate anymore? It was important in the POPL paper but is still relevant?</li>
<li>UNR should be renamed to a less confusing name.</li>
<li>Hoare logic vs liquid types</li>
<li>Semantics &amp; domain theory to prove the correctness of the translation</li>
<li>Unfolding for proving contracts on recursive functions</li>
</ul>
<h2 id="references">References</h2>
<p>[1] : <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/index.htm" class="uri">http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/index.htm</a><br />
[2] : <a href="https://github.com/cpa/haskellcontracts" class="uri">https://github.com/cpa/haskellcontracts</a> and <a href="https://github.com/cpa/haskellcontracts-examples" class="uri">https://github.com/cpa/haskellcontracts-examples</a><br />
[3] : <a href="https://github.com/cpa/haskellcontracts/blob/master/draft2.pdf" class="uri">https://github.com/cpa/haskellcontracts/blob/master/draft2.pdf</a></p>
<h1 id="the-ghc-commentary-coding-style-guidelines-for-rts-c-code">The GHC Commentary: Coding Style Guidelines for RTS C code</h1>
<h2 id="comments-1">Comments</h2>
<p>These coding style guidelines are mainly intended for use in</p>
<pre><code>rts/</code></pre>
<p>and</p>
<pre><code>includes/</code></pre>
<p>. See [wiki:Commentary/CodingStyle Coding Style Guidelines] for code in</p>
<pre><code>compiler/</code></pre>
<p>.</p>
<p>These are just suggestions. They're not set in stone. Some of them are probably misguided. If you disagree with them, feel free to modify this document (and make your commit message reasonably informative) or mail someone (eg. <script type="text/javascript">
<!--
h='&#104;&#x61;&#x73;&#x6b;&#x65;&#108;&#108;&#46;&#x6f;&#114;&#x67;';a='&#64;';n='&#x67;&#108;&#x61;&#x73;&#x67;&#x6f;&#x77;&#x2d;&#104;&#x61;&#x73;&#x6b;&#x65;&#108;&#108;&#x2d;&#x75;&#x73;&#x65;&#114;&#x73;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+'&#84;&#104;&#x65;&#32;&#x47;&#72;&#x43;&#32;&#x6d;&#x61;&#x69;&#108;&#x69;&#110;&#x67;&#32;&#108;&#x69;&#x73;&#116;'+'<\/'+'a'+'>');
// -->
</script><noscript>&#84;&#104;&#x65;&#32;&#x47;&#72;&#x43;&#32;&#x6d;&#x61;&#x69;&#108;&#x69;&#110;&#x67;&#32;&#108;&#x69;&#x73;&#116;&#32;&#40;&#x67;&#108;&#x61;&#x73;&#x67;&#x6f;&#x77;&#x2d;&#104;&#x61;&#x73;&#x6b;&#x65;&#108;&#108;&#x2d;&#x75;&#x73;&#x65;&#114;&#x73;&#32;&#x61;&#116;&#32;&#104;&#x61;&#x73;&#x6b;&#x65;&#108;&#108;&#32;&#100;&#x6f;&#116;&#32;&#x6f;&#114;&#x67;&#x29;</noscript>)</p>
<h2 id="references-1">References</h2>
<p>If you haven't read them already, you might like to check the following. Where they conflict with our suggestions, they're probably right.</p>
<ul>
<li>The C99 standard. One reasonable reference is <a href="http://home.tiscalinet.ch/t_wolf/tw/c/c9x_changes.html">here</a>.</li>
</ul>
<ul>
<li>Writing Solid Code, Microsoft Press. (Highly recommended.)</li>
</ul>
<ul>
<li>Autoconf documentation. See also</li>
</ul>
<p><code>  </code><a href="http://peti.gmd.de/autoconf-archive/"><code>The</code> <code>autoconf</code> <code>macro</code> <code>archive</code></a><br />
<code>  and </code><a href="http://www.cyclic.com/cyclic-pages/autoconf.html"><code>Cyclic</code> <code>Software's</code> <code>description</code></a><code>.</code></p>
<ul>
<li><a href="http://www.cs.arizona.edu/~mccann/cstyle.html">Indian Hill C Style and Coding Standards</a></li>
</ul>
<ul>
<li><a href="http://www.cs.umd.edu/users/cml/cstyle/">A list of C programming style links</a></li>
</ul>
<ul>
<li><a href="http://www.lysator.liu.se/c/c-www.html">A very large list of C programming links</a></li>
</ul>
<h2 id="portability-issues">Portability issues</h2>
<h3 id="which-c-standard">Which C Standard?</h3>
<p>We try to stick to C99 where possible. We use the following C99 features relative to C89, some of which were previously GCC extensions (possibly with different syntax):</p>
<ul>
<li>Variable length arrays as the last field of a struct. GCC has</li>
</ul>
<p><code>  a similar extension, but the syntax is slightly different: in GCC you</code><br />
<code>  would declare the array as </code></p>
<pre><code>arr[0]</code></pre>
<p>, whereas in C99 it is</p>
<p><code>  declared as </code></p>
<pre><code>arr[]</code></pre>
<p>.</p>
<ul>
<li>Inline annotations on functions (see later)</li>
</ul>
<ul>
<li>Labeled elements in initialisers. Again, GCC has a slightly</li>
</ul>
<p><code>  different syntax from C99 here, and we stick with the GCC syntax</code><br />
<code>  until GCC implements the C99 proposal.</code></p>
<ul>
<li>C++-style comments. These are part of the C99 standard, and we</li>
</ul>
<p><code>  prefer to use them whenever possible.</code></p>
<p>In addition we use ANSI-C-style function declarations and prototypes exclusively. Every function should have a prototype; static function prototypes may be placed near the top of the file in which they are declared, and external prototypes are usually placed in a header file with the same basename as the source file (although there are exceptions to this rule, particularly when several source files together implement a subsystem which is described by a single external header file).</p>
<ul>
<li>We use the following GCC extensions, but surround them with
<pre><code>#ifdef&lt;ul&gt;GNUC&lt;/ul&gt;</code></pre>
<dl>

<dd>
</dd>
</dl>
<ul>
<li>Function attributes (mostly just
<pre><code>no_return</code></pre>
<p>and</p>
<pre><code>unused</code></pre>
<p>)</p></li>
<li>Inline assembly.</li>
</ul></li>
</ul>
<h3 id="other-portability-conventions">Other portability conventions</h3>
<ul>
<li>char can be signed or unsigned - always say which you mean</li>
</ul>
<ul>
<li>Our POSIX policy: try to write code that only uses POSIX</li>
</ul>
<p><code>  (</code><a href="http://www.opengroup.org/onlinepubs/009695399/toc.htm"><code>IEEE</code> <code>Std</code> <code>1003.1</code></a><code>)</code><br />
<code>  interfaces and APIs.  We used to define </code></p>
<pre><code>POSIX_SOURCE</code></pre>
<p>by</p>
<p><code>  default, but found that this caused more problems than it solved, so</code><br />
<code>  now we require any code that is POSIX-compliant to explicitly say so</code><br />
<code>  by having </code></p>
<pre><code>#include &quot;PosixSource.h&quot;</code></pre>
<p>at the top. Try to do this</p>
<p><code>  whenever possible.</code></p>
<ul>
<li>Some architectures have memory alignment constraints. Others don't</li>
</ul>
<p><code>  have any constraints but go faster if you align things.  These</code><br />
<code>  macros (from </code></p>
<pre><code>ghcconfig.h</code></pre>
<p>) tell you which alignment to use</p>
<pre><code>      /* minimum alignment of unsigned int */
      #define ALIGNMENT_UNSIGNED_INT 4
    
      /* minimum alignment of long */
      #define ALIGNMENT_LONG 4
    
      /* minimum alignment of float */
      #define ALIGNMENT_FLOAT 4
    
      /* minimum alignment of double */
      #define ALIGNMENT_DOUBLE 4</code></pre>
<ul>
<li>Use
<pre><code>StgInt</code></pre>
<p>,</p>
<pre><code>StgWord</code></pre>
<p>and</p>
<pre><code>StgPtr</code></pre>
<p>when</p></li>
</ul>
<p><code>  reading/writing ints and ptrs to the stack or heap.  Note that, by</code><br />
<code>  definition, </code></p>
<pre><code>StgInt</code></pre>
<p>,</p>
<pre><code>StgWord</code></pre>
<p>and</p>
<pre><code>StgPtr</code></pre>
<p>are the</p>
<p><code>  same size and have the same alignment constraints even if</code><br />
<code>  </code></p>
<pre><code>sizeof(int) &lt;nowiki&gt;=&lt;/nowiki&gt; sizeof(ptr)</code></pre>
<p>on that platform.</p>
<ul>
<li>Use
<pre><code>StgInt8</code></pre>
<p>,</p>
<pre><code>StgInt16</code></pre>
<p>, etc when you need a certain</p></li>
</ul>
<p><code>  minimum number of bits in a type.  Use </code></p>
<pre><code>int</code></pre>
<p>and</p>
<pre><code>nat</code></pre>
<p>when</p>
<p><code>  there's no particular constraint.  ANSI C only guarantees that ints</code><br />
<code>  are at least 16 bits but within GHC we assume they are 32 bits.</code></p>
<ul>
<li>Use
<pre><code>StgFloat</code></pre>
<p>and</p>
<pre><code>StgDouble</code></pre>
<p>for floating point values</p></li>
</ul>
<p><code>  which will go on/have come from the stack or heap.  Note that</code><br />
<code>  </code></p>
<pre><code>StgDouble</code></pre>
<p>may occupy more than one</p>
<pre><code>StgWord</code></pre>
<p>, but it will</p>
<p><code>  always be a whole number multiple.</code></p>
<ul>
<li>Use
<pre><code>PK_FLT(addr)</code></pre>
<p>,</p>
<pre><code>PK_DBL(addr)</code></pre>
<p>to read</p>
<pre><code>StgFloat</code></pre></li>
</ul>
<p><code>  and </code></p>
<pre><code>StgDouble</code></pre>
<p>values from the stack/heap, and</p>
<pre><code>ASSIGN_FLT(val,addr)</code></pre>
<p>/</p>
<pre><code>ASSIGN_DBL(val,addr)</code></pre>
<p>to assign</p>
<p><code>  StgFloat/StgDouble values to heap/stack locations.  These macros</code><br />
<code>  take care of alignment restrictions.</code></p>
<ul>
<li>Heap/Stack locations are always
<pre><code>StgWord</code></pre>
<p>aligned; the</p></li>
</ul>
<p><code>  alignment requirements of an </code></p>
<pre><code>StgDouble</code></pre>
<p>may be more than that</p>
<p><code>  of </code></p>
<pre><code>StgWord</code></pre>
<p>, but we don't pad misaligned</p>
<pre><code>StgDoubles</code></pre>
<p><code>  because doing so would be too much hassle (see </code></p>
<pre><code>PK_DBL</code></pre>
<p>&amp; co</p>
<p><code>  above).</code></p>
<ul>
<li>Avoid conditional code like this:</li>
</ul>
<pre><code>  #ifdef solaris_host_OS
  // do something solaris specific
  #endif</code></pre>
<p><code> Instead, add an appropriate test to the configure.ac script and use</code><br />
<code> the result of that test instead.</code></p>
<pre><code>  #ifdef HAVE_BSD_H
  // use a BSD library
  #endif</code></pre>
<p><code> The problem is that things change from one version of an OS to</code><br />
<code> another - things get added, things get deleted, things get broken,</code><br />
<code> some things are optional extras.  Using &quot;feature tests&quot; instead of</code><br />
<code> &quot;system tests&quot; makes things a lot less brittle.  Things also tend to</code><br />
<code> get documented better.</code></p>
<h2 id="debuggingrobustness-tricks">Debugging/robustness tricks</h2>
<p>Anyone who has tried to debug a garbage collector or code generator will tell you: &quot;If a program is going to crash, it should crash as soon, as noisily and as often as possible.&quot; There's nothing worse than trying to find a bug which only shows up when running GHC on itself and doesn't manifest itself until 10 seconds after the actual cause of the problem.</p>
<p>We put all our debugging code inside</p>
<pre><code>#ifdef DEBUG</code></pre>
<p>. The general policy is we don't ship code with debugging checks and assertions in it, but we do run with those checks in place when developing and testing. Anything inside</p>
<pre><code>#ifdef DEBUG</code></pre>
<p>should not slow down the code by more than a factor of 2.</p>
<p>We also have more expensive &quot;sanity checking&quot; code for hardcore debugging - this can slow down the code by a large factor, but is only enabled on demand by a command-line flag. General sanity checking in the RTS is currently enabled with the</p>
<pre><code>-DS</code></pre>
<p>RTS flag.</p>
<p>There are a number of RTS flags which control debugging output and sanity checking in various parts of the system when</p>
<pre><code>DEBUG</code></pre>
<p>is defined. For example, to get the scheduler to be verbose about what it is doing, you would say</p>
<pre><code>+RTS -Ds -RTS</code></pre>
<p>. See</p>
<pre><code>includes/RtsFlags.h</code></pre>
<p>and</p>
<pre><code>rts/RtsFlags.c</code></pre>
<p>for the full set of debugging flags. To check one of these flags in the code, write:</p>
<pre><code>  IF_DEBUG(gc, fprintf(stderr, &quot;...&quot;));</code></pre>
<p>would check the</p>
<pre><code>gc</code></pre>
<p>flag before generating the output (and the code is removed altogether if</p>
<pre><code>DEBUG</code></pre>
<p>is not defined).</p>
<p>All debugging output should go to</p>
<pre><code>stderr</code></pre>
<p>.</p>
<p>Particular guidelines for writing robust code:</p>
<ul>
<li>Use assertions. Use lots of assertions. If you write a comment</li>
</ul>
<p><code>  that says &quot;takes a +ve number&quot; add an assertion.  If you're casting</code><br />
<code>  an int to a nat, add an assertion.  If you're casting an int to a</code><br />
<code>  char, add an assertion.  We use the </code></p>
<pre><code>ASSERT</code></pre>
<p>macro for writing</p>
<p><code>  assertions; it goes away when </code></p>
<pre><code>DEBUG</code></pre>
<p>is not defined.</p>
<ul>
<li>Write special debugging code to check the integrity of your data</li>
</ul>
<p><code>  structures.  (Most of the runtime checking code is in</code><br />
<code>  </code></p>
<pre><code>rts/Sanity.c</code></pre>
<p>) Add extra assertions which call this code at</p>
<p><code>  the start and end of any code that operates on your data</code><br />
<code>  structures.</code></p>
<ul>
<li>When you find a hard-to-spot bug, try to think of some assertions,</li>
</ul>
<p><code>  sanity checks or whatever that would have made the bug easier to</code><br />
<code>  find.</code></p>
<ul>
<li>When defining an enumeration, it's a good idea not to use 0 for</li>
</ul>
<p><code>  normal values.  Instead, make 0 raise an internal error.  The idea</code><br />
<code>  here is to make it easier to detect pointer-related errors on the</code><br />
<code>  assumption that random pointers are more likely to point to a 0</code><br />
<code>  than to anything else.</code></p>
<pre><code>typedef enum
* Instruction 0 raises an internal error */
* irrefutable pattern match failed! */
* user level error */

    ...</code></pre>
<ul>
<li>Use
<pre><code>#warning</code></pre>
<p>or</p>
<pre><code>#error</code></pre>
<p>whenever you write a piece of</p></li>
</ul>
<p><code>  incomplete/broken code.</code></p>
<ul>
<li>When testing, try to make infrequent things happen often. For</li>
</ul>
<p><code>  example, make a context switch/gc/etc happen every time a context</code><br />
<code>  switch/gc/etc can happen.  The system will run like a pig but it'll</code><br />
<code>  catch a lot of bugs.</code></p>
<h2 id="syntactic-details">Syntactic details</h2>
<ul>
<li>Please keep to 80 columns: the line has to be drawn somewhere, and</li>
</ul>
<p><code>  by keeping it to 80 columns we can ensure that code looks OK on</code><br />
<code>  everyone's screen.  Long lines are hard to read, and a sign that</code><br />
<code>  the code needs to be restructured anyway.</code></p>
<ul>
<li>An indentation width of 4 is preferred (don't use actual tab characters, use spaces).</li>
</ul>
<ul>
<li><strong>Important:</strong> Put &quot;redundant&quot; braces or parens in your code.</li>
</ul>
<p><code>   Omitting braces and parens leads to very hard to spot bugs -</code><br />
<code>   especially if you use macros (and you might have noticed that GHC</code><br />
<code>   does this a lot)</code></p>
<p><code> In particular, put braces round the body of for loops, while loops,</code><br />
<code> if statements, etc.  even if they &quot;aren't needed&quot; because it's</code><br />
<code> really hard to find the resulting bug if you mess up.  Indent them</code><br />
<code> any way you like but put them in there!</code></p>
<ul>
<li>When defining a macro, always put parens round args - just in case.</li>
</ul>
<p><code>   For example, write:</code></p>
<pre><code>  #define add(x,y) ((x)+(y))</code></pre>
<p><code> instead of</code></p>
<pre><code>  #define add(x,y) x+y</code></pre>
<ul>
<li>Don't declare and initialize variables at the same time.</li>
</ul>
<p><code>  Separating the declaration and initialization takes more lines, but</code><br />
<code>  make the code clearer.</code></p>
<ul>
<li>Don't define macros that expand to a list of statements. You could</li>
</ul>
<p><code>  just use braces as in:</code></p>
<pre><code>  #define ASSIGN_CC_ID(ccID)              \
        {                                 \
        ccID = CC_ID;                     \
        CC_ID++;                          \
        }</code></pre>
<p><code> (but it's usually better to use an inline function instead - see above).</code></p>
<ul>
<li>Don't even write macros that expand to 0 statements - they can mess</li>
</ul>
<p><code>  you up as well.  Use the </code></p>
<pre><code>doNothing</code></pre>
<p>macro instead.</p>
<pre><code>  #define doNothing() do { } while (0)</code></pre>
<ul>
<li>This code</li>
</ul>
<pre><code>int* p, q;</code></pre>
<p><code> looks like it declares two pointers but, in fact, only p is a pointer.</code><br />
<code> It's safer to write this:</code></p>
<pre><code>int* p;
int* q;</code></pre>
<p><code> You could also write this:</code></p>
<pre><code>int *p, *q;</code></pre>
<p><code> but it is preferrable to split the declarations.</code></p>
<ul>
<li>Try to use ANSI C's enum feature when defining lists of constants</li>
</ul>
<p><code>  of the same type.  Among other benefits, you'll notice that gdb</code><br />
<code>  uses the name instead of its (usually inscrutable) number when</code><br />
<code>  printing values with enum types and gdb will let you use the name</code><br />
<code>  in expressions you type.</code></p>
<p><code> Examples:</code></p>
<pre><code>* N.B. Used as indexes into arrays */
     NO_HEAP_PROFILING,     
     HEAP_BY_CC,        
     HEAP_BY_MOD,       
     HEAP_BY_GRP,       
     HEAP_BY_DESCR,     
     HEAP_BY_TYPE,      
     HEAP_BY_TIME       
    } ProfilingFlags;</code></pre>
<p><code> instead of</code></p>
<pre><code>* N.B. Used as indexes into arrays */
    # define HEAP_BY_CC     1
    # define HEAP_BY_MOD    2
    # define HEAP_BY_GRP    3
    # define HEAP_BY_DESCR  4
    # define HEAP_BY_TYPE   5
    # define HEAP_BY_TIME   6</code></pre>
<p><code> and </code></p>
<pre><code>    typedef enum {
     CCchar    = &#39;C&#39;,
     MODchar   = &#39;M&#39;,
     GRPchar   = &#39;G&#39;,
     DESCRchar = &#39;D&#39;,
     TYPEchar  = &#39;Y&#39;,
     TIMEchar  = &#39;T&#39;
    } ProfilingTag;</code></pre>
<p><code> instead of</code></p>
<pre><code>    # define CCchar    &#39;C&#39;
    # define MODchar   &#39;M&#39;
    # define GRPchar   &#39;G&#39;
    # define DESCRchar &#39;D&#39;
    # define TYPEchar  &#39;Y&#39;
    # define TIMEchar  &#39;T&#39;</code></pre>
<ul>
<li>When commenting out large chunks of code, use
<pre><code>#ifdef 0 ... #endif</code></pre>
<ul>
<li>... */
</pre>
<p>because C doesn't have</p></li>
</ul></li>
</ul>
<p><code>  nested comments.</code></p>
<ul>
<li>When declaring a typedef for a struct, give the struct a name as</li>
</ul>
<p><code>  well, so that other headers can forward-reference the struct name</code><br />
<code>  and it becomes possible to have opaque pointers to the struct.  Our</code><br />
<code>  convention is to name the struct the same as the typedef, but add a</code><br />
<code>  leading underscore.  For example:</code></p>
<pre><code>  typedef struct _Foo {
    ...
  } Foo;</code></pre>
<ul>
<li>Do not use
<pre><code>&lt;nowiki&gt;</code></pre>
<p></nowiki> instead of explicit comparison against</p>
<pre><code>NULL</code></pre></li>
</ul>
<p><code>  or </code></p>
<pre><code>&#39;\0&#39;</code></pre>
<dl>
<dt>the latter is much clearer.</dt>

</dl>
<ul>
<li>Please write comments in English. Especially avoid Klingon.</li>
</ul>
<h2 id="inline-functions">Inline functions</h2>
<p>Use inline functions instead of macros if possible - they're a lot less tricky to get right and don't suffer from the usual problems of side effects, evaluation order, multiple evaluation, etc.</p>
<ul>
<li>Inline functions get the naming issue right. E.g. they</li>
</ul>
<p><code>  can have local variables which (in an expression context)</code><br />
<code>  macros can't.</code></p>
<ul>
<li>Inline functions have call-by-value semantics whereas macros are</li>
</ul>
<p><code>  call-by-name.  You can be bitten by duplicated computation if you</code><br />
<code>  aren't careful.</code></p>
<ul>
<li>You can use inline functions from inside gdb if you compile with</li>
</ul>
<p><code>  -O0 or -fkeep-inline-functions.  If you use macros, you'd better know</code><br />
<code>  what they expand to.</code></p>
<p><code> However, note that macros can serve as both l-values and r-values and</code><br />
<code> can be &quot;polymorphic&quot; as these examples show:</code></p>
<pre><code>  // you can use this as an l-value or an r-value
* (cl))-&gt;header.profInfo)

  // polymorphic case
  // but note that min(min(1,2),3) does 3 comparisons instead of 2!
  #define min(x,y) (((x)&lt;=(y)) ? (x) : (y))</code></pre>
<p>There are three macros to do inline portably. Don't use</p>
<pre><code>inline</code></pre>
<p>directly, use these instead:</p>
<pre><code>INLINE_HEADER</code></pre>
<p><code> An inline function in a header file.  This is just like a macro.  We never emit</code><br />
<code> a standalone copy of the function, so it </code><em><code>must</code></em><code> be inlined everywhere.</code></p>
<pre><code>STATIC_INLINE</code></pre>
<p><code> An inline function in a C source file.  Again, it is always inlined, and we never</code><br />
<code> emit a standalone copy. </code></p>
<pre><code>EXTERN_INLINE</code></pre>
<p><code> A function which is optionally inlined.  The C compiler is told to inline if possible,</code><br />
<code> but we also generated a standalone copy of the function just in case (see source:rts/Inlines.c).</code></p>
<h2 id="source-control-issues">Source-control issues</h2>
<ul>
<li>Don't be tempted to re-indent or re-organise large chunks of code -</li>
</ul>
<p><code>  it generates large diffs in which it's hard to see whether anything</code><br />
<code>  else was changed, and causes extra conflicts when moving patches to</code><br />
<code>  another branch.</code><br />
<code>  </code><br />
<br />
<code>   If you must re-indent or re-organise, don't include any functional</code><br />
<code>  changes that commit and give advance warning that you're about to do</code><br />
<code>  it in case anyone else is changing that file.  For more details on</code><br />
<code>  source control conventions, see [wiki:WorkingConventions/Git].</code></p>
<h1 id="copying-gc">Copying GC</h1>
<p>GHC uses copying GC by default, while it requires more memory than [wiki:Commentary/Rts/Storage/GC/Compaction mark/compact], it is faster.</p>
<p>The basic copying scheme is <a href="http://en.wikipedia.org/wiki/Cheney%27s_algorithm">Cheney's Algorithm</a>. Starting from the [wiki:Commentary/Rts/Storage/GC/Roots roots], we visit each live object:</p>
<ul>
<li>The object is <em>evacuated</em> (copied) to its destination generation. The destination is given by
<pre><code>bd-&gt;dest` pointer in the `bdescr</code></pre>
<p>of the</p></li>
</ul>
<p><code>  block in which it lives; typically an object is promoted to the next highest generation, but the basic policy is affected by  [wiki:Commentary/Rts/Storage/GC/Aging aging] and [wiki:Commentary/Rts/Storage/GC/EagerPromotion eager promotion].</code></p>
<ul>
<li>The header word of the original object is replaced by a <em>forwarding pointer</em>. The forwarding pointer is just the pointer to the new copy, with the least significant bit set to 1 so that forwarding pointers can be distinguished from info table pointers.</li>
</ul>
<ul>
<li>We scan objects that have been evacuated, and <em>scavenge</em> each one. Scavenging involves evacuating each of the pointers</li>
</ul>
<p><code>  in the object, replacing each pointer with a pointer to the evacuated copy.</code></p>
<ul>
<li>When there are no more objects to be scavenged, the algorithm is complete. The memory containing the evacuated objects is retained, all the memory containing the old objects and forwarding pointers is discarded.</li>
</ul>
<p>Evacuation is implemented in the file <a href="GhcFile(rts/sm/Evac.c)" class="uri" title="wikilink">GhcFile(rts/sm/Evac.c)</a>.<a href="br" class="uri" title="wikilink">br</a> Scavenging is implemented in the file <a href="GhcFile(rts/sm/Scav.c)" class="uri" title="wikilink">GhcFile(rts/sm/Scav.c)</a>.<a href="br" class="uri" title="wikilink">br</a></p>
<p>The principle APIs are</p>
<p>;</p>
<pre><code>void evacuate (StgClosure **p)</code></pre>
<dl>

<dd>which evacuates the object pointed to by the pointer at
<pre><code>p`, and updates `p</code></pre>
<p>to point to the new location.</p>
</dd>
</dl>
<p>;</p>
<pre><code>void scavenge_block (bdescr *bd)</code></pre>
<dl>

<dd>which scavenges all the objects in the block
<pre><code>bd` (objects between `bd-&gt;u.scan` and `bd-&gt;free</code></pre>
<p>are assumed to</p>
</dd>
</dl>
<p><code>  be unscavenged so far).</code></p>
<p>= Core-to-Core optimization pipeline</p>
<p>After the source program has been [wiki:Commentary/Compiler/TypeChecker typechecked] it is desugared into GHC's intermediate language [wiki:Commentary/Compiler/CoreSynType Core]. The Core representation of a program is then optimized by a series of correctness preserving Core-to-Core passes. This page describes the overall structure of the Core-to-Core optimization pipeline. Detailed descriptions of optimizations are available [wiki:Commentary/Compiler/Core2CorePipeline#Furtherreading in the published papers]. An overview of the whole compiler pipeline is available [wiki:Commentary/Compiler/HscMain here].</p>
<p>== Optimizations during desugaring</p>
<p>At the end of desugaring we run the</p>
<pre><code>simpleOptPgm</code></pre>
<p>function that performs some simple optimizations: eliminating dead bindings, and inlining non-recursive bindings that are used only once or where the RHS is trivial. The rest of Core optimisations is performed by the Core-to-Core pipeline.</p>
<p>== The pipeline</p>
<p>The structure of the Core-to-Core pipeline is determined in the</p>
<pre><code>getCoreToDo` function in the [[GhcFile(compiler/simplCore/SimplCore.lhs)]] module. Below is an ordered list of performed optimisations. These are enabled by default with `-O1` and `-O2</code></pre>
<p>unless the description says a specific flag is required. The simplifier, which the pipeline description below often refers to, is described in detail in [wiki:Commentary/Compiler/Core2CorePipeline#Simplifier the next section].</p>
<ul>
<li><strong>Static Argument Transformation</strong>: tries to remove redundant arguments to recursive calls, turning them into free variables in those calls. Only enabled with
<pre><code>-fstatic-argument-transformation</code></pre>
<p>. If run this pass is preceded with a &quot;gentle&quot; run of the simplifier.</p></li>
</ul>
<ul>
<li><strong>Vectorisation</strong>: run the [wiki:DataParallel Data Parallel Haskell] [wiki:DataParallel/Vectorisation vectoriser]. Only enabled with
<pre><code>-fvectorise`. TODO: does `-Odph` imply `fvectorise</code></pre>
<p>?</p></li>
</ul>
<ul>
<li><strong>Simplifier, gentle run</strong></li>
</ul>
<ul>
<li><strong>Specialisation</strong>: specialisation attempts to eliminate overloading. More details can be found in the comments in <a href="GhcFile(compiler/specialise/Specialise.lhs)" class="uri" title="wikilink">GhcFile(compiler/specialise/Specialise.lhs)</a>.</li>
</ul>
<ul>
<li><strong>Full laziness, 1st pass</strong>: floats let-bindings outside of lambdas. This pass includes annotating bindings with level information and then running the float-out pass. In this first pass of the full laziness we don't float partial applications and bindings that contain free variables - this will be done by the second pass later in the pipeline. See &quot;Further Reading&quot; section below for pointers where to find the description of the full laziness algorithm.</li>
</ul>
<ul>
<li><strong>Float in, 1st pass</strong>: the opposite of full laziness, this pass floats let-bindings as close to their use sites as possible. It will not undo the full laziness by sinking bindings inside a lambda, unless the lambda is one-shot. At this stage we have not yet run the demand analysis, so we only have demand information for things that we imported.</li>
</ul>
<ul>
<li><strong>Simplifier, main run</strong>: run the main passes of the simplifier (phases 2, 1 and 0). Phase 0 is run with at least 3 iterations.</li>
</ul>
<ul>
<li><strong>Call arity</strong>: attempts to eta-expand local functions based on how they are used. If run, this pass is followed by a 0 phase of the simplifier. See Notes in <a href="GhcFile(compiler/simplCore/CallArity.hs)" class="uri" title="wikilink">GhcFile(compiler/simplCore/CallArity.hs)</a> and the relevant paper.</li>
</ul>
<ul>
<li><strong>Demand analysis, 1st pass</strong> (a.k.a. strictness analysis): runs the demand analyser followed by worker-wrapper transformation and 0 phase of the simplifier. This pass tries to determine if some expressions are certain to be used and whether they will be used once or many times (cardinality analysis). We currently don't have means of saying that a binding is certain to be used many times. We can only determine that it is certain to be one-shot (ie. used only once) or probable to be one shot. Demand analysis pass only annotates Core with strictness information. This information is later used by worker/wrapper pass to perform transformations. CPR analysis is also done during demand analysis.</li>
</ul>
<ul>
<li><strong>Full laziness, 2nd pass</strong>: another full-laziness pass. This time partial applications and functions with free variables are floated out.</li>
</ul>
<ul>
<li><strong>Common Sub-expression-elimination</strong>: eliminates expressions that are identical.</li>
</ul>
<ul>
<li><strong>Float in, 2nd pass</strong></li>
</ul>
<ul>
<li><strong>Check rules, 1st pass</strong>: this pass is not for optimisation but for troubleshooting the rules. It is only enabled with
<pre><code>-frule-check</code></pre>
<p>flag that accepts a string pattern. This pass looks for rules beginning with that string pattern that could have fired but didn't and prints them to stdout.</p></li>
</ul>
<ul>
<li><strong>Liberate case</strong>: unrolls recursive functions once in their own RHS, to avoid repeated case analysis of free variables. It's a bit like the call-pattern specialisation but for free variables rather than arguments. Followed by a phase 0 simplifier run. Only enabled with
<pre><code>-fliberate-case</code></pre>
<p>flag.</p></li>
</ul>
<ul>
<li><strong>Call-pattern specialisation</strong>: Only enabled with
<pre><code>-fspec-constr</code></pre>
<p>flag. TODO: explain what it does.</p></li>
</ul>
<ul>
<li><strong>Check rules, 2nd pass</strong></li>
</ul>
<ul>
<li><strong>Simplifier, final</strong>: final 0 phase of the simplifier.</li>
</ul>
<ul>
<li><strong>Damand analysis, 2nd pass</strong> (a.k.a. late demand analysis): this pass consists of demand analysis followed by worker-wrapper transformation and phase 0 of the simplifier. The reason for this pass is that some opportunities for discovering strictness were not visible earlier; and optimisations like call-pattern specialisation can create functions with unused arguments which are eliminated by late demand analysis. Only run with
<pre><code>-flate-dmd-anal</code></pre>
<p>. FIXME: but the cardinality paper says something else, namely that the late pass is meant to detect single entry thunks. Is it still the case in the current implementation?</p></li>
</ul>
<ul>
<li><strong>Check rules, 3rd pass</strong></li>
</ul>
<p>The plugin mechanism allows to modify the above pipeline dynamically.</p>
<p>== Simplifier</p>
<p>Simplifier is the workhorse of the Core-to-Core optimisation pipeline. It performs all the local transformations: (TODO: this list is most likely not comprehensive)</p>
<p><code>- constant folding</code><br />
<code>- applying the rewrite rules</code><br />
<code>- inlining</code><br />
<code>- case of case</code><br />
<code>- case of known constructor</code><br />
<code>- eta expansion and eta reduction</code><br />
<code>- combining adjacent casts</code><br />
<code>- pushing a cast out of the way of an application e.g. </code></p>
<p>Video: <a href="http://www.youtube.com/watch?v=EQA69dvkQIk&amp;list=PLBkRCigjPwyeCSD_DFxpd246YIF7_RDDI">GHC Core language</a> (14'04&quot;)</p>
<p>= The</p>
<pre><code>Core</code></pre>
<p>type =</p>
<p>The Core language is GHC's central data types. Core is a very small, explicitly-typed, variant of System F. The exact variant is called [wiki:Commentary/Compiler/FC System FC], which embodies equality constraints and coercions.</p>
<p>The</p>
<pre><code>CoreSyn</code></pre>
<p>type, and the functions that operate over it, gets an entire directory <a href="GhcFile(compiler/coreSyn)" class="uri" title="wikilink">GhcFile(compiler/coreSyn)</a>:</p>
<ul>
<li><a href="GhcFile(compiler/coreSyn/CoreSyn.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreSyn.hs)</a>: the data type itself.</li>
</ul>
<ul>
<li><a href="GhcFile(compiler/coreSyn/PprCore.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/PprCore.hs)</a>: pretty-printing.</li>
<li><a href="GhcFile(compiler/coreSyn/CoreFVs.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreFVs.hs)</a>: finding free variables.</li>
<li><a href="GhcFile(compiler/coreSyn/CoreSubst.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreSubst.hs)</a>: substitution.</li>
<li><a href="GhcFile(compiler/coreSyn/CoreUtils.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreUtils.hs)</a>: a variety of other useful functions over Core.</li>
</ul>
<ul>
<li><a href="GhcFile(compiler/coreSyn/CoreUnfold.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreUnfold.hs)</a>: dealing with &quot;unfoldings&quot;.</li>
</ul>
<ul>
<li><a href="GhcFile(compiler/coreSyn/CoreLint.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreLint.hs)</a>: type-check the Core program. This is an incredibly-valuable consistency check, enabled by the flag
<pre><code>-dcore-lint</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><a href="GhcFile(compiler/coreSyn/CoreTidy.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreTidy.hs)</a>: part of the [wiki:Commentary/Compiler/HscMain the CoreTidy pass] (the rest is in <a href="GhcFile(compiler/main/TidyPgm.hs)" class="uri" title="wikilink">GhcFile(compiler/main/TidyPgm.hs)</a>).</li>
<li><a href="GhcFile(compiler/coreSyn/CorePrep.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CorePrep.hs)</a>: [wiki:Commentary/Compiler/HscMain the CorePrep pass]</li>
</ul>
<p>Here is the entire Core type <a href="GhcFile(compiler/coreSyn/CoreSyn.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreSyn.hs)</a>:</p>
<pre><code>type CoreExpr = Expr Var

data Expr b -- &quot;b&quot; for the type of binders, 
  = Var   Id
  | Lit   Literal
  | App   (Expr b) (Arg b)
  | Lam   b (Expr b)
  | Let   (Bind b) (Expr b)
  | Case  (Expr b) b Type [Alt b]
  | Cast  (Expr b) Coercion
  | Tick  (Tickish Id) (Expr b)
  | Type  Type

type Arg b = Expr b
type Alt b = (AltCon, [b], Expr b)

data AltCon = DataAlt DataCon | LitAlt  Literal | DEFAULT

data Bind b = NonRec b (Expr b) | Rec [(b, (Expr b))]</code></pre>
<p>That's it. All of Haskell gets compiled through this tiny core.</p>
<pre><code>Expr</code></pre>
<p>is parameterised over the type of its <em>binders</em>,</p>
<pre><code>b</code></pre>
<p>. This facility is used only rarely, and always temporarily; for example, the let-floater</p>
<pre><code>SetLevels</code></pre>
<p>pass attaches a binding level to every binder. By far the most important type is</p>
<pre><code>CoreExpr</code></pre>
<p>, which is</p>
<pre><code>Expr</code></pre>
<p>with</p>
<pre><code>Var</code></pre>
<p>binders. If you want to learn more about such AST-parametrization, I encourage you to read a blog post about it: <a href="http://blog.ezyang.com/2013/05/the-ast-typing-problem" class="uri">http://blog.ezyang.com/2013/05/the-ast-typing-problem</a> .</p>
<p>Binder is used (as the name suggest) to bind a variable to an expression. The</p>
<pre><code>Expr</code></pre>
<p>data type is parametrized by the binder type. The most common one is the</p>
<pre><code>type CoreBndr = Var</code></pre>
<p>where</p>
<pre><code>Var</code></pre>
<p>comes from <a href="GhcFile(compiler/basicTypes/Var.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Var.hs)</a>, which in fact is a</p>
<pre><code>Name</code></pre>
<p>with some extra informations attached (like types).</p>
<p>Here are some notes about the individual constructors of</p>
<pre><code>Expr</code></pre>
<p>.</p>
<ul>
<li><pre><code>Var</code></pre>
<p>represents variables. The</p>
<pre><code>Id</code></pre>
<p>it contains is essentially an [wiki:Commentary/Compiler/RdrNameType#TheOccNametype OccName] plus a</p>
<pre><code>Type</code></pre>
<p>; however, equality</p>
<pre><code>(==)</code></pre>
<p>on</p>
<pre><code>Id</code></pre>
<p>s is based only on their</p>
<pre><code>OccName</code></pre>
<p>'s, so ''two</p>
<pre><code>Var</code></pre>
<p>s with different types may be</p>
<pre><code>(==)</code></pre>
<p>-equal''.</p></li>
</ul>
<ul>
<li><pre><code>Lam</code></pre>
<p>is used for both term and type abstraction (small and big lambdas).</p></li>
</ul>
<ul>
<li><pre><code>Type</code></pre>
<p>appears only in type-argument positions (e.g.</p>
<pre><code>App (Var f) (Type ty)</code></pre>
<p>). To emphasise this, the type synonym</p>
<pre><code>Arg</code></pre>
<p>is used as documentation when we expect that a</p>
<pre><code>Type</code></pre>
<p>constructor may show up. Anything not called</p>
<pre><code>Arg</code></pre>
<p>should not use a</p>
<pre><code>Type</code></pre>
<p>constructor. Additional GHC Core uses so called type-lambdas, they are like lambdas, but instead of taking a real argument, they take a type instead. You should not confuse them with TypeFamilies, because type-lambdas are working on a value level, while type families are functions on the type level. The simplies example for a type-lambda usage is a polymorphic one:</p>
<pre><code>\x -&gt; x</code></pre>
<p>. It will be represented in Core as</p>
<pre><code>A.id = \ (@ t_aeK) (x_aeG :: t_aeK) -&gt; x_aeG</code></pre>
<p>, where</p>
<pre><code>t_aeK</code></pre>
<p>is a *type argument*, so when specyfying the argument of</p>
<pre><code>x_aeG</code></pre>
<p>we can refer to</p>
<pre><code>t_aeK</code></pre>
<p>. This is how polymorphism is represented in Core.</p></li>
</ul>
<ul>
<li><pre><code>Let</code></pre>
<p>handles both recursive and non-recursive let-bindings; see the the two constructors for</p>
<pre><code>Bind</code></pre>
<p>. The Let constructor contains both binders as well as the resulting expression. The resulting expression is the</p>
<pre><code>e</code></pre>
<p>in expression</p>
<pre><code>let x = r in e</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>Case</code></pre>
<p>expressions need [wiki:Commentary/Compiler/CoreSynType#Caseexpressions more explanation].</p></li>
</ul>
<ul>
<li><pre><code>Cast</code></pre>
<p>is used for an [wiki:Commentary/Compiler/FC FC cast expression].</p>
<pre><code>Coercion</code></pre>
<p>is a synonym for</p>
<pre><code>Type</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>Tick</code></pre>
<p>is used to represent all the kinds of source annotation we support: profiling SCCs, HPC ticks, and GHCi breakpoints. Was named</p>
<pre><code>Note</code></pre>
<p>some time ago.</p></li>
</ul>
<h2 id="case-expressions">Case expressions</h2>
<p>Case expressions are the most complicated bit of</p>
<pre><code>Core</code></pre>
<p>. In the term</p>
<pre><code>Case scrut case_bndr res_ty alts</code></pre>
<dl>

<dd>
</dd>
</dl>
<ul>
<li><pre><code>scrut</code></pre>
<p>is the scrutinee</p></li>
<li><pre><code>case_bndr</code></pre>
<p>is the <strong>case binder</strong> (see notes below)</p></li>
<li><pre><code>res_ty</code></pre>
<p>is the type of the entire case expression (redundant once [wiki:Commentary/Compiler/FC FC] is in HEAD -- was for GADTs)</p></li>
<li><pre><code>alts</code></pre>
<p>is a list of the case alternatives</p></li>
</ul>
<p>A case expression can scrutinise</p>
<ul>
<li><strong>a data type</strong> (the alternatives are
<pre><code>DataAlt</code></pre>
<p>s), or</p></li>
<li><strong>a primitive literal type</strong> (the alternatives are
<pre><code>LitAlt</code></pre>
<p>s), or</p></li>
<li><strong>a value of any type at all</strong> (if there is one
<pre><code>DEFAULT</code></pre>
<p>alternative).</p></li>
</ul>
<p>A case expression is <strong>always strict</strong>, even if there is only one alternative, and it is</p>
<pre><code>DEFAULT</code></pre>
<p>. (This differs from Haskell) So</p>
<pre><code>case error &quot;urk&quot; of { DEFAULT -&gt; True }</code></pre>
<p>will call</p>
<pre><code>error</code></pre>
<p>, rather then returning</p>
<pre><code>True</code></pre>
<p>.</p>
<p>The</p>
<pre><code>case_bndr</code></pre>
<p>field, called the <strong>case binder</strong>, is an unusual feature of GHC's case expressions. The idea is that <em>in any right-hand side, the case binder is bound to the value of the scrutinee</em>. If the scrutinee was always atomic nothing would be gained, but real expressiveness is added when the scrutinee is not atomic. Here is a slightly contrived example:</p>
<pre><code>case (reverse xs) of y 
  Nil       -&gt; Nil
  Cons x xs -&gt; append y y</code></pre>
<p>(Here, &quot;</p>
<pre><code>y</code></pre>
<p>&quot; is the case binder; at least that is the syntax used by the Core pretty printer.) This expression evaluates</p>
<pre><code>reverse xs</code></pre>
<p>; if the result is</p>
<pre><code>Nil</code></pre>
<p>, it returns</p>
<pre><code>Nil</code></pre>
<p>, otherwise it returns the reversed list appended to itself. Since the returned value of</p>
<pre><code>reverse xs</code></pre>
<p>is present in the implementation, it makes sense to have a name for it!</p>
<p>The most common application is to model call-by-value, by using</p>
<pre><code>case</code></pre>
<p>instead of</p>
<pre><code>let</code></pre>
<p>. For example, here is how we might compile the call</p>
<pre><code>f (reverse xs)</code></pre>
<p>if we knew that</p>
<pre><code>f</code></pre>
<p>was strict:</p>
<pre><code>case (reverse xs) of y { DEFAULT -&gt; f y }</code></pre>
<p>Case expressions have several invariants</p>
<ul>
<li>The
<pre><code>res_ty</code></pre>
<p>type is the same as the type of any of the right-hand sides (up to refining unification -- coreRefineTys in <a href="GhcFile(compiler/types/Unify.hs)" class="uri" title="wikilink">GhcFile(compiler/types/Unify.hs)</a> -- in pre-[wiki:Commentary/Compiler/FC FC]).</p></li>
</ul>
<ul>
<li>If there is a
<pre><code>DEFAULT</code></pre>
<p>alternative, it must appear first. This makes finding a</p>
<pre><code>DEFAULT</code></pre>
<p>alternative easy, when it exists.</p></li>
</ul>
<ul>
<li>The remaining non-DEFAULT alternatives must appear in order of
<ul>
<li>tag, for
<pre><code>DataAlt</code></pre>
<p>s</p></li>
<li>lit, for
<pre><code>LitAlt</code></pre>
<p>s</p></li>
</ul></li>
</ul>
<p><code>This makes finding the relevant constructor easy, and makes comparison easier too.</code></p>
<ul>
<li>The list of alternatives is <strong>always exhaustive</strong>, meaning that it covers <strong>all reachable cases</strong>. Note, however, that an &quot;exhausive&quot; case does not necessarily mention all constructors:</li>
</ul>
<pre><code>data Foo = Red | Green | Blue

...case x of 
    Red   -&gt; True
    other -&gt; f (case x of 
            Green -&gt; ...
            Blue  -&gt; ... )</code></pre>
<p><code>The inner case does not need a </code></p>
<pre><code>Red</code></pre>
<p>alternative, because x can't be</p>
<pre><code>Red</code></pre>
<p>at that program point. Furthermore, GADT type-refinement might mean that some alternatives are not reachable, and hence can be discarded.</p>
<h2 id="shadowing">Shadowing</h2>
<p>One of the important things when working with Core is that variable shadowing is allowed. In other words, it is possible to come across a definition of a variable that has the same name (</p>
<pre><code>realUnique</code></pre>
<p>) as some other one that is already in scope. One of the possible ways to deal with that is to use</p>
<pre><code>Subst</code></pre>
<p>(substitution environment from <a href="GhcFile(compiler/coreSyn/CoreSubst.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreSubst.hs)</a>), which maintains the list of variables in scope and makes it possible to clone (i.e. rename) only the variables that actually capture names of some earlier ones. For some more explanations about this approach see <a href="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm">Secrets of the Glasgow Haskell Compiler inliner (JFP'02)</a> (section 4 on name capture).</p>
<h2 id="human-readable-core-generation">Human readable Core generation</h2>
<p>If you are interested in the way Core is translated into human readable form, you should check the sources for <a href="GhcFile(compiler/coreSyn/PprCore.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/PprCore.hs)</a>. It is especially usefull if you want to see how the Core data types are being build, especially when there is no Show instance defined for them.</p>
<h1 id="cps-conversion">CPS Conversion</h1>
<p>This part of the compiler is now merged in ghc-HEAD.</p>
<h2 id="overview-2">Overview</h2>
<p>This pass takes Cmm with native proceedure calls and an implicit stack and produces Cmm with only tail calls implemented as jumps and an explicit stack. In a word, it does CPS conversion. (All right, so that's two words.)</p>
<h2 id="design-aspects">Design Aspects</h2>
<ul>
<li>Proc-Point Analysis</li>
<li>Calling Conventions</li>
<li>Live Value Analysis</li>
<li>Stack Layout</li>
</ul>
<h2 id="simple-design">Simple Design</h2>
<ul>
<li>Split blocks into multiple blocks at function calls
<ul>
<li>TODO: eliminate extra jump at block ends when there is already a jump at the end of the call</li>
</ul></li>
<li>Do liveness analysis</li>
<li>Split every block into a separate function</li>
<li>Pass all live values as parameters (probably slow)
<ul>
<li>Must arrange for both the caller and callee to know argument order
<ul>
<li>Simple design: callee just chooses some order and all callers must comply</li>
</ul></li>
<li>Eventually could be passed implicitly but keeping things explicit makes things easier</li>
<li>Evantually could use a custom calling convention</li>
<li>Actual syntax is probably virtual. (I.e. in an external table, not in actual syntax because that would require changes to the type for Cmm code)
<ul>
<li>Input code:</li>
</ul></li>
</ul></li>
</ul>
<pre><code>f {
  y = 1;
  z = 2;
  x = call g(a, b); // y, z live
  return x+y+z;
}</code></pre>
<ul>
<li>Output code:</li>
</ul>
<pre><code>f {
  y = 1;
  z = 2;
  push_continuation h [y, z]; // Probably virtual
  jump g(a, b);
}

foreign &quot;ret&quot; h(x) {
  (y, z) = expand_continuation; // Probably virtual
  return x+y+z;
} </code></pre>
<ul>
<li>Save live values before a call in the continuation
<ul>
<li>Must arrange for both the caller and callee to know field order
<ul>
<li>Simple design: callee just chooses some order and all callers must comply</li>
</ul></li>
<li>Eventually needs to be optimized to reduce continuation shuffling
<ul>
<li>Can register allocation algorithms be unified with this into one framework?</li>
</ul></li>
</ul></li>
</ul>
<h2 id="to-be-worked-out">To be worked out</h2>
<ul>
<li>The continuations for
<pre><code>f</code></pre>
<p>and</p>
<pre><code>g</code></pre>
<p>are different.</p></li>
</ul>
<pre><code>if (test) {
  x = f();
} else {
  y = g();
}</code></pre>
<ul>
<li>Could make a for each that shuffles the arguments into a common format.</li>
<li>Could make one branch primary and shuffle the other to match it, but that might entail unnecessary memory writes.</li>
</ul>
<h2 id="pipeline">Pipeline</h2>
<ul>
<li>CPS
<ul>
<li>Make closures and stacks manifest</li>
<li>Makes all calls are tail calls</li>
</ul></li>
<li>Parameter Elimination
<ul>
<li>Makes calling convention explicit</li>
<li>For externally visible functions calling conventions is machine specific, but not backend specific because functions compiled from different backends must be be able to call eachother</li>
<li>For local functions calling convention can be left up to the backend because it can take advantage of register allocation.
<ul>
<li>However, the first first draft will specify the standard calling convention for all functions even local ones because:
<ul>
<li>It's simpler</li>
<li>The C code generator can't handle function parameters because of the Evil Mangler</li>
<li>The NCG doesn't yet understand parameters</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="todo">TODO</h2>
<ul>
<li>Downstream
<ul>
<li>Argument passing convention</li>
<li>Stack check
<ul>
<li>Needs some way to synchronize the branch label with the heap check</li>
</ul></li>
<li>Midstream
<ul>
<li>Support
<pre><code>switch</code></pre>
<p>(needed by rts/Apply.cmm)</p></li>
<li>More factoring and cleanup/documentation</li>
<li>Wiki document the designed choosen</li>
<li>Better stack slot selection</li>
<li>Foreign function calls</li>
<li>Garbage collector</li>
<li>Proc points
<ul>
<li>May cause new blocks</li>
<li>May cause new functions</li>
<li>Lives could be passes either on stack or in arguments</li>
</ul></li>
<li>Proc grouping of blocks</li>
</ul></li>
<li>Upstream
<ul>
<li>Have
<pre><code>codeGen</code></pre>
<p>emit C-- with functions.</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="current-pipeline">Current Pipeline</h2>
<p>===</p>
<pre><code>cmmToRawCmm</code></pre>
<p>=== The</p>
<pre><code>Cmm</code></pre>
<p>/</p>
<pre><code>parseCmmFile</code></pre>
<p>pipeline and the</p>
<pre><code>Stg</code></pre>
<p>/</p>
<pre><code>codeGen</code></pre>
<p>pipeline can each independantly use the CPS pass. However, they currently bypass it untill the CPS code becomes stablized, but they must both use the</p>
<pre><code>cmmToRawCmm</code></pre>
<p>pass. This pass converts the header on each function from a</p>
<pre><code>CmmInfo</code></pre>
<p>to a</p>
<pre><code>[CmmStatic]</code></pre>
<p>.</p>
<h2 id="non-cps-changes">Non-CPS Changes</h2>
<ul>
<li>Cmm Syntax Changes
<ul>
<li>The returns parameters of a function call must be surrounded by parenthesis.</li>
</ul></li>
</ul>
<p><code>    For example</code></p>
<pre><code>foreign &quot;C&quot; fee ();
(x) = foreign &quot;C&quot; foo ();
(x, y) = foreign &quot;C--&quot; bar ();</code></pre>
<p><code>    This is simply to avoid shift-reduce conflicts with assignment.</code><br />
<code>    Future revisions to the parser may eliminate the need for this.</code></p>
<ul>
<li>Variable declarations may are annotated to indicate</li>
</ul>
<p><code>    whether they are GC followable pointers.</code></p>
<pre><code>W_ x; // Not GC followable
&quot;ptr&quot; W_ y, z; // Both GC followable</code></pre>
<ul>
<li>The bitmap of a
<pre><code>INFO_TABLE_RET</code></pre>
<p>is now specified using</p></li>
</ul>
<p><code>    a parameter like syntax.</code></p>
<pre><code>INFO_TABLE_RET(stg_ap_v, RET_SMALL) { ... } // No args
INFO_TABLE_RET(stg_ap_d, RET_SMALL, D_ unused1) { ... } // Single double arg
INFO_TABLE_RET(stg_ap_np, RET_SMALL, W_ non_ptr, &quot;ptr&quot; W_ pointer) { ... }
  // Pointerhood indicated by &quot;ptr&quot; annotation</code></pre>
<p><code>    Note that these are not real parameters, they are the stack layout</code><br />
<code>    of the continuation.  Also, until the CPS algorithm</code><br />
<code>    gets properly hooked into the </code></p>
<pre><code>Cmm</code></pre>
<p>path the parameter names are not used.</p>
<ul>
<li>The return values of a function call may only be
<pre><code>LocalReg</code></pre>
<p>.</p></li>
</ul>
<p><code>    This is due to changes in the </code></p>
<pre><code>Cmm</code></pre>
<p>data type.</p>
<ul>
<li>Cmm Data Type Changes
<ul>
<li>The return parameters of a
<pre><code>CmmCall</code></pre>
<p>are</p>
<pre><code>LocalReg</code></pre>
<p>instead of</p>
<pre><code>CmmReg</code></pre>
<p>.</p></li>
</ul></li>
</ul>
<p><code>    This is because a </code></p>
<pre><code>GlobalReg</code></pre>
<p>doesn't have a well defined pointerhood,</p>
<p><code>    and the return values will become parameters to continuations where</code><br />
<code>    their pointerhood will be needed.</code></p>
<ul>
<li>The type of info tables is now a separate parameter to
<pre><code>GenCmmTop</code></pre>
<ul>
<li>Before</li>
</ul></li>
</ul>
<pre><code>data GenCmmTop d i
  = CmmProc [d] ...
  | CmmData Section [d]</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code>data GenCmmTop d h i
  = CmmProc h ...
  | CmmData Section [d]</code></pre>
<p><code>    This is to support using either </code></p>
<pre><code>CmmInfo</code></pre>
<p>or</p>
<pre><code>[CmmStatic]</code></pre>
<p><code>    as the header of a </code></p>
<pre><code>CmmProc</code></pre>
<p>.</p>
<ul>
<li>Before info table conversion use
<pre><code>Cmm</code></pre></li>
</ul>
<pre><code>type Cmm = GenCmmTop CmmStatic CmmInfo CmmStmt</code></pre>
<ul>
<li>After info table conversion use
<pre><code>RawCmm</code></pre></li>
</ul>
<pre><code>type RawCmm = GenCmmTop CmmStatic [CmmStatic] CmmStmt</code></pre>
<p><code>    Same for </code></p>
<pre><code>CmmTop</code></pre>
<p>and</p>
<pre><code>RawCmmTop</code></pre>
<p>.</p>
<ul>
<li>New type aliases
<pre><code>CmmActuals</code></pre>
<p>,</p>
<pre><code>CmmFormals</code></pre>
<p>and</p>
<pre><code>CmmHintFormals</code></pre>
<p>.</p></li>
</ul>
<p><code>    Respectively these are the actual parameters of a function call,</code><br />
<code>    the formal parameters of a function, and the</code><br />
<code>    return results of a function call with pointerhood annotation</code><br />
<code>    (CPS may convert these to formal parameter of the call's continuation).</code></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Changed the parameter to a
<pre><code>CmmTop</code></pre>
<p>to be</p>
<pre><code>CmmFormals</code></pre>
<p>instead of</p>
<pre><code>[LocalReg]</code></pre>
<ul>
<li><pre><code>CmmFormals</code></pre>
<p>are</p>
<pre><code>[(CmmReg,MachHint)]</code></pre></li>
<li>This field seems to not have been being used; it only require a type change</li>
</ul></li>
<li>GC can be cleaned up b/c of the CPS
<ul>
<li>Before</li>
</ul></li>
</ul>
<pre><code>f (x, y) {
  if (Hp + 5 &gt; HpLim) {
    jump do_gc;
    // do_gc looks up the function type in it&#39;s info table
    // and saves a &quot;RET_FUN&quot; frame on the stack
    // RET_FUN fames are different than every other frame
    // in that the info table isn&#39;t on the RET_FUN code
    // but on the slot under RET_FUN which is filled with &#39;f&#39;
  }
}
g (a, b, c, d, e) {
  if (Hp + 5 &gt; HpLim) {
    jump do_gc;
    // Gen-calls have a special tag
  }
}</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code>f (f, x, y) {
  if (Hp + 5 &gt; HpLim) {
    jump do_gc_pp(f, x, y); // becomes jump do_gc_pp;
    // Tail call, note that arguments are in same order
    // as the arguments to &#39;f&#39;
    // Also can skip the table lookup and
    // do_gc_pp can be high-level C-- and save us the
    // work of saving f, x, and y
  }
}
g (g, a, b, c, d, e) {
  if (Hp + 5 &gt; HpLim) {
    call do_gc(g, a, b, c, d, e);
    jump g(g, a, b, c, d, e);
    // The general form will generate
    // a custom continuation
  }
}</code></pre>
<ul>
<li>We need the NCG to do aliasing analysis. At present the CPS pass will generate the following, and will assume that the NCG can figure out when the loads and stores can be eliminated. (The global saves part of a
<pre><code>CmmProc</code></pre>
<p>is dead b/c of this.)</p></li>
</ul>
<pre><code>foo () {
  // Parameters in regs
  a = R1;
  b = R2;
  // Parameters on stack
  c = [Sp-8];
  d = [Sp-4];
  // Saved live variables
  e = [Sp+4];
  f = [Sp+8];

* 
  ...
  Misc code that might mutate variables
  or branch or loop or any other evil thing
  ...
* 

  // A tail call (there could be multiple blocks that have this)
  a = R1;
  b = R2;
  // Parameters on stack
  c = [Sp-8];
  d = [Sp-4];
  // Saved live variables
  e = [Sp+4];
  f = [Sp+8];
  
}</code></pre>
<ul>
<li>Simple calls
<ul>
<li>Before</li>
</ul></li>
</ul>
<pre><code>f(..., z, ...) {
  ...
  r = f(x, y);
  ...
  ... = z;
  ... = r;
}</code></pre>
<ul>
<li>Output of CPS</li>
</ul>
<pre><code>f() {
  z=R1
  ...
  ... = z;
  ...
  R1 = x;
  R2 = y;
  call f;
  r = R1
  ...
  ... = z;
  ... = r;
}</code></pre>
<ul>
<li>Optimization by the NCG</li>
</ul>
<pre><code>f() {
  ...
  ... = R1;
  ...
  z = R1;
  R1 = x;
  R2 = y;
  call f;
  ...
  ... = z;
  ... = R1;
}</code></pre>
<h2 id="loopholes">Loopholes</h2>
<p>There are a number of deviations from what one might expect from a CPS algorithm due to the need to encode existing optimizations and idioms.</p>
<h3 id="gc-blocks">GC Blocks</h3>
<p>For obvious reasons, the stack used by GC blocks does not count tward the maximum amount of stack used by the function.</p>
<p>This loophole is overloaded by the GC <strong>functions</strong> so they don't create their own infinite loop. The main block is marked as being the GC block so its stack usage doesn't get checked.</p>
<h3 id="update-frames">Update Frames</h3>
<p>Update frame have to be pushed onto the stack at the begining of an update function. We could do this by wrapping the update function inside another function that just does the work of calling that other function, but since updates are so common we don't want to pay the cost of that extra jump. Thus a function can be annotated with a frame that should be pushed on entry.</p>
<p>Note that while the frame is equivalent to a tail call at the end of the function, the frame must be pushed at the beginning of the function because parts of the blackhole code look for these update frames to determine what thunks are under evaluation.</p>
<h3 id="user-defined-continuations">User defined continuations</h3>
<p>Pushing an update frame on the stack requires the ability to define a function that will pull that frame from the stack and have access to any values within the frame. This is done with user-defined continuations.</p>
<h3 id="branches-to-continuations">Branches to continuations</h3>
<p>A GC block for a heap check after a call should only take one or two instructions. However the natural code:</p>
<pre><code>  r = foo(1, 2);
  goto L;
 L:
  if (Hp &lt; HpLim) { do_gc(); goto L; }</code></pre>
<p>would generate a trivial continuation for the</p>
<pre><code>do_gc</code></pre>
<p>call as well as a trivial continuation for the</p>
<pre><code>foo</code></pre>
<p>call that just calls the proc point</p>
<pre><code>L</code></pre>
<p>.</p>
<p>We solve this by changing the syntax to</p>
<pre><code>  r = foo(1, 2);
  goto L;
 L:
  if (Hp &lt; HpLim) { r = do_gc_p(r); goto L; }</code></pre>
<p>Now the</p>
<pre><code>do_gc_p</code></pre>
<p>call has the same return signature as</p>
<pre><code>foo</code></pre>
<p>and can use the same continuation. (A call followed by a</p>
<pre><code>goto</code></pre>
<p>thus gets optimized down to just the call.)</p>
<h2 id="not-in-scope-of-current-work">Not in Scope of Current Work</h2>
<p>Improvements that could be made but that will not be implemented durring the curent effort.</p>
<h3 id="static-reference-table-handling-srt">Static Reference Table Handling (SRT)</h3>
<p>As it stands, each function and thus each call site must be annotated with a bitmap and a pointer or offset to the SRT shared by the function. This does not interact with the stack in any way so it ought to be outside the scope of the CPS algorithm. However there is some level of interaction because</p>
<ol>
<li>the SRT information on each call site needs to be attached to the resulting continuation and</li>
<li>functions read from a Cmm file might need to be annotated with that SRT info.</li>
</ol>
<p>The first is a concern for correctness but may be handled by treating the SRT info as opaque data. The second is a concern for ease of use and thus the likelyhood of mistakes in hand written C-- code. At the moment it appears that all of the C-- functions in the runtime system (RTS) use a null SRT so for now we'll just have the CPS algorithm treat the SRT info as opaque.</p>
<p>In the future it would be nice to have a more satisfactory way to handle both these issues.</p>
<h3 id="cmm-optimization-assumed-by-cps">Cmm Optimization assumed by CPS</h3>
<p>In order to simplify the CPS pass, it makes some assumptions about the optimizer.</p>
<ul>
<li>The CPS pass may generate more blocks than strictly necessary. In particular,</li>
</ul>
<p><code>  it might be possible to join together two blocks when the second block is only</code><br />
<code>  entered by the first block.  This is a simple optimization that needs to be implemented.</code></p>
<ul>
<li>The CPS pass may generate more loads and stores than strictly necessary. In particular,</li>
</ul>
<p><code>  it may load a local register only to store it back to the same stack location a few</code><br />
<code>  statements later.  There may be intervening branches.  The optimizer</code><br />
<code>  needs to be extended to eliminate these load store pairs.</code></p>
<h2 id="notes-on-future-development">Notes on future development</h2>
<h3 id="handling-gc">Handling GC</h3>
<pre><code>stg_gc_gen        = mkRtsApFastLabel SLIT(&quot;stg_gc_gen&quot;)

stg_gc_fun_v      = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_v&quot;)
stg_gc_fun_n      = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_n&quot;)
stg_gc_fun_f      = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_f&quot;)
stg_gc_fun_d      = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_d&quot;)
stg_gc_fun_l      = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_l&quot;)
stg_gc_fun_p      = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_p&quot;)
stg_gc_fun_pp     = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_pp&quot;)
stg_gc_fun_ppp    = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_ppp&quot;)
stg_gc_fun_pppp   = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_pppp&quot;)
stg_gc_fun_ppppp  = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_ppppp&quot;)
stg_gc_fun_pppppp = mkRtsApFastLabel SLIT(&quot;stg_gc_fun_pppppp&quot;)

stg_gc_ret_v      = stg_gc_gen -- Conceptually different but practically the same
stg_gc_ret_n      = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_n&quot;)
stg_gc_ret_f      = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_f&quot;)
stg_gc_ret_d      = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_d&quot;)
stg_gc_ret_l      = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_l&quot;)
stg_gc_ret_p      = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_p&quot;)
stg_gc_ret_pp     = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_pp&quot;)
stg_gc_ret_ppp    = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_ppp&quot;)
stg_gc_ret_pppp   = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_pppp&quot;)
stg_gc_ret_ppppp  = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_ppppp&quot;)
stg_gc_ret_pppppp = mkRtsApFastLabel SLIT(&quot;stg_gc_ret_pppppp&quot;)

call stg_gc_fun_gen() -&gt; stg_gc_gen
jump stg_gc_fun_v(f&#39;)
jump stg_gc_fun_p(f&#39;, p)
jump stg_gc_fun_n(f&#39;, n)

gcFunPattern []                        = Just stg_gc_fun_v
gcFunPattern [x]
  | isNonPtr x &amp;&amp; matchRep x NonPtrArg = Just stg_gc_fun_n
  | isNonPtr x &amp;&amp; matchRep x LongArg   = Just stg_gc_fun_l
  | isNonPtr x &amp;&amp; matchRep x FloatArg  = Just stg_gc_fun_f
  | isNonPtr x &amp;&amp; matchRep x DoubleArg = Just stg_gc_fun_d
gcFunPattern xs
  | all (\x -&gt; isPtr x &amp;&amp; matchRep x PtrArg)
  = case length xs of
      1 -&gt; Just stg_gc_fun_p
      2 -&gt; Just stg_gc_fun_pp
      3 -&gt; Just stg_gc_fun_ppp
      4 -&gt; Just stg_gc_fun_pppp
      5 -&gt; Just stg_gc_fun_ppppp
      6 -&gt; Just stg_gc_fun_pppppp
      _ -&gt; Nothing
gcFunPattern xs = Nothing

case gcFunPattern formals of
  Nothing -&gt; [stg_gc_gen_call srt, CmmJump target formals]
  Just gc -&gt; [stg_gc_fun_spec_jump gc formals]

stg_gc_gen_call srt =
  CmmCall (CmmForeignCall (CmmLit (CmmLabel stg_gc_gen)) CmmCallConv)
          [] [] (CmmSafe srt)
stg_gc_fun_spec_jump gc formals =
  CmmJump (CmmLit (CmmLabel gc)) (map formal_to_actual formals)

isNonPtr x = kind x == KindNonPtr
matchRep x rep = localRep x == argMachrep rep

call stg_gc_ret_gen() -&gt; stg_gc_gen
call stg_gc_ret_v() -&gt; stg_gc_gen
call p = stg_gc_ret_p(p)
call n = stg_gc_ret_n(n)</code></pre>
<pre><code>hpStkCheck:
    rts_label | is_fun    = CmmReg (CmmGlobal GCFun)
                                -- Function entry point
              | otherwise = CmmReg (CmmGlobal GCEnter1)
                                -- Thunk or case return
        -- In the thunk/case-return case, R1 points to a closure
        -- which should be (re)-entered after GC

altHeapCheck:
    rts_label PolyAlt = CmmLit (CmmLabel (mkRtsCodeLabel SLIT( &quot;stg_gc_unpt_r1&quot;)))
* ot* enter R1 after a heap check in
        -- a polymorphic case.  It might be a function
        -- and the entry code for a function (currently)
        -- applies it
        --
        -- However R1 is guaranteed to be a pointer

    rts_label (AlgAlt tc) = stg_gc_enter1
        -- Enter R1 after the heap check; it&#39;s a pointer
        
    rts_label (PrimAlt tc)
      = CmmLit $ CmmLabel $ 
        case primRepToCgRep (tyConPrimRep tc) of
          VoidArg   -&gt; mkRtsCodeLabel SLIT( &quot;stg_gc_noregs&quot;)
          FloatArg  -&gt; mkRtsCodeLabel SLIT( &quot;stg_gc_f1&quot;)
          DoubleArg -&gt; mkRtsCodeLabel SLIT( &quot;stg_gc_d1&quot;)
          LongArg   -&gt; mkRtsCodeLabel SLIT( &quot;stg_gc_l1&quot;)
                                -- R1 is boxed but unlifted: 
          PtrArg    -&gt; mkRtsCodeLabel SLIT( &quot;stg_gc_unpt_r1&quot;)
                                -- R1 is unboxed:
          NonPtrArg -&gt; mkRtsCodeLabel SLIT( &quot;stg_gc_unbx_r1&quot;)

    rts_label (UbxTupAlt _) = panic &quot;altHeapCheck&quot;

unbxTupleHeapCheck:
    rts_label       = CmmLit (CmmLabel (mkRtsCodeLabel SLIT(&quot;stg_gc_ut&quot;)))

hpChkGen:
  stg_gc_gen

hpChkNodePointsAssignSp0:
-- a heap check where R1 points to the closure to enter on return, and
-- we want to assign to Sp[0] on failure (used in AutoApply.cmm:BUILD_PAP).
  stg_gc_enter1

stkChkGen:
  stg_gc_gen

stkChkNodePoints:
  stg_gc_enter1

--------
-- hpStkCheck (is_fun)
stg_gc_fun = CmmReg (CmmGlobal GCFun)
-- hpStkCheck (no is_fun), altHeapCheck (AlgAlt), hpChkNodePointsAssignSp0, stkChkNodePoints
stg_gc_enter1 = CmmReg (CmmGlobal GCEnter1)
-- hpChkGen, stkChkGen
stg_gc_gen = CmmLit (CmmLabel (mkRtsCodeLabel SLIT(&quot;stg_gc_gen&quot;)))
-- unbxTupleHeapCheck
stg_gc_ut = CmmLit (CmmLabel (mkRtsCodeLabel SLIT(&quot;stg_gc_ut&quot;)))

-- altHeapCheck (PrimAlt)
--  VoidArg
stg_gc_noregs = CmmLit (CmmLabel (mkRtsCodeLabel SLIT( &quot;stg_gc_noregs&quot;)))
--  FloatArg
stg_gc_f1 = CmmLit (CmmLabel (mkRtsCodeLabel SLIT( &quot;stg_gc_f1&quot;)))
--  DoubleArg
stg_gc_d1 = CmmLit (CmmLabel (mkRtsCodeLabel SLIT( &quot;stg_gc_d1&quot;)))
--  LongArg
stg_gc_l1 = CmmLit (CmmLabel (mkRtsCodeLabel SLIT( &quot;stg_gc_l1&quot;)))
--  PtrArg and PolyAlt
stg_gc_unpt_r1 = CmmLit (CmmLabel (mkRtsCodeLabel SLIT( &quot;stg_gc_unpt_r1&quot;)))
--  NonPtrArg
stg_gc_unbx_r1 = CmmLit (CmmLabel (mkRtsCodeLabel SLIT( &quot;stg_gc_unbx_r1&quot;)))</code></pre>
<h1 id="the-ghc-commentary-data-types-and-data-constructors">The GHC Commentary: Data types and data constructors</h1>
<p>This chapter was thoroughly changed Feb 2003. If you are interested in how a particular data type is implemented take a look at [wiki:Commentary/Compiler/CaseStudies/Bool this case study].</p>
<h2 id="data-types">Data types</h2>
<p>Consider the following data type declaration:</p>
<pre><code>data T a = MkT &lt;nowiki&gt;(a,a)&lt;/nowiki&gt; &lt;nowiki&gt;(T&lt;/nowiki&gt; a) | Nil

f x = case x of
        MkT p q -&gt; MkT p (q+1)
        Nil     -&gt; Nil</code></pre>
<p>The user's source program mentions only the constructors</p>
<pre><code>MkT` and `Nil`. However, these constructors actually &#39;&#39;do&#39;&#39; something in addition to building a data value. For a start, `MkT` evaluates its arguments. Secondly, with the flag `-funbox-strict-fields` GHC will flatten (or unbox) the strict fields. So we may imagine that there&#39;s the &#39;&#39;source&#39;&#39; constructor `MkT` and the &#39;&#39;representation&#39;&#39; constructor `MkT</code></pre>
<p>, and things start to get pretty confusing.</p>
<p>GHC now generates three unique</p>
<pre><code>Name</code></pre>
<p>s for each data constructor:</p>
<pre><code>                             ---- OccName ------
                               String  Name space     Used for
---------------------------------------------------------------------------
The &quot;source data con&quot;            MkT    DataName      The DataCon itself
The &quot;worker data con&quot;            MkT    VarName       Its worker Id
  aka &quot;representation data con&quot;
The &quot;wrapper data con&quot;           $WMkT  VarName       Its wrapper Id (optional)</code></pre>
<p>Recall that each occurrence name (OccName) is a pair of a string and a name space (see [wiki:Commentary/Compiler/RdrNameType#TheOccNametype RdrNames, Modules, and OccNames]), and two OccNames are considered the same only if both components match. That is what distinguishes the name of the name of the DataCon from the name of its worker Id. To keep things unambiguous, in what follows we'll write &quot;MkT{d}&quot; for the source data con, and &quot;MkT{v}&quot; for the worker Id. (Indeed, when you dump stuff with &quot;-ddumpXXX&quot;, if you also add &quot;-dppr-debug&quot; you'll get stuff like &quot;Foo {- d rMv -}&quot;. The &quot;d&quot; part is the name space; the &quot;rMv&quot; is the unique key.)</p>
<p>Each of these three names gets a distinct unique key in GHC's name cache.</p>
<h1 id="the-life-cycle-of-a-data-type">The life cycle of a data type</h1>
<p>Suppose the Haskell source looks like this:</p>
<pre><code>data T a = MkT &lt;nowiki&gt;(a,a)&lt;/nowiki&gt; &lt;nowiki&gt;Int&lt;/nowiki&gt; | Nil

f x = case x of
        Nil     -&gt; Nil
        MkT p q -&gt; MkT p (q+1)</code></pre>
<p>When the parser reads it in, it decides which name space each lexeme comes from, thus:</p>
<pre><code>data T a = MkT{d} &lt;nowiki&gt;(a,a)&lt;/nowiki&gt; &lt;nowiki&gt;Int&lt;/nowiki&gt; | Nil{d}

f x = case x of
        Nil{d}     -&gt; Nil{d}
        MkT{d} p q -&gt; MkT{d} p (q+1)</code></pre>
<p>Notice that in the Haskell source <em>all data contructors are named via the &quot;source data con&quot; MkT{d}</em>, whether in pattern matching or in expressions.</p>
<p>In the translated source produced by the type checker (-ddump-tc), the program looks like this:</p>
<pre><code>f x = case x of
        Nil{d}     -&gt; Nil{v}
        MkT{d} p q -&gt; $WMkT p (q+1)</code></pre>
<p>Notice that the type checker replaces the occurrence of MkT by the <em>wrapper</em>, but the occurrence of Nil by the <em>worker</em>. Reason: Nil doesn't have a wrapper because there is nothing to do in the wrapper (this is the vastly common case).</p>
<p>Though they are not printed out by &quot;-ddump-tc&quot;, behind the scenes, there are also the following: the data type declaration and the wrapper function for MkT.</p>
<pre><code>data T a = MkT{d} a a Int# | Nil{d}
 
$WMkT :: (a,a) -&gt; T a -&gt; T a
$WMkT p t = case p of 
            (a,b) -&gt; seq t (MkT{v} a b t)</code></pre>
<p>Here, the <em>wrapper</em> $WMkT evaluates and takes apart the argument p, evaluates the argument t, and builds a three-field data value with the <em>worker</em> constructor MkT{v}. (There are more notes below about the unboxing of strict fields.) The worker $WMkT is called an <em>implicit binding</em>, because it's introduced implicitly by the data type declaration (record selectors are also implicit bindings, for example). Implicit bindings are injected into the code just before emitting code or External Core.</p>
<p>After desugaring into Core (-ddump-ds), the definition of f looks like this:</p>
<pre><code>f x = case x of
        Nil{d}       -&gt; Nil{v}
        MkT{d} a b r -&gt; let { p = (a,b); q = I# r } in 
                        $WMkT p (q+1)</code></pre>
<p>Notice the way that pattern matching has been desugared to take account of the fact that the &quot;real&quot; data constructor MkT has three fields.</p>
<p>By the time the simplifier has had a go at it, f will be transformed to:</p>
<pre><code>f x = case x of
      Nil{d}       -&gt; Nil{v}
      MkT{d} a b r -&gt; MkT{v} a b (r +# 1#)</code></pre>
<p>Which is highly cool.</p>
<h2 id="the-constructor-wrapper-functions">The constructor wrapper functions</h2>
<p>The wrapper functions are automatically generated by GHC, and are really emitted into the result code (albeit only after CorePre; see</p>
<pre><code>CorePrep.mkImplicitBinds</code></pre>
<p>). The wrapper functions are inlined very vigorously, so you will not see many occurrences of the wrapper functions in an optimised program, but you may see some. For example, if your Haskell source has</p>
<pre><code>map MkT xs</code></pre>
<p>then</p>
<pre><code>$WMkT</code></pre>
<p>will not be inlined (because it is not applied to anything). That is why we generate real top-level bindings for the wrapper functions, and generate code for them.</p>
<h2 id="the-constructor-worker-functions">The constructor worker functions</h2>
<p>Saturated applications of the constructor worker function MkT{v} are treated specially by the code generator; they really do allocation. However, we do want a single, shared, top-level definition for top-level nullary constructors (like True and False). Furthermore, what if the code generator encounters a non-saturated application of a worker? E.g. (</p>
<pre><code>map Just xs</code></pre>
<p>). We could declare that to be an error (CorePrep should saturate them). But instead we currently generate a top-level defintion for each constructor worker, whether nullary or not. It takes the form:</p>
<pre><code>MkT{v} = \ p q r -&gt; MkT{v} p q r</code></pre>
<p>This is a real hack. The occurrence on the RHS is saturated, so the code generator (both the one that generates abstract C and the byte-code generator) treats it as a special case and allocates a MkT; it does not make a recursive call! So now there's a top-level curried version of the worker which is available to anyone who wants it.</p>
<p>This strange definition is not emitted into External Core. Indeed, you might argue that we should instead pass the list of</p>
<pre><code>TyCon</code></pre>
<p>s to the code generator and have it generate magic bindings directly. As it stands, it's a real hack: see the code in CorePrep.mkImplicitBinds.</p>
<h2 id="external-core">External Core</h2>
<p>When emitting External Core, we should see this for our running example:</p>
<pre><code>data T a = MkT a a Int# | Nil{d}
 
$WMkT :: (a,a) -&gt; T a -&gt; T a
$WMkT p t = case p of 
              (a,b) -&gt; seq t (MkT a b t)

f x = case x of
        Nil       -&gt; Nil
        MkT a b r -&gt; MkT a b (r +# 1#)</code></pre>
<p>Notice that it makes perfect sense as a program all by itself. Constructors look like constructors (albeit not identical to the original Haskell ones).</p>
<p>When reading in External Core, the parser is careful to read it back in just as it was before it was spat out, namely:</p>
<pre><code>data T a = MkT{d} a a Int# | Nil{d}
 
$WMkT :: (a,a) -&gt; T a -&gt; T a
$WMkT p t = case p of 
              (a,b) -&gt; seq t (MkT{v} a b t)

f x = case x of
        Nil{d}       -&gt; Nil{v}
        MkT{d} a b r -&gt; MkT{v} a b (r +# 1#)</code></pre>
<h2 id="unboxing-strict-fields">Unboxing strict fields</h2>
<p>If GHC unboxes strict fields (as in the first argument of MkT above), it also transforms source-language case expressions. Suppose you write this in your Haskell source:</p>
<pre><code>case e of 
  MkT p t -&gt; ..p..t..</code></pre>
<p>GHC will desugar this to the following Core code:</p>
<pre><code>case e of
  MkT a b t -&gt; let p = (a,b) in ..p..t..</code></pre>
<p>The local let-binding reboxes the pair because it may be mentioned in the case alternative. This may well be a bad idea, which is why</p>
<pre><code>-funbox-strict-fields</code></pre>
<p>is an experimental feature.</p>
<p>It's essential that when importing a type</p>
<pre><code>T` defined in some external module `M`, GHC knows what representation was used for that type, and that in turn depends on whether module M was compiled with `-funbox-strict-fields</code></pre>
<p>. So when writing an interface file, GHC therefore records with each data type whether its strict fields (if any) should be unboxed.</p>
<h2 id="labels-and-info-tables">Labels and info tables</h2>
<p><em>Quick rough notes: SLPJ March 2003.</em></p>
<p>Every data constructor</p>
<pre><code>C</code></pre>
<p>has two info tables:</p>
<ul>
<li>The static info table (label
<pre><code>C_static_info</code></pre>
<p>), used for statically-allocated constructors.</p></li>
<li>The dynamic info table (label
<pre><code>C_con_info</code></pre>
<p>), used for dynamically-allocated constructors.</p></li>
</ul>
<p>Statically-allocated constructors are not moved by the garbage collector, and therefore have a different closure type from dynamically-allocated constructors; hence they need a distinct info table. Both info tables share the same entry code, but since the entry code is physically juxtaposed with the info table, it must be duplicated (</p>
<pre><code>C_static_entry` and `C_con_entry</code></pre>
<p>respectively).</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="demand-analyser-in-ghc">Demand analyser in GHC</h1>
<p>This page explains basics of the so-called demand analysis in GHC, comprising strictness and absence analyses. Meanings of demand signatures are explained and examples are provided. Also, components of the compiler possibly affected by the results of the demand analysis are listed with explanations provided.</p>
<ul>
<li>The <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/demand-anal/demand.ps">demand-analyser draft paper</a> is as yet unpublished, but gives the most accurate overview of the way GHC's demand analyser works.</li>
</ul>
<hr />
<h2 id="demand-signatures">Demand signatures</h2>
<p>Let us compile the following program with</p>
<pre><code>-O2 -ddump-stranal</code></pre>
<p>flags:</p>
<pre><code>f c p = case p 
          of (a, b) -&gt; if c 
                       then (a, True) 
                       else (True, False)</code></pre>
<p>The resulting demand signature for function</p>
<pre><code>f</code></pre>
<p>will be the following one:</p>
<pre><code>Str=DmdType &lt;S,U&gt;&lt;S,U(UA)&gt;m</code></pre>
<p>This should be read as &quot;</p>
<pre><code>f` puts stricts demands on both its arguments (hence, `S`); `f` might use its first  and second arguments. but in the second argument (which is a product), the second component is ignored&quot;. The suffix `m</code></pre>
<p>in the demand signature indicates that the function returns <strong>CPR</strong>, a constructed product result (for more information on CPR see the JFP paper <a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm">Constructed Product Result Analysis for Haskell</a>).</p>
<p>Current implementation of demand analysis in Haskell performs annotation of all binders with demands, put on them in the context of their use. For functions, it is assumed, that the result of the function is used strictly. The analysis infers strictness and usage information separately, as two components of a cartesian product domain. The same analysis also performs inference CPR and bottoming properties for functions, which can be read from the suffix of the signature. Demand signatures of inner definitions may also include <em>demand environments</em> that indicate demands, which a closure puts to its free variables, once strictly used, e.g. the signature</p>
<pre><code>Str=DmdType &lt;L,U&gt; {skY-&gt;&lt;S,U&gt;}</code></pre>
<p>indicates that the function has one parameter, which is used lazily (hence</p>
<pre><code>&lt;L,U&gt;`), however, when its result is used strictly, the free variable `skY</code></pre>
<p>in its body is also used strictly.</p>
<h3 id="demand-descriptions">Demand descriptions</h3>
<p>Strictness demands</p>
<ul>
<li><pre><code>B` -- a &#39;&#39;hyperstrict&#39;&#39; demand. The expression `e` puts this demand on its argument `x` if every evaluation of `e` is guaranteed to diverge, regardless of the value of the argument. We call this demand &#39;&#39;hyperstrict&#39;&#39; because it is safe to evaluate `x` to arbitrary depth before evaluating `e`. This demand is polymorphic with respect to function calls and can be seen as `B = C(B) = C(C(B)) = ...</code></pre>
<p>for an arbitrary depth.</p></li>
</ul>
<ul>
<li><pre><code>L`  -- a &#39;&#39;lazy&#39;&#39; demand. If an expression `e` places demand `L` on a variable  `x`, we can deduce nothing about how `e` uses `x`. `L</code></pre>
<p>is the completely uninformative demand, the top element of the lattice.</p></li>
</ul>
<ul>
<li><pre><code>S` -- a &#39;&#39;head-strict&#39;&#39; demand.  If `e` places demand `S` on `x` then `e` evaluates `x` to at least head-normal form; that is, to the outermost constructor of `x`.  This demand is typically placed by the `seq` function on its first argument. The demand `S(L ... L)` places a lazy demand on all the components, and so is equivalent to `S`; hence the identity `S = S(L ... L)`. Another identity is for functions, which states that `S = C(L)</code></pre>
<p>. Indeed, if a function is certainly called, it is evaluated at lest up to the head normal form, i.e., <em>strictly</em>. However, its result may be used lazily.</p></li>
</ul>
<ul>
<li><pre><code>S(s1 ... sn)</code></pre>
<p>-- a structured strictness demand on a product. It is at least head-strict, and perhaps more.</p></li>
</ul>
<ul>
<li><pre><code>C(s)`  -- a &#39;&#39;call-demand&#39;&#39;, when placed on a binder `x`, indicates that the value is a function, which is always called and its result is used according to the demand `s</code></pre>
<p>.</p></li>
</ul>
<p>Absence/usage demands</p>
<ul>
<li><pre><code>A` -- when placed on a binder `x` it means that `x</code></pre>
<p>is definitely unused.</p></li>
</ul>
<ul>
<li><pre><code>U</code></pre>
<p>-- the value is used on some execution path. This demand is a top of usage domain.</p></li>
</ul>
<ul>
<li><pre><code>H` -- a &#39;&#39;head-used&#39;&#39; demand. Indicates that a product value is used itself, however its components are certainly ignored. This demand is typically placed by the `seq` function on its first argument. This demand is polymorphic with respect to products and functions. For a product, the head-used demand is expanded as `U(A, ..., A)` and for functions it can be read as `C(A)</code></pre>
<p>, as the function is called (i.e., evaluated to at least a head-normal form), but its result is ignored.</p></li>
</ul>
<ul>
<li><pre><code>U(u1 ... un)</code></pre>
<p>-- a structured usage demand on a product. It is at least head-used, and perhaps more.</p></li>
</ul>
<ul>
<li><pre><code>C(u)` -- a &#39;&#39;call-demand&#39;&#39; for usage information. When put on a binder `x`, indicates that `x` in all executions paths where `x` is used, it is &#39;&#39;applied&#39;&#39; to some argument, and the result of the application is used with a demand `u</code></pre>
<p>.</p></li>
</ul>
<p>Additional information (demand signature suffix)</p>
<ul>
<li><pre><code>m</code></pre>
<p>-- a function returns a <a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm">constructed product result</a></p></li>
</ul>
<ul>
<li><pre><code>b` -- the function is a &#39;&#39;bottoming&#39;&#39; one, i.e., some decoration of `error</code></pre>
<p>and friends.</p></li>
</ul>
<h2 id="worker-wrapper-split">Worker-Wrapper split</h2>
<p>Demand analysis in GHC drives the <em>worker-wrapper transformation</em>, which exposes specialised calling conventions to the rest of the compiler. In particular, the worker-wrapper transformation implements the unboxing optimisation.</p>
<p>The worker-wrapper transformation splits each function</p>
<pre><code>f</code></pre>
<p>into a <em>wrapper</em>, with the ordinary calling convention, and a <em>worker</em>, with a specialised calling convention. The wrapper serves as an impedance-matcher to the worker; it simply calls the worker using the specialised calling convention. The transformation can be expressed directly in GHC's intermediate language. Suppose that</p>
<pre><code>f</code></pre>
<p>is defined thus:</p>
<pre><code>  f :: (Int,Int) -&gt; Int
  f p = &lt;rhs&gt;</code></pre>
<p>and that we know that</p>
<pre><code>f</code></pre>
<p>is strict in its argument (the pair, that is), and uses its components. What worker-wrapper split shall we make? Here is one possibility:</p>
<pre><code> f :: (Int,Int) -&gt; Int
  f p = case p of
          (a,b) -&gt; $wf a b

  $wf :: Int -&gt; Int -&gt; Int
  $wf a b = let p = (a,b) in &lt;rhs&gt;</code></pre>
<p>Now the wrapper,</p>
<pre><code>f</code></pre>
<p>, can be inlined at every call site, so that the caller evaluates</p>
<pre><code>p</code></pre>
<p>, passing only the components to the worker</p>
<pre><code>$wf</code></pre>
<p>, thereby implementing the unboxing transformation.</p>
<p>But what if</p>
<pre><code>f` did not use `a`, or `b</code></pre>
<p>? Then it would be silly to pass them to the worker</p>
<pre><code>$wf</code></pre>
<p>. Hence the need for absence analysis. Suppose, then, that we know that</p>
<pre><code>b</code></pre>
<p>is not needed. Then we can transform to:</p>
<pre><code>  f :: (Int,Int) -&gt; Int
  f p = case p of (a,b) -&gt; $wf a

  $wf :: Int -&gt; Int
  $wf a = let p = (a,error &quot;abs&quot;) in &lt;rhs&gt;</code></pre>
<p>Since</p>
<pre><code>b</code></pre>
<p>is not needed, we can avoid passing it from the wrapper to the worker; while in the worker, we can use</p>
<pre><code>error &quot;abs&quot;</code></pre>
<p>instead of</p>
<pre><code>b</code></pre>
<p>.</p>
<p>In short, the worker-wrapper transformation allows the knowledge gained from strictness and absence analysis to be exposed to the rest of the compiler simply by performing a local transformation on the function definition. Then ordinary inlining and case elimination will do the rest, transformations the compiler does anyway.</p>
<h2 id="relevant-compiler-parts">Relevant compiler parts</h2>
<p>Multiple parts of GHC are sensitive to changes in the nature of demand signatures and results of the demand analysis, which might cause unexpected errors when hacking into demands. [wiki:Commentary/Compiler/Demand/RelevantParts This list] enumerates the parts of the compiler that are sensitive to demand, with brief summaries of how so.</p>
<p>= Support for deriving</p>
<pre><code>Functor</code></pre>
<p>,</p>
<pre><code>Foldable</code></pre>
<p>, and</p>
<pre><code>Traversable</code></pre>
<p>instances = <a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<p>GHC 6.12.1 introduces an extension to the</p>
<pre><code>deriving</code></pre>
<p>mechanism allowing for automatic derivation of</p>
<pre><code>Functor</code></pre>
<p>,</p>
<pre><code>Foldable</code></pre>
<p>, and</p>
<pre><code>Traversable</code></pre>
<p>instances using the</p>
<pre><code>DeriveFunctor</code></pre>
<p>,</p>
<pre><code>DeriveFoldable</code></pre>
<p>, and</p>
<pre><code>DeriveTraversable</code></pre>
<p>extensions, respectively. Twan van Laarhoven <a href="https://mail.haskell.org/pipermail/haskell-prime/2007-March/002137.html">first proposed this feature</a> in 2007, and <a href="https://ghc.haskell.org/trac/ghc/ticket/2953">opened a related GHC Trac ticket</a> in 2009.</p>
<h2 id="example">Example</h2>
<pre><code>#!hs
{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}

data Example a = Ex a Char (Example a) (Example Char)
  deriving (Functor, Foldable, Traversable)</code></pre>
<p>The derived code would look something like this:</p>
<pre><code>#!hs
instance Functor Example where
    fmap f (Ex a1 a2 a3 a4) = Ex (f a1) a2 (fmap f a3) a4

instance Foldable Example where
    foldr f z (Ex a1 a2 a3 a4) = f a1 (foldr f z a3)
    foldMap f (Ex a1 a2 a3 a4) = mappend (f a1) (mappend mempty (mappend (foldMap f a3) mempty))

instance Traversable Example where
*  pure a2 &lt;*&gt; traverse f a3 &lt;*&gt; pure a4</code></pre>
<h2 id="algorithm-description">Algorithm description</h2>
<pre><code>DeriveFunctor</code></pre>
<p>,</p>
<pre><code>DeriveFoldable</code></pre>
<p>, and</p>
<pre><code>DeriveTraversable</code></pre>
<p>all operate using the same underlying mechanism. GHC inspects the arguments of each constructor and derives some operation to perform on each argument, which depends of the type of the argument itself. In a</p>
<pre><code>Functor</code></pre>
<p>instance, for example</p>
<pre><code>fmap</code></pre>
<p>would be applied to occurrences of the last type parameter, but</p>
<pre><code>id</code></pre>
<p>would be applied to other type parameters. Typically, there are five cases to consider. (Suppose we have a data type</p>
<pre><code>data A a = ...</code></pre>
<p>.)</p>
<p>1. Terms whose type does not mention</p>
<pre><code>a</code></pre>
<p>2. Terms whose type mentions</p>
<pre><code>a</code></pre>
<p>3. Occurrences of</p>
<pre><code>a</code></pre>
<p>4. Tuple values 5. Function values</p>
<p>After this is done, the new terms are combined in some way. For instance,</p>
<pre><code>Functor</code></pre>
<p>instances combine terms in a derived</p>
<pre><code>fmap</code></pre>
<p>definition by applying the appropriate constructor to all terms, whereas in</p>
<pre><code>Foldable</code></pre>
<p>instances, a derived</p>
<pre><code>foldMap</code></pre>
<p>definition would</p>
<pre><code>mappend</code></pre>
<p>the terms together.</p>
<p>===</p>
<pre><code>DeriveFunctor</code></pre>
<p>===</p>
<p>A comment in <a href="http://git.haskell.org/ghc.git/blob/9f968e97a0de9c2509da00f6337b612dd72a0389:/compiler/typecheck/TcGenDeriv.hs#l1476">TcGenDeriv.hs</a> lays out the basic structure of</p>
<pre><code>DeriveFunctor</code></pre>
<p>, which derives an implementation for</p>
<pre><code>fmap</code></pre>
<p>.</p>
<pre><code>For the data type:

  data T a = T1 Int a | T2 (T a)

We generate the instance:

  instance Functor T where
      fmap f (T1 b1 a) = T1 b1 (f a)
      fmap f (T2 ta)   = T2 (fmap f ta)

Notice that we don&#39;t simply apply &#39;fmap&#39; to the constructor arguments.
Rather
  - Do nothing to an argument whose type doesn&#39;t mention &#39;a&#39;
  - Apply &#39;f&#39; to an argument of type &#39;a&#39;
  - Apply &#39;fmap f&#39; to other arguments
That&#39;s why we have to recurse deeply into the constructor argument types,
rather than just one level, as we typically do.

What about types with more than one type parameter?  In general, we only
derive Functor for the last position:

  data S a b = S1 [b] | S2 (a, T a b)
  instance Functor (S a) where
    fmap f (S1 bs)    = S1 (fmap f bs)
    fmap f (S2 (p,q)) = S2 (a, fmap f q)

However, we have special cases for
         - tuples
         - functions

More formally, we write the derivation of fmap code over type variable
&#39;a for type &#39;b as ($fmap &#39;a &#39;b).  In this general notation the derived
instance for T is:

  instance Functor T where
      fmap f (T1 x1 x2) = T1 ($(fmap &#39;a &#39;b1) x1) ($(fmap &#39;a &#39;a) x2)
      fmap f (T2 x1)    = T2 ($(fmap &#39;a &#39;(T a)) x1)

  $(fmap &#39;a &#39;b)          =  \x -&gt; x     -- when b does not contain a
  $(fmap &#39;a &#39;a)          =  f
  $(fmap &#39;a &#39;(b1,b2))    =  \x -&gt; case x of (x1,x2) -&gt; ($(fmap &#39;a &#39;b1) x1, $(fmap &#39;a &#39;b2) x2)
  $(fmap &#39;a &#39;(T b1 b2))  =  fmap $(fmap &#39;a &#39;b2)   -- when a only occurs in the last parameter, b2
  $(fmap &#39;a &#39;(b -&gt; c))   =  \x b -&gt; $(fmap &#39;a&#39; &#39;c) (x ($(cofmap &#39;a &#39;b) b))

For functions, the type parameter &#39;a can occur in a contravariant position,
which means we need to derive a function like:

  cofmap :: (a -&gt; b) -&gt; (f b -&gt; f a)

This is pretty much the same as $fmap, only without the $(cofmap &#39;a &#39;a) case:

  $(cofmap &#39;a &#39;b)          =  \x -&gt; x     -- when b does not contain a
  $(cofmap &#39;a &#39;a)          =  error &quot;type variable in contravariant position&quot;
  $(cofmap &#39;a &#39;(b1,b2))    =  \x -&gt; case x of (x1,x2) -&gt; ($(cofmap &#39;a &#39;b1) x1, $(cofmap &#39;a &#39;b2) x2)
  $(cofmap &#39;a &#39;[b])        =  map $(cofmap &#39;a &#39;b)
  $(cofmap &#39;a &#39;(T b1 b2))  =  fmap $(cofmap &#39;a &#39;b2)   -- when a only occurs in the last parameter, b2
  $(cofmap &#39;a &#39;(b -&gt; c))   =  \x b -&gt; $(cofmap &#39;a&#39; &#39;c) (x ($(fmap &#39;a &#39;c) b))</code></pre>
<pre><code>DeriveFunctor</code></pre>
<p>is special in that it can recurse into function types, whereas</p>
<pre><code>DeriveFoldable</code></pre>
<p>and</p>
<pre><code>DeriveTraversable</code></pre>
<p>cannot (see the section on covariant and contravariant positions).</p>
<p>===</p>
<pre><code>DeriveFoldable</code></pre>
<p>===</p>
<p>Another comment in <a href="http://git.haskell.org/ghc.git/blob/9f968e97a0de9c2509da00f6337b612dd72a0389:/compiler/typecheck/TcGenDeriv.hs#l1725">TcGenDeriv.hs</a> reveals the underlying mechanism behind</p>
<pre><code>DeriveFoldable</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>Deriving Foldable instances works the same way as Functor instances,
only Foldable instances are not possible for function types at all.
Given (data T a = T a a (T a) deriving Foldable), we get:

  instance Foldable T where
      foldr f z (T x1 x2 x3) =
        $(foldr &#39;a &#39;a) x1 ( $(foldr &#39;a &#39;a) x2 ( $(foldr &#39;a &#39;(T a)) x3 z ) )

-XDeriveFoldable is different from -XDeriveFunctor in that it filters out
arguments to the constructor that would produce useless code in a Foldable
instance. For example, the following datatype:

  data Foo a = Foo Int a Int deriving Foldable

would have the following generated Foldable instance:

  instance Foldable Foo where
    foldr f z (Foo x1 x2 x3) = $(foldr &#39;a &#39;a) x2

since neither of the two Int arguments are folded over.

The cases are:

  $(foldr &#39;a &#39;a)         =  f
  $(foldr &#39;a &#39;(b1,b2))   =  \x z -&gt; case x of (x1,x2) -&gt; $(foldr &#39;a &#39;b1) x1 ( $(foldr &#39;a &#39;b2) x2 z )
  $(foldr &#39;a &#39;(T b1 b2)) =  \x z -&gt; foldr $(foldr &#39;a &#39;b2) z x  -- when a only occurs in the last parameter, b2

Note that the arguments to the real foldr function are the wrong way around,
since (f :: a -&gt; b -&gt; b), while (foldr f :: b -&gt; t a -&gt; b).

One can envision a case for types that don&#39;t contain the last type variable:

  $(foldr &#39;a &#39;b)         =  \x z -&gt; z     -- when b does not contain a

But this case will never materialize, since the aforementioned filtering
removes all such types from consideration.</code></pre>
<p>In addition to</p>
<pre><code>foldr</code></pre>
<p>,</p>
<pre><code>DeriveFoldable</code></pre>
<p>also generates a definition for</p>
<pre><code>foldMap</code></pre>
<p>as of GHC 7.8.1 (addressing <a href="https://ghc.haskell.org/trac/ghc/ticket/7436">#7436</a>). The pseudo-definition for</p>
<pre><code>$(foldMap)</code></pre>
<p>would look something like this:</p>
<pre><code>  $(foldMap &#39;a &#39;b)         = \x -&gt; mempty     -- when b does not contain a
  $(foldMap &#39;a &#39;a)         = f
  $(foldMap &#39;a &#39;(b1,b2))   = \x -&gt; case x of (x1, x2) -&gt; mappend ($(foldMap &#39;a &#39;b1) x1) ($(foldMap &#39;a &#39;b2) x2)
  $(foldMap &#39;a &#39;(T b1 b2)) = \x -&gt; foldMap $(foldMap &#39;a &#39;b2) x -- when a only occurs in the last parameter, b2</code></pre>
<p>===</p>
<pre><code>DeriveTraversable</code></pre>
<p>===</p>
<p>From <a href="http://git.haskell.org/ghc.git/blob/9f968e97a0de9c2509da00f6337b612dd72a0389:/compiler/typecheck/TcGenDeriv.hs#l1800">TcGenDeriv.hs</a>:</p>
<pre><code>Again, Traversable is much like Functor and Foldable.

The cases are:

  $(traverse &#39;a &#39;a)          =  f
*  $(traverse &#39;a &#39;b2) x2
  $(traverse &#39;a &#39;(T b1 b2))  =  traverse $(traverse &#39;a &#39;b2)  -- when a only occurs in the last parameter, b2

Like -XDeriveFoldable, -XDeriveTraversable filters out arguments whose types
do not mention the last type parameter. Therefore, the following datatype:

  data Foo a = Foo Int a Int

would have the following derived Traversable instance:

  instance Traversable Foo where
    traverse f (Foo x1 x2 x3) =
      fmap (\b2 -&gt; Foo x1 b2 x3) ( $(traverse &#39;a &#39;a) x2 )

since the two Int arguments do not produce any effects in a traversal.

One can envision a case for types that do not mention the last type parameter:

  $(traverse &#39;a &#39;b)          =  pure     -- when b does not contain a

But this case will never materialize, since the aforementioned filtering
removes all such types from consideration.</code></pre>
<h3 id="covariant-and-contravariant-positions">Covariant and contravariant positions</h3>
<p>One challenge of deriving</p>
<pre><code>Functor</code></pre>
<p>instances for arbitrary data types is handling function types. To illustrate this, note that these all can have derived</p>
<pre><code>Functor</code></pre>
<p>instances:</p>
<pre><code>#!hs
data CovFun1 a = CovFun1 (Int -&gt; a)
data CovFun2 a = CovFun2 ((a -&gt; Int) -&gt; a)
data CovFun3 a = CovFun3 (((Int -&gt; a) -&gt; Int) -&gt; a)</code></pre>
<p>but none of these can:</p>
<pre><code>#!hs
data ContraFun1 a = ContraFun1 (a -&gt; Int)
data ContraFun2 a = ContraFun2 ((Int -&gt; a) -&gt; Int)
data ContraFun3 a = ContraFun3 (((a -&gt; Int) -&gt; a) -&gt; Int)</code></pre>
<p>In</p>
<pre><code>CovFun1</code></pre>
<p>,</p>
<pre><code>CovFun2</code></pre>
<p>, and</p>
<pre><code>CovFun3</code></pre>
<p>, all occurrences of the type variable</p>
<pre><code>a</code></pre>
<p>are in <em>covariant</em> positions (i.e., the</p>
<pre><code>a</code></pre>
<p>values are produced), whereas in</p>
<pre><code>ContraFun1</code></pre>
<p>,</p>
<pre><code>ContraFun2</code></pre>
<p>, and</p>
<pre><code>ContraFun3</code></pre>
<p>, all occurrences of</p>
<pre><code>a</code></pre>
<p>are in <em>contravariant</em> positions (i.e., the</p>
<pre><code>a</code></pre>
<p>values are consumed). If we have a function</p>
<pre><code>f :: a -&gt; b</code></pre>
<p>, we can't apply</p>
<pre><code>f</code></pre>
<p>to an</p>
<pre><code>a</code></pre>
<p>value in a contravariant position, which precludes a</p>
<pre><code>Functor</code></pre>
<p>instance.</p>
<p>Most type variables appear in covariant positions. Functions are special in that the lefthand side of a function arrow reverses variance. If a function type</p>
<pre><code>a -&gt; b</code></pre>
<p>appears in a covariant position (e.g.,</p>
<pre><code>CovFun1</code></pre>
<p>above), then</p>
<pre><code>a</code></pre>
<p>is in a contravariant position and</p>
<pre><code>b</code></pre>
<p>is in a covariant position. Similarly, if</p>
<pre><code>a -&gt; b</code></pre>
<p>appears in a contravariant position (e.g.,</p>
<pre><code>CovFun2</code></pre>
<p>above), then</p>
<pre><code>a</code></pre>
<p>is in a covariant position and</p>
<pre><code>b</code></pre>
<p>is in a contravariant position.</p>
<p>If we annotate covariant positions with</p>
<pre><code>p</code></pre>
<p>(for positive) and contravariant positions with</p>
<pre><code>n</code></pre>
<p>(for negative), then we can examine the above examples with the following pseudo-type signatures:</p>
<pre><code>CovFun1/ContraFun1 :: n -&gt; p
CovFun2/ContraFun2 :: (p -&gt; n) -&gt; p
CovFun3/ContraFun3 :: ((n -&gt; p) -&gt; n) -&gt; p</code></pre>
<p>Since</p>
<pre><code>ContraFun1</code></pre>
<p>,</p>
<pre><code>ContraFun2</code></pre>
<p>, and</p>
<pre><code>ContraFun3</code></pre>
<p>all use the last type parameter in at least one</p>
<pre><code>n</code></pre>
<p>position, GHC would reject a derived</p>
<pre><code>Functor</code></pre>
<p>instance for each of them.</p>
<h2 id="requirements-for-legal-instances">Requirements for legal instances</h2>
<p>This mechanism cannot derive</p>
<pre><code>Functor</code></pre>
<p>,</p>
<pre><code>Foldable</code></pre>
<p>, or</p>
<pre><code>Traversable</code></pre>
<p>instances for all data types. Currently, GHC checks if a data type meets the following criteria:</p>
<p>1. The data type has at least one type parameter. (For example,</p>
<pre><code>data NoArg = NoArg</code></pre>
<p>cannot have a</p>
<pre><code>Functor</code></pre>
<p>instance.) 2. The data type's last type parameter cannot be used contravariantly. (see the section on covariant and contravariant positions.) 3. The data type's last type parameter cannot be used in the &quot;wrong place&quot; in any constructor's data arguments. For example, in</p>
<pre><code>data Right a = Right [a] (Either Int a)</code></pre>
<p>, the type parameter</p>
<pre><code>a</code></pre>
<p>is only ever used as the last type argument in</p>
<pre><code>[]</code></pre>
<p>and</p>
<pre><code>Either</code></pre>
<p>, so both</p>
<pre><code>[a]</code></pre>
<p>and</p>
<pre><code>Either Int a</code></pre>
<p>values can be</p>
<pre><code>fmap</code></pre>
<p>ped. However, in</p>
<pre><code>data Wrong a = Wrong (Either a a)</code></pre>
<p>, the type variable</p>
<pre><code>a</code></pre>
<p>appears in a position other than the last, so trying to</p>
<pre><code>fmap</code></pre>
<p>an</p>
<pre><code>Either a a</code></pre>
<p>value would not typecheck.</p>
<p><code>  Note that there are two exceptions to this rule: tuple and function types.</code></p>
<p>4. The data type's last type variable cannot used in a</p>
<pre><code>-XDatatypeContexts</code></pre>
<p>constraint. For example,</p>
<pre><code>data Ord a =&gt; O a = O a deriving Functor</code></pre>
<p>would be rejected.</p>
<p>In addition, GHC performs checks for certain classes only:</p>
<p>1. For derived</p>
<pre><code>Foldable</code></pre>
<p>and</p>
<pre><code>Traversable</code></pre>
<p>instances, a data type cannot use function types. This restriction does not apply to derived</p>
<pre><code>Functor</code></pre>
<p>instances, however. 2. For derived</p>
<pre><code>Functor</code></pre>
<p>and</p>
<pre><code>Traversable</code></pre>
<p>instances, the data type's last type variable must be truly universally quantified, i.e., it must not have any class or equality constraints. This means that the following is legal:</p>
<pre><code>#!hs
data T a b where
    T1 :: a -&gt; b -&gt; T a b      -- Fine! Vanilla H-98
    T2 :: b -&gt; c -&gt; T a b      -- Fine! Existential c, but we can still map over &#39;b&#39;
    T3 :: b -&gt; T Int b         -- Fine! Constraint &#39;a&#39;, but &#39;b&#39; is still polymorphic

deriving instance Functor (T a)

{-
instance Functor (T a) where
    fmap f (T1 a b) = T1 a (f b)
    fmap f (T2 b c) = T2 (f b) c
    fmap f (T3 x)   = T3 (f x)
-}</code></pre>
<p><code>  but the following is not legal:</code></p>
<pre><code>#!hs
data T a b where
    T4 :: Ord b =&gt; b -&gt; T a b  -- No!  &#39;b&#39; is constrained
    T5 :: b -&gt; T b b           -- No!  &#39;b&#39; is constrained
    T6 :: T a (b,b)            -- No!  &#39;b&#39; is constrained</code></pre>
<p><code>  This restriction does not apply to derived </code></p>
<pre><code>Foldable</code></pre>
<p>instances. See the following section for more details.</p>
<p>=== Relaxed universality check for</p>
<pre><code>DeriveFoldable</code></pre>
<p>===</p>
<pre><code>DeriveFunctor</code></pre>
<p>and</p>
<pre><code>DeriveTraversable</code></pre>
<p>cannot be used with data types that use existential constraints, since the type signatures of</p>
<pre><code>fmap</code></pre>
<p>and</p>
<pre><code>traverse</code></pre>
<p>make this impossible. However,</p>
<pre><code>Foldable</code></pre>
<p>instances are unique in that they do not produce constraints, but only consume them. Therefore, it is permissible to derive</p>
<pre><code>Foldable</code></pre>
<p>instances for constrained data types (e.g., GADTs).</p>
<p>For example, consider the following GADT:</p>
<pre><code>#!hs
data T a where
    T1 :: Ord a =&gt; a -&gt; T a</code></pre>
<p>In the type signatures for</p>
<pre><code>fmap :: Functor t =&gt; (a -&gt; b) -&gt; t a -&gt; t b</code></pre>
<p>and</p>
<pre><code>traverse :: (Applicative f, Traversable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</code></pre>
<p>, the</p>
<pre><code>t</code></pre>
<p>parameter appears both in an argument and the result type, so pattern-matching on a value of</p>
<pre><code>t</code></pre>
<p>must not impose any constraints, as neither</p>
<pre><code>fmap</code></pre>
<p>nor</p>
<pre><code>traverse</code></pre>
<p>would typecheck.</p>
<pre><code>Foldable</code></pre>
<p>, however, only mentions</p>
<pre><code>t</code></pre>
<p>in argument types:</p>
<pre><code>#!hs
class Foldable t where
    fold :: Monoid m =&gt; t m -&gt; m
    foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m
    foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldr&#39; :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl&#39; :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldr1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
    foldl1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
    toList :: t a -&gt; [a]
    null :: t a -&gt; Bool
    length :: t a -&gt; Int
    elem :: Eq a =&gt; a -&gt; t a -&gt; Bool
    maximum :: forall a. Ord a =&gt; t a -&gt; a
    minimum :: forall a. Ord a =&gt; t a -&gt; a
    sum :: Num a =&gt; t a -&gt; a
    product :: Num a =&gt; t a -&gt; a</code></pre>
<p>Therefore, a derived</p>
<pre><code>Foldable</code></pre>
<p>instance for</p>
<pre><code>T</code></pre>
<p>typechecks:</p>
<pre><code>#!hs
instance Foldable T where
    foldr f z (T1 a) = f a z -- foldr :: Ord a =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; T a -&gt; b
    foldMap f (T1 a) = f a   -- foldMap :: (Monoid m, Ord a) =&gt; (a -&gt; m) -&gt; T a -&gt; m</code></pre>
<p>Deriving</p>
<pre><code>Foldable</code></pre>
<p>instances for GADTs with equality constraints could become murky, however. Consider this GADT:</p>
<pre><code>#!hs
data E a where
    E1 :: (a ~ Int) =&gt; a   -&gt; E a
    E2 ::              Int -&gt; E Int
    E3 :: (a ~ Int) =&gt; a   -&gt; E Int
    E4 :: (a ~ Int) =&gt; Int -&gt; E a</code></pre>
<p>All four</p>
<pre><code>E</code></pre>
<p>constructors have the same &quot;shape&quot; in that they all take an argument of type</p>
<pre><code>a</code></pre>
<p>(or</p>
<pre><code>Int</code></pre>
<p>, to which</p>
<pre><code>a</code></pre>
<p>is constrained to be equal). Does that mean all four constructors would have their arguments folded over? While it is possible to derive perfectly valid code which would do so:</p>
<pre><code>#!hs
instance Foldable E where
    foldr f z (E1 e) = f e z
    foldr f z (E2 e) = f e z
    foldr f z (E3 e) = f e z
    foldr f z (E4 e) = f e z

    foldMap f (E1 e) = f e
    foldMap f (E2 e) = f e
    foldMap f (E3 e) = f e
    foldMap f (E4 e) = f e</code></pre>
<p>it is much harder to determine which arguments are equivalent to</p>
<pre><code>a</code></pre>
<p>. Also consider this case:</p>
<pre><code>#!hs
data UnknownConstraints a where
    UC :: Mystery a =&gt; Int -&gt; UnknownConstraints a</code></pre>
<p>For all we know, it may be that</p>
<pre><code>a ~ Int =&gt; Mystery a</code></pre>
<p>. Does this mean that the</p>
<pre><code>Int</code></pre>
<p>argument in</p>
<pre><code>UC</code></pre>
<p>should be folded over?</p>
<p>To avoid these thorny edge cases, we only consider constructor arguments (1) whose types are <em>syntactically</em> equivalent to the last type parameter and (2) in cases when the last type parameter is a truly universally polymorphic. In the above</p>
<pre><code>E</code></pre>
<p>example, only</p>
<pre><code>E1</code></pre>
<p>fits the bill, so the derived</p>
<pre><code>Foldable</code></pre>
<p>instance is actually:</p>
<pre><code>#!hs
instance Foldable E where
    foldr f z (E1 e) = f e z
    foldr f z (E2 e) = z
    foldr f z (E3 e) = z
    foldr f z (E4 e) = z

    foldMap f (E1 e) = f e
    foldMap f (E2 e) = mempty
    foldMap f (E3 e) = mempty
    foldMap f (E4 e) = mempty</code></pre>
<p>To expound more on the meaning of criterion (2), we want not only to avoid cases like</p>
<pre><code>E2 :: Int -&gt; E Int</code></pre>
<p>, but also something like this:</p>
<pre><code>#!hs
data HigherKinded f a where
    HigherKinded :: f a -&gt; HigherKinded f (f a)</code></pre>
<p>In this example, the last type variable is instantiated with</p>
<pre><code>f a</code></pre>
<p>, which contains one type variable</p>
<pre><code>f</code></pre>
<p>applied to another type variable</p>
<pre><code>a</code></pre>
<p>. We would <em>not</em> fold over the argument of type</p>
<pre><code>f a</code></pre>
<p>in this case, because the last type variable should be <em>simple</em>, i.e., contain only a single variable without any application.</p>
<p>For the original discussion on this proposal, see <a href="https://ghc.haskell.org/trac/ghc/ticket/10447">#10447</a>.</p>
<p>== Alternative strategy for deriving</p>
<pre><code>Foldable` and `Traversable</code></pre>
<p>== We adapt the algorithms for</p>
<pre><code>-XDeriveFoldable` and `-XDeriveTraversable` based on that of `-XDeriveFunctor</code></pre>
<p>. However, there is an important difference between deriving the former two typeclasses and the latter one (as of GHC 8.2, addressing <a href="https://ghc.haskell.org/trac/ghc/ticket/11174">Trac #11174</a>), which is best illustrated by the following scenario:</p>
<pre><code>#!hs
data WithInt a = WithInt a Int# deriving (Functor, Foldable, Traversable)</code></pre>
<p>The generated code for the</p>
<pre><code>Functor</code></pre>
<p>instance is straightforward:</p>
<pre><code>#!hs
instance Functor WithInt where
  fmap f (WithInt a i) = WithInt (f a) i</code></pre>
<p>But if we use too similar of a strategy for deriving the</p>
<pre><code>Foldable` and `Traversable</code></pre>
<p>instances, we end up with this code:</p>
<pre><code>#!hs
instance Foldable WithInt where
  foldMap f (WithInt a i) = f a &lt;&gt; mempty

instance Traversable WithInt where
*  pure i</code></pre>
<p>This is unsatisfying for two reasons:</p>
<p>1. The</p>
<pre><code>Traversable` instance doesn&#39;t typecheck! `Int#` is of kind `#`, but `pure` expects an argument whose type is of kind `*`. This effectively prevents `Traversable</code></pre>
<p>from being derived for any datatype with an unlifted argument type (see <a href="https://ghc.haskell.org/trac/ghc/ticket/11174">Trac #11174</a>).</p>
<p>2. The generated code contains superfluous expressions. By the</p>
<pre><code>Monoid` laws, we can reduce `f a &lt;&gt; mempty` to `f a`, and by the `Applicative` laws, we can reduce `fmap WithInt (f a) &lt;*&gt; pure i` to `fmap (\b -&gt; WithInt b i) (f a)</code></pre>
<p>.</p>
<p>We can fix both of these issues by incorporating a slight twist to the usual algorithm that we use for</p>
<pre><code>-XDeriveFunctor</code></pre>
<p>. The differences can be summarized as follows:</p>
<p>1. In the generated expression, we only fold over arguments whose types mention the last type parameter. Any other argument types will simply produce useless</p>
<pre><code>mempty`s or `pure</code></pre>
<p>s, so they can be safely ignored.</p>
<p>2. In the case of</p>
<pre><code>-XDeriveTraversable`, instead of applying `ConName`, we apply `\b_i ... b_k -&gt; ConName a_1 ... a_n</code></pre>
<p>, where</p>
<ul>
<li><pre><code>ConName` has `n</code></pre>
<p>arguments</p></li>
<li><pre><code>{b_i, ..., b_k}` is a subset of `{a_1, ..., a_n}` whose indices correspond to the arguments whose types mention the last type parameter. As a consequence, taking the difference of `{a_1, ..., a_n}` and `{b_i, ..., b_k}` yields the all the argument values of `ConName` whose types do not mention the last type parameter. Note that `[i, ..., k]</code></pre>
<p>is a strictly increasing</p></li>
</ul>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="llvm-back-end-design">LLVM Back-end Design</h1>
<p>The current design tries to fit into GHC's pipeline stages as an alternative to the C and NCG back-ends as seamlessly as possible. This allows for quicker development and focus on the core task of LLVM code generation.</p>
<p>The LLVM pipeline works as follows:</p>
<ul>
<li>New path for LLVM generation, separate from C and NCG. (path forks at compiler/main/CodeOutput.lhs, same place where C and NCG fork).</li>
<li>LLVM code generation will output LLVM assembly code.</li>
<li>The LLVM assembly code is translated to an object file as follows
<ul>
<li>The LLVM optimizer is run which is a series of bitcode to bitcode optimization passes (using the
<pre><code>llc</code></pre>
<p>tool).</p></li>
<li>Finally an object file is created from the LLVM bitcode (using the
<pre><code>llc</code></pre>
<p>tool)</p></li>
</ul></li>
<li>This brings the LLVM path back to the other back-ends.</li>
<li>The final state is the Link stage, which uses the system linker as with the other back-ends.</li>
</ul>
<p>Here is a diagram of the pipeline:</p>
<pre><code>Cmm -&gt; (codeOutput) ---&gt;(ncg) Assembler      --&gt;(mangler, splitter) --&gt; (&#39;As&#39; phase) -----&gt; Object Code --&gt; (link) --&gt; executable
                        \---&gt; (llvm) LLVM IR --&gt; LLVM Optimizer     --&gt; (&#39;llc&#39; phase) -----/</code></pre>
<p>This approach was the easiest and thus quickest way to initially implement the LLVM back-end. Now that it is working, there is some room for additional optimisations. A potential optimisation would be to add a new linker phase for LLVM. Instead of each module just being compiled to native object code ASAP, it would be better to keep them in the LLVM bitcode format and link all the modules together using the LLVM linker. This enable all of LLVM's link time optimisations. All the user program LLVM bitcode will then be compiled to a native object file and linked with the runtime using the native system linker.</p>
<h1 id="implementation">Implementation</h1>
<h2 id="framework">Framework</h2>
<ul>
<li>New <strong>-fllvm</strong> code generation pipeline, involved modifying:
<ul>
<li><pre><code>main/CodeOutput.lhs</code></pre>
<p>- Selects appropriate back-end for code generation (C, NCG, LLVM).</p></li>
<li><pre><code>main/DynFlags.hs</code></pre>
<p>- Stores GHC configuration (command line options, compile time options... ect). Added</p>
<pre><code>HscLlvm</code></pre>
<p>target type.</p></li>
<li><pre><code>ghc.cabal.in</code></pre>
<p>- Stores modules/files to compile for ghc. Added new LLVM files and directory stored under</p>
<pre><code>llvmGen`, and new CPP flag to enable the LLVM code generator (`-DLLVM</code></pre>
<p>).</p></li>
<li><pre><code>ghc.mk</code></pre>
<p>- Added new</p>
<pre><code>GhcWithLlvmCodeGen` option which can be set in `build.mk` to `YES</code></pre>
<p>to enable the LLVM code generator.</p></li>
<li><pre><code>main/DriverPhases.hs</code></pre>
<p>- Added</p>
<pre><code>LlvmAs</code></pre>
<p>phase to invoke the compilation of LLVM bitcode/IR to an object file. After this phase linking can occur.</p></li>
<li><pre><code>main/DriverPipeline.hs</code></pre>
<p>- Added code for new</p>
<pre><code>LlvmAs`, `LlvmOpt` and `LlvmLlc</code></pre>
<p>phases.</p>
<ul>
<li><pre><code>LlvmAs</code></pre>
<p>- Invokes</p>
<pre><code>llvm-as` tool to compile a llvm assembly file (&#39;.ll&#39;) to a bitcode file (`.bc</code></pre>
<p>).</p></li>
<li><pre><code>LlvmOpt</code></pre>
<p>- Invokes the llvm</p>
<pre><code>opt` tool to optimise the module. Just use the llvm standard optimisation groups of `O1`, `O2`, `O3</code></pre>
<p>, depending on the optimisation level passed to 'ghc' by the user.</p></li>
<li><pre><code>LlvmLlc</code></pre>
<p>- Invokes the llvm</p>
<pre><code>llc</code></pre>
<p>tool to generate the machine code ('.s' file) from the optimised bitcode. 'As' stage runs next, part of existing 'ghc' pipeline.</p></li>
</ul></li>
<li><pre><code>SysTools.lhs</code></pre>
<p>- Stores the path and default settings of the system tools needed, so for LLVM back-end this is</p>
<pre><code>llvm-as`, `opt` and `llc</code></pre>
<p>.</p></li>
</ul></li>
</ul>
<p>The LLVM pipeline works as specified above. Code generation phase occurs, using the</p>
<pre><code>dflags</code></pre>
<p>option data the appropriate generator is selected (which is the Llvm back-end is</p>
<pre><code>-fllvm` has been specified on the command line). After code generation, the next phase is determined, this is done from the `HscLlvm` target data constructor which is selected at ghc startup by &lt;pre&gt;DynFlags.hs</code></pre>
<p>. The next phase is `LlvmAs` which will compile the text IR to an LLVM bitcode file (equivalent to `llvm-as` tool). After this the `LlvmLlc` phase is run, which produces a native object file from the llvm bitcode file (equivalanet to the `llc` tool). At this stage, the output from all three back-ends should be 'equivalent'. After this phase, the `StopLn</p>
</pre>
<p>, or linking phase occurs which should result in the end result. Compiling some Haskell code with the c-backend and some with the llvm-backend and linking them together is supported.</p>
<h2 id="llvm-code-generation">LLVM Code Generation</h2>
<p>For LLVM code generation we need a method for representing and generating LLVM code. The <a href="http://llvm.org/docs/FAQ.html#langirgen">LLVM FAQ</a> suggest the following possible approaches:</p>
<ul>
<li>Call into LLVM Libraries using FFI (can probably use <a href="http://hackage.haskell.org/package/llvm">Haskell LLVM Bindings</a>)</li>
<li>Emit LLVM Assembly (approach taken by <a href="http://www.cs.uu.nl/wiki/Ehc/WebHome">EHC's</a> LLVM Back-end, can use the <a href="https://subversion.cs.uu.nl/repos/project.UHC.pub/trunk/EHC/src/ehc/LLVM.cag">module</a> developed by them for this)</li>
<li>Emit LLVM Bitcode (can't see any reason to do this)</li>
</ul>
<p>The approach taken was to use the LLVM module from <a href="http://www.cs.uu.nl/wiki/Ehc/WebHome">EHC</a>. This module contains an abstract syntax representation of LLVM Assembly and the ability to pretty print it. It has been heavily modified to increase its language coverage as it was missing several LLVM constructs which were needed. Ideally we would like to add a second pretty printer which calls into the LLVM C++ API to generate LLVM Bitcode. This should hopefully decrease the compile times and make the back-end more resilient to future changes to LLVM Assembly. The LLVM Haskell binding (first option) wasn't used as it represents LLVM at a very high level, which isn't appropriate for the back-end.</p>
<h2 id="register-pinning">Register Pinning</h2>
<p>The new back-end supports a custom calling convention to place the STG virtual registers into specific hardware registers. The current approach taken by the C back-end and NCG of having a fixed assignment of STG virtual registers to hardware registers for performance gains is not implemented in the LLVM back-end. Instead, it uses a custom calling convention to support something semantically equivalent to register pinning. The custom calling convention passes the first N variables in specific hardware registers, thus guaranteeing on all function entries that the STG virtual registers can be found in the expected hardware registers. This approach is believed to provide better performance than the register pinning used by NCG/C back-ends as it keeps the STG virtual registers mostly in hardware registers but allows the register allocator more flexibility and access to all machine registers.</p>
<p>For some more information about the use of a custom calling convention see <a href="http://www.nondot.org/sabre/LLVMNotes/GlobalRegisterVariables.txt">here (Discussion between Chris Lattner and David Terei)</a></p>
<h2 id="code-generation">Code Generation</h2>
<p>Code generation consists of translating a list of</p>
<pre><code>GenCmmTop` data types to LLVM code. `GenCmmTop</code></pre>
<p>has the following form:</p>
<pre><code>data GenCmmTop d h g
  = CmmProc          -- Function
        h            -- Extra header such as the info table
        CLabel       -- Procedure name
        CmmFormals   -- Argument locals live on entry
        g            -- Control flow graph
 
 | CmmData           -- Static data
        Section      -- Type
        [d]          -- Data

data BlockId = BlockId Unique
data GenBasicBlock i = BasicBlock BlockId [i]
type CmmBasicBlock = GenBasicBlock CmmStmt

newtype ListGraph i = ListGraph [[GenBasicBlock i]

type RawCmmTop = GenCmmmTop CmmStatic [CmmStatic] (ListGraph CmmStmt)
-- new type RawCmm = Cmm [RawCmmTop] : A list version of RawCmmTop, actual code is different, but its effectively this.</code></pre>
<p>That is, it consists of two types, static data and functions. Each can largely be handled separately. Just enough information is needed such that pointers can be constructed to them and in many cases this information can be gathered from assumptions and constraints on Cmm.</p>
<p>After all the polymorphic types are bound we get this:</p>
<pre><code>RawCmm = [
    CmmProc [CmmSatic] CLabel [LocalReg] [BlockId [CmmStmt]]
  | CmmData Section [CmmStatic]
]

data Section = Text | Data | ReadOnlyData | RelocatableReadOnlyData | UninitialisedData | ReadOnlyData16 | OtherSection String</code></pre>
<p>The code generator lives in</p>
<pre><code>llvmGen` with the driver being `llvmGen/LlvmCodeGen.lhs</code></pre>
<p>.</p>
<p>A large part of the code generation is keeping track of defined variables/functions and their type. An</p>
<pre><code>LlvmEnv</code></pre>
<p>construct is used for this. It is simply a dictionary storing function/variable names with their corresponding type information. This is used to create correct references/pointers between variables and functions.</p>
<h3 id="unregisterised-vs.-registerised">Unregisterised Vs. Registerised</h3>
<p>Code generation can take place in two general modes,</p>
<pre><code>unregisterised` and `registerised`. There are two major differences from a back-end code generation point of view. Firstly, in unregisterised mode a optimisation feature called &lt;pre&gt;TABLES_NEXT_TO_CODE</code></pre>
<p>is disabled. This means that the `h` field of `CmmProc` is empty. In registerised mode it instead contains the `CmmStatic` data for the procedures info table which must be placed just before the procedure in the generated code so that both the info table and procedure can be accessed through one pointer. This optimisation can be disabled separately though in `registerised</p>
</pre>
<p>mode.</p>
<p>The other major change is the use of pinned global registers. The</p>
<pre><code>Cmm` language includes a concept called registers. These are used like machine registers or variables in C to store the result of expressions. Unlike `LLVM` they are mutable. `Cmm</code></pre>
<p>includes two types of registers as you can see below:</p>
<pre><code>data CmmReg 
  = CmmLocal  LocalReg
  | CmmGlobal GlobalReg
  deriving( Eq, Ord )

data LocalReg = LocalReg Unique CmmType</code></pre>
<p>A</p>
<pre><code>LocalReg` is a temporary general purpose register used in a procedure with scope of a single procedure. A `GlobalReg` on the other hand has global scope and a specific use. They are used just like machine registers, with a Stack Pointer and Heap Pointer registers creating a virtual machine (`STG`). `GlobalReg</code></pre>
<p>is of the form:</p>
<pre><code>data GlobalReg
  -- Argument and return registers
  = VanillaReg          -- pointers, unboxed ints and chars
    {-# UNPACK #-} &lt;nowiki&gt;Int&lt;/nowiki&gt; -- its number
    VGcPtr

  | FloatReg        -- single-precision floating-point registers
    {-# UNPACK #-} &lt;nowiki&gt;Int&lt;/nowiki&gt; -- its number

  | DoubleReg       -- double-precision floating-point registers
    {-# UNPACK #-} &lt;nowiki&gt;Int&lt;/nowiki&gt; -- its number

  | LongReg         -- long int registers (64-bit, really)
    {-# UNPACK #-} &lt;nowiki&gt;Int&lt;/nowiki&gt; -- its number

  -- STG registers
  | Sp          -- Stack ptr; points to last occupied stack location.
  | SpLim       -- Stack limit
  | Hp          -- Heap ptr; points to last occupied heap location.
  | HpLim       -- Heap limit register
  | CurrentTSO      -- pointer to current thread&#39;s TSO
  | CurrentNursery  -- pointer to allocation area
  | HpAlloc     -- allocation count for heap check failure

        -- We keep the address of some commonly-called 
        -- functions in the register table, to keep code
        -- size down:
  | EagerBlackholeInfo  -- stg_EAGER_BLACKHOLE_info
  | GCEnter1        -- stg_gc_enter_1
  | GCFun       -- stg_gc_fun

  -- Base offset for the register table, used for accessing registers
  -- which do not have real registers assigned to them.  This register
  -- will only appear after we have expanded GlobalReg into memory accesses
  -- (where necessary) in the native code generator.
  | BaseReg

  -- Base Register for PIC (position-independent code) calculations
  -- Only used inside the native code generator. It&#39;s exact meaning differs
  -- from platform to platform (see module PositionIndependentCode).
  | PicBaseReg

  deriving( Show )</code></pre>
<p>In unregisterised mode these global registers are all just stored in memory in the heap. A specific pass operating on Cmm that takes place just before code generation thus transforms code such as:</p>
<pre><code>__stginit_ZCMain() {
        { update_frame: &lt;none&gt;
        }
    cfF:
        Sp = Sp + 4;
        jump (I32[Sp - 4]) ();
}</code></pre>
<p>into the following unregisterised form for code generation:</p>
<pre><code>__stginit_main::Main() {
        { []
        }
    crF:
        I32[MainCapability+92] = I32[MainCapability+92] + 4;
        jump (I32[I32[MainCapability+92] - 4]) ();
}</code></pre>
<p>Where</p>
<pre><code>MainCapability</code></pre>
<p>is a label to the start of a RTS defined structure storing all the global registers.</p>
<p>In registerised mode as many of these global registers are assigned permanently to fixed hardware registers. This is done as it greatly improves performance. As these registers are accessed very frequently needing to load and store to memory for accessing adds a great cost. So for example on</p>
<pre><code>x86` the following map between `Cmm` global registers and `x86</code></pre>
<p>hardware registers exists:</p>
<pre><code>Base -&gt; %EBX
Sp   -&gt; %EBP
Hp   -&gt; %EDI
R1   -&gt; %ESI</code></pre>
<p>These are all the available</p>
<pre><code>callee save` registers on x86. `callee save` are used as in ghc generated code now saving and restoring of these registers are needed due to there new special use and because GHC uses continuation passing style, so a `&#39;ret&#39;` statement is never actually generated. And since they are `callee save`, foreign code can also be called without any need to handle the `Cmm</code></pre>
<p>registers.</p>
<h2 id="cmmdata">CmmData</h2>
<pre><code>CmmData</code></pre>
<p>takes the following form:</p>
<pre><code>newtype CmmData = CmmData Section [CmmStatic]

data CmmStatic
  = CmmStaticLit      CmmLit  -- static value
  | CmmUninitialised  Int     -- n bytes of uninitialised data
  | CmmAlign          Int     -- align to next N byte boundary
  | CmmDataLabel      CLabel  -- label current position in code
  | CmmString         [Word8] -- string of 8 bit values

data CmmLit
  = CmmInt            Integer  Width    -- 2 compliments, truncated int
  | CmmFloat          Rational Width    -- float
  | CmmLabel          CLabel            -- &amp;l1
  | CmmLabelOff       CLabel Int        -- &amp;l1 + offset
  | CmmLabelDiffOff   CLabel CLabel Int -- &amp;l1 - &amp;l2 + offset
  | CmmBlock          BlockId           -- address of code label
  | CmmHighStackMark                    -- max stack space used during a procedure

data Width = W8 | W16 | W32 | W64 | W80 | W128</code></pre>
<p>Code generation takes place mainly in</p>
<pre><code>llvmGen/LlvmCodeGen/Data.hs</code></pre>
<p>, driven by the main Llvm compiler driver, {{llvmGen/LlvmCodeGen.lhs</p>
</pre>
<p>.</p>
<p>The code generation for data occurs in two phases, firstly the types and all data is generated except for address values. Then the address values are resolved. This two step method is used as in the first pass, we don't know if a address refers to an external address or a procedure/data structure in the current LLVM module. We also need the type information in LLVM to create a pointer.</p>
<h3 id="st-pass-generation">1st Pass : Generation</h3>
<p>All</p>
<pre><code>CmmStatic</code></pre>
<p>is translated to LLVM structures.</p>
<h2 id="cmmstaticlit">CmmStaticLit</h2>
<p>These are translated when possible as follows:</p>
<ul>
<li><pre><code>CmmInt` -&gt; Reduced to Int and then an appropriate `LMInt</code></pre>
<p>of correct size is created. As LLVM supports any bit size, this is very straight forward.</p></li>
<li><pre><code>CmmFloat` -&gt; Translated to a double, detecting NAN and INFINITY correctly. Then correct LLVM type (`float`, `double`, `float80`, `float128</code></pre>
<p>) is selected.</p></li>
<li><pre><code>CmmLabel</code></pre>
<p>-&gt; Left untranslated at first, later resolved once we have determined types. As pointers are cast to word size ints, we can still determine types.</p></li>
<li><pre><code>CmmLabelOff</code></pre>
<p>-&gt; As above.</p></li>
<li><pre><code>CmmLabelDiffOff</code></pre>
<p>-&gt; As above.</p></li>
<li><pre><code>CmmBlock` -&gt; `BlockId` is changed to a `CLabel` and then treated as a `CmmLabel</code></pre>
<p>static type.</p></li>
<li><pre><code>CmmHighStackMark</code></pre>
<p>-&gt; Panic occurs if this type is encountered.</p></li>
</ul>
<h4 id="cmmuninitialised">CmmUninitialised</h4>
<p>For this, a zeroed array of</p>
<pre><code>8bit</code></pre>
<p>values is created of correct size.</p>
<h4 id="cmmalign-cmmdatalabel">CmmAlign &amp; CmmDataLabel</h4>
<p>The LLVM back-end can't handle</p>
<pre><code>CmmAlign` or `CmmDataLabel`. A panic occurs if either is encountered. A `CmmDataLabel` is expected at the very start of each list of `CmmStatic</code></pre>
<p>. It is removed and used as the name for the structure and constant instance.</p>
<h4 id="cmmstring">CmmString</h4>
<p>This is translated into a LLVM string. Ascii characters are used when they are printable, escaped hex values otherwise. A null termination is added.</p>
<h3 id="nd-pass-resolution">2nd Pass : Resolution</h3>
<p>After the first pass, all types have been determined and all data translated except for address values (CLabel's). All generated llvm data is added to a Map of string to</p>
<pre><code>LlvmType`, string being the data structure name. All `CmmProc&#39;s</code></pre>
<p>are added to the map as well, they don't need to be properly passed though, just their names retrieved as they have a constant type of void return and no parameters.</p>
<p>Now appropriate pointers can be generated using the type information from the map and LLVM's</p>
<pre><code>getelementptr</code></pre>
<p>instruction. These are then all passed to int's to allow the types of structures to be determined in advance. If a pointer doesn't have a match in the Map, it is assumed to refer to an external (outside of this module) address. An external reference is declared for this address as:</p>
<pre><code>@label = external global [0 * i32]</code></pre>
<p>Where i32 is the pointer size. (i64 if on 64 bit).</p>
<h2 id="cmmproc">CmmProc</h2>
<p>A Cmm procedure is made up of a list of basic blocks, with each basic block being comprised of a list of CmmStmt</p>
<h1 id="desugaring-instance-declarations">Desugaring instance declarations</h1>
<p>These notes compare various ways of desugaring Haskell instance declarations. The tradeoffs are more complicated than I thought!</p>
<h2 id="basic-stuff">Basic stuff</h2>
<pre><code>class C a where
  opF :: a -&gt; Int
  opG :: a -&gt; Bool
  opG x = True

instance C Int where
* </code></pre>
<p>These desugar to the following Core:</p>
<pre><code>data C a = DC (a-&gt;Int) (a-&gt;Bool)

opF :: C a -&gt; a -&gt; Int
opF d = case d of { DC opf _ -&gt; opf }

opG :: C a -&gt; a -&gt; Bool
opG d = case d of { DC _ opg -&gt; opg }

$dmopG :: C a -&gt; a -&gt; Bool
$dmopG d x = True

Rec {
  dCInt :: C Int
  dCInt = DC opFI opGI
  
  opFI :: Int -&gt; Int
* 

  opGI :: Int -&gt; Bool
  opGI = $dmopG dCInt
}</code></pre>
<p>(Notation: I am omitting foralls, big lambdas, and type arguments. I'm also using</p>
<pre><code>f x = e` rather than `f = \x.e</code></pre>
<p>.)</p>
<p>Points worth noting:</p>
<ul>
<li>The class gives rise to an eponymous data type (in GHC it is actually</li>
</ul>
<p><code>  called </code></p>
<pre><code>:TC</code></pre>
<p>), the dictionary.</p>
<ul>
<li>There is an eponymous top-level selector function for each class method,</li>
</ul>
<pre><code>opF` and `opG</code></pre>
<p>in this case.</p>
<ul>
<li>The default method for
<pre><code>opG` becomes a top-level function `$dmopG</code></pre>
<p>.</p></li>
</ul>
<p><code>  It takes the </code></p>
<pre><code>(C a)</code></pre>
<p>dictionary a argument because the RHS is allowed to call</p>
<p><code>  other methods of C.</code></p>
<ul>
<li>The instance declaration defines a dictionary
<pre><code>dCInt</code></pre>
<p>. Notice</p></li>
</ul>
<p><code>  that it's recursive, because we must pass </code></p>
<pre><code>dCInt` to `opGI</code></pre>
<p>.</p>
<ul>
<li>Crucially, the simplifier is careful not to choose
<pre><code>dCInt</code></pre>
<p>as</p></li>
</ul>
<p><code>  a loop breaker, and hence if it sees </code></p>
<pre><code>case dCInt of ...</code></pre>
<p>it</p>
<p><code>  can simplify the </code></p>
<pre><code>case</code></pre>
<p>.</p>
<ul>
<li>If
<pre><code>$dmopG</code></pre>
<p>is inlined, the recursion is broken anyway.</p></li>
</ul>
<h2 id="dictionary-functions">Dictionary functions</h2>
<p>Now consider an instance declaration that has a context:</p>
<pre><code>instance C a =&gt; C [a] where
  opF xs = case xs of 
             []     -&gt; 0
             (y:ys) -&gt; opF y + opf ys</code></pre>
<p>Here is one way to desugar it.</p>
<pre><code>dCList :: C a -&gt; C [a]
dCList d_a = letrec {
           d_as = DC opfl opgl

               opfl xs = case xs of
                          [] -&gt; 0
                          (y:ys) -&gt; opF d_a y + opF d_as ys

               opgl = $dmopG d_as }

             } in d_as</code></pre>
<p>Notice that</p>
<ul>
<li>If we inline the selector
<pre><code>opF` in `opF d_as</code></pre>
<p>, then</p></li>
</ul>
<p><code>  we can simplify </code></p>
<pre><code>opfl</code></pre>
<p>to give a directly-recursive function:</p>
<pre><code>               oplf xs = case xs of
                          [] -&gt; 0
                          (y:ys) -&gt; opF d_a y + opf ys</code></pre>
<p><code>  This is important.</code></p>
<ul>
<li>The BAD THING is that
<pre><code>dCList</code></pre>
<p>is big, and hence won't be inlined.</p></li>
</ul>
<p><code>  That's bad because it means that if we see</code></p>
<pre><code>   ...(opF (dCList dCInt))...</code></pre>
<p><code>  we don't get to call </code></p>
<pre><code>opfl` directly. Instead we&#39;ll call `dCList</code></pre>
<p>, build</p>
<p><code>  the dictionary, do the selection, etc.  So specialiation won't happen,</code><br />
<code>  even when all the types are fixed.</code></p>
<h2 id="the-inline-strategy">The INLINE strategy</h2>
<p>An obvious suggestion, which GHC implemented for a long time, is to give</p>
<pre><code>dCList</code></pre>
<p>an INLINE pragma. Then it'll inline at every call site, the dictionary will be visible to the selectors, and good things happen.</p>
<p>But it leads to a huge code blow-up in some cases. We call these dictionary functions a lot, often in a nested way, and we know programs for which the INLINE-all-dfuns approach generates gigantic code. (Example: Serge's DoCon.)</p>
<h2 id="the-out-of-line-a-strategy">The out-of-line (A) strategy</h2>
<p>The INLINE strategy would make sense if</p>
<pre><code>dCList</code></pre>
<p>could be guaranteed small. Suppose the original instance declaration had been like this:</p>
<pre><code>instance C a =&gt; C [a] where
  opF = opF_aux

opF_aux :: C a =&gt; a -&gt; Int
opF_aux xs = case xs of 
               []     -&gt; 0
               (y:ys) -&gt; opF y + opf ys</code></pre>
<p>This is exactly what GHC 6.10 now does, behind the scenes. Desugaring just as above, we'd get the following:</p>
<pre><code>Rec {
  dCList :: C a -&gt; C [a]
  dCList d_a = letrec {
             d_as = DC opfl opgl
                 opfl = opF_aux d_a
                 opgl = $dmopG d_as
               } in d_as

  opF_aux :: C a -&gt; a -&gt; Int
  opF_aux d_a xs = let { d_as = dCList d_a } in
                   case xs of
                     []     -&gt; 0
                     (y:ys) -&gt; opF d_a y + opF d_as ys
}</code></pre>
<p>Notice that</p>
<ul>
<li><pre><code>dCList</code></pre>
<p>is guaranteed small, and could reasonably be INLINEd</p></li>
</ul>
<p><code>  at every call site.  This good because it exposes the dictionary</code><br />
<code>  structure to selectors.</code></p>
<ul>
<li><pre><code>dCList` and `opF_aux</code></pre>
<p>are mutually recursive. But if we</p></li>
</ul>
<p><code>  avoid choosing </code></p>
<pre><code>dCList</code></pre>
<p>as the loop breaker we can inline</p>
<pre><code>dCList` into `opF_aux`, and then the `opF</code></pre>
<p>selector</p>
<p><code>  can &quot;see&quot; the dictionary structure, and </code></p>
<pre><code>opF_aux</code></pre>
<p>simplifies, thus:</p>
<pre><code>  let { d_as = dCList d_a } in
  case xs of
    []     -&gt; 0
    (y:ys) -&gt; opF d_a y + opF d_as ys

=                  { Inline dCList }
  let { d_as = letrec {
             d_as = DC opfl opgl
                 opfl = opF_aux d_a
                 opgl = $dmopG d_as
               } in d_as
   } in
  case xs of
    []     -&gt; 0
    (y:ys) -&gt; opF d_a y + opF d_as ys

=                  { Float the letrec }
  letrec { d_as = DC opfl opgl
           opfl = opF_aux d_a
           opgl = $dmopG d_as
   } in
  case xs of
    []     -&gt; 0
    (y:ys) -&gt; opF d_a y + opF d_as ys

=                  { Inline opF and d_as }
  case xs of
    []     -&gt; 0
    (y:ys) -&gt; opF d_a y + opF_aux d_a ys</code></pre>
<p><code>  Good!  Now </code></p>
<pre><code>opF_aux</code></pre>
<p>is self-recursive as it should be.</p>
<p><code>  The same thing happens with two mutually recursive methods</code></p>
<ul>
<li>BUT notice that we reconstruct the
<pre><code>(C [a])</code></pre>
<p>dictionary on</p></li>
</ul>
<p><code>  each iteration of the loop.  As Ganesh points out in #3073, that</code><br />
<code>  is sometimes bad.</code></p>
<h2 id="the-out-of-line-b-strategy">The out-of-line (B) strategy</h2>
<p>We can avoid reconstructing the dictionary by passing it to</p>
<pre><code>opF_aux</code></pre>
<p>, by recasting latter thus:</p>
<pre><code>instance C a =&gt; C [a] where
  opF = opF_aux

opF_aux :: (C [a], C a) =&gt; a -&gt; Int
opF_aux xs = case xs of 
               []     -&gt; 0
               (y:ys) -&gt; opF y + opf ys</code></pre>
<p>Notice the extra</p>
<pre><code>C [a]` in the context of `opF_aux</code></pre>
<p>. (Remember this is all internal to GHC.) Now the same desugaring does this:</p>
<pre><code>  dCList :: C a -&gt; C [a]
  dCList d_a = letrec {
             d_as = DC opfl opgl
                 opfl = opF_aux d_a
                 opgl = $dmopG d_as
               } in d_as

  opF_aux :: C [a] -&gt; C a -&gt; a -&gt; Int
  opF_aux d_as d_a xs = case xs of
                          []     -&gt; 0
                          (y:ys) -&gt; opF d_a y + opF d_as ys</code></pre>
<p>The two definitions aren't even recursive. BUT now that</p>
<pre><code>d_as</code></pre>
<p>is an <em>argument</em> of</p>
<pre><code>opF_aux</code></pre>
<p>, the latter can't &quot;see&quot; that it's always a dictionary! Sigh. As a result, the recursion in</p>
<pre><code>opF_aux</code></pre>
<p>always indirects through the (higher order) dictionary argument, using a so-called &quot;unknown&quot; call, which is <em>far</em> less efficient than direct recursion.</p>
<p>Note also that</p>
<ul>
<li>Typechecking
<pre><code>opF_aux</code></pre>
<p>is a bit fragile; see #3018. Trouble is that</p></li>
</ul>
<p><code>  when a constraint </code></p>
<pre><code>(C [a])</code></pre>
<p>arises in its RHS there are two ways</p>
<p><code>  of discharging it: by using the argument </code></p>
<pre><code>d_as</code></pre>
<p>directly, or by</p>
<p><code>  calling </code></p>
<pre><code>(dCList d_a)</code></pre>
<p>. As #3018 shows, it's hard to guarantee that</p>
<p><code>  we'll do the former.</code></p>
<h2 id="user-inline-pragmas-and-out-of-line-a">User INLINE pragmas and out-of-line (A)</h2>
<p>There is another difficulty with the out-of-line(A) strategy, that is currently unsolved. Consider something like this:</p>
<pre><code>  instance C a =&gt; C (T a) where
     {-# INLINE opF #-}
     opF x = if opG x then 1 else 2</code></pre>
<p>Then we'll desugar to something like this:</p>
<pre><code>Rec {
  dCT :: C a -&gt; C (T a)
  {-# INLINE dCT #-}
  dCT d_a = ...opF_aux...

  {-# INLINE opF_aux #-}
  opF_aux d_a = ...dCT...
}</code></pre>
<p>The INLINE on</p>
<pre><code>dCT` is added by the compiler; the INLINE on `opF_aux</code></pre>
<p>is just propagated from the users's INLINE pragma... maybe the RHS is big.</p>
<p>Now the difficulty is that we GHC currently doesn't inline into the RHS of an INLINE function (else you'd get terrible code blowup). So the recursion between</p>
<pre><code>dCT` and `opF_aux</code></pre>
<p>is not broken. One of the two must be chosen as loop breaker, and the simplifier chooses</p>
<pre><code>opF_aux</code></pre>
<p>. Ironcially, therefore the user INLINE pragma has served only to guarantee that it <em>won't</em> be inlined!</p>
<p>(This issue doesn't arise with out-of-line(B) because (B) doesn't make</p>
<pre><code>dCT` and `opF_aux</code></pre>
<p>mutually recursive.)</p>
<h2 id="summary">Summary</h2>
<p>Here are the current (realistic) options:</p>
<ul>
<li>Out-of-line(A): GHC 6.10 does this.
<ul>
<li>Good: recursive methods become directly mutually-recursive</li>
<li>Bad: lack of memoisation</li>
<li>Bad: difficulty with user INLINE pragmas</li>
</ul></li>
</ul>
<ul>
<li>Out-of-line(B)
<ul>
<li>Good: memoisation works</li>
<li>Very bad: recursive methods iterate only via &quot;unknown&quot; calls.</li>
<li>Good: no difficulty with user INLINE pragmas</li>
</ul></li>
</ul>
<p>My current difficulty is that I see no way to get all the good things at once.</p>
<p>PS: see also the comments at the start of</p>
<pre><code>compiler/typecheck/TcInstDcls.lhs</code></pre>
<p>, which cover some of the same ground.</p>
<h1 id="bugs-other-problems">Bugs &amp; Other Problems</h1>
<p>I've moved all known bugs into the trac bug database, the can be found <a href="http://hackage.haskell.org/trac/ghc/query?status=infoneeded&amp;status=merge&amp;status=new&amp;status=patch&amp;component=Compiler+%28LLVM%29&amp;order=priority&amp;col=id&amp;col=summary&amp;col=status&amp;col=type&amp;col=priority&amp;col=milestone&amp;col=component">here</a></p>
<h1 id="compiling-more-than-one-module-at-once">Compiling more than one module at once</h1>
<p>When compiling a single module, we can assume that all of our dependencies have already been compiled, and query the environment as necessary when we need to do things like look up interfaces to find out what the types in our dependencies are. When we compile more than module at once, as in</p>
<pre><code>--make</code></pre>
<p>, things get a bit more complicated:</p>
<p>1. We have to analyze the dependency structure of the program in question, and come up with a plan for how to compile the various modules, and</p>
<p>2. We have an opportunity to cache and reuse information from interface files which we may load from the environment. This is why, for example,</p>
<pre><code>ghc --make</code></pre>
<p>outperforms parallel one-shot compilation on one core.</p>
<p>This discussion is going to omit concerns related to dynamic code loading in GHC (as would be the case in GHCi).</p>
<h2 id="the-overall-driver">The overall driver</h2>
<p>The meat of this logic is in <a href="GhcFile(compiler/main/GhcMake.hs)" class="uri" title="wikilink">GhcFile(compiler/main/GhcMake.hs)</a>, with primary entry point the function</p>
<pre><code>load` (in the case of `--make`, this function is called with `LoadAllTargets`, instructing all target modules to be compiled, which is stored in `hsc_targets</code></pre>
<p>).</p>
<h3 id="dependency-analysis-1">Dependency analysis</h3>
<p>Dependency analysis is carried out by the</p>
<pre><code>depanal` function; the resulting `ModuleGraph` is stored into `hsc_mod_graph`. Essentially, this pass looks at all of the imports of the target modules (`hsc_targets`), and recursively pulls in all of their dependencies (stopping at package boundaries.) The resulting module graph consists of a list of `ModSummary</code></pre>
<p>(defined in <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a>), which record various information about modules prior to compilation (recompilation checking, even), such as their module identity (the current package name plus the module name), whether or not the file is a boot file, where the source file lives. Dependency analysis inside GHC is often referred to as **downsweep**.</p>
<p>ToDo: say something about how hs-boot files are</p>
<p>The dependency analysis is cached (in</p>
<pre><code>hsc_mod_graph`), so later calls to `depanal` can reuse this information. (This is not germane for `--make`, which only calls `depanal` once.)  `discardProg` deletes this information entirely, while `invalidateModSummaryCache</code></pre>
<p>simply &quot;touches&quot; the timestamp associated with the file so that we resummarize it.</p>
<p>The result of dependency analysis is topologically sorted in</p>
<pre><code>load` by `topSortModuleGraph</code></pre>
<p>.</p>
<h3 id="recompilation-checking-and-stability">Recompilation checking and stability</h3>
<p>See also the page on [wiki:Commentary/Compiler/RecompilationAvoidance recompilation avoidance].</p>
<p>ToDo: say something about stability; it's per SCC</p>
<h3 id="compilation">Compilation</h3>
<p>Compilation, also known as **upsweep**, walks the module graph in topological order and compiles everything. Depending on whether or not we are doing parallel compilation, this implemented by</p>
<pre><code>upsweep` or by `parUpsweep</code></pre>
<p>. In this section, we'll talk about the sequential upsweep.</p>
<p>The key data structure which we are filling in as we perform compilation is the **home package table** or HPT (</p>
<pre><code>hsc_HPT`, defined in [[GhcFile(compiler/main/HscTypes.lhs)]]). As its name suggests, it contains informations from the *home package*, i.e. the package we are currently compiling. Its entries, `HomeModInfo`, contain the sum total knowledge of a module after compilation: both its pre-linking interface `ModIface` as well as the post-linking details `ModDetails</code></pre>
<p>.</p>
<p>We *clear* out the home package table in the session (for</p>
<pre><code>--make</code></pre>
<p>, this was empty anyway), but we pass in the old HPT.</p>
<p>ToDo: talk about how we fix up loops after we finish the loop</p>
<p>Finally, when the module is completely done being compiled, it is registered in the home package table</p>
<p>ToDo: Talk about what happens when we fail while in the middle of compiling a module cycle</p>
<h1 id="eager-promotion">Eager Promotion</h1>
<p>Eager promotion is a technique we use in GHC to improve the performance of generational GC. It is somewhat specific to the characteristics of lazy evaluation, since it takes advantage of the fact that we have some objects that are mutated just once (i.e. thunks).</p>
<p>The key observation is this: when an object P contains a pointer to an object Q in a younger generation, and P is not mutable, then we know that Q cannot be garbage collected until the generation in which P resides is collected. Hence, we might as well promote Q to this generation immediately, rather than [wiki:Commentary/Rts/Storage/GC/Aging aging] it or promoting it to an intermediate generation. Furthermore, if eager promotion is successful, then the object containing the old-to-new pointers will no longer need to be in the [wiki:Commentary/Rts/Storage/GC/RememberedSets remembered set] for the generation it resides in.</p>
<p>We gave some performance results for this technique in <a href="http://www.haskell.org/~simonmar/papers/multicore-ghc.pdf">Runtime Support for Multicore Haskell</a>; the upshot is that it's worth 10% or so.</p>
<p>Eager promotion works like this. To do eager promtion, the scavenger sets the flag</p>
<pre><code>gct-&gt;eager_promotion` (it can leave the flag set when scavenging multiple objects, this is the usual way), and `gct-&gt;evac_gen` is set to the generation to which to eagerly promote objects.  The `evacuate` function will try to move each live object into `gct-&gt;evac_gen` or a higher generation if possible, and set `gct-&gt;failed_to_evac</code></pre>
<p>if it fails (see [wiki:Commentary/Rts/Storage/GC/RememberedSets]). It may fail if the target object has already been moved: we can't move an object twice during GC, because there may be other pointers already updated to point to the new location. It may also fail if the object is in a generation that is not being collected during this cycle.</p>
<p>Objects which are repeatedly mutable should not be subject to eager promotion, because the object may be mutated again, so eagerly promoting the objects it points to may lead to retaining garbage unnecessarily. Hence, when we are scavenging a mutable object (see <a href="GhcFile(rts/sm/Scav.c)" class="uri" title="wikilink">GhcFile(rts/sm/Scav.c)</a>), we temporarily turn off</p>
<pre><code>gct-&gt;eager_promotion</code></pre>
<p>.</p>
<h1 id="eager-version-bumping-strategy">Eager Version Bumping Strategy</h1>
<p>Versioning of GHC core/boot libraries adheres to Haskell's <a href="https://wiki.haskell.org/Package_versioning_policy">Package Versioning Policy</a> whose scope is considered to apply to **released artifacts** (and therefore doesn't prescribe when to //actually// perform version increments during development)</p>
<p>However, in the spirit of continuous integration, GHC releases snapshot artifacts, and therefore it becomes important for early testers/evaluators/package-authors to be presented with accurate PVP-adhering versioning, especially for those who want adapt to upcoming API changes in new major GHC releases early (rather than being hit suddenly by a disruptive version-bump-wave occurring at GHC release time).</p>
<p>So while the usual scheme is to update a package version in the VCS right before a release (and reviewing at that point whether a patchlevel, minor or major version bump is mandated by the PVP), for GHC bundled core/boot packages, the **eager version bumping** scheme is preferred, which basically means:</p>
<pre><code>#!box
The Cabal version gets patchlevel/minor/major version bumped as soon as it becomes evident that a patchlevel/minor/major version increment (relative to the previous released version) is mandated by the PVP</code></pre>
<p>This becomes particularly easy when also maintaining a</p>
<pre><code>changelog</code></pre>
<p>file during development highlighting the changes for releases, as then one easily keeps track of the last released version, as well as becoming aware more easily of minor/major version increment-worthy API changes.</p>
<p>Video: <a href="http://www.youtube.com/watch?v=pN9rhQHcfCo&amp;list=PLBkRCigjPwyeCSD_DFxpd246YIF7_RDDI">Types and Classes</a> (23'53&quot;)</p>
<p>= Data types for Haskell entities:</p>
<pre><code>Id</code></pre>
<p>,</p>
<pre><code>TyVar</code></pre>
<p>,</p>
<pre><code>TyCon</code></pre>
<p>,</p>
<pre><code>DataCon</code></pre>
<p>, and</p>
<pre><code>Class</code></pre>
<p>=</p>
<p>For each kind of Haskell entity (identifier, type variable, type constructor, data constructor, class) GHC has a data type to represent it. Here they are:</p>
<ul>
<li><strong>Type constructors</strong> are represented by the
<pre><code>TyCon</code></pre>
<p>type (<a href="GhcFile(compiler/types/TyCon.hs)" class="uri" title="wikilink">GhcFile(compiler/types/TyCon.hs)</a>).</p></li>
<li><strong>Classes</strong> are represented by the
<pre><code>Class</code></pre>
<p>type (<a href="GhcFile(compiler/types/Class.hs)" class="uri" title="wikilink">GhcFile(compiler/types/Class.hs)</a>).</p></li>
<li><strong>Data constructors</strong> are represented by the
<pre><code>DataCon</code></pre>
<p>type (<a href="GhcFile(compiler/basicTypes/DataCon.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/DataCon.hs)</a>).</p></li>
<li><strong>Pattern synonyms</strong> are represented by the
<pre><code>PatSyn</code></pre>
<p>type (<a href="GhcFile(compiler/basicTypes/PatSyn.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/PatSyn.hs)</a>).</p></li>
<li><strong>Term variables</strong>
<pre><code>Id</code></pre>
<p>and <strong>type variables</strong></p>
<pre><code>TyVar</code></pre>
<p>are both represented by the</p>
<pre><code>Var</code></pre>
<p>type (<a href="GhcFile(compiler/basicTypes/Var.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Var.hs)</a>).</p></li>
</ul>
<p>All of these entities have a</p>
<pre><code>Name</code></pre>
<p>, but that's about all they have in common. However they are sometimes treated uniformly:</p>
<ul>
<li>A '''
<pre><code>TyThing</code></pre>
<p>''' (<a href="GhcFile(compiler/types/TypeRep.hs)" class="uri" title="wikilink">GhcFile(compiler/types/TypeRep.hs)</a>) is simply the sum of all four:</p></li>
</ul>
<pre><code>data TyThing = AnId     Id
         | AConLike ConLike
         | ATyCon   TyCon
         | AClass   Class

data ConLike = RealDataCon DataCon | PatSynCon PatSyn</code></pre>
<p><code>For example, a type environment is a map from </code></p>
<pre><code>Name</code></pre>
<p>to</p>
<pre><code>TyThing</code></pre>
<p>. (The fact that a</p>
<pre><code>Name</code></pre>
<p>tells what name space it belongs to allow, for example, identically named values and types to sit in a single map.)</p>
<p>All these data types are implemented as a big record of information that tells you everything about the entity. For example, a</p>
<pre><code>TyCon</code></pre>
<p>contains a list of its data constructors; a</p>
<pre><code>DataCon</code></pre>
<p>contains its type (which mentions its</p>
<pre><code>TyCon</code></pre>
<p>); a</p>
<pre><code>Class</code></pre>
<p>contains the</p>
<pre><code>Id</code></pre>
<p>s of all its method selectors; and an</p>
<pre><code>Id</code></pre>
<p>contains its type (which mentions type constructors and classes).</p>
<p>So you can see that the GHC data structures for entities is a <em>graph</em> not tree: everything points to everything else. This makes it very convenient for the consumer, because there are accessor functions with simple types, such as</p>
<pre><code>idType :: Id -&gt; Type</code></pre>
<p>. But it means that there has to be some tricky almost-circular programming (&quot;knot-tying&quot;) in the type checker, which constructs the entities.</p>
<h2 id="type-variables-and-term-variables">Type variables and term variables</h2>
<p>Type variables and term variables are represented by a single data type,</p>
<pre><code>Var</code></pre>
<p>, thus (<a href="GhcFile(compiler/basicTypes/Var.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Var.hs)</a>):</p>
<pre><code>type Id    = Var
type TyVar = Var</code></pre>
<p>It's incredibly convenient to use a single data type for both, rather than using one data type for term variables and one for type variables. For example:</p>
<ul>
<li>Finding the free variables of a term gives a set of variables (both type and term variables):
<pre><code>exprFreeVars :: CoreExpr -&gt; VarSet</code></pre>
<p>.</p></li>
<li>We only need one lambda constructor in Core:
<pre><code>Lam :: Var -&gt; CoreExpr -&gt; CoreExpr</code></pre>
<p>.</p></li>
</ul>
<p>The</p>
<pre><code>Var</code></pre>
<p>type distinguishes the two sorts of variable; indeed, it makes somewhat finer distinctions (<a href="GhcFile(compiler/basicTypes/Var.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Var.hs)</a>):</p>
<pre><code>data Var
  = TyVar {
    varName    :: &lt;nowiki&gt;Name,&lt;/nowiki&gt;
    realUnique :: FastInt,      -- Key for fast comparison
    tyVarKind :: Kind,
        isCoercionVar :: Bool }

  | TcTyVar {               -- Used only during type inference
    varName        :: &lt;nowiki&gt;Name,&lt;/nowiki&gt;
    realUnique     :: FastInt,
    tyVarKind      :: Kind,
    tcTyVarDetails :: TcTyVarDetails }

  | GlobalId {          -- Used for imported Ids, dict selectors etc
    varName    :: &lt;nowiki&gt;Name,&lt;/nowiki&gt;    -- Always an External or WiredIn Name
    realUnique :: FastInt,
    idType     :: Type,
    idInfo     :: IdInfo,
    gblDetails :: GlobalIdDetails }

  | LocalId {           -- Used for locally-defined Ids (see NOTE below)
    varName    :: &lt;nowiki&gt;Name,&lt;/nowiki&gt;
    realUnique :: FastInt,
    idType     :: Type,
    idInfo     :: IdInfo,
    lclDetails :: LocalIdDetails }</code></pre>
<p>Every</p>
<pre><code>Var</code></pre>
<p>has fields</p>
<pre><code>varName::Name</code></pre>
<p>and a</p>
<pre><code>realUnique::FastInt</code></pre>
<p>. The latter is identical to the</p>
<pre><code>Unique</code></pre>
<p>in the former, but is cached in the</p>
<pre><code>Var</code></pre>
<p>for fast comparison.</p>
<p>Here are some per-flavour notes:</p>
<pre><code>TyVar</code></pre>
<dl>

<dd><dl>

<dd>is self explanatory.
</dd>
</dl>
</dd>
</dl>
<pre><code>TcTyVar</code></pre>
<dl>

<dd><dl>

<dd>is used during type-checking only. Once type checking is finished, there are no more
<pre><code>TcTyVar</code></pre>
<p>s.</p>
</dd>
</dl>
</dd>
</dl>
<pre><code>LocalId</code></pre>
<dl>

<dd><dl>

<dd>is used for term variables bound <em>in the module being compiled</em>. More specifically, a
<pre><code>LocalId</code></pre>
<p>is bound either <em>within</em> an expression (lambda, case, local let), or at the top level of the module being compiled.</p>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>The
<pre><code>IdInfo</code></pre>
<p>of a</p>
<pre><code>LocalId</code></pre>
<p>may change as the simplifier repeatedly bashes on it.</p></li>
<li>A
<pre><code>LocalId</code></pre>
<p>carries a flag saying whether it's exported. This is useful for knowing whether we can discard it if it is not used.</p></li>
</ul>
<pre><code>data LocalIdDetails 
  = NotExported -- Not exported; may be discarded as dead code.
  | Exported    -- Exported; keep alive</code></pre>
<pre><code>GlobalId</code></pre>
<dl>

<dd><dl>

<dd>is used for fixed, immutable, top-level term variables, notably ones that are imported from other modules. This means that, for example, the optimizer won't change its properties.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Always has an
<pre><code>External</code></pre>
<p>or</p>
<pre><code>WiredIn</code></pre>
<p>[wiki:Commentary/Compiler/NameType Name], and hence has a</p>
<pre><code>Unique</code></pre>
<p>that is globally unique across the whole of a GHC invocation.</p></li>
<li>Always bound at top level.</li>
<li>The
<pre><code>IdInfo</code></pre>
<p>of a</p>
<pre><code>GlobalId</code></pre>
<p>is completely fixed.</p></li>
<li>All implicit Ids (data constructors, class method selectors, record selectors and the like) are are
<pre><code>GlobalId</code></pre>
<p>s from birth, even the ones defined in the module being compiled.</p></li>
<li>When finding the free variables of an expression (
<pre><code>exprFreeVars</code></pre>
<p>), we only collect</p>
<pre><code>LocalIds</code></pre>
<p>and ignore</p>
<pre><code>GlobalIds</code></pre>
<p>.</p></li>
</ul>
<p>All the value bindings in the module being compiled (whether top level or not) are</p>
<pre><code>LocalId</code></pre>
<p>s until the CoreTidy phase. In the CoreTidy phase, all top-level bindings are made into</p>
<pre><code>GlobalId</code></pre>
<p>s. This is the point when a</p>
<pre><code>LocalId</code></pre>
<p>becomes &quot;frozen&quot; and becomes a fixed, immutable</p>
<pre><code>GlobalId</code></pre>
<p>.</p>
<p>==</p>
<pre><code>GlobalIdDetails</code></pre>
<p>and implict Ids ==</p>
<pre><code>GlobalId</code></pre>
<p>s are further classified by their</p>
<pre><code>GlobalIdDetails</code></pre>
<p>. This type is defined in <a href="GhcFile(compiler/basicTypes/IdInfo.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/IdInfo.hs)</a>, because it mentions other structured types such as</p>
<pre><code>DataCon</code></pre>
<p>. Unfortunately it is <em>used</em> in Var.hs so there's a hi-boot knot to get it there. Anyway, here's the declaration (elided a little):</p>
<pre><code>data GlobalIdDetails
  = VanillaGlobal       -- Imported from elsewhere, a default method Id.
  | RecordSelId { ... }     -- Record selector
* orker*
* rapper*
  | ClassOpId Class     -- An operation of a class
  | PrimOpId PrimOp     -- The Id for a primitive operator
  | FCallId ForeignCall     -- The Id for a foreign call
  | NotGlobalId         -- Used as a convenient extra return value from globalIdDetails</code></pre>
<p>Some</p>
<pre><code>GlobalId</code></pre>
<p>s are called '''implicit</p>
<pre><code>Id</code></pre>
<p>s'''. These are</p>
<pre><code>Id</code></pre>
<p>s that are defined by a declaration of some other entity (not just an ordinary variable binding). For example:</p>
<ul>
<li>The selectors of a record type</li>
<li>The method selectors of a class</li>
<li>The worker and wrapper Id for a data constructor</li>
</ul>
<p>It's easy to distinguish these Ids, because the</p>
<pre><code>GlobalIdDetails</code></pre>
<p>field says what kind of thing it is:</p>
<pre><code>Id.isImplicitId :: Id -&gt; Bool</code></pre>
<p>.</p>
<h1 id="hc-files-and-the-evil-mangler">HC files and the Evil Mangler</h1>
<p>GHC no longer has an evil mangler.</p>
<h1 id="strictness-analysis-examples">Strictness analysis: examples</h1>
<p>Consider:</p>
<pre><code>f g True = 3
f g False = g 1 2

...f (\ x -&gt; let foo = somethingExpensive in \ y -&gt; ...)...</code></pre>
<p>We want to make sure to figure out that f's argument is demanded with type L1X(L1X(LMX)) -- that is, it may or may not be demanded, but if it is, it's always applied to two arguments. This shows why</p>
<pre><code>deferType</code></pre>
<p>shouldn't just throw away the argument info: in this case, the</p>
<pre><code>(\ x -&gt; ...)</code></pre>
<p>expression has a nonstrict demand placed on it, yet we still care about the arguments.</p>
<p>On the other hand, in:</p>
<pre><code>foo x y = 
  case x of
* 
     B -&gt; \ z -&gt; x+z</code></pre>
<p>we want to say that if the result of</p>
<pre><code>foo</code></pre>
<p>has demand</p>
<pre><code>S</code></pre>
<p>placed on it (i.e., not a call demand), the body of</p>
<pre><code>foo</code></pre>
<p>has demand</p>
<pre><code>S</code></pre>
<p>placed on it, not</p>
<pre><code>S(LMX)</code></pre>
<p>. So this case needs to be treated differently from the one above.</p>
<h1 id="system-fc-equality-constraints-and-coercions">System FC: equality constraints and coercions</h1>
<p>For many years, GHC's intermediate language was essentially:</p>
<ul>
<li>System Fw, plus</li>
<li>algebraic data types (including existentials)</li>
</ul>
<p>But that is inadequate to describe GADTs and associated types. So in 2006 we extended GHC to support System FC, which adds</p>
<ul>
<li>equality constraints and coercions</li>
</ul>
<p>You can find a full description of FC in the paper <a href="http://research.microsoft.com/~simonpj/papers/ext-f">1</a>; note that GHC uses the system described in post-publication Appendix C, not the system in the main body of the paper. The notes that follow sketch the implementation of FC in GHC, but without duplicating the contents of the paper.</p>
<p>A coercion</p>
<pre><code>c</code></pre>
<p>, is a type-level term, with a kind of the form</p>
<pre><code>T1 :=: T2`. (`c :: T1 :=: T2`) is a proof that a term of type `T1</code></pre>
<p>can be coerced to type</p>
<pre><code>T2</code></pre>
<p>. Coercions are classified by a new sort of kind (with the form</p>
<pre><code>T1 :=: T2</code></pre>
<p>). Most of the coercion construction and manipulation functions are found in the</p>
<pre><code>Coercion</code></pre>
<p>module, <a href="GhcFile(compiler/types/Coercion.hs)" class="uri" title="wikilink">GhcFile(compiler/types/Coercion.hs)</a>.</p>
<p>Coercions appear in Core in the form of</p>
<pre><code>Cast</code></pre>
<p>expressions: if</p>
<pre><code>t :: T1` and `c :: T1:=:T2`, then &lt;pre&gt;(t `cast</code></pre>
<p>c) :: T2</p>
</pre>
<p>. See [wiki:Commentary/Compiler/CoreSynType].</p>
<h2 id="coercions-and-coercion-kinds">Coercions and Coercion Kinds</h2>
<p>The syntax of coercions extends the syntax of types (and the type</p>
<pre><code>Coercion` is just a synonym for `Type</code></pre>
<p>). By representing coercion evidence on the type level, we can take advantage of the existing erasure mechanism and keep non-termination out of coercion proofs (which is necessary to keep the system sound). The syntax of coercions and types also overlaps a lot. A normal type is evidence for the reflexive coercion, i.e.,</p>
<pre><code>Int :: Int :=: Int</code></pre>
<p>Coercion variables are used to abstract over evidence of type equality, as in</p>
<pre><code>(/\c::(a :=: Bool). \x::a. if (x &lt;pre&gt;cast</code></pre>
<p>c) then 0 else 1) :: (a :=: Bool) =&gt; a -&gt; Int</p>
</pre>
<p>There are also coercion constants that are introduced by the compiler to implement some source language features (newtypes for now, associated types soon and probably more in the future). Coercion constants are represented as</p>
<pre><code>TyCon</code></pre>
<p>s made with the constructor</p>
<pre><code>CoercionTyCon</code></pre>
<p>.</p>
<p>Coercions are type level terms and can have normal type constructors applied to them. The action of type constructors on coercions is much like in a logical relation. So if</p>
<pre><code>c1 :: T1 :=: T2</code></pre>
<p>then</p>
<pre><code>[c1] :: [T1] :=: [T2]</code></pre>
<p>and if</p>
<pre><code>c2 :: S1 :=: S2</code></pre>
<p>then</p>
<pre><code>c1 -&gt; c2 :: (T1 -&gt; S1 :=: T2 -&gt; S2)</code></pre>
<p>The sharing of syntax means that a normal type can be looked at as either a type or as coercion evidence, so we use two different kinding relations, one to find type-kinds (implemented in Type as `typeKind :: Type -&gt; Kind`) and one to find coercion-kinds (implemented in Coercion as</p>
<pre><code>coercionKind :: Coercion -&gt; Kind</code></pre>
<p>).</p>
<p>Coercion variables are distinguished from type variables, and non-coercion type variables (just like any normal type) can be used as the reflexive coercion, while coercion variables have a particular coercion kind which need not be reflexive.</p>
<h2 id="gadts">GADTs</h2>
<p>The internal representation of GADTs is as regular algebraic datatypes that carry coercion evidence as arguments. A declaration like</p>
<pre><code>data T a b where
  T1 :: a -&gt; b -&gt; T [a] (a,b)</code></pre>
<p>would result in a data constructor with type</p>
<pre><code>T1 :: forall a b. forall a1 b1. (a :=: [a1], b :=: (a1, b1)) =&gt; a1 -&gt; b1 -&gt; T a b</code></pre>
<p>This means that (unlike in the previous intermediate language) all data constructor return types have the form</p>
<pre><code>T a1 ... an</code></pre>
<p>where</p>
<pre><code>a1` through `an</code></pre>
<p>are the parameters of the datatype.</p>
<p>However, we also generate wrappers for GADT data constructors which have the expected user-defined type, in this case</p>
<pre><code>$wT1 = /\a b. \x y. T1 [a] (a,b) a b [a] (a,b) x y</code></pre>
<p>Where the 4th and 5th arguments given to</p>
<pre><code>T1</code></pre>
<p>are the reflexive coercions</p>
<pre><code>[a]   :: [a] :=: [a]
(a,b) :: (a,b) :=: (a,b)</code></pre>
<h2 id="representation-of-coercion-assumptions">Representation of coercion assumptions</h2>
<p>In most of the compiler, as in the FC paper, coercions are abstracted using</p>
<pre><code>ForAllTy cv ty` where `cv</code></pre>
<p>is a coercion variable, with a kind of the form</p>
<pre><code>PredTy (EqPred T1 T2)</code></pre>
<p>. However, during type inference it is convenient to treat such coercion qualifiers in the same way other class membership or implicit parameter qualifiers are treated. So functions like</p>
<pre><code>tcSplitForAllTy` and `tcSplitPhiTy` and `tcSplitSigmaTy</code></pre>
<p>, treat</p>
<pre><code>ForAllTy cv ty` as if it were `FunTy (PredTy (EqPred T1 T2)) ty</code></pre>
<p>(where</p>
<pre><code>PredTy (EqPred T1 T2)` is the kind of `cv`).  Also, several of the `dataCon</code></pre>
<p>XXX functions treat coercion members of the data constructor as if they were dictionary predicates (i.e. they return the</p>
<pre><code>PredTy (EqPred T1 T2)</code></pre>
<p>with the theta).</p>
<h2 id="newtypes-are-coerced-types">Newtypes are coerced types</h2>
<p>The implementation of newtypes has changed to include explicit type coercions in the place of the previously used ad-hoc mechanism. For a newtype declared by</p>
<pre><code>newtype T a = MkT (a -&gt; a)</code></pre>
<p>the</p>
<pre><code>NewTyCon` for `T` will contain n`t_co = CoT</code></pre>
<p>where:</p>
<pre><code>CoT t : (T t :=: t -&gt; t)</code></pre>
<p>This</p>
<pre><code>TyCon` is a `CoercionTyCon</code></pre>
<p>, so it does not have a kind on its own; it basically has its own typing rule for the fully-applied version. If the newtype</p>
<pre><code>T` has k type variables, then `CoT</code></pre>
<p>has arity at most k. In the case that the right hand side is a type application ending with the same type variables as the left hand side, we &quot;eta-contract&quot; the coercion. So if we had</p>
<pre><code>newtype S a = MkT [a]</code></pre>
<p>then we would generate the arity 0 coercion</p>
<pre><code>CoS : S :=: []</code></pre>
<p>. The primary reason we do this is to make newtype deriving cleaner. If the coercion cannot be reduced in this fashion, then it has the same arity as the tycon.</p>
<p>In the paper we'd write</p>
<pre><code>axiom CoT : (forall t. T t) :=: (forall t. [t])</code></pre>
<p>and then when we used</p>
<pre><code>CoT` at a particular type, `s</code></pre>
<p>, we'd say</p>
<pre><code>CoT @ s</code></pre>
<p>which encodes as</p>
<pre><code>(TyConApp instCoercionTyCon [TyConApp CoT [], s])</code></pre>
<p>But in GHC we instead make</p>
<pre><code>CoT</code></pre>
<p>into a new piece of type syntax (like</p>
<pre><code>instCoercionTyCon`, `symCoercionTyCon</code></pre>
<p>etc), which must always be saturated, but which encodes as</p>
<pre><code>TyConApp CoT [s]</code></pre>
<p>In the vocabulary of the paper it's as if we had axiom declarations like</p>
<pre><code>axiom CoT t :  T t :=: [t]</code></pre>
<p>The newtype coercion is used to wrap and unwrap newtypes whenever the constructor or case is used in the Haskell source code.</p>
<p>Such coercions are always used when the newtype is recursive and are optional for non-recursive newtypes. Whether or not they are used can be easily changed by altering the function mkNewTyConRhs in iface/BuildTyCl.lhs.</p>
<h2 id="roles">Roles</h2>
<p>Roles specify what nature of equality a coercion is proving. See [wiki:Roles] and RolesImplementation.</p>
<h2 id="simplification">Simplification</h2>
<ul>
<li>exprIsConApp_maybe</li>
</ul>
<ul>
<li>simplExpr</li>
</ul>
<h1 id="ghc-commentary-runtime-aspects-of-the-ffi">GHC Commentary: Runtime aspects of the FFI</h1>
<h2 id="foreign-import-wrapper">Foreign Import &quot;wrapper&quot;</h2>
<p>Files <a href="GhcFile(rts/Adjustor.c)" class="uri" title="wikilink">GhcFile(rts/Adjustor.c)</a> <a href="GhcFile(rts/AdjustorAsm.S)" class="uri" title="wikilink">GhcFile(rts/AdjustorAsm.S)</a>.</p>
<p>Occasionally, it is convenient to treat Haskell closures as C function pointers. This is useful, for example, if we want to install Haskell callbacks in an existing C library. This functionality is implemented with the aid of adjustor thunks.</p>
<p>An adjustor thunk is a dynamically allocated code snippet that allows Haskell closures to be viewed as C function pointers.</p>
<p>Stable pointers provide a way for the outside world to get access to, and evaluate, Haskell heap objects, with the RTS providing a small range of ops for doing so. So, assuming we've got a stable pointer in our hand in C, we can jump into the Haskell world and evaluate a callback procedure, say. This works OK in some cases where callbacks are used, but does require the external code to know about stable pointers and how to deal with them. We'd like to hide the Haskell-nature of a callback and have it be invoked just like any other C function pointer.</p>
<p>Enter adjustor thunks. An adjustor thunk is a little piece of code that's generated on-the-fly (one per Haskell closure being exported) that, when entered using some 'universal' calling convention (e.g., the C calling convention on platform X), pushes an implicit stable pointer (to the Haskell callback) before calling another (static) C function stub which takes care of entering the Haskell code via its stable pointer.</p>
<p>An adjustor thunk is allocated on the C heap, and is called from within Haskell just before handing out the function pointer to the Haskell (IO) action. User code should never have to invoke it explicitly.</p>
<p>An adjustor thunk differs from a C function pointer in one respect: when the code is through with it, it has to be freed in order to release Haskell and C resources. Failure to do so will result in memory leaks on both the C and Haskell side.</p>
<hr />
<p>CategoryStub</p>
<h1 id="function-calls">Function Calls</h1>
<p>Source files: <a href="GhcFile(rts/Apply.h)" class="uri" title="wikilink">GhcFile(rts/Apply.h)</a>, <a href="GhcFile(rts/Apply.cmm)" class="uri" title="wikilink">GhcFile(rts/Apply.cmm)</a></p>
<p>Dealing with calls is by far the most complicated bit of the execution model, and hence of the code generator. GHC uses an <em>eval/apply</em> strategy for compiling function calls; all the details of the design are in the paper <a href="http://www.haskell.org/~simonmar/papers/eval-apply.pdf">Making a fast curry: push/enter vs. eval/apply for higher-order languages</a>.</p>
<p>First, we need some terminology:</p>
<ul>
<li>The <strong>arity</strong> of a function is the number of lambdas statically used in [wiki:Commentary/Compiler/StgSynType the lambda-form of its definition]. Note that arity is not deducible from the type. Example:</li>
</ul>
<pre><code>f :: Bool -&gt; Bool -&gt; Bool
f = \x -&gt; case x of 
               True  -&gt; not
               False -&gt; id</code></pre>
<p><code>   Here, </code></p>
<pre><code>f` has arity 1, even though its type suggests it takes two arguments.  The point is that the compiled code for `f` will expect to be passed just one argument, `x</code></pre>
<p>.</p>
<ul>
<li>The <strong>entry point</strong> (sometimes called the <strong>fast entry point</strong>) of a function of arity N expects its first N arguments to be passed in accordance with the standard [wiki:Commentary/Rts/HaskellExecution/CallingConvention calling conventions].</li>
</ul>
<ul>
<li>A <strong>known call</strong> is a call of a function whose binding site is statically visible:
<ul>
<li>The function is bound at top level in this module; or,</li>
<li>The function is bound at top level in another module, and optimistion is on, so we can see the details (notably arity) of the function in the module's interface file; or,</li>
<li>The function is bound by an
<pre><code>let</code></pre>
<p>binding that encloses the call.</p></li>
</ul></li>
</ul>
<p>When compiling a call, there are several cases to consider, which are treated separately.</p>
<ul>
<li><strong>Unknown function</strong>; a call in which we do not statically know what the function is. In that case we must do a &quot;generic apply&quot;. This is so exciting that it deserves its [wiki:Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply own section].</li>
</ul>
<ul>
<li><strong>Known function, saturated call</strong>. The function is applied to exactly the right number of arguments to satisfy its arity. In that case, we simply load the arguments according to the standard entry convention, and tail-call (jump to) the function's entry point. On average, about 80% of all calls fall into this category (see the eval/apply paper for measurements).</li>
</ul>
<ul>
<li><strong>Known function, too few arguments</strong>. In this case, we want to build a partial application (PAP), and return with a pointer to the PAP in the return register. Since building a PAP is a complicated business, instead we just behave as for an unknown function call, which will end up calling into the <a href="ref(Generic_apply)" title="wikilink">ref(Generic apply)</a> code, which will build the PAP for us.</li>
</ul>
<ul>
<li><strong>Known function, too many arguments</strong>. We want to save the extra arguments on the stack, push a return address, and then behave just like a saturated call. When the result comes back, we should behave like &quot;unknown call&quot;. However, to avoid needing to generate code for a new continuation here, the return address that we push on the stack is that of an appropriate <a href="ref(Generic_apply)" title="wikilink">ref(Generic apply)</a> function, which will perform the application of the extra arguments to the (unknown) function returned by the saturated call.</li>
</ul>
<h2 id="generic-apply">Generic apply</h2>
<p>Files: <a href="GhcFile(utils/genapply)" class="uri" title="wikilink">GhcFile(utils/genapply)</a></p>
<p>When compiling a call that has an unknown function, we must generate code to</p>
<ul>
<li>Evaluate the function</li>
<li>Scrutinise the function value returned to see its arity, and dispatch into the same three cases as in the case of known calls:
<ul>
<li>Exactly the right number of arguments: load them into the standard locations and tail-call the function's entry point</li>
<li>Too few arguments: build a PAP</li>
<li>Too many arguments: save the excess arguments, and tail call the function as for a saturated cal.</li>
</ul></li>
</ul>
<p>All of this takes quite a lot of code, so we pre-generate a whole bunch of generic-apply code sequencues, one for each combination of arguments. This code is generated by the tool <a href="GhcFile(utils/genapply)" class="uri" title="wikilink">GhcFile(utils/genapply)</a>, and the generated code appears in</p>
<pre><code>rts/AutoApply.cmm</code></pre>
<p>.</p>
<p>For example, if we find a call to an unknown function applied to two (boxed)</p>
<pre><code>Int` arguments, load the function and its two arguments as for the standard entry convention and jump to `stg_ap_pp_fast`.  This latter code is in `rts/AutoApply.cmm`, generated by the `genapply` tool.  The &quot;`pp</code></pre>
<p>&quot; part is the bit that says the code is specialised for two pointer arguments.</p>
<p>In addition to the family of</p>
<pre><code>stg_ap_&lt;pattern&gt;_fast` functions for making calls to unknown functions with various argument patterns, there is a corresponding family of return addresses `stg_ap_&lt;pattern&gt;_info</code></pre>
<p>. The idea is that you can push a continuation that will make a call to the function that is returned to it. For example, to push a continuation that will apply a single pointer argument, we would push the following words on the stack:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>arg</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>stg_ap_p_info</code></pre></td>
</tr>
</tbody>
</table>
<h1 id="the-garbage-collector">The Garbage Collector</h1>
<p>GC concepts:</p>
<ul>
<li>[wiki:Commentary/Rts/Storage/GC/Aging Aging]</li>
<li>[wiki:Commentary/Rts/Storage/GC/Pinned Pinned objects]</li>
<li>[wiki:Commentary/Rts/Storage/GC/Roots Roots]</li>
<li>[wiki:Commentary/Rts/Storage/GC/EagerPromotion Eager promotion]</li>
<li>[wiki:Commentary/Rts/Storage/GC/RememberedSets Remembered sets]</li>
<li>[wiki:Commentary/Rts/Storage/GC/Weak Weak pointers and finalizers]</li>
<li>[wiki:Commentary/Rts/Storage/GC/CAFs CAFs]</li>
</ul>
<p>GC algorithms supported:</p>
<ul>
<li>[wiki:Commentary/Rts/Storage/GC/Copying Copying GC]</li>
<li>[wiki:Commentary/Rts/Storage/GC/Parallel Parallel GC]</li>
<li>[wiki:Commentary/Rts/Storage/GC/Marking Marking] (for compaction or sweeping)</li>
<li>[wiki:Commentary/Rts/Storage/GC/Compaction Compaction]</li>
<li>[wiki:Commentary/Rts/Storage/GC/Sweeping Sweeping] (for mark-region GC)</li>
<li>[wiki:Commentary/Rts/Storage/GC/Immix Immix] (not supported yet)</li>
</ul>
<h2 id="gc-overview">GC overview</h2>
<p>The GC is designed to be flexible, supporting lots of ways to tune its behaviour. Here's an overview of the techniques we use:</p>
<ul>
<li>Generational GC, with a runtime-selectable number of generations (
<pre><code>+RTS -G&lt;n&gt; -RTS`, where `n &gt;= 1</code></pre>
<p>). Currently it is a</p></li>
</ul>
<p><code>  traditional generational collector where each collection collects a particular generation and all younger generations.</code><br />
<code>  Generalizing this such that any subset of generations can be collected is a possible future extension.</code></p>
<ul>
<li>The heap grows on demand. This is straightforwardly implemented by basing the whole storage manager on a [wiki:Commentary/Rts/Storage/BlockAlloc block allocator].</li>
</ul>
<ul>
<li>Aging: objects can be aged within a generation, to avoid premature promotion. See [wiki:Commentary/Rts/Storage/GC/Aging].</li>
</ul>
<ul>
<li>The heap collection policy is runtime-tunable. You select how large a generation gets before it is collected using the
<pre><code>+RTS -F&lt;n&gt; -RTS` option, where `&lt;n&gt;</code></pre>
<p>is a factor of the generation's size the last time it was collected. The default value is 2, that is a generation is allowed to double in size before being collected.</p></li>
</ul>
<h2 id="gc-data-structures">GC data structures</h2>
<p><a href="GhcFile(includes/rts/storage/GC.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/GC.h)</a></p>
<h3 id="generation">generation</h3>
<p>The main data structure is</p>
<pre><code>generation</code></pre>
<p>, which contains:</p>
<p>;</p>
<pre><code>blocks</code></pre>
<dl>

<dd>a pointer to a list of blocks
</dd>
</dl>
<p>;</p>
<pre><code>large_objects</code></pre>
<dl>

<dd>a pointer to a list of blocks containing large objects
</dd>
</dl>
<p>;</p>
<pre><code>threads</code></pre>
<dl>

<dd>a list of threads in this generation
</dd>
</dl>
<p>;</p>
<pre><code>mut_list</code></pre>
<dl>

<dd>the [wiki:Commentary/Rts/Storage/GC/RememberedSets remembered set], a list of blocks containing pointers to objects in <em>this</em> generation that point to objects in <em>younger</em> generations
</dd>
</dl>
<p>and various other administrative fields (see <a href="GhcFile(includes/rts/storage/GC.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/GC.h)</a> for the details).</p>
<p>Generations are kept in the array</p>
<pre><code>generations[]</code></pre>
<p>, indexed by the generation number.</p>
<h3 id="nursery">nursery</h3>
<p>A</p>
<pre><code>nursery</code></pre>
<p>is a list of blocks into which the mutator allocates new (small) objects. For reasons of locality, we want to re-use the list of blocks for the nursery after each GC, so we keep the nursery blocks rather than freeing and re-allocating a new nursery after GC.</p>
<p>The struct</p>
<pre><code>nursery</code></pre>
<p>contains only two fields</p>
<p>;</p>
<pre><code>blocks</code></pre>
<dl>

<dd>the list of blocks in this nursery
</dd>
</dl>
<p>;</p>
<pre><code>n_blocks</code></pre>
<dl>

<dd>the number of blocks in the above list
</dd>
</dl>
<p>In the threaded RTS, there is one nursery per Capability, as each Capability allocates independently into its own allocation area. Nurseries are therefore stored in an array</p>
<pre><code>nurseries[]</code></pre>
<p>, indexed by Capability number.</p>
<p>The blocks of the nursery notionally logically to generation 0, although they are not kept on the list</p>
<pre><code>generations[0].blocks</code></pre>
<p>. The reason is that we want to keep the actual nursery blocks separate from any blocks containing live data in generation 0. Generation 0 may contain live data for two reasons:</p>
<ul>
<li>objects live in the nursery are not promoted to generation 1 immediately, instead they are [wiki:Commentary/Rts/Storage/GC/Aging aged], first being copied to generation 0, and then being promoted to generation 1 in the next GC cycle if they are still alive.</li>
</ul>
<ul>
<li>If there is only one generation (generation 0), then live objects in generation 0 are retained in generation 0 after a GC.</li>
</ul>
<h1 id="i-know-kung-fu-learning-stg-by-example">I know kung fu: learning STG by example</h1>
<p>The STG machine is an essential part of GHC, the world's leading Haskell compiler. It defines how the Haskell evaluation model should be efficiently implemented on standard hardware. Despite this key role, it is generally poorly understood amongst GHC users. This document aims to provide an overview of the STG machine in its modern, eval/apply-based, pointer-tagged incarnation by a series of simple examples showing how Haskell source code is compiled.</p>
<h2 id="what-is-stg-exactly">What is STG, exactly?</h2>
<p>Haskell code being sucked through GHC has a complex lifecycle. Broadly speaking, it transitions between five representations:</p>
<pre><code>
                                                                           +---------+
                                                         LLVM backend /---&gt;| LLVM IR |--\
                                                                      |    +---------+  | LLVM
                                                                      |                 v
 +------------+ Desugar  +------+ STGify  +-----+ CodeGen  +-----+    |  NCG    +----------+
 | Parse tree |---------&gt;| Core |--------&gt;| STG |---------&gt;| C-- |----+--------&gt;| Assembly |
 +------------+          +------+         +-----+          +-----+    |         +----------+
                                                                      |            ^
                                                                      |     +---+  | GCC
                                                            C backend \----&gt;| C |--/
                                                                            +---+</code></pre>
<p>The path from C-- to assembly varies: the three possible backends are C (</p>
<pre><code>-fvia-c`), LLVM (`-fllvm</code></pre>
<p>), and the default backend -- the native code genarator (or NCG), which generates assembly directly from the GHC-internal C-- data type.</p>
<p>STG is a simple functional language, rather like the more famous Core language. It differs in the following main respects:</p>
<ol>
<li>In its current incarnation, it isn't typed in the Haskell sense,</li>
</ol>
<p><code>   though it does know about </code><em><code>representation</code></em><code> types</code></p>
<ol>
<li><ol>
<li>It is in administrative normal form (ANF), which is where every</li>
</ol></li>
</ol>
<p><code>   subexpression is given a name</code></p>
<ol>
<li><ol>
<li>Every $\lambda$, constructor application, and primitive operator</li>
</ol></li>
</ol>
<p><code>   is $\eta$-expanded</code></p>
<ol>
<li><ol>
<li>It is annotated with a ton of information that the code</li>
</ol></li>
</ol>
<p><code>   generator is interested in knowing</code></p>
<p>STG expressions can be one of the following:</p>
<ol>
<li><ol>
<li>Atoms (i.e. literals and variables)</li>
<li><pre><code>let</code></pre>
<p>-bindings (both recursive and non-recursive) over another</p></li>
</ol></li>
</ol>
<p><code>   expression, where let-bound things are one of:</code></p>
<ul>
<li>A function value with explicit lambdas</li>
<li>An unsaturated application</li>
<li>A constructor applied to atoms</li>
<li>A thunk (i.e. any expression not fitting into one of the above</li>
</ul>
<p><code>      categories)</code></p>
<ol>
<li>Saturated primitive application of a primitive to variables</li>
<li>Application of a variable to one or more atoms</li>
<li>Case deconstruction of an expression, where each branch may also</li>
</ol>
<p><code>   be an expression</code></p>
<p>The job of the <em>STG machine</em> is to evaluate these expressions in a way which is efficiently implementable on standard hardware. This document will look at how exactly this is achieved by looking at real examples of the C-- code GHC generates for various Haskell expressions.</p>
<p>This document will take a very low-level view of the machine, so if you want to get comfortable with how the STG machine executes at a more abstract level before reading this document, you might want to read the paper <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/">&quot;How to make a fast curry: push/enter vs. eval/apply&quot;</a>. It presents the STG machine without reference to an explicit stack or registers, but instead as a transition system. This transition system has also been implemented as a Haskell program called <a href="http://hackage.haskell.org/package/ministg">ministg</a> by <a href="http://ww2.cs.mu.oz.au/~bjpop/">Bernie Pope</a>, for those who wish to see it in action on some simple examples.</p>
<h2 id="an-overview-of-the-stg-machine">An overview of the STG machine</h2>
<p>Before we dive in, a note: this document will describe the STG machine as it is implemented on x86-style architectures. I will use the terms &quot;the STG machine&quot; and &quot;the STG machine as implemented on x86 by GHC&quot; interchangeably. The implementation is somewhat different on x64, not least due to the greater number of available registers.</p>
<p>This overview section is rather bare. Readers might be able to fill in any gaps in my explanation by using some of the following sources:</p>
<ul>
<li><a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution">The Haskell Execution Model</a></li>
<li><a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage">Storage</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/spineless-tagless-gmachine.ps.gz">The Spineless Tagless G-machine</a></li>
</ul>
<p><code>  - now sadly rather out of date</code></p>
<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/ptr-tagging.pdf">Faster laziness through dynamic pointer tagging</a></li>
</ul>
<h3 id="components-of-the-machine">Components of the machine</h3>
<p>In its bare essentials, the STG machine consists of three parts:</p>
<ol>
<li>The STG registers:</li>
</ol>
<ul>
<li>There are rather a lot of registers here: more than can be</li>
</ul>
<p><code>      practicably stored in actual available processor registers on most</code><br />
<code>      architectures.</code></p>
<ul>
<li>To deal with the lack of processor registers, most of the STG</li>
</ul>
<p><code>      registers are actually kept on the stack in a block of memory</code><br />
<code>      pointed to by a special STG register called the &quot;base register&quot; (or </code><br />
<code>      </code></p>
<pre><code>BaseReg</code></pre>
<p>). To get or set values of registers which are not kept in</p>
<p><code>      processor registers, the STG machine generates an instruction to</code><br />
<code>      load or store from an address relative to the </code></p>
<pre><code>BaseReg</code></pre>
<p>.</p>
<ul>
<li>The most important four registers are the
<pre><code>BaseReg</code></pre>
<p>, the stack</p></li>
</ul>
<p><code>      pointer (</code></p>
<pre><code>Sp`), the heap pointer (`Hp</code></pre>
<p>), and the general purpose</p>
<p><code>      register </code></p>
<pre><code>R1</code></pre>
<p>which is used for intermediate values, as well as for</p>
<p><code>      returning evaluated values when unwinding the stack. These are the </code><br />
<code>      four registers which are assigned actual processor registers when</code><br />
<code>      implementing the STG machine on x86.</code></p>
<ol>
<li>The STG stack:</li>
</ol>
<ul>
<li>Stores function arguments and continuations (i.e. the stack</li>
</ul>
<p><code>      frames which are executed when a function returns)</code></p>
<ul>
<li>Grows downwards in memory</li>
<li>The top of the stack is pointed to by the STG register
<pre><code>Sp</code></pre>
<p>, and</p></li>
</ul>
<p><code>      the maximum available stack pointer is stored in </code></p>
<pre><code>SpLim</code></pre>
<p>. There is</p>
<p><code>      no frame pointer.</code></p>
<ol>
<li>The heap:</li>
</ol>
<ul>
<li>Used to store many different sorts of heap object: notably</li>
</ul>
<p><code>     functions, thunks and data constructors</code></p>
<ul>
<li>Grows upwards in memory, towards the stack</li>
<li>All allocation occurs using a bump-allocator: the heap pointer is</li>
</ul>
<p><code>     simply incremented by the number of bytes desired (subject to to a</code><br />
<code>     check that this does not exhaust available memory). The garbage</code><br />
<code>     collector is responsible for moving objects out of the area of the </code><br />
<code>     heap managed by the bump allocator and into the care of its </code><br />
<code>     generational collector.</code></p>
<ul>
<li>The last address in the bump-allocated part of the heap that has</li>
</ul>
<p><code>     been used is pointed to by the STG register </code></p>
<pre><code>Hp`, with `HpLim</code></pre>
<p><code>     holding the maximum address available for bump-allocation.</code></p>
<h3 id="important-concepts-in-the-machine">Important concepts in the machine</h3>
<p>Some of the key concepts in the STG machine include <em>closures</em>, <em>info tables</em> and <em>entry code</em>. We tackle them in reverse order:</p>
<dl>
<dt>Entry code</dt>
<dd>The actual machine code that the STG machine will execute upon
</dd>
</dl>
<p><code>    &quot;entry&quot;. Entry means different things for different heap objects.</code></p>
<ul>
<li>For <em>thunks</em>, entry is when the thunk is forced by some demand</li>
</ul>
<p><code>       for its value, such as a </code></p>
<pre><code>case</code></pre>
<p>expression scrutinising it</p>
<ul>
<li>For <em>functions</em>, entry is when the function is applied to as</li>
</ul>
<p><code>       many arguments as are demanded by the arity recorded in its info</code><br />
<code>       table</code></p>
<ul>
<li>For <em>continuations</em>, entry occurs when a value is returned from</li>
</ul>
<p><code>       a nested call, and hence the need arises to consume the value and</code><br />
<code>       continue evaluation</code></p>
<dl>
<dt>Info table</dt>
<dd>A block of memory allocated statically, which contains metadata
</dd>
</dl>
<p><code>    about a closure. The most important fields for our purposes are the</code><br />
<code>    entry code pointer and the arity information (if this is the info</code><br />
<code>    table for a thunk, function or partial application)</code></p>
<dl>
<dt>Closure</dt>
<dd>Essentially a heap-allocated pair of the free variables of some
</dd>
</dl>
<p><code>    code, and a pointer to its info table (i.e. its info pointer).</code></p>
<p>For an example of how these parts work together, consider the following code</p>
<pre><code>my_fun x zs = map (\y -&gt; y + x) zs</code></pre>
<p>The nested lambda will give rise to all of the above objects.</p>
<p>The closure will store a pointer to</p>
<pre><code>x</code></pre>
<p>'s closure (as it is a free variable of the lambda), along with a pointer to an info table. That info table will contain information relevant to a function value, recording information such as the fact that it has an arity of 1 (i.e. the binding for</p>
<pre><code>y</code></pre>
<p>), and the pointer to the entry code for the function</p>
<pre><code>\y -&gt; y + x</code></pre>
<p>itself. This entry code will implement the addition by combining the closure for the free variable</p>
<pre><code>x` (taken from the closure) with the stack-passed `y</code></pre>
<p>variable's closure.</p>
<p>Upon entry to some code, pointers to closures are made available in</p>
<pre><code>R1`. That is to say, before entry code is jumped to, `R1</code></pre>
<p>is set up to point to the associated closure, so that the entry code can access free variables (if any).</p>
<p>Closures for code which contain no free variables (such as the closure for</p>
<pre><code>True` and `False</code></pre>
<p>, and functions applied to no arguments such as</p>
<pre><code>(:)` and `id</code></pre>
<p>) are allocated statically by the compiler in the same manner as info tables are.</p>
<h3 id="overview-of-execution-model-of-the-machine">Overview of execution model of the machine</h3>
<p>This will be covered in more detail in the examples below, so I will use this section to make some general points.</p>
<p>The goal of the STG machine is to reduce the current expression to a value. When it has done so, it:</p>
<ol>
<li>Stores a tagged pointer to evaluated closure in the STG register</li>
</ol>
<pre><code>R1</code></pre>
<ol>
<li><ol>
<li>Jumps to the entry code of the info table pointed to by the</li>
</ol></li>
</ol>
<p><code>   value at the top of the STG stack</code></p>
<ul>
<li>This may also be called the info table of the <em>continuation</em> of</li>
</ul>
<p><code>      the expression</code></p>
<p>The continuation code is responsible for popping its info pointer (and stack-allocated free variables, if any) from the stack before returning.</p>
<p>Arguments are passed on the stack, and are popped by the callee. Upon a jump to the entry code for a function, there are always precisely as many arguments on the stack as the (statically known) arity of that function, and those arguments will be followed by the info pointer of a continuation.</p>
<h2 id="saturated-application-to-known-functions">Saturated application to known functions</h2>
<p>Handling application in the STG machine is a big topic, and so in this first section we only look at the case of <em>saturated</em> applications to <em>known</em> functions - i.e. those functions that the compiler statically knows information such as the entry code pointer and arity for.</p>
<h3 id="example-1-function-application-with-sufficient-stack-space">Example 1: function application with sufficient stack space</h3>
<p>Application of functions is the bread and butter of the STG machine. Correspondingly, this first Haskell program</p>
<pre><code>{-# NOINLINE known_fun #-}
known_fun :: a -&gt; a
known_fun x = x

known_app :: () -&gt; Int
known_app _ = known_fun 10</code></pre>
<p>compiles to very simple C-- code</p>
<pre><code>#!c
Main_knownzuapp_entry() {
    cl3:
        I32[Sp + 0] = stg_INTLIKE_closure+209;
        jump Main_knownzufun_entry ();
}</code></pre>
<pre><code>_Main_knownzuapp_entry:
Lcl3:
    movl L_stg_INTLIKE_closure$non_lazy_ptr,%eax
    addl $209,%eax
    movl %eax,(%ebp)
    jmp _Main_knownzufun_entry</code></pre>
<p>The STG machine passes arguments to functions on the STG stack, and a pointer to the stack top is stored in the STG register</p>
<pre><code>Sp</code></pre>
<p>. Furthermore, because GHC currently uses the eval/apply variant of the STG machine, exactly as many arguments as the function expects to receive are guaranteed to present on the stack.</p>
<p>Therefore, upon entry to the</p>
<pre><code>known_app</code></pre>
<p>function, we are guaranteed that the STG stack has a pointer to a closure of type</p>
<pre><code>()` on top of it. In order to call `known_fun</code></pre>
<p>, we just modify the top of the stack to replace that pointer with a pointer to the statically allocated closure for the literal</p>
<pre><code>10</code></pre>
<p>, and then tail-call into the entry code of</p>
<pre><code>known_fun</code></pre>
<p>.</p>
<h3 id="example-2-function-application-that-needs-to-grow-the-stack">Example 2: function application that needs to grow the stack</h3>
<p>This Haskell code is apparently little more complicated than the previous example</p>
<pre><code>{-# NOINLINE known_fun_2 #-}
known_fun_2 :: a -&gt; a -&gt; a
known_fun_2 x _ = x

known_app_2 :: () -&gt; Int
known_app_2 _ = known_fun_2 10 10</code></pre>
<p>however, it generates radically different C-- code:</p>
<pre><code>#!c
Main_knownzuappzu2_entry() {
    clE:
        if (Sp - 4 &lt; SpLim) goto clH;
        I32[Sp + 0] = stg_INTLIKE_closure+209;
        I32[Sp - 4] = stg_INTLIKE_closure+209;
        Sp = Sp - 4;
        jump Main_knownzufunzu2_entry ();
    clH:
        R1 = Main_knownzuappzu2_closure;
        jump stg_gc_fun ();
}</code></pre>
<pre><code>_Main_knownzuappzu2_entry:
LclE:
    leal -4(%ebp),%eax
    cmpl 84(%ebx),%eax
    jb LclH
    movl L_stg_INTLIKE_closure$non_lazy_ptr,%eax
    addl $209,%eax
    movl %eax,(%ebp)
    movl L_stg_INTLIKE_closure$non_lazy_ptr,%eax
    addl $209,%eax
    movl %eax,-4(%ebp)
    addl $-4,%ebp
    jmp _Main_knownzufunzu2_entry
LclH:
    movl $_Main_knownzuappzu2_closure,%esi
* 4(%ebx)</code></pre>
<p>As before, upon entry the STG stack is guaranteed to have a single closure pointer at its top. However, in order to call into known_fun_2 we need at least two free stack slots at the top for arguments, which means that we have to grow the stack by one word before we can make the call.</p>
<h4 id="checking-for-sufficient-stack-space">Checking for sufficient stack space</h4>
<p>First, we check to see if growing the stack would overflow allocated stack space, by comparing the STG stack pointer register</p>
<pre><code>Sp` with the stack limit register `SpLim</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>#!c
    if (Sp - 4 &lt; SpLim) goto clH;</code></pre>
<p>(The stack grows downwards, hence the <em>subtraction</em> of 4 from the current</p>
<pre><code>Sp`). If the stack check fails, we branch to `clH</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>#!c
clH:
    R1 = Main_knownzuappzu2_closure;
    jump stg_gc_fun ();</code></pre>
<p>This stores the closure of the current function in</p>
<pre><code>R1</code></pre>
<p>, and then jumps into the hand-written garbage collector code to force it to grow the stack. After the stack has been grown, the collector will call back into</p>
<pre><code>Main_knownzuappzu2_entry</code></pre>
<p>by using the information stored in the (statically-allocated)</p>
<pre><code>Main_knownzuappzu2_closure</code></pre>
<p>closure pointed to by</p>
<pre><code>R1</code></pre>
<p>, and the stack check will be run again - hopefully succeeding this time!</p>
<h4 id="making-the-known-call">Making the known call</h4>
<p>Given that the stack check succeeds, it is easy to make the actual call we are after. We simply grow the stack by the required amount, and write the two arguments to</p>
<pre><code>known_fun_2</code></pre>
<p>into the top two stack slots (overwriting our own first argument in the process, of course):</p>
<pre><code>#!c
    I32[Sp + 0] = stg_INTLIKE_closure+209;
    I32[Sp - 4] = stg_INTLIKE_closure+209;
    Sp = Sp - 4;</code></pre>
<p>A simple tail call to the new function finishes us off:</p>
<pre><code>#!c
    jump Main_knownzufunzu2_entry ();</code></pre>
<h2 id="example-3-unsaturated-applications-to-known-functions">Example 3: Unsaturated applications to known functions</h2>
<p>Despite describing an undersaturated call, this Haskell code</p>
<pre><code>{-# NOINLINE known_fun_2 #-}
known_fun_2 :: a -&gt; a -&gt; a
known_fun_2 x _ = x

known_undersaturated_app :: () -&gt; Int -&gt; Int
known_undersaturated_app _ = known_fun_2 10</code></pre>
<p>compiles to straightforward C-- as follows</p>
<pre><code>#!c
Main_knownzuundersaturatedzuapp_entry() {
    cmd:
        I32[Sp + 0] = stg_INTLIKE_closure+209;
        jump Main_knownzufunzu2_entry ();
}</code></pre>
<pre><code>_Main_knownzuundersaturatedzuapp_entry:
Lcmd:
    movl L_stg_INTLIKE_closure$non_lazy_ptr,%eax
    addl $209,%eax
    movl %eax,(%ebp)
    jmp _Main_knownzufunzu2_entry</code></pre>
<p>The reason that there is no special magic to deal with undersaturated applications to known functions is simple: GHC simply gives</p>
<pre><code>known_undersaturated_app</code></pre>
<p>an arity of 2, so by the time we jump to the entry code the stack must already contain any arguments required by</p>
<pre><code>known_fun_2</code></pre>
<p>.</p>
<h2 id="example-4-applications-to-unknown-functions">Example 4: Applications to unknown functions</h2>
<p>We aren't going to tackle oversaturated calls to known functions until we've considered happens to calls to statically-unknown functions. To see what these look like, we are going to use the following Haskell code</p>
<pre><code>unknown_app :: (Int -&gt; Int) -&gt; Int -&gt; Int
unknown_app f x = f x</code></pre>
<p>Which compiles to this C-- function</p>
<pre><code>#!c
Main_unknownzuapp_entry() {
    cnO:
        R1 = I32[Sp + 0];
        Sp = Sp + 4;
        jump stg_ap_p_fast ();
}</code></pre>
<pre><code>_Main_unknownzuapp_entry:
Lcn0:
    movl (%ebp),%esi
    addl $4,%ebp
    jmp _stg_ap_p_fast</code></pre>
<p>Unlike the previous cases we have looked at, we are compiling an application where we don't statically know either the arity or the info pointer of the function being applied. To deal with such cases, the STG machine uses several pre-compiled &quot;generic apply&quot; functions which inspect the info-table for the function in question and decide how the available arguments should be applied to it.</p>
<h3 id="dealing-with-generic-application">Dealing with generic application</h3>
<p>There are three cases the generic apply functions have to deal with:</p>
<ol>
<li>The function's arity (recorder in the function closure's info</li>
</ol>
<p><code>   table) exactly matches the number of arguments available on the</code><br />
<code>   stack</code></p>
<ul>
<li>This is the best case. In this case, the generic apply function</li>
</ul>
<p><code>      simply makes a tail call into the function's entry code</code></p>
<ol>
<li><ol>
<li>The function's arity is greater than the number of arguments</li>
</ol></li>
</ol>
<p><code>   available on the stack</code></p>
<ul>
<li>In this case, the generic apply code allocates a PAP (partial</li>
</ul>
<p><code>      application) closure which closes over both the new arguments and</code><br />
<code>      the function pointer, and returns that value, in the normal STGish</code><br />
<code>      way, to the continuation on the top of the stack</code></p>
<ol>
<li><ol>
<li>The function's arity is less than the number of arguments</li>
</ol></li>
</ol>
<p><code>   available on the stack</code></p>
<ul>
<li>In this case, a number of arguments matching the arity are pushed</li>
</ul>
<p><code>      on top of the stack, followed by a continuation which uses another</code><br />
<code>      of the generic apply functions to apply the remaining arguments.</code><br />
<code>      The code for the original function is then entered</code></p>
<ul>
<li>Eventually the code for the continuation is entered and another</li>
</ul>
<p><code>      generic apply function will be tail-called to deal with the</code><br />
<code>      result</code></p>
<p>Potentially, one generic apply function is required for every &quot;argument pattern&quot;. Some example argument patterns are:</p>
<pre><code>#!rst</code></pre>
<p>Because the number of patterns is large (actually unbounded, because functions might be of any arity), GHC only generates generic apply functions for enough patterns so that 99.9% of all calls observed in practice have a generic apply function. Generic apply functions for calls of larger arity can be simulated by chaining together several smaller generic apply functions, in a similar manner as when dealing with oversaturated function applications.</p>
<h3 id="making-the-call-to-the-generic-application-code">Making the call to the generic application code</h3>
<p>Let's remind ourselves of the original code:</p>
<pre><code>#!c
    R1 = I32[Sp + 0];
    Sp = Sp + 4;
    jump stg_ap_p_fast ();</code></pre>
<p>Knowing about generic apply functions, the call itself is easy to understand. We pop the top of the stack (the function argument) into</p>
<pre><code>R1</code></pre>
<p>and then jump into the generic application code for the case where the stack contains a single pointer argument, which deals with all the cases for</p>
<pre><code>f</code></pre>
<p>described above.</p>
<h2 id="example-5-oversaturated-applications-to-known-functions">Example 5: oversaturated applications to known functions</h2>
<p>This Haskell code</p>
<pre><code>{-# NOINLINE known_fun_2 #-}
known_fun_2 :: a -&gt; a -&gt; a
known_fun_2 x _ = x

known_oversat_app :: () -&gt; Int
known_oversat_app _ = known_fun_2 id id 10</code></pre>
<p>compiles to the following C-- function</p>
<pre><code>#!c
Main_knownzuoversatzuapp_entry() {
    cmj:
        if (Sp - 12 &lt; SpLim) goto cmm;
        I32[Sp + 0] = stg_INTLIKE_closure+209;
        I32[Sp - 4] = stg_ap_p_info;
        I32[Sp - 8] = base_GHCziBase_id_closure;
        I32[Sp - 12] = base_GHCziBase_id_closure;
        Sp = Sp - 12;
        jump Main_knownzufunzu2_entry ();
    cmm:
        R1 = Main_knownzuoversatzuapp_closure;
        jump stg_gc_fun ();
}</code></pre>
<pre><code>_Main_knownzuoversatzuapp_entry:
Lcmj:
    leal -12(%ebp),%eax
    cmpl 84(%ebx),%eax
    jb Lcmm
    movl L_stg_INTLIKE_closure$non_lazy_ptr,%eax
    addl $209,%eax
    movl %eax,(%ebp)
    movl L_stg_ap_p_info$non_lazy_ptr,%eax
    movl %eax,-4(%ebp)
    movl $_base_GHCziBase_id_closure,-8(%ebp)
    movl $_base_GHCziBase_id_closure,-12(%ebp)
    addl $-12,%ebp
    jmp _Main_knownzufunzu2_entry
Lcmm:
    movl $_Main_knownzuoversatzuapp_closure,%esi
* 4(%ebx)</code></pre>
<p>As you might see, despite being a call to a known function, this code makes use of the generic apply functions we discussed in the last section. Let's pick the function apart and see how it works.</p>
<p>First, we do the usual stack check. What differs from the last time we saw this check is that we are not only allocating space for arguments on the stack, but also for a <em>continuation</em>. We set up these new stack entries as follows:</p>
<pre><code>#!c
    I32[Sp + 0] = stg_INTLIKE_closure+209;
    I32[Sp - 4] = stg_ap_p_info;
    I32[Sp - 8] = base_GHCziBase_id_closure;
    I32[Sp - 12] = base_GHCziBase_id_closure;
    Sp = Sp - 12;</code></pre>
<p>i.e. the final stack looks as follows (note that the code overwrites the old pointer to a closure of type ()):</p>
<pre><code>
 /----\    +---------------------------+
 | Sp |---&gt;| base_GHCziBase_id_closure |
 \----/    +---------------------------+
           | base_GHCziBase_id_closure |
           +---------------------------+
           |       stg_ap_p_info       |
           +---------------------------+
           |  stg_INTLIKE_closure+209  |
           +---------------------------+
           |           ...             |</code></pre>
<p>Because</p>
<pre><code>known_fun_2</code></pre>
<p>is of arity 2, when we jump to its entry code, it will only consume the top two arguments from the stack: i.e. the two pointers to</p>
<pre><code>base_GHCziBase_id_closure</code></pre>
<p>. It will then evaluate to some sort of value and transfer control to the entry code for</p>
<pre><code>stg_ap_p_info</code></pre>
<p>.</p>
<p>This is where the magic happens: the entry code for</p>
<pre><code>stg_ap_p_info</code></pre>
<p>will apply the function value that was returned from</p>
<pre><code>known_fun_2</code></pre>
<p>to the (pointer) argument in the &quot;free variable&quot; of its (stack allocated) closure -- and we have arranged that that is</p>
<pre><code>stg_INTLIKE_closure+209`, i.e. the closure for the `Int</code></pre>
<p>literal</p>
<pre><code>10</code></pre>
<p>. This code is shared with the generic application functions for calls to unknown functions, so this will make use of the</p>
<pre><code>stg_ap_p_fast</code></pre>
<p>function we saw before.</p>
<p>Finally, control will be transferred back to the caller for</p>
<pre><code>known_oversat_app</code></pre>
<p>, and all will be well.</p>
<h2 id="example-6-allocation-of-thunks-and-data">Example 6: allocation of thunks and data</h2>
<p>Something that happens all the time in Haskell is allocation. There are three principal types of thing that get allocated: function closures, thunks, and data. These are all treated pretty much the same in the STG machine for the simple reason that they share many common characteristics:</p>
<ul>
<li>Entry code which the STG machine jumps to, in order to evaluate</li>
</ul>
<p><code>  them</code></p>
<ul>
<li>Note that for constructors, the entry code is trivial, as they</li>
</ul>
<p><code>     are always already evaluated! In this case, control will be</code><br />
<code>     transferred directly back to the caller's continuation.</code></p>
<ul>
<li>Free variables stored in a closure
<ul>
<li>For data, these &quot;free variables&quot; will be the values in the fields</li>
</ul></li>
</ul>
<p><code>     of the particular data constructor</code></p>
<ul>
<li>Info-tables containing various miscellaneous metadata about the</li>
</ul>
<p><code>  heap object, such as function arity</code></p>
<p>Let us look at how a thunk and a data constructor get allocated in a simple setting:</p>
<pre><code>build_data :: Int -&gt; Maybe Int
build_data x = Just (x + 1)</code></pre>
<p>This compiles into the following C--:</p>
<pre><code>#!c
Main_buildzudata_entry() {
    clE:
        Hp = Hp + 20;
        if (Hp &gt; HpLim) goto clH;
        I32[Hp - 16] = slk_info;
        I32[Hp - 8] = I32[Sp + 0];
        I32[Hp - 4] = base_DataziMaybe_Just_con_info;
        I32[Hp + 0] = Hp - 16;
        R1 = Hp - 2;
        Sp = Sp + 4;
        jump (I32[I32[Sp + 0]]) ();
    clI:
        R1 = Main_buildzudata_closure;
        jump stg_gc_fun ();
    clH:
        HpAlloc = 20;
        goto clI;
}</code></pre>
<pre><code>_Main_buildzudata_entry:
LclE:
    addl $20,%edi
    cmpl 92(%ebx),%edi
    ja LclH
    movl $_slk_info,-16(%edi)
    movl (%ebp),%eax
    movl %eax,-8(%edi)
    movl $_base_DataziMaybe_Just_con_info,-4(%edi)
    leal -16(%edi),%eax
    movl %eax,(%edi)
    leal -2(%edi),%esi
    addl $4,%ebp
    movl (%ebp),%eax
* %eax)
LclH:
    movl $20,112(%ebx)
LclI:
    movl $_Main_buildzudata_closure,%esi
* 4(%ebx)</code></pre>
<p>Let's break this function down slowly.</p>
<h3 id="checking-for-sufficient-heap-space">Checking for sufficient heap space</h3>
<p>Any function that needs to allocate memory might find that the heap has been exhausted. If that happens, it needs to call into the garbage collector in order to get the heap cleaned up and (possibly) enlarged.</p>
<p>Hence, the first thing any such function does is check to see if enough memory is available for its purposes:</p>
<pre><code>#!c
clE:
    Hp = Hp + 20;
    if (Hp &gt; HpLim) goto clH;
...
clI:
    R1 = Main_buildzudata_closure;
    jump stg_gc_fun ();
clH:
    HpAlloc = 20;
    goto clI;</code></pre>
<p>This is simple enough. The function needs to allocate 20 bytes (the data constructor takes up 2 words, and the thunk will take up 3), so it speculatively increments Hp and then checks the STG registers</p>
<pre><code>Hp` and `HpLim</code></pre>
<p>(the pointer to the top of the available heap space) against each other.</p>
<p>If memory is insufficient (i.e. we have moved</p>
<pre><code>Hp</code></pre>
<p>past the top of the available heap), the code deals with it by setting the</p>
<pre><code>HpAlloc` register to the number of bytes needed and `R1</code></pre>
<p>to the closure for the function in which the heap check failed, before jumping into the hand-written garbage collector code for the cleanup. The garbage collector will resume execution of the code by using the information from</p>
<pre><code>R1</code></pre>
<p>, after it has freed up enough memory.</p>
<p>Side note: I believe that the line setting</p>
<pre><code>R1</code></pre>
<p>is unnecessary here, because</p>
<pre><code>R1</code></pre>
<p>should anyway always be set to the address of the closure when executing the closure entry code. I could be wrong, though.</p>
<h3 id="performing-the-actual-allocation">Performing the actual allocation</h3>
<p>Once the heap check succeeds, we will be able to enter the body of the function proper. Since the</p>
<pre><code>Hp</code></pre>
<p>has already been incremented, we can just construct the new heap objects directly:</p>
<pre><code>#!c
    I32[Hp - 16] = slk_info;
    I32[Hp - 8] = I32[Sp + 0];
    I32[Hp - 4] = base_DataziMaybe_Just_con_info;
    I32[Hp + 0] = Hp - 16;</code></pre>
<p>So we get something like this:</p>
<pre><code>
            |              ...               |
            +--------------------------------+
            |           slk_info             |&lt;-\ Pointer to thunk info table
            +--------------------------------+  |
            |          (undefined)           |  |
            +--------------------------------+  |
            |               x                |  | The &quot;x + 1&quot; thunk&#39;s free variable
            +--------------------------------+  |
            | base_DataziMaybe_Just_con_info |  | Pointer to Just info table
  /----\    +--------------------------------+  |
  | Hp |---&gt;|                                |--/ Free variable of Just constructor
  \----/    +--------------------------------+</code></pre>
<p>The bottom two words are the allocated</p>
<pre><code>Just</code></pre>
<p>value, and the three above that correspond to the</p>
<pre><code>x + 1</code></pre>
<p>closure.</p>
<h3 id="returning-an-allocated-value-to-the-caller">Returning an allocated value to the caller</h3>
<p>Now that we have allocated the data we entered the function in order to construct, we need to return it to the caller. This is achieved by the following code:</p>
<pre><code>#!c
    R1 = Hp - 2;
    Sp = Sp + 4;
    jump (I32[I32[Sp + 0]]) ();</code></pre>
<p>To return, the STG machine:</p>
<ol>
<li>Sets
<pre><code>R1</code></pre>
<p>to the pointer to the result of evaluation</p></li>
<li>Pops all the arguments to the function from the stack</li>
<li>Jumps to the entry code for the continuation. This is always</li>
</ol>
<p><code>   found at the top of the STG stack, logically below any arguments</code><br />
<code>   that were pushed to make the call.</code></p>
<p>This is indeed exactly what happens here, with two interesting points: pointer tagging, and the double-deference of the stack pointer. These will be discussed in the next two subsections.</p>
<h4 id="pointer-tagging">Pointer tagging</h4>
<p>One exciting feature is that the code setting</p>
<pre><code>R1</code></pre>
<p>, i.e.</p>
<pre><code>R1 = Hp - 2`. This is setting `R1` to point to the `Just</code></pre>
<p>, we just allocated, but simultaneously tagging that pointer with the value 2. The fact that the tag is non-zero indicates to users of the pointer that the thing pointed to is already evaluated. Furthermore, because</p>
<pre><code>Maybe</code></pre>
<p>has only two constructors, we are able to use the pointer tags to record which constructor it evaluated to: in this case, the 2 indicates the</p>
<pre><code>Just</code></pre>
<p>constructor.</p>
<p>It is compulsory to tag pointers before jumping to the address of the continuation entry code: the entry code can and will rely on those tags being present!</p>
<p>====</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>====</p>
<p>Because I have compiled GHC without</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>, the entry code for the continuation is found by dereferencing the pointer to the info table we found at the top of the STG stack - i.e. a double-dereference.</p>
<p>The layout of heap objects without</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>is as follows:</p>
<pre><code>
          Closure             Info table        Entry code
       +--------------+    +--------------+   +------------+
 x ---&gt;| Info pointer |---&gt;| Code pointer |--&gt;|    ...     |
       +--------------+    +--------------+
       |  .. FVs ..   |    |     ...      |</code></pre>
<p>With</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>on, the situation looks more like this:</p>
<pre><code>
          Closure          | .. Info table .. |
       +--------------+    +------------------+
 x ---&gt;| Info pointer |---&gt;| .. Entry code .. |
       +--------------+    |                  |
       |  .. FVs ..   |</code></pre>
<p>The</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>optimisation removes the need for that second dereference during the return, because the entry code is always right next to the info table. However, it requires special support from the backend for ensuring that data (i.e. the info table) and code are contiguous in memory, so it cannot always be used.</p>
<p>== Example 7:</p>
<pre><code>case</code></pre>
<p>expressions ==</p>
<p>Let us now examine how</p>
<pre><code>case</code></pre>
<p>expressions are handled. Compiling the following Haskell</p>
<pre><code>case_scrut :: Maybe Int -&gt; Int
case_scrut x = case x of Just x -&gt; x; Nothing -&gt; 10</code></pre>
<p>Produces this C-- code</p>
<pre><code>#!c
Main_casezuscrut_entry() {
    ccx:
        R1 = I32[Sp + 0];
        I32[Sp + 0] = scj_info;
        if (R1 &amp; 3 &lt;nowiki&gt;=&lt;/nowiki&gt; 0) goto ccA;
        jump (I32[I32[R1]]) ();
    ccA:
        jump (I32[scj_info]) ();
}

scj_ret() {
    cct:
        _ccu::I32 = R1 &amp; 3;
        if (_ccu::I32 &gt;= 2) goto ccv;
        R1 = stg_INTLIKE_closure+209;
        Sp = Sp + 4;
        jump (I32[I32[Sp + 0]]) ();
    ccv:
        R1 = I32[R1 + 2];
        Sp = Sp + 4;
        R1 = R1 &amp; (-4);
        jump (I32[I32[R1]]) ();
}</code></pre>
<pre><code>_Main_casezuscrut_entry:
Lccx:
    movl (%ebp),%esi
    movl $_scj_info,(%ebp)
    testl $3,%esi
    jne LccA
    movl (%esi),%eax
* %eax)
LccA:
* scj_info

_scj_ret:
Lcct:
    movl %esi,%eax
    andl $3,%eax
    cmpl $2,%eax
    jae Lccv
    movl L_stg_INTLIKE_closure$non_lazy_ptr,%eax
    leal 209(%eax),%esi
    addl $4,%ebp
    movl (%ebp),%eax
* %eax)
Lccv:
    movl 2(%esi),%esi
    addl $4,%ebp
    andl $-4,%esi
    movl (%esi),%eax
* %eax)</code></pre>
<p>Notice that GHC has generated <em>two</em> functions:</p>
<pre><code>Main_casezuscrut_entry` and `scj_ret</code></pre>
<p>correspond to the code for forcing the argument to the</p>
<pre><code>case</code></pre>
<p>, and for the <em>continuation</em> of the</p>
<pre><code>case</code></pre>
<p>respectively. Let's pick them apart and see how they work!</p>
<p>=== Forcing the scrutinee of the</p>
<pre><code>case</code></pre>
<p>===</p>
<p>When we first call the</p>
<pre><code>case_scrut</code></pre>
<p>function, its entry code begins executing:</p>
<pre><code>#!c
ccx:
    R1 = I32[Sp + 0];
    I32[Sp + 0] = scj_info;
    if (R1 &amp; 3 &lt;nowiki&gt;=&lt;/nowiki&gt; 0) goto ccA;
    jump (I32[I32[R1]]) ();
ccA:
    jump (I32[scj_info]) ();</code></pre>
<p>This is a function of arity 1 (i.e. with a single argument), so upon entry the machine state looks like this:</p>
<pre><code>
  /----\     +--------------------------+
  | R1 |----&gt;| Main_casezuscrut_closure |
  \----/     +--------------------------+

  /----\     +------------+
  | Sp |----&gt;|     x      |
  \----/     +------------+
             |    ...     |</code></pre>
<p>Because this is a top level function, the closure is statically allocated and contains no free variables. However, as discussed previously, the single argument to the function is guaranteed to be present at the top of the stack.</p>
<p>The code starts off by saving this argument (the</p>
<pre><code>x</code></pre>
<p>) temporarily into</p>
<pre><code>R1</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>#!c
ccx:
    R1 = I32[Sp + 0];</code></pre>
<p>The next thing the code does is overwrites this argument on the stack with a pointer to the info-table of the continuation code. This is the code that will be invoked after</p>
<pre><code>x</code></pre>
<p>has been evaluated into WHNF, and which will do the test to decide whether to continue as the</p>
<pre><code>Nothing` or as the `Just</code></pre>
<p>branch of the case:</p>
<pre><code>#!c
    I32[Sp + 0] = scj_info;</code></pre>
<p>As we saw earlier, any time that the STG machine decides that it has a value in its hand, it will continue evaluation by tail-calling the entry code found by dereferencing the info-table pointer at the top of the stack. So by putting the address of our continuation in here, we ensure that the entry code for</p>
<pre><code>scj_info</code></pre>
<p>is executed after</p>
<pre><code>x</code></pre>
<p>becomes a value.</p>
<p>Now, what we need to do is to start the evaluation of</p>
<pre><code>x</code></pre>
<p>. We could just jump into</p>
<pre><code>x</code></pre>
<p>'s entry code and hope for the best, but thanks to GHC's pointer tagging we can sometimes avoid doing this indirect branch.</p>
<p>So, instead, we test to see if the</p>
<pre><code>x</code></pre>
<p>pointer has a tag. If it is tagged, then we know that it is already evaluated and hence jump directly to the code for the continuation. If it is not tagged, we are forced to make the jump into the entry code for</p>
<pre><code>x</code></pre>
<p>. This choice is embodied by the following code:</p>
<pre><code>#!c
    if (R1 &amp; 3 &lt;nowiki&gt;=&lt;/nowiki&gt; 0) goto ccA;
    jump (I32[I32[R1]]) ();
ccA:
    jump (I32[scj_info]) ();</code></pre>
<p>Note the test</p>
<pre><code>R1 &amp; 3 &lt;nowiki&gt;=&lt;/nowiki&gt; 0</code></pre>
<dl>

<dd>this reflects the fact that pointer
</dd>
</dl>
<p>tags are stored in the lower 2 bits of the pointer on 32 bit machines. Another interesting feature is how the</p>
<pre><code>jump</code></pre>
<p>instructions find the entry code: again, we see a deference of the info pointer because</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>is turned off.</p>
<p>As we saw, the</p>
<pre><code>case</code></pre>
<p>scrutinisation code ended with one of two things happening: 1. A direct call into the continuation code</p>
<pre><code>scj_ret</code></pre>
<p>if the scrutinee was already evaluated 2. A call into the entry code for the scrutinee, if the scrutinee was not evaluated (or it <em>was</em> evaluated, but the pointer was somehow not tagged with that information) - Because we pushed</p>
<pre><code>scj_info</code></pre>
<p>onto the STG stack, control will eventually return to</p>
<pre><code>scj_ret</code></pre>
<p>after the evaluation of</p>
<pre><code>x</code></pre>
<p>has finished</p>
<p>It is now time to examine the continuation code to see what happens after</p>
<pre><code>x</code></pre>
<p>becomes a value.</p>
<h3 id="dealing-with-the-forced-scrutinee">Dealing with the forced scrutinee</h3>
<p>The continuation code is a little more complicated:</p>
<pre><code>#!c
cct:
    _ccu::I32 = R1 &amp; 3;
    if (_ccu::I32 &gt;= 2) goto ccv;
    R1 = stg_INTLIKE_closure+209;
    Sp = Sp + 4;
    jump (I32[I32[Sp + 0]]) ();
ccv:
    R1 = I32[R1 + 2];
    Sp = Sp + 4;
    R1 = R1 &amp; (-4);
    jump (I32[I32[R1]]) ();</code></pre>
<p>Whenever the STG machine evaluates to a value it will return the value by jumping to the entry point at the top of the stack. In this case,</p>
<pre><code>R1</code></pre>
<p>is guaranteed to be a (tagged) pointer to the thing that was just evaluated. Because we are scrutinising a</p>
<pre><code>Maybe</code></pre>
<p>type (which has fewer than 4 constructors) the code for the</p>
<pre><code>case</code></pre>
<p>continuation is able to use the tag bits on the returned pointer to decide which of the two branches to take:</p>
<pre><code>#!c
cct:
    _ccu::I32 = R1 &amp; 3;
    if (_ccu::I32 &gt;= 2) goto ccv;</code></pre>
<p>If we were scrutinising a data type with more constructors, the tag bits would only tell us that the thing was evaluated, not which constructor it was evaluated to. In this case, we would have to read the constructor tag by dereferencing</p>
<pre><code>R1</code></pre>
<p>and testing the resulting info table pointer against all possibilities.</p>
<p>If the tag was greater than or equal to 2, we go to the</p>
<pre><code>ccv</code></pre>
<p>branch, which deals with what happens if we had a</p>
<pre><code>Just</code></pre>
<p>. In this case, we need to continue by forcing the thunk inside the</p>
<pre><code>Just</code></pre>
<p>and returning that value to our caller, which is what these lines are doing:</p>
<pre><code>#!c
ccv:
    R1 = I32[R1 + 2];
    Sp = Sp + 4;
    R1 = R1 &amp; (-4);
    jump (I32[I32[R1]]) ();</code></pre>
<p>To access the thing inside the</p>
<pre><code>Just</code></pre>
<p>, the code assumes that the</p>
<pre><code>R1` pointer is tagged with the 2 that indicates a `Just</code></pre>
<p>constructor, and hence finds the first free variable (stored 4 bytes into the closure) using</p>
<pre><code>I32[R1 + 2]</code></pre>
<p>, which is then saved into</p>
<pre><code>R1`. It pops the address of `scj_info</code></pre>
<p>that was pushed onto the stack in</p>
<pre><code>Main_casezuscrut_entry` by moving `Sp</code></pre>
<p>up 4 bytes (remember that the STG stack grows downwards) and then untags and jumps into the entry code for the</p>
<pre><code>R1</code></pre>
<p>thunk, using the same double-dereference pattern discussed earlier.</p>
<p>There seems to be a small missed opportunity here: the code could check the pointer tag on</p>
<pre><code>R1</code></pre>
<p>, and then return directly if it is set. I imagine that this isn't being done in order to reduce possible code bloat.</p>
<h2 id="example-8-thunks-and-thunk-update">Example 8: thunks and thunk update</h2>
<p>You might be wondering how the</p>
<pre><code>x + 1</code></pre>
<p>thunk we saw allocated in a previous section will behave when it is actually forced. To remind you, the thunk we saw was constructed by the following Haskell code:</p>
<pre><code>build_data :: Int -&gt; Maybe Int
build_data x = Just (x + 1)</code></pre>
<p>So how does the</p>
<pre><code>x + 1</code></pre>
<p>thunk work? An excellent question! Let's take a look at the C-- for its entry code and find out:</p>
<pre><code>#!c
slk_entry() {
    cph:
        if (Sp - 12 &lt; SpLim) goto cpj;
        I32[Sp - 8] = stg_upd_frame_info;
        I32[Sp - 4] = R1;
        R1 = I32[R1 + 8];
        I32[Sp - 12] = soN_info;
        Sp = Sp - 12;
        if (R1 &amp; 3 &lt;nowiki&gt;=&lt;/nowiki&gt; 0) goto cpk;
        jump (I32[I32[R1]]) ();
    cpj: jump stg_gc_enter_1 ();
    cpk: jump (I32[soN_info]) ();
}

soN_ret() {
    cp7:
        Hp = Hp + 8;
        if (Hp &gt; HpLim) goto cpc;
        _soL::I32 = I32[R1 + 3] + 1;
        I32[Hp - 4] = ghczmprim_GHCziTypes_Izh_con_info;
        I32[Hp + 0] = _soL::I32;
        R1 = Hp - 3;
        Sp = Sp + 4;
        jump (I32[stg_upd_frame_info]) ();
    cpd: jump stg_gc_enter_1 ();
    cpc:
        HpAlloc = 8;
        goto cpd;
}</code></pre>
<pre><code>_sst_entry:
Lcph:
    leal -12(%ebp),%eax
    cmpl 84(%ebx),%eax
    jb Lcpj
    movl L_stg_upd_frame_info$non_lazy_ptr,%eax
    movl %eax,-8(%ebp)
    movl %esi,-4(%ebp)
    movl 8(%esi),%esi
    movl $_soN_info,-12(%ebp)
    addl $-12,%ebp
    testl $3,%esi
    jne Lcpk
    movl (%esi),%eax
* %eax)
Lcpj:
* 8(%ebx)
Lcpk:
* soN_info

_soN_ret:
Lcp7:
    addl $8,%edi
    cmpl 92(%ebx),%edi
    ja Lcpc
    movl 3(%esi),%eax
    incl %eax
    movl $_ghczmprim_GHCziTypes_Izh_con_info,-4(%edi)
    movl %eax,(%edi)
    leal -3(%edi),%esi
    addl $4,%ebp
    movl L_stg_upd_frame_info$non_lazy_ptr,%eax
* %eax)
Lcpc:
    movl $8,112(%ebx)
Lcpd:
* 8(%ebx)</code></pre>
<p>The original Haskell code read</p>
<pre><code>x + 1</code></pre>
<p>, but GHC has inlined the actual code for the addition operation on</p>
<pre><code>Int</code></pre>
<p>s, which looks something like:</p>
<pre><code>plusInt (I# a) (I# b) = I# (a + b)</code></pre>
<p>The second pattern match (to get</p>
<pre><code>b</code></pre>
<p>) has been performed statically by GHC, obtaining the machine literal 1, which shows up directly in the generated code. Therefore, the code only need to evaluate and case-decompose the unknown free variable</p>
<pre><code>x</code></pre>
<p>of our closure, to get the</p>
<pre><code>a` argument to `plusInt</code></pre>
<p>.</p>
<h3 id="thunk-entry-point">Thunk entry point</h3>
<p>This evaluation is what is being done by the thunk entry code</p>
<pre><code>slk_entry</code></pre>
<p>. Ignoring the stack check, the C-- begins thusly:</p>
<pre><code>#!c
    I32[Sp - 8] = stg_upd_frame_info;
    I32[Sp - 4] = R1;
    R1 = I32[R1 + 8];
    I32[Sp - 12] = soN_info;
    Sp = Sp - 12;</code></pre>
<p>Remembering that upon entry to the thunk entry code,</p>
<pre><code>R1</code></pre>
<p>points to the thunk's closure, the new stack looks as follows:</p>
<pre><code>
 /----\    +---------------------+
 | Sp |---&gt;|       soN_info      |
 \----/    +---------------------+
           | stg_upd_frame_info  |
           +---------------------+     +-------------+
           | (thunk closure ptr) |----&gt;|   slk_info  |
           +---------------------+     +-------------+
           |        ...          |     | (undefined) |
                                       +-------------+
                                       |      x      | Free variable of thunk
                                       +-------------+</code></pre>
<p>The C-- statement</p>
<pre><code>R1 = I32[R1 + 8]</code></pre>
<p>is pulling out the pointer to the free variable of the thunk (which was set up in</p>
<pre><code>Main_buildzudata_entry`) into `R1</code></pre>
<p>.</p>
<p>Finally, the entry code evaluates that free variable (checking the tag bits of the pointer first, as usual):</p>
<pre><code>#!c
    if (R1 &amp; 3 &lt;nowiki&gt;=&lt;/nowiki&gt; 0) goto cpk;
    jump (I32[I32[R1]]) ();
cpk: jump (I32[soN_info]) ();</code></pre>
<p>Because we put</p>
<pre><code>soN_info</code></pre>
<p>at the top of the stack, when evaluation of</p>
<pre><code>x</code></pre>
<p>is complete the STG machine will continue by executing the</p>
<pre><code>soN_ret</code></pre>
<p>code.</p>
<p>The most interesting feature of this code is the extra stuff that has been pushed onto the stack below</p>
<pre><code>soN_ret</code></pre>
<dl>

<dd>an info pointer
</dd>
</dl>
<p>called</p>
<pre><code>stg_upd_frame_info</code></pre>
<p>, and a pointer to the thunk currently being evaluated.</p>
<p>This is all part of the STG machine's thunk update mechanism. When the</p>
<pre><code>soN_ret</code></pre>
<p>continuation returns, it will transfer control <em>not</em> to the code forcing the thunk, but to some code which overwrites the contents of the current thunk closure with a closure representing an &quot;indirection&quot;. The entry code for such an indirection closure is trivial: it immediately returns a pointer to the thing that was returned from the</p>
<pre><code>soN_ret</code></pre>
<p>continuation in</p>
<pre><code>R1</code></pre>
<p>.</p>
<p>These indirections are the mechanism which ensures that the STG machine never repeats the work of evaluating a thunk more than once: after the first evaluation, any code forcing the thunk jumps into the indirection entry code rather than</p>
<pre><code>slk_entry</code></pre>
<p>.</p>
<p>That being said, let us look at how the continuation responsible for actually finding the value of</p>
<pre><code>x + 1</code></pre>
<p>works:</p>
<h3 id="continuation-of-the-thunk">Continuation of the thunk</h3>
<p>Upon entry to the continuation code, we have the evaluated</p>
<pre><code>x</code></pre>
<p>in</p>
<pre><code>R1`: it now needs to do the addition and allocate a `I#</code></pre>
<p>constructor to hold the result of the addition. Because of the allocation,</p>
<pre><code>soN_ret</code></pre>
<p>begins with a heap check. Ignoring that check, we have the following code:</p>
<pre><code>#!c
    _soL::I32 = I32[R1 + 3] + 1;
    I32[Hp - 4] = ghczmprim_GHCziTypes_Izh_con_info;
    I32[Hp + 0] = _soL::I32;
    R1 = Hp - 3;
    Sp = Sp + 4;
    jump (I32[stg_upd_frame_info]) ();</code></pre>
<p>This is mostly standard stuff. Because the</p>
<pre><code>R1</code></pre>
<p>pointer is guaranteed tagged, and there is only one possible constructor, the tag must be 1 and so the</p>
<pre><code>Int#` value inside the `Int</code></pre>
<p>is pulled out using</p>
<pre><code>I32[R1 + 3]</code></pre>
<p>. This is then put into a newly heap-allocated</p>
<pre><code>I#` constructor, which is returned in `R1</code></pre>
<p>after we pop the</p>
<pre><code>soN_info</code></pre>
<p>pointer from the stack.</p>
<p>The only interesting point is where we return to: rather than dereference</p>
<pre><code>Sp</code></pre>
<p>to find the info pointer at the top of the STG stack, GHC has generated code that takes advantage of the fact that the</p>
<pre><code>Sp` is guaranteed to point to `stg_upd_frame_info</code></pre>
<p>. This avoids one pointer dereference.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This document has left much of the detail of how STG is implemented out: notable omissions include CAFs, and the precise behaviour of the garbage collector. Nonetheless, my hope is that it has helped you to gain some more insight into the weird and wonderful way the Haskell evaluation model is implemented.</p>
<h1 id="support-for-generic-programming">Support for generic programming</h1>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<p>GHC includes a new (in 2010) mechanism to let you write generic functions. It is described in paper <a href="http://www.dreixel.net/research/pdf/gdmh_nocolor.pdf">A generic deriving mechanism for Haskell</a>. This page sketches the specifics of the implementation; we assume you have read the paper. The <a href="http://www.haskell.org/haskellwiki/Generics">HaskellWiki page</a> gives a more general overview.</p>
<p>This mechanism replaces the <a href="http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/generic-classes.html">previous generic classes implementation</a>. What we describe until the &quot;Kind polymorphic overhaul&quot; section is implemented and released in GHC 7.2.1.</p>
<h2 id="status">Status</h2>
<p>Use <strong>Keyword</strong> =</p>
<pre><code>Generics</code></pre>
<p>to ensure that a ticket ends up on this auto-generated list</p>
<p>Open Tickets: <a href="TicketQuery(status=infoneeded,status=new" title="wikilink">patch|infoneeded,keywords=~Generics)</a></p>
<p>Closed Tickets: <a href="TicketQuery(status=infoneeded,status=closed,keywords=~Generics)" class="uri" title="wikilink">TicketQuery(status=infoneeded,status=closed,keywords=~Generics)</a></p>
<h2 id="main-components">Main components</h2>
<ul>
<li><pre><code>TcDeriv.tcDeriving` now allows deriving `Generic</code></pre>
<p>instances.</p></li>
</ul>
<ul>
<li>The representation types and core functionality of the library live on
<pre><code>GHC.Generics` (on the `ghc-prim</code></pre>
<p>package).</p></li>
</ul>
<ul>
<li>Many names have been added as known in
<pre><code>prelude/PrelNames</code></pre></li>
</ul>
<ul>
<li>Most of the code generation is handled by
<pre><code>types/Generics</code></pre></li>
</ul>
<h2 id="things-that-have-been-removed">Things that have been removed</h2>
<ul>
<li>All of the <a href="http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/generic-classes.html">generic classes stuff</a>. In particular, the following have been removed:
<ul>
<li><pre><code>hasGenerics` field from `TyCon</code></pre>
<p>;</p></li>
<li><pre><code>HsNumTy` constructor from `HsType</code></pre>
<p>;</p></li>
<li><pre><code>TypePat` constructor from `Pat</code></pre>
<p>.</p></li>
</ul></li>
</ul>
<ul>
<li>The
<pre><code>-XGenerics</code></pre>
<p>flag is now deprecated.</p></li>
</ul>
<h2 id="what-already-works">What already works</h2>
<ul>
<li><pre><code>Generic` and `Generic1` instances can be derived when `-XDeriveGeneric</code></pre>
<p>is enabled.</p></li>
</ul>
<ul>
<li>The
<pre><code>default` keyword can used for generic default method signatures when `-XDefaultSignatures</code></pre>
<p>is enabled.</p></li>
</ul>
<ul>
<li>Generic defaults are properly instantiated when giving an instance without defining the generic default method.</li>
</ul>
<ul>
<li>Base types like
<pre><code>[]`, `Maybe</code></pre>
<p>, tuples, come with Generic instances.</p></li>
</ul>
<h2 id="testing">Testing</h2>
<ul>
<li>Tests are available under the
<pre><code>generics</code></pre>
<p>directory of the testsuite.</p></li>
</ul>
<h1 id="kind-polymorphic-overhaul">Kind polymorphic overhaul</h1>
<p>With the new</p>
<pre><code>-XPolyKinds` functionality we can make the support for generic programming better typed. The basic idea is to define the universe codes (`M1`, `:+:</code></pre>
<p>, etc.) as constructors of a datatype. Promotion then lifts these constructors to types, which we can use as before, only that now we have them all classified under a new kind. The overhaul of the main module is explained below; for easier comparison with the current approach, names are kept the same whenever possible.</p>
<h2 id="generic-representation-universe">Generic representation universe</h2>
<pre><code>m` is the only real parameter here. `f` and `x</code></pre>
<p>are there because we can't write kinds directly, since</p>
<pre><code>Universe</code></pre>
<p>is also a datatype (even if we're only interested in its promoted version). So we pass</p>
<pre><code>f` and `x</code></pre>
<p>only to set them to</p>
<pre><code>* -&gt; *` and `*`, respectively, in `Interprt</code></pre>
<p>.</p>
<pre><code>m</code></pre>
<p>is different: it stands for the kind of metadata representation types, and we really want to be polymorphic over that, since each user datatype will introduce a new metadata kind.</p>
<pre><code>data Universe f x m = 
  -- Void (used for datatypes without constructors)
    VV
    
  -- Unit
  | UU
  
  -- The parameter
  | PAR
  
* -&gt; *
  | REC f
  
* 
  | KK Constant x
  
  -- Metadata
  | MM MetaData m (Universe f x m)
  
  -- Sum, product, composition
  | Universe f x m :++: Universe f x m
* : Universe f x m
  | f :..: Universe f x m
  -- Note that we always compose a concrete type on the left (like []) with
  -- a generic representation on the right

infixr 5 :++:
infixr 6 :**:
infixr 6 :*:
infixr 7 :..:

-- Some shortcuts
data MetaData = CC | DD | SS
data Constant = PP | RR

data ConstantV (c :: Constant) where
  P :: ConstantV PP
  R :: ConstantV RR
  
data MetaDataV (m :: MetaData) where
  C :: MetaDataV CC
  D :: MetaDataV DD
  S :: MetaDataV SS</code></pre>
<h2 id="universe-interpretation">Universe interpretation</h2>
<p>As promised, we set</p>
<pre><code>f` to `* -&gt; *` and `x` to `*</code></pre>
<p>. Unfortunately we don't have [GhcKinds#Explicitkindvariables explicit kind variable annotations] yet, so we cannot leave</p>
<pre><code>m</code></pre>
<p>polymorphic! So this code doesn't compile:</p>
<pre><code>data Interprt :: Universe (* -&gt; *) * m -&gt; * -&gt; * where

  -- No interpretation for VV, as it shouldn&#39;t map to any value
  
  -- Unit
  U1     :: Interprt UU p
  
  -- The parameter
  Par1   :: p -&gt; Interprt PAR p
  
* -&gt; *
  Rec1   :: r p -&gt; Interprt (REC r) p
  
  -- Constants
  K1     :: x -&gt; Interprt (KK c x) p
  -- Constants shortcuts
  Par0   :: x -&gt; Interprt (KK PP x) p
  Rec0   :: x -&gt; Interprt (KK RR x) p
  
  -- Metadata
  M1     :: Interprt x p -&gt; Interprt (MM m c x) p
  -- Metadata shortcuts
  D1     :: Interprt x p -&gt; Interprt (MM DD c x) p
  C1     :: Interprt x p -&gt; Interprt (MM CC c x) p
  S1     :: Interprt x p -&gt; Interprt (MM SS c x) p
  
  -- Sum, product, and composition
  L1     :: Interprt a r -&gt; Interprt (a :++: b) r
  R1     :: Interprt b r -&gt; Interprt (a :++: b) r
* )  :: Interprt a r -&gt; Interprt b r -&gt; Interprt (a :**: b) r
  Comp1  :: f (Interprt g r) -&gt; Interprt (f :..: g) r</code></pre>
<h3 id="names">Names</h3>
<p>As an aside, note that we have to come up with names like</p>
<pre><code>UU` and `KK` for the `Universe</code></pre>
<p>even though we really just wanted to use</p>
<pre><code>U1` and `K1</code></pre>
<p>, like before. Then we would have a type and a constructor with the same name, but that's ok. However,</p>
<pre><code>Universe</code></pre>
<p>defines both a type (with constructors) and a kind (with types). So if we were to use</p>
<pre><code>U1</code></pre>
<p>in the</p>
<pre><code>Universe` constructors, then we could no longer use that name in the `Interprt</code></pre>
<p>constructors. It's a bit annoying, because we are never really interested in the type</p>
<pre><code>Universe</code></pre>
<p>and its constructors: we're only interested in its promoted variant. This is a slight annoyance of automatic promotion: when you define a &quot;singleton type&quot; (like our GADT</p>
<pre><code>Interprt` for `Universe</code></pre>
<p>) you cannot reuse the constructor names.</p>
<h2 id="metadata-representation">Metadata representation</h2>
<pre><code>data Proxy d = Proxy -- kind polymorphic

-- Meta data classes
class Datatype d where -- kind polymorphic
  -- The name of the datatype, fully qualified
  datatypeName :: Proxy d -&gt; String</code></pre>
<p>There's more of these, but they don't add any new concerns.</p>
<h2 id="conversion-between-user-datatypes-and-generic-representation">Conversion between user datatypes and generic representation</h2>
<p>We now get a more precise kind for</p>
<pre><code>Rep</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>-- Representable types of kind *
class Generic a where
* -&gt; *) * m
  from :: a -&gt; Interprt (Rep a) x
  to   :: Interprt (Rep a) x -&gt; a
  
-- Representable types of kind * -&gt; *
class Generic1 (f :: * -&gt; *) where
* -&gt; *) * m
  from1  :: f a -&gt; Interprt (Rep1 f) a
  to1    :: Interprt (Rep1 f) a -&gt; f a</code></pre>
<p>== Example generic function:</p>
<pre><code>fmap` (kind `* -&gt; *</code></pre>
<p>) ==</p>
<p>User-visible class, exported:</p>
<pre><code>class Functor (f :: * -&gt; *) where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
  default fmap :: (Generic1 f, GFunctor (Rep1 f)) =&gt; (a -&gt; b) -&gt; f a -&gt; f b
  fmap f = to1 . gfmap f . from1  </code></pre>
<p>Defined by the generic programmer, not exported:</p>
<pre><code>class GFunctor (f :: Universe (* -&gt; *) * m) where
  gfmap :: (a -&gt; b) -&gt; Interprt f a -&gt; Interprt f b
  
instance GFunctor UU where
  gfmap _ U1 = U1
  
instance GFunctor PAR where
  gfmap f (Par1 a) = Par1 (f a)

instance GFunctor (KK i c) where
  gfmap _ (K1 a) = K1 a

instance (Functor f) =&gt; GFunctor (REC f) where
  gfmap f (Rec1 a) = Rec1 (fmap f a)

instance (GFunctor f) =&gt; GFunctor (MM m c f) where
  gfmap f (M1 a) = M1 (gfmap f a)

instance (GFunctor f, GFunctor g) =&gt; GFunctor (f :++: g) where
  gfmap f (L1 a) = L1 (gfmap f a)
  gfmap f (R1 a) = R1 (gfmap f a)

instance (GFunctor f, GFunctor g) =&gt; GFunctor (f :**: g) where
*  b) = gfmap f a :*: gfmap f b

instance (Functor f, GFunctor g) =&gt; GFunctor (f :..: g) where
  gfmap f (Comp1 x) = Comp1 (fmap (gfmap f) x)</code></pre>
<p>Note that previously</p>
<pre><code>Functor` and `GFunctor</code></pre>
<p>had exactly the same types. Now we can make clear what the difference between them is.</p>
<p>== Example generic function:</p>
<pre><code>show` (kind `*</code></pre>
<p>, uses metadata) ==</p>
<p>User-visible class, exported:</p>
<pre><code>class Show (a :: *) where
  show :: a -&gt; String
  default show :: (Generic a, GShow (Rep a)) =&gt; a -&gt; String
  show = gshow . from</code></pre>
<p>Defined by the generic programmer, not exported:</p>
<pre><code>class GShow (f :: Universe (* -&gt; *) * m) where
  gshow :: Interprt f x -&gt; String
  
instance GShow UU where
  gshow U1 = &quot;&quot;
  
instance (P.Show c) =&gt; GShow (KK i c) where
  gshow (K1 a) = P.show a
  
instance (Datatype c, GShow f) =&gt; GShow (MM DD c f) where
  gshow (M1 x) = datatypeName (Proxy :: Proxy c) ++ &quot; &quot; ++ gshow x</code></pre>
<p>The other cases do not add any further complexity.</p>
<h2 id="example-datatype-encoding-lists-derived-by-the-compiler">Example datatype encoding: lists (derived by the compiler)</h2>
<pre><code>  
instance Generic [a] where
  type Rep [a] = MM DD DList 
                   (MM CC DList_Nil UU :++: 
* : KK RR [a]))

  from [] = D1 (L1 (C1 U1))
*  Rec0 t)))
  to (D1 (L1 (C1 U1))) = []
*  Rec0 t)))) = h:t
  
-- Metadata
data List_Meta = DList | DList_Nil | DList_Cons</code></pre>
<p>Note that we use only one datatype; more correct would be to use 3, one for</p>
<pre><code>DList</code></pre>
<p>, another for the constructors, and yet another for the selectors (or maybe even n datatypes for the selectors, one for each constructor?) But we don't do that because</p>
<pre><code>Universe` is polymorphic only over `m</code></pre>
<p>, so a single metadata representation type. If we want a more fine-grained distinction then we would need more parameters in</p>
<pre><code>Universe</code></pre>
<p>, and also to split the</p>
<pre><code>MM</code></pre>
<p>case.</p>
<pre><code>instance Datatype DList where datatypeName _ = &quot;[]&quot;</code></pre>
<h3 id="digression">Digression</h3>
<p>Even better would be to index the metadata representation types over the type they refer to. Something like:</p>
<pre><code>  data family MetaTypes a -- kind polymorphic
  data instance MetaTypes [] = DList | DList_Nil | DList_Cons</code></pre>
<p>But now we are basically asking for promotion of data families, since we want to use promoted</p>
<pre><code>DList`. Also, the case for `MM` in `Universe</code></pre>
<p>would then be something like:</p>
<pre><code>  | MM MetaData (MetaTypes m) (Universe f x m)</code></pre>
<p>But I'm not entirely sure about this.</p>
<h2 id="ghc-8.0-and-later">GHC 8.0 and later</h2>
<h3 id="type-level-metadata-encoding">Type-level metadata encoding</h3>
<p>Because what we've described so far is rather backwards-incompatible, we wanted to at least try to improve the encoding of metadata, which was currently rather clunky prior to GHC 8.0 (giving rise to lots of empty, compiler-generated datatypes and respective instances). We can accomplished that by changing</p>
<pre><code>M1</code></pre>
<p>to keep the meta-information <em>at the type level</em>:</p>
<pre><code>newtype M1 i (c :: Meta) f p = M1 { unM1 :: f p }

data Meta = MetaData Symbol Symbol  Bool
          | MetaCons Symbol FixityI Bool
          | MetaSel  Symbol SourceUnpackedness SourceStrictness DecidedStrictness

data Fixity  = Prefix  | Infix  Associativity Int
data FixityI = PrefixI | InfixI Associativity Nat

data Associativity = LeftAssociative
                   | RightAssociative
                   | NotAssociative

data SourceUnpackedness = NoSourceUnpackedness
                        | SourceNoUnpack
                        | SourceUnpack

data SourceStrictness = NoSourceStrictness
                      | SourceLazy
                      | SourceStrict

data DecidedStrictness = DecidedLazy
                       | DecidedStrict
                       | DecidedUnpack</code></pre>
<p>Why did we need to add</p>
<pre><code>FixityI`? Because `Fixity` does not promote. Yet, we wanted to expose `Fixity` to the user, not `FixityI</code></pre>
<p>. Note that the meta-data classes remained mostly unchanged (aside from some enhancements to <a href="https://ghc.haskell.org/trac/ghc/ticket/10030">Datatype</a> and <a href="https://ghc.haskell.org/trac/ghc/ticket/10716">Selector</a>):</p>
<pre><code>class Datatype d where
* -&gt; *) a -&gt; [Char]
* -&gt; *) a -&gt; [Char]
* -&gt; *) a -&gt; [Char]
* -&gt; *) a -&gt; Bool

class Constructor c where
* -&gt; *) a -&gt; [Char]
* -&gt; *) a -&gt; Fixity
* -&gt; *) a -&gt; Bool

class Selector s where
* -&gt; *) a -&gt; [Char]
* -&gt; *) a -&gt; SourceUnpackedness
* -&gt; *) a -&gt; SourceStrictness
* -&gt; *) a -&gt; DecidedStrictness</code></pre>
<p>But now, using the magic of singletons, we give <em>one single instance</em> for each of these classes, instead of having to instantiate them each time a user derives</p>
<pre><code>Generic</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>instance (KnownSymbol n, KnownSymbol m, KnownSymbol p, SingI nt)
    =&gt; Datatype (&#39;MetaData n m p nt) where
  datatypeName _ = symbolVal (Proxy :: Proxy n)
  moduleName   _ = symbolVal (Proxy :: Proxy m)
  packageName  _ = symbolVal (Proxy :: Proxy p)
  isNewtype    _ = fromSing  (sing  :: Sing nt)

instance (KnownSymbol n, SingI f, SingI r)
    =&gt; Constructor (&#39;MetaCons n f r) where
  conName     _ = symbolVal (Proxy :: Proxy n)
  conFixity   _ = fromSing  (sing  :: Sing f)
  conIsRecord _ = fromSing  (sing  :: Sing r)

instance (SingI mn, SingI su, SingI ss, SingI ds)
    =&gt; Selector (&#39;MetaSel mn su ss ds) where
  selName               _ = fromMaybe &quot;&quot; (fromSing (sing :: Sing mn))
  selSourceUnpackedness _ = fromSing (sing :: Sing su)
  selSourceStrictness   _ = fromSing (sing :: Sing ss)
  selDecidedStrictness  _ = fromSing (sing :: Sing ds)</code></pre>
<p>Naturally, we require singletons for</p>
<pre><code>Bool`, `Maybe`, `FixityI`, `Associativity`, `SourceUnpackedness`, `SourceStrictness`, and `DecidedStrictness`, but that is one time boilerplate code, and is not visible for the user. (In particular, this is where we encode that the demotion of (the kind) `FixityI` is (the type) `Fixity</code></pre>
<p>.)</p>
<p>I believe this change is almost fully backwards-compatible, and lets us simplify the code for</p>
<pre><code>deriving Generic</code></pre>
<p>in GHC. Furthermore, I suspect it will be useful to writers of generic functions, who can now match at the type-level on things such as whether a constructor is a record or not.</p>
<p>I say &quot;almost fully backwards-compatible&quot; because handwritten</p>
<pre><code>Generic</code></pre>
<p>instances might break with this change. But we've never recommended doing this, and I think users who do this are more than aware that they shouldn't rely on it working across different versions of GHC.</p>
<h4 id="example-1">Example</h4>
<p>Before GHC 8.0, the following declaration:</p>
<pre><code>#!hs
data Example = Example deriving Generic1</code></pre>
<p>Would have generated all of this:</p>
<pre><code>#!hs
instance Generic Example where
  type Rep Example = D1 D1Example (C1 C1_0Example (S1 NoSelector U1))
  ...

data D1Example
data C1_0Example

instance Datatype D1Example where
  datatypeName _ = &quot;Example&quot;
  moduleName   _ = &quot;Module&quot;
  isNewtype    _ = False

instance Constructor C1_0Example where
  conName     _ = &quot;Example&quot;
  conFixity   _ = Prefix
  conIsRecord _ = False</code></pre>
<p>But on GHC 8.0 and later, this is all that is generated (assuming it was compiled with no strictness optimizations):</p>
<pre><code>#!hs
instance Generic Example where
  type Rep Example =
    D1 (&#39;MetaData &quot;Example&quot; &quot;Module&quot; &quot;package&quot; &#39;False)
      (C1 (&#39;MetaCons &quot;Example&quot; &#39;PrefixI &#39;False)
        (S1 (&#39;MetaSel &#39;Nothing &#39;NoSourceUnpackedness &#39;NoSourceStrictness &#39;DecidedLazy)
          U1))
  ...</code></pre>
<p>Not bad!</p>
<h3 id="strictness">Strictness</h3>
<p>The</p>
<pre><code>Selector</code></pre>
<p>class now looks like this:</p>
<pre><code>#!hs
class Selector s where
* -&gt; *) a -&gt; [Char]
* -&gt; *) a -&gt; SourceUnpackedness
* -&gt; *) a -&gt; SourceStrictness
* -&gt; *) a -&gt; DecidedStrictness

data SourceUnpackedness = NoSourceUnpackedness
                        | SourceNoUnpack
                        | SourceUnpack

data SourceStrictness = NoSourceStrictness
                      | SourceLazy
                      | SourceStrict

data DecidedStrictness = DecidedLazy
                       | DecidedStrict
                       | DecidedUnpack</code></pre>
<p>This design draws much inspiration from the way Template Haskell handles strictness as of GHC 8.0 (see <a href="https://ghc.haskell.org/trac/ghc/ticket/10697">here</a> for what motivated the change). We make a distinction between the <em>source</em> strictness annotations and the strictness GHC actually <em>decides</em> during compilation. To illustrate the difference, consider the following data type:</p>
<pre><code>#!hs
data T = T {-# UNPACK #-} &lt;nowiki&gt;Int&lt;/nowiki&gt;
                          &lt;nowiki&gt;Int&lt;/nowiki&gt;
                           Int
  deriving Generic</code></pre>
<p>If we were to encode the source unpackedness and strictness of each of</p>
<pre><code>T`&#39;s fields, they were be `SourceUnpack`/`SourceStrict`, `NoSourceUnpackedness`/`SourceStrict`, and `NoSourceUnpackedness`/`NoSourceStrictness</code></pre>
<p>, no matter what. Source unpackedness/strictness is a purely syntactic property.</p>
<p>The strictness that the user writes, however, may be different from the strictness that GHC decides during compilation. For instance, if we were to compile</p>
<pre><code>T` with no optimizations, the decided strictness of each field would be `DecidedStrict`, `DecidedStrict`, and `DecidedLazy`. If we enabled `-O2`, however, they would be `DecidedUnpack`, `DecidedStrict`, and `DecidedLazy</code></pre>
<p>.</p>
<p>Things become even more interesting when</p>
<pre><code>-XStrict` and `-O2` are enabled. Then the strictness that GHC would decided is `DecidedUnpack`, `DecidedStrict`, and `DecidedStrict`. And if you enable `-XStrict`, `-O2`, &#39;&#39;and&#39;&#39; `-funbox-strict-fields`, then the decided strictness is `DecidedUnpack`, `DecidedUnpack`, and `DecidedUnpack</code></pre>
<p>.</p>
<p>The variety of possible</p>
<pre><code>DecidedStrictness</code></pre>
<p>combinations demonstrates that strictness is more just annotation</p>
<h2 id="source-tree-layout">Source Tree Layout</h2>
<p>An overview of the source tree may be found [wiki:Commentary/SourceTree here].</p>
<h2 id="build-system-basics">Build System Basics</h2>
<p>Detailed information about the build system may be found [wiki:Building here]; what follows is a quick overview, highlighting the areas where GHC's build system diverges substantially from the way</p>
<pre><code>make</code></pre>
<p>is used in most other projects.</p>
<p>Most projects keep the parts of their build machinery in files called</p>
<pre><code>Makefile</code></pre>
<p>found in many/most subdirectories of the source tree. GHC uses the filename</p>
<pre><code>ghc.mk</code></pre>
<p>instead; you'll find a file with this name in quite a number of subdirectories.</p>
<p>Other build system files are in</p>
<pre><code>rules/</code></pre>
<p>and</p>
<pre><code>mk/</code></pre>
<p>.</p>
<h2 id="coding-style">Coding Style</h2>
<p>The [wiki:WorkingConventions Coding style guidelines] may be found on the wiki.</p>
<h1 id="the-ghc-commentary-ghci">The GHC Commentary: GHCi</h1>
<p>This isn't a coherent description of how GHCi works, sorry. What it is (currently) is a dumping ground for various bits of info pertaining to GHCi, which ought to be recorded somewhere.</p>
<h2 id="debugging-the-interpreter">Debugging the interpreter</h2>
<p>The usual symptom is that some expression / program crashes when running on the interpreter (commonly), or gets wierd results (rarely). Unfortunately, finding out what the problem really is has proven to be extremely difficult. In retrospect it may be argued a design flaw that GHC's implementation of the STG execution mechanism provides only the weakest of support for automated internal consistency checks. This makes it hard to debug.</p>
<p>Execution failures in the interactive system can be due to problems with the bytecode interpreter, problems with the bytecode generator, or problems elsewhere. From the bugs seen so far, the bytecode generator is often the culprit, with the interpreter usually being correct.</p>
<p>Here are some tips for tracking down interactive nonsense:</p>
<ul>
<li>Find the smallest source fragment which causes the problem.</li>
</ul>
<ul>
<li>Using an RTS compiled with
<pre><code>-DDEBUG`, run with `+RTS -Di</code></pre>
<p>to get a listing in great detail from the interpreter. Note that the listing is so voluminous that this is impractical unless you have been diligent in the previous step.</p></li>
</ul>
<ul>
<li>At least in principle, using the trace and a bit of GDB poking around at the time of death (See also [wiki:Debugging]), you can figure out what the problem is. In practice you quickly get depressed at the hopelessness of ever making sense of the mass of details. Well, I do, anyway.</li>
</ul>
<ul>
<li><pre><code>+RTS -Di` tries hard to print useful descriptions of what&#39;s on the stack, and often succeeds. However, it has no way to map addresses to names in code/data loaded by our runtime linker. So the C function `ghci_enquire</code></pre>
<p>is provided. Given an address, it searches the loaded symbol tables for symbols close to that address. You can run it from inside GDB:</p></li>
</ul>
<pre><code>(gdb) p ghci_enquire ( 0x50a406f0 )
0x50a406f0 + -48  ==  `PrelBase_Czh_con_info&#39;
0x50a406f0 + -12  ==  `PrelBase_Izh_static_info&#39;
0x50a406f0 + -48  ==  `PrelBase_Czh_con_entry&#39;
0x50a406f0 + -24  ==  `PrelBase_Izh_con_info&#39;
0x50a406f0 +  16  ==  `PrelBase_ZC_con_entry&#39;
0x50a406f0 +   0  ==  `PrelBase_ZMZN_static_entry&#39;
0x50a406f0 + -36  ==  `PrelBase_Czh_static_entry&#39;
0x50a406f0 + -24  ==  `PrelBase_Izh_con_entry&#39;
0x50a406f0 +  64  ==  `PrelBase_EQ_static_info&#39;
0x50a406f0 +   0  ==  `PrelBase_ZMZN_static_info&#39;
0x50a406f0 +  48  ==  `PrelBase_LT_static_entry&#39;
$1 = void</code></pre>
<p><code>In this case the enquired-about address is </code></p>
<pre><code>PrelBase_ZMZN_static_entry</code></pre>
<p>. If no symbols are close to the given addr, nothing is printed. Not a great mechanism, but better than nothing.</p>
<ul>
<li>We have had various problems in the past due to the bytecode generator (compiler/ghci/ByteCodeGen.lhs) being confused about the true set of free variables of an expression. The compilation scheme for
<pre><code>let`s applies the BCO for the RHS of the `let</code></pre>
<p>to its free variables, so if the free-var annotation is wrong or misleading, you end up with code which has wrong stack offsets, which is usually fatal.</p></li>
</ul>
<ul>
<li>Following the traces is often problematic because execution hops back and forth between the interpreter, which is traced, and compiled code, which you can't see. Particularly annoying is when the stack looks OK in the interpreter, then compiled code runs for a while, and later we arrive back in the interpreter, with the stack corrupted, and usually in a completely different place from where we left off.</li>
</ul>
<p><code>If this is biting you baaaad, it may be worth copying sources for the compiled functions causing the problem, into your interpreted module, in the hope that you stay in the interpreter more of the time.</code></p>
<ul>
<li>There are various commented-out pieces of code in Interpreter.c which can be used to get the stack sanity-checked after every entry, and even after after every bytecode instruction executed. Note that some bytecodes (
<pre><code>PUSH_UBX`) leave the stack in an unwalkable state, so the `do_print_stack</code></pre>
<p>local variable is used to suppress the stack walk after them.</p></li>
</ul>
<h2 id="useful-stuff-to-know-about-the-interpreter">Useful stuff to know about the interpreter</h2>
<p>The code generation scheme is straightforward (naive, in fact).</p>
<pre><code>-ddump-bcos</code></pre>
<p>prints each BCO along with the Core it was generated from, which is very handy.</p>
<ul>
<li>Simple
<pre><code>let`s are compiled in-line. For the general case, `let v = E in ...`, the expression `E` is compiled into a new BCO which takes as args its free variables, and `v` is bound to `AP(the new BCO, free vars of E)</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>case`s as usual, become: push the return continuation, enter the scrutinee. There is some magic to make all combinations of compiled/interpreted calls and returns work, described below. In the interpreted case, all `case</code></pre>
<p>alts are compiled into a single big return BCO, which commences with instructions implementing a switch tree.</p></li>
</ul>
<h3 id="stack-management">Stack management</h3>
<p>There isn't any attempt to stub the stack, minimise its growth, or generally remove unused pointers ahead of time. This is really due to laziness on my part, although it does have the minor advantage that doing something cleverer would almost certainly increase the number of bytecodes that would have to be executed. Of course we</p>
<pre><code>SLIDE</code></pre>
<p>out redundant stuff, to get the stack back to the sequel depth, before returning a HNF, but that's all. As usual this is probably a cause of major space leaks.</p>
<h3 id="building-constructors">Building constructors</h3>
<p>Constructors are built on the stack and then dumped into the heap with a single</p>
<pre><code>PACK` instruction, which simply copies the top N words of the stack verbatim into the heap, adds an info table, and zaps N words from the stack. The constructor args are pushed onto the stack one at a time. One upshot of this is that unboxed values get pushed untaggedly onto the stack (via `PUSH_UBX</code></pre>
<p>), because that's how they will be in the heap. That in turn means that the stack is not always walkable at arbitrary points in BCO execution, although naturally it is whenever GC might occur.</p>
<p>Function closures created by the interpreter use the AP-node (tagged) format, so although their fields are similarly constructed on the stack, there is never a stack walkability problem.</p>
<h3 id="perspective">Perspective</h3>
<p>I designed the bytecode mechanism with the experience of both STG hugs and Classic Hugs in mind. The latter has an small set of bytecodes, a small interpreter loop, and runs amazingly fast considering the cruddy code it has to interpret. The former had a large interpretative loop with many different opcodes, including multiple minor variants of the same thing, which made it difficult to optimise and maintain, yet it performed more or less comparably with Classic Hugs.</p>
<p>My design aims were therefore to minimise the interpreter's complexity whilst maximising performance. This means reducing the number of opcodes implemented, whilst reducing the number of insns despatched. In particular, very few (TODO: How many? Which?) opcodes which deal with tags. STG Hugs had dozens of opcodes for dealing with tagged data. Finally, the number of insns executed is reduced a little by merging multiple pushes, giving</p>
<pre><code>PUSH_LL` and `PUSH_LLL</code></pre>
<p>. These opcode pairings were determined by using the opcode-pair frequency profiling stuff which is ifdef-d out in Interpreter.c. These significantly improve performance without having much effect on the ugliness or complexity of the interpreter.</p>
<p>Overall, the interpreter design is something which turned out well, and I was pleased with it. Unfortunately I cannot say the same of the bytecode generator.</p>
<h2 id="case-returns-between-interpreted-and-compiled-code">case returns between interpreted and compiled code</h2>
<p>Variants of the following scheme have been drifting around in GHC RTS documentation for several years. Since what follows is actually what is implemented, I guess it supersedes all other documentation. Beware; the following may make your brain melt. In all the pictures below, the stack grows downwards.</p>
<h3 id="returning-to-interpreted-code.">Returning to interpreted code.</h3>
<p>Interpreted returns employ a set of polymorphic return infotables. Each element in the set corresponds to one of the possible return registers (R1, D1, F1) that compiled code will place the returned value in. In fact this is a bit misleading, since R1 can be used to return either a pointer or an int, and we need to distinguish these cases. So, supposing the set of return registers is {R1p, R1n, D1, F1}, there would be four corresponding infotables, stg_ctoi_ret_R1p_info, etc. In the pictures below we call them stg_ctoi_ret_REP_info.</p>
<p>These return itbls are polymorphic, meaning that all 8 vectored return codes and the direct return code are identical.</p>
<p>Before the scrutinee is entered, the stack is arranged like this:</p>
<pre><code>   |        |
   +--------+
   |  BCO   | -------&gt; the return contination BCO
   +--------+
* | -------&gt; stg_ctoi_ret_REP_info, with all 9 codes as follows:
   +--------+
* bco = Sp[1];
                          push R1/F1/D1 depending on REP
                          push bco
                          yield to sched</code></pre>
<p>On entry, the interpreted contination BCO expects the stack to look like this:</p>
<pre><code>   |        |
   +--------+
   |  BCO   | -------&gt; the return contination BCO
   +--------+
* | -------&gt; ret_REP_ctoi_info, with all 9 codes as follows:
   +--------+
   : VALUE  :  (the returned value, shown with : since it may occupy
   +--------+   multiple stack words)</code></pre>
<p>A machine code return will park the returned value in R1/F1/D1, and enter the itbl on the top of the stack. Since it's our magic itbl, this pushes the returned value onto the stack, which is where the interpreter expects to find it. It then pushes the BCO (again) and yields. The scheduler removes the BCO from the top, and enters it, so that the continuation is interpreted with the stack as shown above.</p>
<p>An interpreted return will create the value to return at the top of the stack. It then examines the return itbl, which must be immediately underneath the return value, to see if it is one of the magic stg_ctoi_ret_REP_info set. Since this is so, it knows it is returning to an interpreted contination. It therefore simply enters the BCO which it assumes it immediately underneath the itbl on the stack.</p>
<h3 id="returning-to-compiled-code.">Returning to compiled code.</h3>
<p>Before the scrutinee is entered, the stack is arranged like this:</p>
<pre><code>                        ptr to vec code 8 ------&gt; return vector code 8
   |        |           ....
   +--------+           ptr to vec code 1 ------&gt; return vector code 1
* | --        Itbl end
   +--------+   \       ....   
                 \      Itbl start
                  ----&gt; direct return code</code></pre>
<p>The scrutinee value is then entered. The case continuation(s) expect the stack to look the same, with the returned HNF in a suitable return register, R1, D1, F1 etc.</p>
<p>A machine code return knows whether it is doing a vectored or direct return, and, if the former, which vector element it is. So, for a direct return we jump to</p>
<pre><code>Sp[0]`, and for a vectored return, jump to `((CodePtr*)(Sp[0]))[ - ITBL_LENGTH - vector number ]</code></pre>
<p>. This is (of course) the scheme that compiled code has been using all along.</p>
<p>An interpreted return will, as described just above, have examined the itbl immediately beneath the return value it has just pushed, and found it not to be one of the ret_REP_ctoi_info set, so it knows this must be a return to machine code. It needs to pop the return value, currently on the stack, into R1/F1/D1, and jump through the info table. Unfortunately the first part cannot be accomplished directly since we are not in Haskellised-C world.</p>
<p>We therefore employ a second family of magic infotables, indexed, like the first, on the return representation, and therefore with names of the form stg_itoc_ret_REP_info. (Note: itoc; the previous bunch were ctoi). This is pushed onto the stack (note, tagged values have their tag zapped), giving:</p>
<pre><code>   |        |
   +--------+
* | -------&gt; arbitrary machine code return itbl
   +--------+
   : VALUE  :  (the returned value, possibly multiple words)
   +--------+
* | -------&gt; stg_itoc_ret_REP_info, with code:
   +--------+
                          pop myself (stg_itoc_ret_REP_info) off the stack
                          pop return value into R1/D1/F1
                          do standard machine code return to itbl at t.o.s.</code></pre>
<p>We then return to the scheduler, asking it to enter the itbl at t.o.s. When entered, stg_itoc_ret_REP_info removes itself from the stack, pops the return value into the relevant return register, and returns to the itbl to which we were trying to return in the first place.</p>
<p>Amazingly enough, this stuff all actually works! Well, mostly ...</p>
<h2 id="unboxed-tuples-a-right-royal-spanner-in-the-works">Unboxed tuples: a Right Royal Spanner In The Works</h2>
<p>The above scheme depends crucially on having magic infotables stg_{itoc,ctoi}_ret_REP_info for each return representation REP. It unfortunately fails miserably in the face of unboxed tuple returns, because the set of required tables would be infinite; this despite the fact that for any given unboxed tuple return type, the scheme could be made to work fine.</p>
<p>This is a serious problem, because it prevents interpreted code from doing IO-typed returns, since IO t is implemented as</p>
<pre><code>(# t, RealWorld# #)</code></pre>
<p>or thereabouts. This restriction in turn rules out FFI stuff in the interpreter. Not good.</p>
<p>Although we have no way to make general unboxed tuples work, we can at least make IO-types work using the following ultra-kludgey observation:</p>
<pre><code>RealWorld#` doesn&#39;t really exist and so has zero size, in compiled code. In turn this means that a type of the form `(# t, RealWorld# #)</code></pre>
<p>has the same representation as plain t does. So the bytecode generator, whilst rejecting code with general unboxed tuple returns, recognises and accepts this special case. Which means that IO-typed stuff works in the interpreter. Just.</p>
<p>If anyone asks, I will claim I was out of radio contact, on a 6-month walking holiday to the south pole, at the time this was ... er ... dreamt up.</p>
<h1 id="porting-ghc-using-llvm-backend">Porting GHC using LLVM backend</h1>
<p>This document is kind of short porting roadmap which serves as a high-level overview for porters of GHC who decided to use LLVM instead of implementing new NCG for their target platform. Please have [wiki:Commentary/Compiler/Backends/LLVM/Design Design &amp; Implementation] at hand since this contains more in-depth information. The list of steps needed for new GHC/LLVM port is:</p>
<p><strong>(1)</strong> Make sure GHC unregisterised build is working on your target platform (using the C backend). This guide isn't intended for porting GHC to a completely unsupported platform. If the platform in question doesn't have a GHC unregisterised build then follow the [wiki:Building/Porting GHC Porting Guide] first.</p>
<p><strong>(2)</strong> Now try to compile some very simple programs such as 'hello world' or simpler using the GHC you just built. Try with the C backend First to make sure everything is working. Then try with the LLVM backend. If the llvm backend built programs are failing find out why. This is done using a combination of things such as the error message you get when the program fails, [wiki:Debugging/CompiledCode tracing the execution with GDB] and also just comparing the assembly code produced by the C backend to what LLVM produces. This last method is often the easiest and you can occasionally use techniques like doing doing a 'binary search' for the bug by merging the assembly produced by the C backend and LLVM backend.</p>
<p><strong>(3)</strong> When the programs you throw at the LLVM backend are running, try running the GHC testsuite. First run it against the C backend to get a baseline, then run it against the LLVM backend. Fix any failures that are LLVM backend specific.</p>
<p><strong>(4)</strong> If the testsuite is passing, now try to build GHC itself using the LLVM backend. This is a very tough test. When working though its a good proof that the LLVM backend is working well on your platform.</p>
<p><strong>(5)</strong> Now you have LLVM working in unregistered mode, so the next thing is to implement the GHC calling convention in LLVM that is used by GHC's LLVM backend. This should then allow you to get the LLVM backend working in registered mode but with (TABLES_NEXT_TO_CODE = NO in your build.mk). Majority of this step involves hacking inside the LLVM code. Usually lib/Target/<your target platform name> is the best way to start. Also you might study what David Terei did for <a href="http://lists.cs.uiuc.edu/pipermail/llvmdev/2010-March/030031.html">x86 support</a> and his <a href="http://lists.cs.uiuc.edu/pipermail/llvmdev/attachments/20100307/714e5c37/attachment-0001.obj">patch itself</a> to get an idea what's really needed.</p>
<p><strong>(6)</strong> Once <strong>(5)</strong> is working you have it all running except TABLES_NEXT_TO_CODE. So change that to Yes in your build.mk and get that working. This will probably involve changing the mangler used by LLVM to work on the platform you are targeting.</p>
<h2 id="registerised-mode">Registerised Mode</h2>
<p>Here is an expanded version of what needs to be done in step 5 and 6 to get a registerised port of LLVM working:</p>
<p>1. GHC in registerised mode stores some of its virtual registers in real hardware registers for performance. You will need to decide on a mapping of GHC's virtual registers to hardware registers. So how many registers you want to map and which virtual registers to store and where. GHC's design for this on X86 is basically to use as many hardware registers as it can and to store the more frequently cessed virtual registers like the stack pointer in callee saved registers rather than caller saved registers. You can find the mappings that GHC currently uses for supported architectures in 'includes/stg/MachRegs.h'.</p>
<p>2. You will need to implement a custom calling convention for LLVM for your platform that supports passing arguments using the register map you decided on. You can see the calling convention I have created for X86 in the llvm source file 'lib/Target/X86/X86CallingConvention.td'.</p>
<p>3. Get GHC's build system running on your platform in registerised mode.</p>
<p>4. Add new inline assembly code for your platform to ghc's RTS. See files like 'rts/StgCRun.c' that include assembly code for the architectures GHC supports. This is the main place as its where the boundary between the RTS and haskell code is but I'm sure there are definitely other places that will need to be changed. Just grep the source code to find existing assembly and add code for your platform appropriately.</p>
<p>5. Will need to change a few things in LLVM code gen.</p>
<p>5.1 'compiler/llvmGen/LlvmCodeGen/Ppr.hs' defines a platform specific string that is included in all generated llvm code. Add one for your platform. This string specifies the datalayout parameters for the platform (e.g pointer size, word size..). If you don't include one llvm should still work but wont optimise as aggressively.</p>
<p>5.2 'compiler/llvmGen/LlvmCodeGen/CodeGen.hs' has some platform specific code on how write barriers should be handled.</p>
<p>6. Probably some stuff elsewhere in ghc that needs to be changed (most likely in the main/ subfolder which is where most the compiler driver lives or in codegen/ which is the Cmm code generator).</p>
<p>7. This is just what I know needs to be done, I'm sure there is many small pieces missing although they should all fall into one of the above categories. In the end just trial and error your way to success.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="packages-in-ghc">Packages in GHC</h1>
<p>This page summarises our current proposal for packages in GHC. (See also [wiki:Commentary/Packages/PackageNamespacesProposal an extended proposal] to make namespaces first-class. The two proposals are mutually exclusive.)</p>
<h2 id="the-problem">The problem</h2>
<p>A vexed question in the current design of Haskell is the issue of whether a single program can contain two modules with the same name. In Haskell 98 that is absolutely ruled out. As a result, packages are fundamentally non-modular: to avoid collisions <em>every</em> module in <em>every</em> package written by <em>anyone</em> must have different module names. That's like saying that every function must have different local variables, and is a serious loss of modularity.</p>
<p>GHC 6.6 makes a significant step forward by lifting this restriction. However it leaves an open question, which is what this page is about.</p>
<h2 id="assumptions">Assumptions</h2>
<p>Before we start, note that we take for granted the following</p>
<ul>
<li><strong>Each package has a globally-unique name</strong>, organised by some social process. This assumption is deeply built into Cabal, and lots of things would need to change if it wasn't met.</li>
</ul>
<ul>
<li>'''Module names describe <em>purpose</em> (what it's for, e.g.
<pre><code>Data.Bits</code></pre>
<p>), whereas package names describe <em>provenance</em> (where it comes from, e.g.</p>
<pre><code>&quot;gtkhs&quot;</code></pre>
<p>)'''. We should not mix these two up, and that is a good reason for not combining package and module names into a single grand name. One quite frequently wants to globally change provenance but not purpose (e.g. compile my program with a new version of package &quot;foo&quot;), without running through all the source files to change the import statements.</p></li>
</ul>
<ul>
<li><strong>New: a module name must be unique within its package (only)</strong>. That is, a single program can use two modules with the same module name, provided they come from different packages. This is new in GHC 6.6.</li>
</ul>
<p>For all this to work, GHC must incorporate the package name (and version) into the names of entities the package defines. That means that when compiling a module M you must say what package it is part of:</p>
<pre><code>  ghc -c -package-name P1 C.hs</code></pre>
<p>Then C.o will contain symbols like &quot;</p>
<pre><code>P1.A.B.C.f</code></pre>
<p>&quot; etc. In effect, the &quot;original name&quot; of a function</p>
<pre><code>f</code></pre>
<p>in module</p>
<pre><code>M</code></pre>
<p>of package</p>
<pre><code>P</code></pre>
<p>is</p>
<pre><code>&lt;P,M,f&gt;</code></pre>
<p>.</p>
<h2 id="the-open-question">The open question</h2>
<p>The remaining question is this: '''When you say</p>
<pre><code>import A.B.C</code></pre>
<p>, from what package does A.B.C come?'''. Three alternatives are under consideration:</p>
<ul>
<li>Plan A (GHC's current story)</li>
<li>Plan B: grafting. An enhancement of plan A; see [wiki:Commentary/Packages/PackageMountingProposal Frederik Eaton's proposal]</li>
<li>Plan C: optionally specify the package in the import. An alternative to (B), described in a [wiki:Commentary/Packages/PackageImportsProposal separate page].</li>
</ul>
<hr />
<h2 id="plan-a-ghcs-current-story">Plan A: GHC's current story</h2>
<p>GHC already has a fairly elaborate scheme (perhaps too elaborate; <a href="http://www.haskell.org/ghc/dist/current/docs/users_guide/packages.html">documentation here</a>) for deciding what package you mean when you say &quot;import A.B.C&quot;:</p>
<ul>
<li>For a start, it only looks in <em>installed</em> packages.</li>
<li>Even for installed packages, the package may or may not be <em>exposed</em> by default (reasoning: you may want old versions of package X to be installed, but not in scope by default).</li>
<li>Then, you can use the
<pre><code>-hide-package</code></pre>
<p>flag to hide an otherwise-exposed package, and the</p>
<pre><code>-package</code></pre>
<p>flag to expose an otherwise-hidden package.</p></li>
</ul>
<p>So, you can expose package P1 when compiling module M (say), and expose P2 when compiling module N by manipulating these flags. Then M and N could both import module A.B.C, which would come from P1 and P2 respectively. But:</p>
<ul>
<li>What if you wanted to import A.B.C from P1 and A.B.C from P2 into the <em>same</em> module?</li>
<li>What if you want to only replace <em>parts</em> of P1 (e.g., you want to use an updated version of a module in
<pre><code>base</code></pre>
<p>)?</p></li>
<li>Compiling different modules with different flags in a way that affects the <em>semantics</em> (rather than, say, the optimisation level) seems undesirable.</li>
<li>To support
<pre><code>--make</code></pre>
<p>in this situation we'd need to allow</p>
<pre><code>-package</code></pre>
<p>flags in the per-module</p>
<pre><code>OPTIONS</code></pre>
<p>pragmas, which isn't currently supported. (</p>
<pre><code>ghc --make</code></pre>
<p>already gathers those options together for the link step.) <em>This is not yet implemented, but it is close to being implemented.</em></p></li>
</ul>
<p>If we did implement the &quot;</p>
<pre><code>-package` in `OPTIONS</code></pre>
<p>pragma&quot; fix, then is is not clear how pressing the need is for anything more. It's still impossible to import M from P1, and M from P2, into the same module. But how often will that happen?</p>
<hr />
<h2 id="plan-b-package-mounting">Plan B: package mounting</h2>
<p>This proposal is described by a [wiki:Commentary/Packages/PackageMountingProposal separate page].</p>
<hr />
<h2 id="plan-c-mention-the-package-in-the-import">Plan C: mention the package in the import</h2>
<p>This proposal is described by a [wiki:Commentary/Packages/PackageImportsProposal separate page].</p>
<p>This wiki discusses how bringing <a href="https://nixos.org/nix/">Nix</a>-style package management facilities to cabal can solve various cabal problems and help in effective mitigation of cabal hell. It also contains the goals and implementation plan for the GSoC project. It is based on a <a href="http://www.well-typed.com/blog/2015/01/how-we-might-abolish-cabal-hell-part-2/">blog post by Duncan Coutts</a>.</p>
<h1 id="problems">Problems</h1>
<h2 id="breaking-re-installations">Breaking re-installations</h2>
<p><a href="Image(http://www.well-typed.com/blog/aux/images/cabal-hell/install-example1.png)" class="uri" title="wikilink">Image(http://www.well-typed.com/blog/aux/images/cabal-hell/install-example1.png)</a></p>
<p>There are situations where Cabal's chosen solution would involve reinstalling an existing version of a package but built with different dependencies. In this example, after installing app-1.1, app-1.0 and other-0.1 will be broken. The root of the problem is having to delete or mutate package instances when installing new packages. This is due to the limitation of only being able to have one instance of a package version installed at once.</p>
<h2 id="type-errors-when-using-packages-together">Type errors when using packages together</h2>
<p><a href="Image(http://www.well-typed.com/blog/aux/images/cabal-hell/install-example2.png)" class="uri" title="wikilink">Image(http://www.well-typed.com/blog/aux/images/cabal-hell/install-example2.png)</a></p>
<p>The second, orthogonal, problem is that it is possible to install two packages and then load them both in GHCi and find that you get type errors when composing things defined in the two different packages. Effectively you cannot use these two particular installed packages together. The fundamental problem is that developers expect to be able to use combinations of their installed packages together, but the package tools do not enforce consistency of the developer's environment.</p>
<h1 id="goals">Goals</h1>
<ul>
<li>Fix breaking re-installs (Persistent package store)</li>
<li>Implement garbage collection to free unreachable packages</li>
<li>Enable sharing of packages between sandbox</li>
<li>Enforce development environment consistency (Giving error earlier and better)</li>
<li>Implement package manager tools in cabal-install(cabal upgrade and cabal remove)</li>
</ul>
<h1 id="implementation-plan">Implementation Plan</h1>
<h2 id="persistent-package-store">Persistent package store</h2>
<p>A <a href="https://github.com/ghc/ghc/commit/dd3a7245d4d557b9e19bfa53b0fb2733c6fd4f88">patch</a> has been pushed for ghc-7.11 that allows multiple instance of the same package to be installed. So the remaining work is in cabal tool for never modifying installed packages. I have written a <a href="https://github.com/fugyk/cabal/commit/45ec5edbaada1fd063c67d6109e69efa0e732e6a">patch to make cabal (almost)non-destructive</a>. This patch makes all the changes to Package database non-destructive if Installed Package ID is different. To make it fully non-mutable, Thomas Tuegel suggested to</p>
<ul>
<li>change installed package IDs to be computed by hash of the sdist tarball.</li>
<li>Enforce that a package is never overwritten by taking out a lock when updating the database.(before building the package)</li>
</ul>
<p>It will have additional benefit that package will not be built again if same source has already been built earlier, thus saving time.</p>
<h2 id="views">Views</h2>
<p>Views will the subset of packages of package store whose modules can be imported. Views will be present as various *.view file in <Package DB location>/views like default.view. The view file contains list of installed package IDs. There will exist a default view which contains packages installed by cabal install outside sandbox. If a package name is installed two times, default view will contain the instance of package which is installed at last. Views' packages will also act like GC roots.</p>
<p>To facilitate views, ghc-pkg will need some new commands:</p>
<ul>
<li>Create a view / Symlink a view</li>
<li>Delete a view</li>
<li>List all views</li>
<li>Modify a view</li>
<li>Add a package</li>
<li>Remove a package</li>
</ul>
<p>Sandbox will be a view. Cabal needs to set view when using sandbox. It also needs the ability to make a view and also add a package to the view. Packages can be shared between views. View path will be passed to ghc using -package-env. The view file that sandbox creates lies in the same directory and is symlinked from the package database view file for allowing GC. It will have a benefit that when we just delete the sandbox directory without deleting the view, GC can free that sandbox package.</p>
<p>It looks similar to nix development environment but has some differences. nix environments are like everything that is visible. It is kind of like imported packages with dependency closure. nix needs to make directories visible, while here we already have one more layer. Here we only need exposed package and ghc can make complete environment already. Views are just exposed packages of the environment. So, dependency of the package need not be in the view that the package is in. The problem that we are trying to solve with views is consistent way of managing packages and sandboxes, allowing packages to be shared between sandboxes and its packages being used as GC root.</p>
<p>Summary of design details</p>
<p>When installing a package outside sandbox</p>
<ul>
<li>Package is added to default view / modified in default view</li>
</ul>
<p>Making a sandbox</p>
<ul>
<li>A view is made in the directory</li>
<li>The new view is symlinked from the database</li>
<li>Packages that are installed are added to that view. Sandboxes cannot affect any other things outside sandbox.</li>
</ul>
<p>Within sandbox</p>
<ul>
<li>All the cabal commands pass view name to ghc and ghc will use relevant package</li>
</ul>
<h2 id="consistent-developer-environment">Consistent developer environment</h2>
<p>It will require additional constraint to check that there is no other instance of the same package or its dependencies is in the environment(packages from which we have imported the modules with their dependency closure) when we are importing the module from a package. It also needs to be checked when cabal is configuring the package, that a package do not directly or indirectly depends on two version of same package. If it is violated it needs to give out an error.</p>
<h2 id="garbage-collection">Garbage collection</h2>
<p>This will firstly involve determining the root packages and package list. Root packages are the packages which are in some view. Then we find list of all packages in the database. As there will be single database after implementing views, we don't need to call it for every sandbox database. Then we need to do mark-sweep and find which package are not in the reachable package list and select it for garbage collection. Then the selected packages will be deleted from the package store and also unregistered from database with ghc-pkg.</p>
<h2 id="cabal-remove">cabal remove</h2>
<p>With everything implemented above, it is just removing a package from default view. If package is unreachable it can be freed from disk by GC. It is guaranteed to not break any package except the package that is removed.</p>
<h2 id="cabal-upgrade">cabal upgrade</h2>
<p>cabal upgrade is just installing every package that is present in default view that has update available.</p>
<h2 id="current-status-1">Current Status</h2>
<p>It is possible to install multiple instances of the same package version with my forks of cabal and ghc. Quite a few problems remain.</p>
<p>See also [wiki:Commentary/Packages/MultiInstances]</p>
<h3 id="unique-install-location">Unique Install Location</h3>
<p>When specifying the install location there is a new variable $unique available. It is resolved to a random number by cabal-install during configuring. The default libsubdir for cabal-install should be &quot;$packageid-$unique&quot; for example &quot;mtl-2.1.2-1222131559&quot;. Cabal the library does not understand $unique so multiple instances of the same package version installed via &quot;runhaskell Setup.hs install&quot; are still problematic.</p>
<h3 id="ghc-pkg">ghc-pkg</h3>
<p>ghc-pkg never removes registered packages when registering a new one. Even if a new package with the same</p>
<pre><code>InstalledPackageId` as an existing package is registered. Or if a new package that points to the same install directory is registered. `ghc-pkg</code></pre>
<p>should probably check this and issue a warning.</p>
<h3 id="adhoc-dependency-resolution">Adhoc dependency resolution</h3>
<p>A new field</p>
<pre><code>timestamp` was added to `InstalledPackageInfo</code></pre>
<p>. It is set by Cabal the library when registering a package. It is used by Cabal the library, GHC and cabal-install to choose between different instances of the same package version.</p>
<h3 id="detect-whether-an-overwrite-happens-and-warn-about-it">Detect whether an overwrite happens and warn about it</h3>
<p>Currently cabal-install still warns about dangerous reinstalls and requires</p>
<pre><code>--force-reinstalls</code></pre>
<p>when it is sure a reinstall would happen. The correct behaviour here would be to detect if a reinstall causes overwriting (because of a version of ghc-pkg that does this) and warn only in this case. In this implementation reinstalls are not dangerous anymore.</p>
<p>=== Communicate the</p>
<pre><code>InstalledPackageId</code></pre>
<p>back to cabal-install ===</p>
<p>An</p>
<pre><code>InstallPlan` contains installed packages as well as packages to be installed and dependencies between those. We want to specify all of these dependencies with an `InstalledPackageId`. Unfortunately the `InstalledPackageId` is determined after installation and therefore not available for not yet installed packages. After installation it would have to be somehow communicated back to cabal-install. The current workaround is to only specify those packages that were previously installed with an `InstalledPackageId</code></pre>
<p>and trust on Cabal picking the instance that was most recently (during execution of this install plan) installed for the other ones.</p>
<h3 id="garbage-collection-1">Garbage Collection</h3>
<p>A garbage collection should offer the removal of a certain package specified by</p>
<pre><code>InstalledPackageId</code></pre>
<p>, the removal of broken packages and the removal of probably unnecessary packages. A package is unnecessary if all packages that depend on it are unnecessary (this includes the case that no package depends on it) and it is not the most recently installed instance for its version. All of this should be accompanied by a lot of &quot;are you sure&quot; questioning.</p>
<h3 id="about-shadowing">About Shadowing</h3>
<p>GHC has the concept of shadowing. It was introduced as far as i understand (correct me please) because when combining the global and the user package databases you could end up with two instances of the same package version. The instance in the user database was supposed to shadow the one in the global database. Now that there are multiple instances of the same package version even in one package database this concepts needs to be rethought. This is non-trivial because flags asking for a package version as well as flags requiring a certain instance need to be taken into account.</p>
<h3 id="about-unique-identifier">About Unique Identifier</h3>
<p>Currently a big random number is created by cabal-install during configuration and passed to Cabal to be appended to the</p>
<pre><code>InstalledPackageId` before registering. The reason is that the `InstalledPackageId` still contains the ABI hash which is only known after compilation. I personally would like the `InstalledPackageId` to be the name of the package, the version and a big random number. This could be determined before compilation, used as the `libsubdir` and baked into `package_Paths.hs`. Since it would be determined by cabal-install it would also make communicating the InstalledPackageId back to cabal-install after an installation unnecessary. The problem is that the `InstalledPackageId</code></pre>
<p>would not be deterministic anymore.</p>
<h2 id="original-plan">Original Plan</h2>
<p>Cabal and GHC do not support multiple instances of the same package version installed at the same time. If a second instance of a package version is installed it is overwritten on the file system as well as in the</p>
<pre><code>PackageDB</code></pre>
<p>. This causes packages that depended upon the overwritten instance to break. The idea is to never overwrite an installed package. As already discussed in <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Packages/MultiInstances">2</a> the following changes need to be made:</p>
<ul>
<li>Cabal should install packages to a location that does not just depend on name and version,</li>
<li><pre><code>ghc-pkg` should always add instances to the `PackageDB</code></pre>
<p>and never overwrite them,</p></li>
<li><pre><code>ghc --make`, `ghci</code></pre>
<p>, and the configure phase of Cabal should select suitable instances according to some rule of thumb (similar to the current resolution technique),</p></li>
<li>we want to be able to make more fine-grained distinctions between package instances than currently possible, for example by distinguishing different build flavours or &quot;ways&quot; (profiling, etc.)</li>
<li><pre><code>cabal-install` should still find an `InstallPlan</code></pre>
<p>, and still avoid unnecessarily rebuilding packages whenever it makes sense</p></li>
<li>some form of garbage collection should be offered to have a chance to reduce the amount of installed packages</li>
</ul>
<h2 id="hashes-and-identifiers">Hashes and identifiers</h2>
<p>There are three identifiers:</p>
<ul>
<li><pre><code>XXXX</code></pre>
<dl>

<dd>the identifier appended to the installation directory so that installed packages do not clash with each other
</dd>
</dl></li>
<li><pre><code>YYYY`: the `InstalledPackageId</code></pre>
<p>, which is an identifier used to uniquely identify a package in the package database.</p></li>
<li><pre><code>ZZZZ</code></pre>
<dl>

<dd>the ABI hash derived by GHC after compiling the package
</dd>
</dl></li>
</ul>
<p>The current situation:</p>
<ul>
<li><pre><code>XXXX</code></pre>
<dl>

<dd>is empty, which is bad (two instances of a package install in the same place)
</dd>
</dl></li>
<li><pre><code>YYYY`: is currently equal to `ZZZZ</code></pre>
<p>, which is bad because we need to make more distinctions:</p>
<ul>
<li>we need to distinguish between two packages that have identical ABIs but different behaviour (e.g. a bug was fixed)</li>
<li>we need to distinguish between two instances of a package that are compiled against different dependencies, or with different options, or compiled in a different way (profiling, dynamic)</li>
</ul></li>
</ul>
<p>Some notes:</p>
<ul>
<li><pre><code>XXXX` must be decided &#39;&#39;before&#39;&#39; we begin compiling, because we have to generate the `Paths_P.hs` file that is compiled along with the package, whereas `ZZZZ</code></pre>
<p>is only available <em>after</em> we have compiled the package.</p></li>
<li><pre><code>ZZZZ</code></pre>
<p>is not uniquely determined by the compilation inputs (see #4012), although in the future we hope it will be</p></li>
<li>It is desirable that when two packages have identical
<pre><code>YYYY` values, then they are compatible, even if they were built on separate systems.  Note that this is not guaranteed even if `YYYY` is a deterministic function of the compilation inputs, because `ZZZZ` is non-deterministic (previous point).  Hence `YYYY` must be dependent on `ZZZZ</code></pre>
<p>.</p></li>
<li>It is desirable that
<pre><code>YYYY` be as deterministic as possible, i.e. we would rather not use a GUID, but `YYYY` should be determined by the compilation inputs and `ZZZZ`.  We know that `ZZZZ` is currently not deterministic, but in the future it will be, and at that point `YYYY` will become deterministic too, in the meantime `YYYY` should be no less deterministic than `ZZZZ</code></pre>
<p>.</p></li>
</ul>
<p>Our proposal:</p>
<ul>
<li>We define a new <em>Cabal Hash</em> that hashes the compilation inputs (the
<pre><code>LocalBuildInfo</code></pre>
<p>and the contents of the source files)</p></li>
<li><pre><code>XXXX</code></pre>
<p>is a GUID.</p>
<ul>
<li>Why not use the <em>Cabal Hash</em>? We could, but then there could conceivably be a clash. (Andres - please expand this point, I have forgotten the full rationale).</li>
</ul></li>
<li><pre><code>YYYY` is the combination of the &#39;&#39;Cabal Hash&#39;&#39; and `ZZZZ</code></pre>
<p>(concatenated)</p></li>
<li><pre><code>ZZZZ` is recorded in the package database as a new field `abi-hash</code></pre>
<p>.</p>
<ul>
<li>When two packages have identical
<pre><code>ZZZZ`s then they are interface-compatible, and the user might in the future want to change a particular dependency to use a different package but the the same `ZZZZ`.  We do not want to make this change automatically, because even when two packages have identical `ZZZZ</code></pre>
<p>s, they may have different behaviour (e.g. bugfixes).</p></li>
</ul></li>
</ul>
<h2 id="install-location-of-installed-cabal-packages">Install location of installed Cabal packages</h2>
<p>Currently the library part of packages is installed to</p>
<pre><code>$prefix/lib/$pkgid/$compiler`. For example the `GLUT` package of version 2.3.0.0 when compiled with GHC 7.4.1 when installed globally lands in `/usr/local/lib/GLUT-2.3.0.0/ghc-7.4.1/</code></pre>
<p>. This is the default path. It is completely customizable by the user. In order to allow multiple instances of this package to coexist we need to change the install location to a path that is unique for each instance. Several ways to accomplish this have been discussed:</p>
<h3 id="hash">Hash</h3>
<p>Use a hash to uniquely identify package instances and make the hash part of both the InstalledPackageId and the installation path.</p>
<p>The ABI hash currently being used by GHC is not suitable for unique identification of a package, because it is nondeterministic and not necessarily unique. In contrast, the proposed Cabal hash should be based on all the information needed to build a package.</p>
<p>This approach requires that we know the hash prior to building the package, because there is a data directory (per default under $prefix/share/$pkgid/) that is baked into Paths_foo.hs in preparation of the build process.</p>
<h3 id="unique-number">Unique number</h3>
<p>Use a unique number as part of the installation path.</p>
<p>A unique number could be the number of packages installed, or the number of instances of this package version already installed, or a random number. It is important that the numbers are guaranteed to be unique system-wide, so the counter-based approaches are somewhat tricky.</p>
<p>The advantage over using a hash is that this approach should be very simple to implement. On the other hand, identifying installed packages (see below) could possibly become more difficult, and migrating packages to other systems is only possible if the chance of collisions is reasonably low (for example, if random numbers are being used).</p>
<ol>
<li>The unique number is also part of the installed package id.</li>
</ol>
<ol>
<li><ol>
<li>We can use another unique identifier (for example, a Cabal hash) to identify installed packages. In this case, that identifier would be allowed to depend on the output of a package build.</li>
</ol></li>
</ol>
<p>==</p>
<pre><code>ghc-pkg</code></pre>
<p>==</p>
<pre><code>ghc-pkg` currently identifies each package by means of an `InstalledPackageId</code></pre>
<p>. At the moment, this id has to be unique per package DB and is thereby limiting the amount of package instances that can be installed in a single package DB at one point in time.</p>
<p>In the future, we want the</p>
<pre><code>InstalledPackageId` to still uniquely identify installed packages, but in addition to be unique among all package instances that could possibly be installed on a system. There&#39;s still the option that one InstalledPackageId occurs in several package DBs at the same time, but in this case, the associated packages should really be completely interchangeable. [If we want to be strict about this, we&#39;d have to include the ABI hash in the `InstalledPackageId</code></pre>
<p>.]</p>
<p>Even though, as discussed above, the ABI hash is not suitable for use as the</p>
<pre><code>InstalledPackageId</code></pre>
<p>given these changed requirements, we will need to keep the ABI hash as an essential piece of information for ghc itself.</p>
<pre><code>ghc-pkg` is responsible for storing all information we have about installed packages. Depending on design decisions about the solver and the Cabal hash, further information may be required in `ghc-pkg</code></pre>
<p>'s description format (see below).</p>
<p>The following fields will be added to the description format:</p>
<p>A field <em>Way</em> of type</p>
<pre><code>[String]`. It tracks the way in which the package was compiled. It is a subset of `{v,d,p}</code></pre>
<p>. &quot;v&quot; means vanilla, &quot;d&quot; means dynamic linking and &quot;p&quot; means profiling. Other ways may be added later.</p>
<p>A</p>
<pre><code>timestamp</code></pre>
<p>of the time when the package was installed (or built?). It is used by GHC and Cabal to put a preference on the latest package of a certain version.</p>
<p>A currently empty but extensible set of fields starting with &quot;x-cabal-...&quot;.</p>
<pre><code>ghc-pkg` ignores them when parsing. During the resolution phase `cabal-install</code></pre>
<p>might use them to decide compatibility between packages.</p>
<p>A field abi-hash that contains the ABI hash because it is no longer stored implicitly as part of the</p>
<pre><code>InstalledPackageId</code></pre>
<p>.</p>
<h2 id="simplistic-dependency-resolution">Simplistic dependency resolution</h2>
<p>The best tool for determining suitable package instances to use as build inputs is</p>
<pre><code>cabal-install`. However, in practice there will be many situations where users will probably not have the full `cabal-install</code></pre>
<p>functionality available:</p>
<ol>
<li><ol>
<li>invoking GHCi from the command line,</li>
<li>invoking GHC directly from the command line,</li>
<li>invoking the configure phase of Cabal (without using
<pre><code>cabal-install</code></pre>
<p>).</p></li>
</ol></li>
</ol>
<p>In these cases, we have to come up with a suitable selection of package instances, and the only info we have available are the package DBs plus potential command line flags. Cabal will additionally take into account the local constraints of the package it is being invoked for, whereas GHC will only consider command-line flags, but not modules it has been invoked with.</p>
<p>Currently if GHC is invoked by the user it does some adhoc form of dependency resolution. The most common case of this is using ghci. If there are multiple instances of the same package in the</p>
<pre><code>PackageDBStack</code></pre>
<p>the policy used to select a single one prefers DBs higher in the stack. It then prefers packages with a higher version. Once we allow package instances with the same version within a single package DB, we need to refine the algorithm. Options are:</p>
<ul>
<li>pick a random / unspecified instances</li>
<li>use the time of installation</li>
<li>user-specified priorities</li>
<li>use the order in the
<pre><code>PackageDB</code></pre></li>
<li>look at the transitive closure of dependencies and their versions</li>
<li>build a complex solver into GHC</li>
</ul>
<p>Picking a random version is a last resort. A combination of installation time and priorities seems rather feasible. It makes conflicts unlikely, and allows to persistently change the priorities of installed packages. Using the order in the package DB is difficult if directories are being used as DBs. Looking at the transitive closure of dependencies makes it hard to define a total ordering of package instances. Adding a complex solver is unattractive unless we find a way to reuse</p>
<pre><code>cabal-install</code></pre>
<p>'s functionality within GHC, but probably we do not want to tie the two projects together in this way.</p>
<h2 id="build-flavours">Build flavours</h2>
<p>Once we distinguish several package instances with the same version, we have a design decision how precise we want that distinction to be.</p>
<p>The minimal approach would be to just take the transitive dependencies into account. However, we might also want to include additional information about builds such as Cabal flag settings, compiler options, profiling, documentation, build tool versions, external (OS) dependencies, and more.</p>
<p>These differences have to be tracked. The two options we discuss are to store information in the</p>
<pre><code>ghc-pkg</code></pre>
<p>format, or to incorporate them in a Cabal hash (which is then stored). Both options can be combined.</p>
<h3 id="the-cabal-hash">The Cabal hash</h3>
<p>[A few notes about where to find suitable information in the source code:]</p>
<p>A build configuration consists of the following:</p>
<p>The Cabal hashes of all the package instances that are actually used for compilation. This is the environment. It is available in the</p>
<pre><code>installedPkgs` field of `LocalBuildInfo` which is available in every step after configuration. It can also be extracted from an `InstallPlan</code></pre>
<p>after dependency resolution.</p>
<p>The compiler, its version and its arguments and the tools and their version and their arguments. Available from LocalBuildInfo also. More specifically:</p>
<pre><code>compiler`, `withPrograms`, `withVanillaLib`, `withProfLib`, `withSharedLib`, `withDynExe`, `withProfExe`, `withOptimization`, `withGHCiLib`, `splitObjs`, `stripExes</code></pre>
<p>. And a lot more. [Like what?]</p>
<p>The source code. This is necessary because if the source code changes the result of compilation changes. For released packages I would assume that the version number uniquely identifies the source code. A hash of the source code should be available from hackage to avoid downloading the source code. For an unreleased package we need to find all the source files that are needed for building it. Including non-haskell source files. One way is to ask a source tarball to be built as if the package was released and then hash all the sources included in that.</p>
<p>OS dependencies are not taken into account because i think it would be very hard.</p>
<h3 id="released-and-unreleased-packages">Released and Unreleased packages</h3>
<p>If we cabal install a package that is released on hackage we call this a <strong>clean install</strong>. If we cabal install an unreleased package we call this a <strong>dirty install</strong>. Clean installs are mainly used to bring a package into scope for ghci and to install applications. While they can be used to satisfy dependencies this is discouraged. For released packages the set of source files needed for compilation is known. For unreleased packages this is currently not the case.</p>
<h2 id="dependency-resolution-in-cabal-install">Dependency resolution in cabal-install</h2>
<p>There are two general options for communicating knowledge about build flavors to the solver:</p>
<ol>
<li><strong>the direct way</strong>: i.e., all info is available to ghc-pkg and can be communicated back to Cabal and therefore the solver can figure out if a particular package is suitable to use or not, in advance;</li>
</ol>
<ol>
<li><ol>
<li><strong>the agnostic way</strong>: this is based on the idea that the solver at first doesn't consider installed packages at all. It'll just do resolution on the source packages available. Then, taking all build parameters into account, Cabal hashes will be computed, which can then be compared to hashes of installed packages.</li>
</ol></li>
</ol>
<p>Reusing installed packages instead of rebuilding them is then an optimization of the install plan.</p>
<p>The agnostic way does not require</p>
<pre><code>ghc-pkg</code></pre>
<p>to be directly aware of all the build parameters, as long as the hash computation is robust</p>
<p>The options are to support either both by putting all info into</p>
<pre><code>InstalledPackageInfo` or to support only the second option by just putting a hash into `InstalledPackageInfo`. The disadvantage of supporting both is that `InstalledPackageInfo` would have to change more often. This could be fixed by explicitly making the `InstalledPackageInfo</code></pre>
<p>format extensible in a backwards-compatible way.</p>
<p>The advantages of having all info available, independently of the solver algorihm, are that the info might be useful for other tools and user feedback.</p>
<p>Possible disadvantages of the agnostic approach could be that is is a rather significant change and can probably not be supported in a similar way for other Haskell implementation. Also, in the direct approach, we could in principle allow more complex compatibility rules, such as allowing non-profiling libraries to depend on profiling libraries.</p>
<p>Also, even if we go for the agnostic approach, we still have to be able to handle packages such as base or ghc-prim which are in general not even available in source form.</p>
<p>On the other hand, the agnostic approach might lead to more predictable and reproducible solver results across many different systems.</p>
<h2 id="garbage-collection-2">Garbage Collection</h2>
<p>The proposed changes will likely lead to a dramatic increase of the number of installed package instances on most systems. This is particularly relevant for package developers who will conduct lots of dirty builds that lead to new instances being installed all the time.</p>
<p>It should therefore be possible to have a garbage collection to remove unneeded packages. However, it is not possible for Cabal to see all potential reverse dependencies of a package, so automatic garbage collection would be extremely unsafe.</p>
<p>Options are to either offer an interactive process where packages that look unused are suggested for removal, or to integrate with a sandbox mechanism. If, for example, dirty builds are usually installed into a separate package DB, that package DB could just be removed completely by a user from time to time.</p>
<p>The garbage collection functionality is part of cabal-install not of ghc-pkg. As a first approximation gc does not remove files only unregisters packages from the</p>
<pre><code>PackageDB</code></pre>
<p>.</p>
<h2 id="currently-open-design-decisions">Currently open design decisions</h2>
<p>===</p>
<pre><code>InstalledPackageId</code></pre>
<p>and install path ===</p>
<p>Options for uniquely identifying</p>
<pre><code>InstalledPackageId</code></pre>
<dl>

<dd>
</dd>
</dl>
<ul>
<li>Cabal hash only</li>
<li>Cabal + ABI hash (truly unique)</li>
<li>random number</li>
</ul>
<p>Options for identifying install path:</p>
<ul>
<li>Cabal hash</li>
<li>random number</li>
</ul>
<p>ABI hash cannot be in install path because it's only available after build.</p>
<h3 id="handling-of-dirty-builds">Handling of dirty builds</h3>
<p>How should hash computation work for dirty builds?</p>
<ul>
<li>Use a random number even if we otherwise use hashes</li>
<li>Hash the complete build directory</li>
<li>Attempt to make a clean (sdist-like) copy or linked copy of the sources and hash and build from that.</li>
<li>Use the Cabal file to determine the files that would end up in an sdist and hash those directly without copying.</li>
</ul>
<p>The third option has the advantage(?) that the build is more guaranteed to use only files actually mentioned in the Cabal file.</p>
<h3 id="build-flavours-1">Build flavours</h3>
<p>To what degree should we distinguish package instances?</p>
<ul>
<li>Only package versions transitively</li>
<li>Ways and Cabal flags</li>
<li>Everything Haskell-specific info that we can query</li>
<li>Even non-Haskell-specific inputs such as OS dependencies</li>
</ul>
<p>===</p>
<pre><code>InstalledPackageInfo</code></pre>
<p>and solver algorithm ===</p>
<p>Options for</p>
<pre><code>InstalledPackageInfo</code></pre>
<dl>

<dd>
</dd>
</dl>
<ul>
<li>Only add Cabal hash.</li>
<li>Add (nearly) all information, but in an extensible format.</li>
<li>Add all information in a way that
<pre><code>ghc-pkg</code></pre>
<p>itself can use it.</p></li>
</ul>
<p>[These aren't necessarily mutually exclusive.]</p>
<p>Options for the solver:</p>
<ul>
<li>Direct (see above): requires a certain amount of info in the
<pre><code>InstalledPackageInfo</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>Agnostic (except for builtin packages): could be done with only the Cabal hash in
<pre><code>InstalledPackageInfo</code></pre>
<p>.</p></li>
</ul>
<h3 id="simplistic-dependency-resolution-1">Simplistic dependency resolution</h3>
<p>Options (in order of preference):</p>
<ul>
<li>use the time of installation</li>
<li>user-specified priorities</li>
<li>pick a random / unspecified instances</li>
<li>(build a complex solver into GHC)</li>
</ul>
<p>A combination of the first two seems possible and useful.</p>
<h2 id="related-topics">Related topics</h2>
<p>In the following, we discuss some other issues which are related to the multi-instance problem, but not necessarily directly relevant in order to produce an implementation.</p>
<h3 id="separating-storage-and-selection-of-packages">Separating storage and selection of packages</h3>
<p>Currently the two concepts of storing package instances (cabal store) and selecting package instances for building (environment) are conflated into a</p>
<pre><code>PackageDB`. Sandboxes are used as a workaround to create multiple different environments. But they also create multiple places to store installed packages. The disadvantages of this are disk usage, compilation time and one might lose the overview. Also if the multi-instance restriction is not lifted sandboxes will eventually suffer from the same unintended breakage of packages as non-sandboxed `PackageDB</code></pre>
<p>s. There should be a separation between the set of all installed packages called the cabal store and a subset of these called an environment. While the cabal store can contain multiple instances of the same package version an environment needs to be consistent. An environment is consistent if for every package version it contains only one instance of that package version.</p>
<h3 id="first-class-environments">First class environments</h3>
<p>It would be nice if we had some explicit notion of an environment.</p>
<h2 id="questions-to-remember">Questions to remember</h2>
<p>Should the cabal version be part of the hash?</p>
<p>Does the hash contain characters conflicting under windows?</p>
<p>What about builtin packages like ghc-prim, base, rts and so on?</p>
<p>Inplace Registration?</p>
<p>Who has assumptions about the directory layout of installed packages?</p>
<p>Executables?</p>
<p>Haddock?</p>
<p>Installation Planner?</p>
<p>Custom Builds and BuildHooks?</p>
<p>Other Compilers, backwards compatibility?</p>
<p>What is ComponentLocalBuildInfo for?</p>
<h1 id="the-haskell-execution-model">The Haskell Execution Model</h1>
<p>The [wiki:Commentary/Compiler/StgSynType STG language] has a clear <em>operational</em> model, as well as having a declarative lambda-calculus reading. The business of the [wiki:Commentary/Compiler/CodeGen code generator] is to translate the STG program into</p>
<pre><code>C--</code></pre>
<p>, and thence to machine code, but that is mere detail. From the STG program you should be able to understand:</p>
<ul>
<li>What functions are in the compiled program, and what their entry and return conventions are</li>
<li>What heap objects are allocated, when, and what their layout is</li>
</ul>
<p>GHC uses an eval/apply execution model, described in the paper <a href="http://research.microsoft.com/%7Esimonpj/papers/eval-apply">How to make a fast curry: push/enter vs eval/apply</a>. This paper is well worth reading if you are interested in this section.</p>
<p>Contents:</p>
<ul>
<li>[wiki:Commentary/Rts/HaskellExecution/Registers Registers]</li>
<li>[wiki:Commentary/Rts/HaskellExecution/FunctionCalls Function Calls]</li>
<li>[wiki:Commentary/Rts/HaskellExecution/CallingConvention Call and Return Conventions]</li>
<li>[wiki:Commentary/Rts/HaskellExecution/HeapChecks Heap and Stack checks]</li>
<li>[wiki:Commentary/Rts/HaskellExecution/Updates Updates]</li>
<li>[wiki:Commentary/Rts/HaskellExecution/PointerTagging Pointer Tagging]</li>
</ul>
<h1 id="heap_alloced">HEAP_ALLOCED</h1>
<p>This page is about the</p>
<pre><code>HEAP_ALLOCED()` macro/function in the runtime system.  See #8199 which is about getting rid of `HEAP_ALLOCED</code></pre>
<p>.</p>
<pre><code>StgBool HEAP_ALLOCED(void *p);</code></pre>
<p>It is defined in</p>
<pre><code>rts/sm/MBlock.h`.  The purpose of `HEAP_ALLOCED()` is to return true if the given address is part of the dynamically-allocated heap, and false otherwise.  Its primary use is in the Garbage Collector: when examining a pointer, we need to get to the block descriptor for that object.  Static objects don&#39;t have block descriptors, because they live in static code space, so we need to establish whether the pointer is into the dynamic heap first, hence `HEAP_ALLOCED()</code></pre>
<p>.</p>
<p>On a 32-bit machine,</p>
<pre><code>HEAP_ALLOCED()</code></pre>
<p>is implemented with a 4096-entry byte-map, one byte per megabyte of the address space (the dynamic heap is allocated in units of aligned megabytes).</p>
<p>On a 64-bit machine, it's a bit more difficult. The current method (GHC 6.10.1 and earlier) uses a cache, with a 4096-entry map and a 32-bit tag. If the upper 32 bits of the pointer match the tag, we look up in the map, otherwise we back off to a slow method that searches a list of mappings (bug #2934 is about the lack of thread-safety in the slow path here). This arrangement works fine for small heaps, but is pessimal for large (multi-GB) heaps, or heaps that are scattered around the address space.</p>
<p>== Speeding up</p>
<pre><code>HEAP_ALLOCED()</code></pre>
<p>==</p>
<p>We should consider how to speed up</p>
<pre><code>HEAP_ALLOCED()</code></pre>
<p>for large heaps on 64-bit machines. This involves some kind of cache arrangement - the memory map is like a page table, and we want a cache that gives us quick access to commonly accessed parts of that map.</p>
<p><a href="attachment:faster-heap-alloced.patch.gz">3</a> implements one such scheme. Measurements show that it slows down GC by about 20% for small heaps (hence it wasn't committed), though it would probably speed up GC on large heaps.</p>
<p>== Eliminating</p>
<pre><code>HEAP_ALLOCED</code></pre>
<p>completely ==</p>
<p>Can we eliminate</p>
<pre><code>HEAP_ALLOCED</code></pre>
<p>altogether? We must arrange that all closure pointers have a valid block descriptor.</p>
<h3 id="method-1-put-static-closures-in-an-aligned-section">Method 1: put static closures in an aligned section</h3>
<p>ELF sections can be arbitrarily aligned. So we could put all our static closures in a special section, align the section to 1MB, and arrange that there is space at the beginning of the section for the block descriptors.</p>
<p>This almost works (see <a href="attachment:eliminate-heap-alloced.patch.gz">4</a>), but sadly fails for shared libraries: the system dynamic linker doesn't honour section-alignment requests larger than a page, it seems. Here is a simple test program which shows the problem on Linux:</p>
<pre><code>// test.S
    .section foo,&quot;aw&quot;
    .p2align 20
    .global foo_start
foo_start:
    .ascii &quot;A&quot;</code></pre>
<pre><code>// main.c
#include &lt;stdio.h&gt;
extern char foo_start;
int main(void) {
    printf(&quot;%c\n&quot;, foo_start); // force libtest.so to be loaded
    printf(&quot;%p\n&quot;, &amp;foo_start);
}</code></pre>
<p>Compare static linking and dynamic linking:</p>
<pre><code>ezyang@javelin:~/Dev/labs/reloc$ gcc test.S main.c -g &amp;&amp; ./a.out
A
0x700000
ezyang@javelin:~/Dev/labs/reloc$ gcc test.S  -shared -o libtest.so -fPIC
ezyang@javelin:~/Dev/labs/reloc$ gcc -Wl,-R&lt;pre&gt;pwd</code></pre>
<p>-L. main.c -ltest -g -O0 -fPIC &amp;&amp; ./a.out /usr/bin/ld: warning: type and size of dynamic symbol `foo_start' are not defined A 0x7f012f9e7000</p>
</pre>
<h3 id="method-2-copy-static-closures-into-a-special-area-at-startup">Method 2: copy static closures into a special area at startup</h3>
<p>We could arrange that we access all static closures via indirections, and then at startup time we copy all the static closures into a special area with block descriptors.</p>
<p>Disadvantages:</p>
<ul>
<li>references to static objects go through another indirection. (This includes all of the RTS code)
<ul>
<li>when doing dynamic linking, references to static objects in another package</li>
</ul></li>
</ul>
<p><code>    already go through an indirection and we could arrange that only one indirection is required.</code></p>
<ul>
<li>References to static closures from the the fields of a static constructor would not incur the extra indirection,</li>
</ul>
<p><code>    only direct references to static closures from code.</code></p>
<ul>
<li>we currently reference the static closure of a function from the heap-check-fail code, but in fact</li>
</ul>
<p><code>    we only really need to pass the info pointer.</code></p>
<p>Advantages</p>
<ul>
<li>we get to fix up all the tag bits in static closure pointers</li>
<li>we get to eliminate HEAP_ALLOCED, speeding up GC and removing complexity</li>
<li>CAFs might get a bit simpler, since they are already indirections into the heap</li>
</ul>
<h1 id="heap-and-stack-checks">Heap and Stack checks</h1>
<p>Source files: <a href="GhcFile(rts/HeapStackCheck.cmm)" class="uri" title="wikilink">GhcFile(rts/HeapStackCheck.cmm)</a></p>
<p>When allocating a heap object, we bump</p>
<pre><code>Hp` and compare to `HpLim`. If the test fails we branch to ???.  Usually this code tests an interrupt flag (to see if execution should be brought tidily to a halt); grabs the next block of allocation space; makes `Hp` point to it and `HpLim</code></pre>
<p>to its end; and returns. If there are no more allocation-space blocks, garbage collection is triggered.</p>
<hr />
<p>CategoryStub</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="ghc-commentary-the-layout-of-heap-objects">GHC Commentary: The Layout of Heap Objects</h1>
<h2 id="terminology">Terminology</h2>
<ul>
<li>A <em>lifted</em> type is one that contains bottom (_|_), conversely an <em>unlifted</em> type does not contain _|_.</li>
</ul>
<p><code>  For example, </code></p>
<pre><code>Array</code></pre>
<p>is lifted, but</p>
<pre><code>ByteArray#</code></pre>
<p>is unlifted.</p>
<ul>
<li>A <em>boxed</em> type is represented by a pointer to an object in the heap, an <em>unboxed</em> object is represented by a value.</li>
</ul>
<p><code>  For example, </code></p>
<pre><code>Int</code></pre>
<p>is boxed, but</p>
<pre><code>Int#</code></pre>
<p>is unboxed.</p>
<p>The representation of _|_ must be a pointer: it is an object that when evaluated throws an exception or enters an infinite loop. Therefore, only boxed types may be lifted.</p>
<p>There are boxed unlifted types: eg.</p>
<pre><code>ByteArray#</code></pre>
<p>. If you have a value of type</p>
<pre><code>ByteArray#</code></pre>
<p>, it definitely points to a heap object with type</p>
<pre><code>ARR_WORDS</code></pre>
<p>(see below), rather than an unevaluated thunk.</p>
<p>Unboxed tuples</p>
<pre><code>(#...#)</code></pre>
<p>are both unlifted and unboxed. They are represented by multiple values passed in registers or on the stack, according to the [wiki:Commentary/Rts/HaskellExecution return convention].</p>
<p>Unlifted types cannot currently be used to represent terminating functions: an unlifted type on the right of an arrow is implicitly lifted to include</p>
<pre><code>_|_</code></pre>
<p>.</p>
<hr />
<h2 id="heap-objects">Heap Objects</h2>
<p>All heap objects have the same basic layout, embodied by the type</p>
<pre><code>StgClosure</code></pre>
<p>in [source:includes/rts/storage/Closures.h Closures.h]. The diagram below shows the layout of a heap object:</p>
<p><a href="Image(heap-object.png)" class="uri" title="wikilink">Image(heap-object.png)</a></p>
<p>A heap object always begins with a <em>header</em>, defined by</p>
<pre><code>StgHeader</code></pre>
<p>in [source:includes/rts/storage/Closures.h Closures.h]:</p>
<pre><code>typedef struct {
* info;
#ifdef PROFILING
    StgProfHeader         prof;
#endif
} StgHeader;</code></pre>
<p>The most important part of the header is the <em>info pointer</em>, which points to the info table for the closure. In the default build, this is all the header contains, so a header is normally just one word. In other builds, the header may contain extra information: eg. in a profiling build it also contains information about who built the closure.</p>
<p>Most of the runtime is insensitive to the size of</p>
<pre><code>StgHeader</code></pre>
<p>; that is, we are careful not to hardcode the offset to the payload anywhere, instead we use C struct indexing or</p>
<pre><code>sizeof(StgHeader)</code></pre>
<p>. This makes it easy to extend</p>
<pre><code>StgHeader</code></pre>
<p>with new fields if we need to.</p>
<p>The compiler also needs to know the layout of heap objects, and the way this information is plumbed into the compiler from the C headers in the runtime is described here: [wiki:Commentary/Compiler/CodeGen#Storagemanagerrepresentations].</p>
<hr />
<h2 id="info-tables">Info Tables</h2>
<p>The info table contains all the information that the runtime needs to know about the closure. The layout of info tables is defined by</p>
<pre><code>StgInfoTable</code></pre>
<p>in [source:includes/rts/storage/InfoTables.h InfoTables.h]. The basic info table layout looks like this:</p>
<p><a href="Image(basic-itbl.png)" class="uri" title="wikilink">Image(basic-itbl.png)</a></p>
<p>Where:</p>
<ul>
<li>The <em>closure type</em> is a constant describing the kind of closure this is (function, thunk, constructor etc.). All</li>
</ul>
<p><code>  the closure types are defined in [source:includes/rts/storage/ClosureTypes.h ClosureTypes.h], and many of them have corresponding C struct</code><br />
<code>  definitions in [source:includes/rts/storage/Closures.h Closures.h].</code></p>
<ul>
<li>The <em>SRT bitmap</em> field is used to support [wiki:Commentary/Rts/Storage/GC/CAFs garbage collection of CAFs].</li>
</ul>
<ul>
<li>The <em>layout</em> field describes the layout of the payload for the garbage collector, and is described in more</li>
</ul>
<p><code>  detail in </code><a href="ref(Types_of_Payload_Layout)" title="wikilink"><code>ref(Types</code> <code>of</code> <code>Payload</code> <code>Layout)</code></a><code> below.</code></p>
<ul>
<li>The <em>entry code</em> for the closure is usually the code that will <em>evaluate</em> the closure. There is one exception:</li>
</ul>
<p><code>  for functions, the entry code will apply the function to the arguments given in registers or on the stack, according</code><br />
<code>  to the calling convention.  The entry code assumes all the arguments are present - to apply a function to fewer arguments</code><br />
<code>  or to apply an unknown function, the [wiki:Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply generic apply functions] must</code><br />
<code>  be used.</code></p>
<p>Some types of object add more fields to the end of the info table, notably functions, return addresses, and thunks.</p>
<p>Space in info tables is a premium: adding a word to the standard info table structure increases binary sizes by 5-10%.</p>
<p>===</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>===</p>
<p>Note that the info table is followed immediately by the entry code, rather than the code being at the end of an indirect pointer. This both reduces the size of the info table and eliminates one indirection when jumping to the entry code.</p>
<p>GHC can generate code that uses the indirect pointer instead; the</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>turns on the optimised layout. Generally</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>is turned off when compiling unregisterised.</p>
<p>When</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>is off, info tables get another field,</p>
<pre><code>entry</code></pre>
<p>, which points to the entry code. In a generated object file, each symbol</p>
<pre><code>X_info</code></pre>
<p>representing an info table will have an associated symbol</p>
<pre><code>X_entry</code></pre>
<p>pointing to the entry code (in</p>
<pre><code>TABLES_NEXT_TO_CODE</code></pre>
<p>, the entry symbol is omitted to keep the size of symbol tables down).</p>
<hr />
<h2 id="types-of-payload-layout">Types of Payload Layout</h2>
<p>The GC needs to know two things about the payload of a heap object: how many words it contains, and which of those words are pointers. There are two basic kinds of layout for the payload: <em>pointers-first</em> and <em>bitmap</em>. Which of these kinds of layout is being used is a property of the <em>closure type</em>, so the GC first checks the closure type to determine how to interpret the layout field of the info table.</p>
<h3 id="pointers-first-layout">Pointers-first layout</h3>
<p>The payload consists of zero or more pointers followed by zero or more non-pointers. This is the most common layout: constructors, functions and thunks use this layout. The layout field contains two half-word-sized fields:</p>
<ul>
<li>Number of pointers</li>
<li>Number of non-pointers</li>
</ul>
<h3 id="bitmap-layout">Bitmap layout</h3>
<p>The payload consists of a mixture of pointers and non-pointers, described by a bitmap. There are two kinds of bitmap:</p>
<p><strong>Small bitmaps.</strong> A small bitmap fits into a single word (the layout word of the info table), and looks like this:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Size (bits 0-4)</p></td>
<td align="left"><p>Bitmap (bits 5-31)</p></td>
</tr>
</tbody>
</table>
<p>(for a 64-bit word size, the size is given 6 bits instead of 5).</p>
<p>The size field gives the size of the payload, and each bit of the bitmap is 1 if the corresponding word of payload contains a pointer to a live object.</p>
<p>The macros</p>
<pre><code>MK_BITMAP</code></pre>
<p>,</p>
<pre><code>BITMAP_SIZE</code></pre>
<p>, and</p>
<pre><code>BITMAP_BITS</code></pre>
<p>in [source:includes/rts/storage/InfoTables.h InfoTables.h] provide ways to conveniently operate on small bitmaps.</p>
<p><strong>Large bitmaps.</strong> If the size of the stack frame is larger than the 27 words that a small bitmap can describe, then the fallback mechanism is the large bitmap. A large bitmap is a separate structure, containing a single word size and a multi-word bitmap: see</p>
<pre><code>StgLargeBitmap</code></pre>
<p>in [source:includes/rts/storage/InfoTables.h InfoTables.h].</p>
<hr />
<h2 id="dynamic-vs.-static-objects">Dynamic vs. Static objects</h2>
<p>Objects fall into two categories:</p>
<ul>
<li><em>dynamic</em> objects reside in the heap, and may be moved by the garbage collector.</li>
</ul>
<ul>
<li><em>static</em> objects reside in the compiled object code. They are never moved, because pointers to such objects are</li>
</ul>
<p><code>  scattered through the object code, and only the linker knows where.</code></p>
<p>To find out whether a particular object is dynamic or static, use the [wiki:Commentary/Rts/Storage/HeapAlloced HEAP_ALLOCED()] macro, from [source:rts/sm/HeapAlloc.h]. This macro works by consulting a bitmap (or structured bitmap) that tells for each [wiki:Commentary/Rts/Storage#Structureofblocks megablock] of memory whether it is part of the dynamic heap or not.</p>
<h3 id="dynamic-objects">Dynamic objects</h3>
<p>Dynamic objects have a minimum size, because every object must be big enough to be overwritten by a forwarding pointer (<a href="ref(Forwarding_Pointers)" title="wikilink">ref(Forwarding Pointers)</a>) during GC. The minimum size of the payload is given by</p>
<pre><code>MIN_PAYLOAD_SIZE</code></pre>
<p>in [source:includes/rts/Constants.h].</p>
<h3 id="static-objects">Static objects</h3>
<p>All static objects have closure types ending in</p>
<pre><code>_STATIC</code></pre>
<p>, eg.</p>
<pre><code>CONSTR_STATIC</code></pre>
<p>for static data constructors.</p>
<p>Static objects have an additional field, called the <em>static link field</em>. The static link field is used by the GC to link all the static objects in a list, and so that it can tell whether it has visited a particular static object or not - the GC needs to traverse all the static objects in order to [wiki:Commentary/Rts/CAFs garbage collect CAFs].</p>
<p>The static link field resides after the normal payload, so that the static variant of an object has compatible layout with the dynamic variant. To access the static link field of a closure, use the</p>
<pre><code>STATIC_LINK()</code></pre>
<p>macro from [source:includes/rts/storage/ClosureMacros.h].</p>
<hr />
<h2 id="types-of-object">Types of object</h2>
<h3 id="data-constructors">Data Constructors</h3>
<p>All data constructors have pointers-first layout:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Pointers...</p></td>
<td align="left"><p>Non-pointers...</p></td>
</tr>
</tbody>
</table>
<p>Data constructor closure types:</p>
<ul>
<li><pre><code>CONSTR</code></pre>
<dl>

<dd>a vanilla, dynamically allocated constructor
</dd>
</dl></li>
<li><pre><code>CONSTR_p_n</code></pre>
<dl>

<dd>a constructor whose layout is encoded in the closure type (eg.
<pre><code>CONSTR_1_0</code></pre>
<p>has one pointer</p>
</dd>
</dl></li>
</ul>
<p><code>  and zero non-pointers.  Having these closure types speeds up GC a little for common layouts.</code></p>
<ul>
<li><pre><code>CONSTR_STATIC</code></pre>
<dl>

<dd>a statically allocated constructor.
</dd>
</dl></li>
<li><pre><code>CONSTR_NOCAF_STATIC</code></pre>
<dl>

<dd>TODO: Needs documentation
</dd>
</dl></li>
</ul>
<p>The entry code for a constructor returns immediately to the topmost stack frame, because the data constructor is already in WHNF. The return convention may be vectored or non-vectored, depending on the type (see [wiki:Commentary/Rts/HaskellExecution/CallingConvention]).</p>
<p>Symbols related to a data constructor X:</p>
<ul>
<li>X_
<pre><code>con_info</code></pre>
<dl>

<dd>info table for a dynamic instance of X
</dd>
</dl></li>
<li>X_
<pre><code>static_info</code></pre>
<dl>

<dd>info table for a static instance of X
</dd>
</dl></li>
<li>X_
<pre><code>info</code></pre>
<dl>

<dd>the <em>wrapper</em> for X (a function, equivalent to the
</dd>
</dl></li>
</ul>
<p><code>  curried function </code></p>
<pre><code>X</code></pre>
<p>in Haskell, see</p>
<p><code>  [wiki:Commentary/Compiler/EntityTypes]).  </code></p>
<ul>
<li>X_
<pre><code>closure</code></pre>
<dl>

<dd>static closure for X's wrapper
</dd>
</dl></li>
</ul>
<h3 id="function-closures">Function Closures</h3>
<p>A function closure represents a Haskell function. For example:</p>
<pre><code>  f = \x -&gt; let g = \y -&gt; x + y
            in g x</code></pre>
<p>Here,</p>
<pre><code>f</code></pre>
<p>would be represented by a static function closure (see below), and</p>
<pre><code>g</code></pre>
<p>a dynamic function closure. Every function in the Haskell program generates a new info table and entry code, and top-level functions additionally generate a static closure.</p>
<p>All function closures have pointers-first layout:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Pointers...</p></td>
<td align="left"><p>Non-pointers...</p></td>
</tr>
</tbody>
</table>
<p>The payload of the function closure contains the free variables of the function: in the example above, a closure for</p>
<pre><code>g</code></pre>
<p>would have a payload containing a pointer to</p>
<pre><code>x</code></pre>
<p>.</p>
<p>Function closure types:</p>
<ul>
<li><pre><code>FUN</code></pre>
<dl>

<dd>a vanilla, dynamically allocated function
</dd>
</dl></li>
<li><pre><code>FUN_p_n</code></pre>
<dl>

<dd>same, specialised for layout (see constructors above)
</dd>
</dl></li>
<li><pre><code>FUN_STATIC</code></pre>
<dl>

<dd>a static (top-level) function closure
</dd>
</dl></li>
</ul>
<p>Symbols related to a function</p>
<pre><code>f</code></pre>
<dl>

<dd>
</dd>
</dl>
<ul>
<li><pre><code>f_info</code></pre>
<dl>

<dd>f's info table and code
</dd>
</dl></li>
<li><pre><code>f_closure</code></pre>
<dl>

<dd>f's static closure, if f is a top-level function.
</dd>
</dl></li>
</ul>
<p><code>  The static closure has no payload, because there are no free</code><br />
<code>  variables of a top-level function.  It does have a static link</code><br />
<code>  field, though.</code></p>
<h3 id="thunks">Thunks</h3>
<p>A thunk represents an expression that is not obviously in head normal form. For example, consider the following top-level definitions:</p>
<pre><code>  range = between 1 10
  f = \x -&gt; let ys = take x range
        in sum ys</code></pre>
<p>Here the right-hand sides of</p>
<pre><code>range</code></pre>
<p>and</p>
<pre><code>ys</code></pre>
<p>are both thunks; the former is static while the latter is dynamic.</p>
<p>Thunks have pointers-first layout:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>(empty)</p></td>
<td align="left"><p>Pointers...</p></td>
<td align="left"><p>Non-pointers...</p></td>
</tr>
</tbody>
</table>
<p>As for function closures, the payload contains the free variables of the expression. A thunk differs from a function closure in that it can be [wiki:Commentary/Rts/HaskellExecution#Updates updated].</p>
<p>There are several forms of thunk:</p>
<ul>
<li><pre><code>THUNK</code></pre>
<p>,</p>
<pre><code>THUNK_p_n</code></pre>
<dl>

<dd>vanilla, dynamically allocated
</dd>
</dl></li>
</ul>
<p><code>  thunks.  Dynamic thunks are overwritten with normal indirections</code><br />
<code>  </code></p>
<pre><code>IND</code></pre>
<p>when evaluated.</p>
<ul>
<li><pre><code>THUNK_STATIC</code></pre>
<dl>

<dd>a static thunk is also known as a ''constant
</dd>
</dl></li>
</ul>
<p><code>  applicative form'', or </code><em><code>CAF</code></em><code>.  Static thunks are overwritten with</code><br />
<code>  static indirections (</code></p>
<pre><code>IND_STATIC</code></pre>
<p>).</p>
<p>The only label associated with a thunk is its info table:</p>
<ul>
<li><pre><code>f_info</code></pre>
<p>is f's info table.</p></li>
</ul>
<p>The empty padding is to allow thunk update code to overwrite the target of an indirection without clobbering any of the saved free variables. This means we can do thunk update without synchronization, which is a big deal.</p>
<h3 id="selector-thunks">Selector thunks</h3>
<pre><code>THUNK_SELECTOR</code></pre>
<p>is a (dynamically allocated) thunk whose entry code performs a simple selection operation from a data constructor drawn from a single-constructor type. For example, the thunk</p>
<pre><code>x = case y of (a,b) -&gt; a</code></pre>
<p>is a selector thunk. A selector thunk is laid out like this:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Selectee pointer</p></td>
</tr>
</tbody>
</table>
<p>The</p>
<pre><code>layout</code></pre>
<p>word contains the byte offset of the desired word in the selectee. Note that this is different from all other thunks.</p>
<p>The garbage collector &quot;peeks&quot; at the selectee's tag (in its info table). If it is evaluated, then it goes ahead and does the selection, and then behaves just as if the selector thunk was an indirection to the selected field. If it is not evaluated, it treats the selector thunk like any other thunk of that shape.</p>
<p>This technique comes from the Phil Wadler paper <a href="http://homepages.inf.ed.ac.uk/wadler/topics/garbage-collection.html">Fixing some space leaks with a garbage collector</a>, and later Christina von Dorrien who called it &quot;Stingy Evaluation&quot;.</p>
<p>There is a fixed set of pre-compiled selector thunks built into the RTS, representing offsets from 0 to</p>
<pre><code>MAX_SPEC_SELECTOR_THUNK</code></pre>
<p>, see [source:rts/StgStdThunks.cmm]. The info tables are labelled</p>
<pre><code>__sel_n_upd_info</code></pre>
<p>where</p>
<pre><code>n</code></pre>
<p>is the offset. Non-updating versions are also built in, with info tables labelled</p>
<pre><code>_sel_n_noupd_info</code></pre>
<p>.</p>
<p>These thunks exist in order to prevent a space leak. For example, if y is a thunk that has been evaluated, and y is unreachable, but x is reachable, the risk is that x keeps both the a and b components of y live. By making the selector thunk a special case, we make it possible to reclaim the memory associated with b. (The situation is further complicated when selector thunks point to other selector thunks; the garbage collector sees all, knows all.)</p>
<h3 id="partial-applications">Partial applications</h3>
<p>Partial applications are tricky beasts.</p>
<p>A partial application, closure type</p>
<pre><code>PAP</code></pre>
<p>, represents a function applied to too few arguments. Partial applications are only built by the [wiki:Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply generic apply functions] in [source:rts/Apply.cmm].</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Arity</p></td>
<td align="left"><p>No. of words</p></td>
<td align="left"><p>Function closure</p></td>
<td align="left"><p>Payload...</p></td>
</tr>
</tbody>
</table>
<p>Where:</p>
<ul>
<li><em>Arity</em> is the arity of the PAP. For example, a function with</li>
</ul>
<p><code>  arity 3 applied to 1 argument would leave a PAP with arity 2.</code></p>
<ul>
<li><em>No. of words</em> refers to the size of the payload in words.</li>
</ul>
<ul>
<li><em>Function closure</em> is the function to which the arguments are</li>
</ul>
<p><code>  applied.  Note that this is always a pointer to one of the</code><br />
<code>  </code></p>
<pre><code>FUN</code></pre>
<p>family, never a</p>
<pre><code>PAP</code></pre>
<p>. If a</p>
<pre><code>PAP</code></pre>
<p>is applied</p>
<p><code>  to more arguments to give a new </code></p>
<pre><code>PAP</code></pre>
<p>, the arguments from</p>
<p><code>  the original </code></p>
<pre><code>PAP</code></pre>
<p>are copied to the new one.</p>
<ul>
<li>The payload is the sequence of arguments already applied to</li>
</ul>
<p><code>  this function.  The pointerhood of these words are described</code><br />
<code>  by the function's bitmap (see </code></p>
<pre><code>scavenge_PAP_payload()</code></pre>
<p>in</p>
<p><code>  [source:rts/sm/Scav.c] for an example of traversing a PAP).</code></p>
<p>There is just one standard form of PAP. There is just one info table too, called</p>
<pre><code>stg_PAP_info</code></pre>
<p>. A PAP should never be entered, so its entry code causes a failure. PAPs are applied by the generic apply functions in</p>
<pre><code>AutoApply.cmm</code></pre>
<p>.</p>
<h3 id="generic-application">Generic application</h3>
<p>An</p>
<pre><code>AP</code></pre>
<p>object is very similar to a</p>
<pre><code>PAP</code></pre>
<p>, and has identical layout:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Arity</p></td>
<td align="left"><p>No. of words</p></td>
<td align="left"><p>Function closure</p></td>
<td align="left"><p>Payload...</p></td>
</tr>
</tbody>
</table>
<p>The difference is that an</p>
<pre><code>AP</code></pre>
<p>is not necessarily in WHNF. It is a thunk that represents the application of the specified function to the given arguments.</p>
<p>The arity field is always zero (it wouldn't help to omit this field, because it is only half a word anyway).</p>
<pre><code>AP</code></pre>
<p>closures are used mostly by the byte-code interpreter, so that it only needs a single form of thunk object. Interpreted thunks are always represented by the application of a</p>
<pre><code>BCO</code></pre>
<p>to its free variables.</p>
<h3 id="stack-application">Stack application</h3>
<p>An</p>
<pre><code>AP_STACK</code></pre>
<p>is a special kind of object:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Size</p></td>
<td align="left"><p>Closure</p></td>
<td align="left"><p>Payload...</p></td>
</tr>
</tbody>
</table>
<p>It represents computation of a thunk that was suspended midway through evaluation. In order to continue the computation, copy the payload onto the stack (the payload was originally the stack of the suspended computation), and enter the closure.</p>
<p>Since the payload is a chunk of stack, the GC can use its normal stack-walking code to traverse it.</p>
<pre><code>AP_STACK</code></pre>
<p>closures are built by</p>
<pre><code>raiseAsync()</code></pre>
<p>in [source:rts/RaiseAsync.c] when an [wiki:Commentary/Rts/AsyncExceptions asynchronous exception] is raised. It's fairly typical for the end of an AP_STACK's payload to have another AP_STACK: you'll get one per update frame.</p>
<h3 id="indirections">Indirections</h3>
<p>Indirection closures just point to other closures. They are introduced when a thunk is updated to point to its value. The entry code for all indirections simply enters the closure it points to.</p>
<p>The basic layout of an indirection is simply</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Target closure</p></td>
</tr>
</tbody>
</table>
<p>There are several variants of indirection:</p>
<ul>
<li><pre><code>IND</code></pre>
<dl>

<dd>is the vanilla, dynamically-allocated indirection.
</dd>
</dl></li>
</ul>
<p><code>  It is removed by the garbage collector.  An </code></p>
<pre><code>IND</code></pre>
<p>only exists in the youngest generation.</p>
<p><code>  The update code (</code></p>
<pre><code>stg_upd_frame_info</code></pre>
<p>and friends) checks whether the updatee is in the youngest</p>
<p><code>  generation before deciding which kind of indirection to use.</code></p>
<ul>
<li><pre><code>IND_STATIC</code></pre>
<dl>

<dd>a static indirection, arises when we update a
<pre><code>THUNK_STATIC</code></pre>
<p>. A new</p>
<pre><code>IND_STATIC</code></pre>
</dd>
</dl></li>
</ul>
<p><code>  is placed on the mutable list when it is created (see </code></p>
<pre><code>newCaf()</code></pre>
<p>in [source:rts/sm/Storage.c]).</p>
<h3 id="byte-code-objects">Byte-code objects</h3>
<pre><code>BCO</code></pre>
<h3 id="black-holes">Black holes</h3>
<pre><code>BLACKHOLE</code></pre>
<p>,</p>
<pre><code>CAF_BLACKHOLE</code></pre>
<p>Black holes represent thunks which are under evaluation by another thread (that thread is said to have claimed the thunk). Attempting to evaluate a black hole causes a thread to block until the thread who claimed the thunk either finishes evaluating the thunk or dies. You can read more about black holes in the paper 'Haskell on a Shared-Memory Multiprocessor'. Black holes have the same layout as indirections.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Target closure</p></td>
</tr>
</tbody>
</table>
<p>Sometimes black holes are just ordinary indirection. Check</p>
<pre><code>stg_BLACKHOLE_info</code></pre>
<p>for the final word: if the indirectee has no tag, then we assume that it is the TSO that has claimed the thunk; if the indirectee is tagged, then it is just a normal indirection. (EZY: I think this optimization is to avoid having to do two memory writes on thunk update; we don't bother updating the header, only the target.)</p>
<p>When eager blackholing is enabled, the black hole that is written is not a true black hole, but an eager black hole. True black holes are synchronized, and guarantee that only one black hole is claimed (this property is used to implement non-dupable unsafePerformIO). Eager black holes are not synchronized; eager black hole are converted into true black holes in ThreadPaused.c. Incidentally, this facility is also used to convert update frames to black holes; this is important for eliminating a space leak caused by the thunk under evaluation retaining too much data (overwriting it with a black hole frees up variable.)</p>
<h3 id="arrays">Arrays</h3>
<pre><code>ARR_WORDS</code></pre>
<p>,</p>
<pre><code>MUT_ARR_PTRS_CLEAN</code></pre>
<p>,</p>
<pre><code>MUT_ARR_PTRS_DIRTY</code></pre>
<p>,</p>
<pre><code>MUT_ARR_PTRS_FROZEN0</code></pre>
<p>,</p>
<pre><code>MUT_ARR_PTRS_FROZEN</code></pre>
<p>Non-pointer arrays are straightforward:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>| Header</p></td>
<td align="left"><p>| Bytes</p></td>
<td align="left"><p>| Array payload</p></td>
</tr>
</tbody>
</table>
<p>Arrays with pointers are a little more complicated, they include a card table, which is used by the GC to know what segments of the array to traverse as roots (the card table is modified by the GC write barrier):</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>| Header</p></td>
<td align="left"><p>| Ptrs</p></td>
<td align="left"><p>| Size</p></td>
<td align="left"><p>| Array payload + card table</p></td>
</tr>
</tbody>
</table>
<p>You can access the card table by using</p>
<pre><code>mutArrPtrsCard(array, element index)</code></pre>
<p>, which gives you the address of the card for that index.</p>
<h3 id="mvars">MVars</h3>
<pre><code>MVar</code></pre>
<p>MVars have a queue of the TSOs blocking on them along with their value:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Head of queue</p></td>
<td align="left"><p>Tail of queue</p></td>
<td align="left"><p>Value</p></td>
</tr>
</tbody>
</table>
<p>An MVar can be in several states. It can be empty (in which case the value is actually just a</p>
<pre><code>stg_END_TSO_QUEUE_closure</code></pre>
<p>) or it can be full. When it is full, the queue of TSOs are those waiting to put; when it is empty, the queue of TSOs are those waiting to read and take (with readers first). Like many mutable objects, MVars have CLEAN and DIRTY headers to avoid reapplying a write barrier when an MVar is already dirty.</p>
<h3 id="weak-pointers">Weak pointers</h3>
<pre><code>Weak</code></pre>
<h3 id="stable-names">Stable Names</h3>
<pre><code>STABLE_NAME</code></pre>
<h3 id="thread-state-objects">Thread State Objects</h3>
<p>Closure type</p>
<pre><code>TSO</code></pre>
<p>is a Thread State Object. It represents the complete state of a thread, including its stack.</p>
<p>TSOs are ordinary objects that live in the heap, so we can use the existing allocation and garbage collection machinery to manage them. This gives us one important benefit: the garbage collector can detect when a blocked thread is unreachable, and hence can never become runnable again. When this happens, we can notify the thread by sending it the</p>
<pre><code>BlockedIndefinitely</code></pre>
<p>exception.</p>
<p>GHC keeps divides stacks into stack chunks, with logic to handle stack underflow and overflow: <a href="http://hackage.haskell.org/trac/ghc/blog/stack-chunks" class="uri">http://hackage.haskell.org/trac/ghc/blog/stack-chunks</a></p>
<p>The TSO structure contains several fields. For full details see [source:includes/rts/storage/TSO.h]. Some of the more important fields are:</p>
<ul>
<li><em>link</em>: field for linking TSOs together in a list. For example, the threads blocked on an
<pre><code>MVar</code></pre>
<p>are kept in</p></li>
</ul>
<p><code>  a queue threaded through the link field of each TSO.</code></p>
<ul>
<li><em>global_link</em>: links all TSOs together; the head of this list is
<pre><code>all_threads</code></pre>
<p>in [source:rts/Schedule.c].</p></li>
<li><em>what_next</em>: how to resume execution of this thread. The valid values are:
<ul>
<li><pre><code>ThreadRunGhc</code></pre>
<dl>

<dd>continue by returning to the top stack frame.
</dd>
</dl></li>
<li><pre><code>ThreadInterpret</code></pre>
<dl>

<dd>continue by interpreting the BCO on top of the stack.
</dd>
</dl></li>
<li><pre><code>ThreadKilled</code></pre>
<dl>

<dd>this thread has received an exception which was not caught.
</dd>
</dl></li>
<li><pre><code>ThreadRelocated</code></pre>
<dl>

<dd>this thread ran out of stack and has been relocated to a larger TSO; the link field points
</dd>
</dl></li>
</ul></li>
</ul>
<p><code>    to its new location.</code></p>
<ul>
<li><pre><code>ThreadComplete</code></pre>
<dl>

<dd>this thread has finished and can be garbage collected when it is unreachable.
</dd>
</dl></li>
</ul>
<p><em><code>why_blocked</code></em><code>: for a blocked thread, indicates why the thread is blocked.  See [source:includes/rts/Constants.h] for</code><br />
<code>  the list of possible values.</code></p>
<ul>
<li><em>block_info</em>: for a blocked thread, gives more information about the reason for blockage, eg. when blocked on an</li>
</ul>
<p><code>   MVar, block_info will point to the MVar.</code></p>
<ul>
<li><em>bound</em>: pointer to a [wiki:Commentary/Rts/Scheduler#Task Task] if this thread is bound</li>
<li><em>cap</em>: the [wiki:Commentary/Rts/Scheduler#Capabilities Capability] on which this thread resides.</li>
</ul>
<h3 id="stm-objects">STM objects</h3>
<p>These object types are used by [wiki:Commentary/Rts/STM STM]:</p>
<pre><code>TVAR_WAIT_QUEUE</code></pre>
<p>,</p>
<pre><code>TVAR</code></pre>
<p>,</p>
<pre><code>TREC_CHUNK</code></pre>
<p>,</p>
<pre><code>TREC_HEADER</code></pre>
<p>.</p>
<h3 id="forwarding-pointers">Forwarding Pointers</h3>
<p>Forwarding pointers appear temporarily during [wiki:Commentary/Rts/Storage/GC garbage collection]. A forwarding pointer points to the new location for an object that has been moved by the garbage collector. It is represented by replacing the info pointer for the closure with a pointer to the new location, with the least significant bit set to 1 to distinguish a forwarding pointer from an info pointer.</p>
<h2 id="how-to-add-new-heap-objects">How to add new heap objects</h2>
<p>There are two</p>
<p>This page is a stub.</p>
<h2 id="change-history">Change History</h2>
<ul>
<li><em>History of when Hoopl was integrated into a GHC back end</em></li>
</ul>
<ul>
<li>After the publication of the Hoopl paper, a contributor (sorry I have forgotten who) did quite a bit to integrate the supply of
<pre><code>Uniq</code></pre>
<p>s into Hoopl. (Time? Person?)</p></li>
</ul>
<ul>
<li><em>Note that the new code generator appears about 10x slower than the old. Slowdown attributed to Hoopl dataflow.</em> See <a href="https://plus.google.com/107890464054636586545/posts/dBbewpRfw6R">Google Plus post by Simon Marlow</a>.</li>
</ul>
<ul>
<li>Fixed-point algorithm rewritten to reduce duplicate computation. (Simon Marlow in late 2011. Also Edward Yang in spring 2011.) Is there any more? I suggest looking at traces in the simple cases.</li>
</ul>
<ul>
<li>Change in representation of blocks, Simon Marlow, late 2011. (Details?) Performance difference almost too small to be measurable, but Simon M likes the new rep anyway.</li>
</ul>
<h2 id="speculation-and-commentary">Speculation and Commentary</h2>
<ul>
<li>Simon PJ had questions about &quot;optimization fuel&quot; from the beginning. Norman maintains that optimization fuel is an invaluable debugging aid, but that in a production compiler, one would like it to be turned off. At some point we had abstracted over the
<pre><code>FuelMonad</code></pre>
<p>so that we could make a &quot;zero&quot; fuel monad that did nothing and cost nothing. As of January 2012, Norman doesn't know what the state of that plan is or whether GHC's optimiser can actually eliminate the overheads.</p></li>
</ul>
<ul>
<li>Unlike Fuel, a supply of
<pre><code>Uniq</code></pre>
<p>s was believed to be an absolute necessity: an optimiser must be able to rewrite blocks, and in the general case, it must be able to introduce new blocks. It was believed that the only way to do this consistent with GHC was to plumb in a Uniq supply. <em>Query</em>: was this integrated with Fuel somehow?</p></li>
</ul>
<ul>
<li>The published version of Hoopl passes an explicit dictionary that contains all the dataflow facts for all the labels. Earlier versions of Hoopl kept this information in a monad. It's not known whether the change has implications for performance, but it is probably easier to manage the speculative rewriting without a monad.</li>
</ul>
<ul>
<li>Norman has always been uneasy about the dictionaries passed to the
<pre><code>block</code></pre>
<p>function. He conjectures that most blocks have a small number of outedges, and probably not that many inedges either (case expressions and the Adams optimisation notwithstanding). He wonders if instead of some kind of trie structure with worst-case logarithmic performance, we might not be better off with a simple association list---especially because it is common to simply join <em>all</em> facts flowing into a block. <strong>Query: Is there a way to measure the costs of using dictionaries in this fashion? Cost centers, perhaps?</strong></p></li>
</ul>
<ul>
<li>There was a Google Plus thread in which CPS was criticized (by Jan Maessen, I think). The original authors had many big fights, and one of them was about CPS. At some point Norman drafted a dataflow analyser that was very aggressively CPS. Simon PJ found the extensive CPS difficult to read. Norman doesn't remember the eventual outcome. Is it possible that the CPS is causing the allocation of too many function closures? Could the CPS be rewritten, perhaps by a different way of nesting functions, to eliminate the need to allocate closures in the inner loop? Johan Tibell tried optimizing postorder_dfs, but was put off by the CPS style of code. (We speculate that caching the result of toposort may help.)</li>
</ul>
<ul>
<li>Another important thing to keep in mind is that some of the existing passes used by GHC may be implemented inefficiently (of no fault of Hoopl itself.) For example, the rewrite assignments pass takes around 15% of the entire compilation time; we believe this is because it has to rewrite the entire graph into a new representation before doing any transformations, and then rewrite it back to the original. Optimizations here (for example, storing the information in an external map as opposed to the AST itself) would probably would help a lot.</li>
</ul>
<h2 id="record-of-performance-improvements-made-to-the-hoopl-library-starting-january-2012">Record of performance improvements made to the Hoopl library starting January 2012</h2>
<h1 id="haskell-program-coverage">Haskell Program Coverage</h1>
<p>This page describes the Haskell Program Coverage implementation inside GHC. Background information can be found in the paper <a href="http://www.ittc.ku.edu/~andygill/papers/Hpc07.pdf">Haskell Program Coverage</a> by Andy Gill and Colin Runciman, and the Haskell wiki page <a href="https://wiki.haskell.org/Haskell_program_coverage">Haskell program coverage</a>.</p>
<p>The basic idea is this</p>
<ul>
<li>For each (sub)expression in the Haskell Syntax, write the (sub)expression in a</li>
</ul>
<pre><code>HsTick</code></pre>
<ul>
<li>Each
<pre><code>HsTick</code></pre>
<p>has a module local index number.</p></li>
<li>There is a table (The Mix data structure) that maps this index number to original source location.</li>
<li>Each
<pre><code>HsTick</code></pre>
<p>is mapped in the Desugar pass with:</p></li>
</ul>
<pre><code>  dsExpr (HsTick n e) = case tick&lt;modname,n&gt; of DEFAULT -&gt; e</code></pre>
<ul>
<li>This tick is a special type of
<pre><code>Id`, a `TickOpId</code></pre>
<p>which takes no core-level argument, but has two pre-applied arguments; the module name and the module-local tick number.</p>
<ul>
<li>We store both module name and tick number to allow this Id to be passed (inlined) inside other modules.</li>
<li>This
<pre><code>Id</code></pre>
<p>has type <strong>State# World#</strong></p></li>
</ul></li>
<li>The core simplifier must not remove this case, but it can move it.
<ul>
<li>The do-not-remove is enforced via the ... function in ....</li>
<li>The semantics are tick if-and-when-and-as you enter the
<pre><code>DEFAULT</code></pre>
<p>case. But a chain of consecutive ticks can be executed in any order.</p></li>
</ul></li>
<li>The CoreToStg Pass translates the ticks into
<pre><code>StgTick</code></pre></li>
</ul>
<pre><code>  coreToStgExpr (case tick&lt;m,n&gt; of DEFAULT -&gt; e) = StgTick m n (coreToStgExpr e)</code></pre>
<ul>
<li>The
<pre><code>Cmm` code generator translates `StgTick</code></pre>
<p>to a 64 bit increment.</p></li>
</ul>
<p>Other details</p>
<ul>
<li>A executable startup time, we perform a depth first traversal some module</li>
</ul>
<p><code>  specific code, gathering a list of all Hpc registered modules, and the</code><br />
<code>  module specific tick table. </code></p>
<ul>
<li>There is one table per module, so we can link the increment statically,</li>
</ul>
<p><code>  without needing to know the global tick number.</code></p>
<ul>
<li>The module Hpc.c in the RTS handles all the reading of these table.</li>
<li>At startup, if a .tix file is found, Hpc.c checks that this is the same</li>
</ul>
<p><code>  binary as generated the .tix file, and if so, pre-loads all the tick counts</code><br />
<code>  in the module specific locations.</code></p>
<ul>
<li>(I am looking for a good way of checking the binaries for sameness)</li>
<li>At shutdown, we write back out the .tix files, from the module-local tables.</li>
</ul>
<h3 id="binary-tick-boxes">Binary Tick Boxes</h3>
<p>There is also the concept of a binary tick box. This is a syntactical boolean, like a guard or conditional for an if. We use tick boxes to record the result of the boolean, to check for coverage over True and False.</p>
<ul>
<li>Each
<pre><code>HsBinaryTick</code></pre>
<p>is mapped in the Desugar pass with:</p></li>
</ul>
<pre><code>  dsExpr (HsBinaryTick t f e) = case e of 
                                 { True -&gt; case tick&lt;modname,t&gt; of DEFAULT -&gt; True
                                 ; False -&gt; case tick&lt;modname,f&gt; of DEFAULT -&gt; False }</code></pre>
<ul>
<li>After desugaring, there is no longer any special code for binary tick box.</li>
</ul>
<h2 id="machine-generated-haskell">Machine Generated Haskell</h2>
<p>Sometimes, Haskell is the target language - for example, Happy and Alex. In this case, you want to be able to check for coverage of your <strong>original</strong> program. So we have a new pragma.</p>
<pre><code>    {-# GENERATED &quot;Parser&quot; 100-2:101-4 #-} &lt;expr&gt;
 </code></pre>
<p>This means that the expression was obtained from the given file and locations. This might be code included verbatim (for example the actions in Happy), or be generated from a specification from this location.</p>
<h1 id="compiling-one-module-hscmain">Compiling one module: HscMain</h1>
<p>Here we are going to look at the compilation of a single module. There is a picture that goes with this description, which appears at the bottom of this page, but you'll probably find it easier to open [wiki:Commentary/Compiler/HscPipe this link] in another window, so you can see it at the same time as reading the text.</p>
<p>You can also watch a <strong>video</strong> of Simon Peyton-Jones explaining the compilation pipeline here: <a href="http://www.youtube.com/watch?v=Upm_kYMgI_c&amp;list=PLBkRCigjPwyeCSD_DFxpd246YIF7_RDDI">Compiler Pipeline II</a> (10'16&quot;)</p>
<p>Look at the picture first. The yellow boxes are compiler passes, while the blue stuff on the left gives the data type that moves from one phase to the next. The entire pipeline for a single module is run by a module called HscMain (<a href="GhcFile(compiler/main/HscMain.hs)" class="uri" title="wikilink">GhcFile(compiler/main/HscMain.hs)</a>). Each data type's representation can be dumped for further inspection using a</p>
<pre><code>-ddump-*` flag. (Consider also using `-ddump-to-file</code></pre>
<dl>

<dd>some of the dump outputs can be large) Here are the steps it goes through:
</dd>
</dl>
<ul>
<li>The <strong>Front End</strong> processes the program in the [wiki:Commentary/Compiler/HsSynType big HsSyn type].
<pre><code>HsSyn</code></pre>
<p>is parameterised over the types of the term variables it contains. The first three passes (the front end) of the compiler work like this:<br />
<br />
* The <strong>[wiki:Commentary/Compiler/Parser Parser]</strong> produces</p>
<pre><code>HsSyn</code></pre>
<p>parameterised by <strong>[wiki:Commentary/Compiler/RdrNameType RdrName]</strong>. To a first approximation, a</p>
<pre><code>RdrName</code></pre>
<p>is just a string. (</p>
<pre><code>-ddump-parsed</code></pre>
<p>)<br />
<br />
* The <strong>[wiki:Commentary/Compiler/Renamer Renamer]</strong> transforms this to</p>
<pre><code>HsSyn</code></pre>
<p>parameterised by <strong>[wiki:Commentary/Compiler/NameType Name]</strong>. To a first appoximation, a</p>
<pre><code>Name</code></pre>
<p>is a string plus a</p>
<pre><code>Unique</code></pre>
<p>(number) that uniquely identifies it. In particular, the renamer associates each identifier with its binding instance and ensures that all occurrences which associate to the same binding instance share a single</p>
<pre><code>Unique</code></pre>
<p>. (</p>
<pre><code>-ddump-rn</code></pre>
<p>)<br />
<br />
* The <strong>[wiki:Commentary/Compiler/TypeChecker Typechecker]</strong> transforms this further, to</p>
<pre><code>HsSyn</code></pre>
<p>parameterised by <strong>[wiki:Commentary/Compiler/EntityTypes Id]</strong>. To a first approximation, an</p>
<pre><code>Id</code></pre>
<p>is a</p>
<pre><code>Name</code></pre>
<p>plus a type. In addition, the type-checker converts class declarations to</p>
<pre><code>Class</code></pre>
<p>es, and type declarations to</p>
<pre><code>TyCon</code></pre>
<p>s and</p>
<pre><code>DataCon</code></pre>
<p>s. And of course, the type-checker deals in</p>
<pre><code>Type</code></pre>
<p>s and</p>
<pre><code>TyVar</code></pre>
<p>s. The [wiki:Commentary/Compiler/EntityTypes data types for these entities] (</p>
<pre><code>Type</code></pre>
<p>,</p>
<pre><code>TyCon</code></pre>
<p>,</p>
<pre><code>Class</code></pre>
<p>,</p>
<pre><code>Id</code></pre>
<p>,</p>
<pre><code>TyVar</code></pre>
<p>) are pervasive throughout the rest of the compiler. (</p>
<pre><code>-ddump-tc</code></pre>
<p>)</p></li>
</ul>
<p><code>These three passes can all discover programmer errors, which are sorted and reported to the user.</code><br />
</p>
<ul>
<li>The <strong>Desugarer</strong> (<a href="GhcFile(compiler/deSugar/Desugar.hs)" class="uri" title="wikilink">GhcFile(compiler/deSugar/Desugar.hs)</a>) converts from the massive
<pre><code>HsSyn</code></pre>
<p>type to [wiki:Commentary/Compiler/CoreSynType GHC's intermediate language, CoreSyn]. This Core-language data type is unusually tiny: just eight constructors.) (</p>
<pre><code>-ddump-ds</code></pre>
<p>)<br />
<br />
</p></li>
</ul>
<p><code>  Generally speaking, the desugarer produces few user errors or warnings. But it does produce </code><em><code>some</code></em><code>.  In particular, (a) pattern-match overlap warnings are produced here; and (b) when desugaring Template Haskell code quotations, the desugarer may find that </code></p>
<pre><code>THSyntax</code></pre>
<p>is not expressive enough. In that case, we must produce an error (<a href="GhcFile(compiler/deSugar/DsMeta.hs)" class="uri" title="wikilink">GhcFile(compiler/deSugar/DsMeta.hs)</a>).<br />
<br />
 This late desugaring is somewhat unusual. It is much more common to desugar the program before typechecking, or renaming, because that presents the renamer and typechecker with a much smaller language to deal with. However, GHC's organisation means that</p>
<ul>
<li>error messages can display precisely the syntax that the user wrote; and</li>
<li>desugaring is not required to preserve type-inference properties.<br />
<br />
</li>
</ul>
<ul>
<li>The '''SimplCore''' pass (<a href="GhcFile(compiler/simplCore/SimplCore.hs)" class="uri" title="wikilink">GhcFile(compiler/simplCore/SimplCore.hs)</a>) is a bunch of Core-to-Core passes that optimise the program; see <a href="http://research.microsoft.com/%7Esimonpj/Papers/comp-by-trans-scp.ps.gz">A transformation-based optimiser for Haskell (SCP'98)</a> for a more-or-less accurate overview. See [wiki:Commentary/Compiler/Core2CorePipeline] for an overview of the Core-to-Core optimisation pipeline. The main passes are:<br />
<br />
* The <strong>Simplifier</strong>, which applies lots of small, local optimisations to the program. The simplifier is big and complicated, because it implements a <em>lot</em> of transformations; and tries to make them cascade nicely. The transformation-based optimiser paper gives lots of details, but two other papers are particularly relevant: <a href="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm">Secrets of the Glasgow Haskell Compiler inliner (JFP'02)</a> and <a href="http://research.microsoft.com/%7Esimonpj/Papers/rules.htm">Playing by the rules: rewriting as a practical optimisation technique in GHC (Haskell workshop 2001)</a>. (
<pre><code>-ddump-simpl</code></pre>
<p>)<br />
<br />
* The <strong>float-out</strong> and <strong>float-in</strong> transformations, which move let-bindings outwards and inwards respectively. See <a href="http://research.microsoft.com/%7Esimonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs (ICFP '96)</a>.<br />
<br />
* The <strong>strictness analyser</strong>. This actually comprises two passes: the <strong>analyser</strong> itself and the <strong>worker/wrapper</strong> transformation that uses the results of the analysis to transform the program. (Further described in [wiki:Commentary/Compiler/Demand Demand analysis].) The same analyser also does <a href="http://research.microsoft.com/%7Esimonpj/Papers/cpr/index.htm">Constructed Product Result analysis</a> and <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/usage-types/cardinality-extended.pdf">Cardinality analysis</a>. (</p>
<pre><code>-ddump-stranal</code></pre>
<p>)<br />
<br />
* The <strong>liberate-case</strong> transformation.<br />
<br />
* The <strong>constructor-specialialisation</strong> transformation.<br />
<br />
* The <strong>common sub-expression eliminiation</strong> (CSE) transformation. (</p>
<pre><code>-ddump-cse</code></pre>
<p>)</p></li>
</ul>
<ul>
<li>Then the <strong>CoreTidy pass</strong> gets the code into a form in which it can be imported into subsequent modules (when using
<pre><code>--make</code></pre>
<p>) and/or put into an interface file.</p></li>
</ul>
<p><code>It makes a difference whether or not you are using </code></p>
<pre><code>-O` at this stage.  With `-O` (or rather, with `-fomit-interface-pragmas` which is a consequence of `-O`), the tidied program (produced by `tidyProgram`) has unfoldings for Ids, and RULES.  Without `-O</code></pre>
<p>the unfoldings and RULES are omitted from the tidied program. And that, in turn, affects the interface file generated subsequently.</p>
<p><code>There are good notes at the top of the file </code><a href="GhcFile(compiler/main/TidyPgm.hs)" title="wikilink"><code>GhcFile(compiler/main/TidyPgm.hs)</code></a><code>; the main function is </code></p>
<pre><code>tidyProgram</code></pre>
<p>, documented as &quot;Plan B&quot; (&quot;Plan A&quot; is a simplified tidy pass that is run when we have only typechecked, but haven't run the desugarer or simplifier).</p>
<ul>
<li>At this point, the data flow forks. First, the tidied program is dumped into an interface file. This part happens in two stages:
<ul>
<li>It is '''converted to
<pre><code>IfaceSyn</code></pre>
<p>''' (defined in <a href="GhcFile(compiler/iface/IfaceSyn.hs)" class="uri" title="wikilink">GhcFile(compiler/iface/IfaceSyn.hs)</a> and <a href="GhcFile(compiler/iface/IfaceType.hs)" class="uri" title="wikilink">GhcFile(compiler/iface/IfaceType.hs)</a>).</p></li>
<li>The
<pre><code>IfaceSyn</code></pre>
<p>is <strong>serialised into a binary output file</strong> (<a href="GhcFile(compiler/iface/BinIface.hs)" class="uri" title="wikilink">GhcFile(compiler/iface/BinIface.hs)</a>).</p></li>
</ul></li>
</ul>
<p><code> The serialisation does (pretty much) nothing except serialise.  All the intelligence is in the </code></p>
<pre><code>Core`-to-`IfaceSyn</code></pre>
<p>conversion; or, rather, in the reverse of that step.</p>
<ul>
<li>The same, tidied Core program is now fed to the Back End. First there is a two-stage conversion from
<pre><code>CoreSyn</code></pre>
<p>to [wiki:Commentary/Compiler/StgSynType GHC's intermediate language, StgSyn].</p>
<ul>
<li>The first step is called '''CorePrep''', a Core-to-Core pass that puts the program into A-normal form (ANF). In ANF, the argument of every application is a variable or literal; more complicated arguments are let-bound. Actually
<pre><code>CorePrep</code></pre>
<p>does quite a bit more: there is a detailed list at the top of the file <a href="GhcFile(compiler/coreSyn/CorePrep.hs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CorePrep.hs)</a>.</p></li>
<li>The second step, '''CoreToStg''', moves to the
<pre><code>StgSyn</code></pre>
<p>data type (<a href="GhcFile(compiler/stgSyn/CoreToStg.hs)" class="uri" title="wikilink">GhcFile(compiler/stgSyn/CoreToStg.hs)</a>). The output of CorePrep is carefully arranged to exactly match what</p>
<pre><code>StgSyn</code></pre>
<p>allows (notably ANF), so there is very little work to do. However,</p>
<pre><code>StgSyn</code></pre>
<p>is decorated with lots of redundant information (free variables, let-no-escape indicators), which is generated on-the-fly by</p>
<pre><code>CoreToStg</code></pre>
<p>.</p></li>
</ul></li>
</ul>
<ul>
<li>Next, the <strong>[wiki:Commentary/Compiler/CodeGen Code Generator]</strong> converts the STG program to a
<pre><code>C--</code></pre>
<p>program. The code generator is a Big Mother, and lives in directory <a href="GhcFile(compiler/codeGen)" class="uri" title="wikilink">GhcFile(compiler/codeGen)</a></p></li>
</ul>
<ul>
<li>Now the path forks again:
<ul>
<li>If we are generating GHC's stylised C code, we can just pretty-print the
<pre><code>C--</code></pre>
<p>code as stylised C (<a href="GhcFile(compiler/cmm/PprC.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/PprC.hs)</a>)</p></li>
<li>If we are generating native code, we invoke the native code generator. This is another Big Mother (<a href="GhcFile(compiler/nativeGen)" class="uri" title="wikilink">GhcFile(compiler/nativeGen)</a>).</li>
<li>If we are generating LLVM code, we invoke the LLVM code generator. This is a reasonably simple code generator (<a href="GhcFile(compiler/llvmGen)" class="uri" title="wikilink">GhcFile(compiler/llvmGen)</a>).</li>
</ul></li>
</ul>
<h1 id="the-diagram">The Diagram</h1>
<p>This diagram is also located [wiki:Commentary/Compiler/HscPipe here], so that you can open it in a separate window.</p>
<p><a href="Image(Commentary/Compiler/HscPipe:HscPipe2.png)" class="uri" title="wikilink">Image(Commentary/Compiler/HscPipe:HscPipe2.png)</a></p>
<h1 id="picture-of-the-main-compiler-pipeline">Picture of the main compiler pipeline</h1>
<p>See [wiki:Commentary/Compiler compiling one module] for the commentary on this diagram.</p>
<p><a href="Image(HscPipe2.png)" class="uri" title="wikilink">Image(HscPipe2.png)</a></p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<p>Video: <a href="http://www.youtube.com/watch?v=lw7kbUvAmK4&amp;list=PLBkRCigjPwyeCSD_DFxpd246YIF7_RDDI">Abstract Syntax Types</a> (1hr03')</p>
<p>= The</p>
<pre><code>HsSyn</code></pre>
<p>types =</p>
<p>The program is initially parsed into &quot;'''</p>
<pre><code>HsSyn</code></pre>
<p>'''&quot;, a collection of data types that describe the full abstract syntax of Haskell.</p>
<pre><code>HsSyn</code></pre>
<p>is a pretty big collection of types: there are 52 data types at last count. Many are pretty trivial, but a few have a lot of constructors (</p>
<pre><code>HsExpr</code></pre>
<p>has 40).</p>
<pre><code>HsSyn</code></pre>
<p>represents Haskell in its full glory, complete with all syntactic sugar.</p>
<p>The</p>
<pre><code>HsSyn</code></pre>
<p>modules live in the <a href="GhcFile(compiler/hsSyn)" class="uri" title="wikilink">GhcFile(compiler/hsSyn)</a> directory. Each module declares a related group of declarations, <em>and</em> gives their pretty-printer.</p>
<ul>
<li><a href="GhcFile(compiler/hsSyn/HsSyn.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsSyn.hs)</a>: the root module. It exports everything you need, and it's generally what you should import.</li>
<li><a href="GhcFile(compiler/hsSyn/HsBinds.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsBinds.hs)</a>: bindings.</li>
<li><a href="GhcFile(compiler/hsSyn/HsImpExp.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsImpExp.hs)</a>: imports and exports.</li>
<li><a href="GhcFile(compiler/hsSyn/HsDecls.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsDecls.hs)</a>: top-level declarations.</li>
<li><a href="GhcFile(compiler/hsSyn/HsExpr.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsExpr.hs)</a>: expressions, match expressions, comprehensions.</li>
<li><a href="GhcFile(compiler/hsSyn/HsLit.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsLit.hs)</a>: literals.</li>
<li><a href="GhcFile(compiler/hsSyn/HsPat.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsPat.hs)</a>: patterns.</li>
<li><a href="GhcFile(compiler/hsSyn/HsTypes.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsTypes.hs)</a>: types.</li>
<li><a href="GhcFile(compiler/hsSyn/HsUtils.hs)" class="uri" title="wikilink">GhcFile(compiler/hsSyn/HsUtils.hs)</a>: utility functions (no data types).</li>
</ul>
<p>There is significant mutual recursion between modules, and hence a couple of</p>
<pre><code>hs-boot</code></pre>
<p>files. Look at [wiki:ModuleDependencies] to see the dependencies.</p>
<p>== Decorating</p>
<pre><code>HsSyn</code></pre>
<p>with type information ==</p>
<p>The type checker adds type information to the syntax tree, otherwise leaving it as undisturbed as possible. This is done in two ways:</p>
<ul>
<li>Some constructors have a field of type
<pre><code>PostTcType</code></pre>
<p>, which is just a synonym for</p>
<pre><code>Type</code></pre>
<p>. For example:</p></li>
</ul>
<pre><code>data HsExpr id = ... | ExplicitList PostTcType [LHsExpr id] | ...

type PostTcType = Type

placeHolderType :: PostTcType
placeHolderType = panic &quot;Evaluated the place holder for a PostTcType&quot;</code></pre>
<p><code> An </code></p>
<pre><code>ExplicitList</code></pre>
<p>represents the explicit list construct in Haskell (e.g. &quot;</p>
<pre><code>[2, 4, 1]</code></pre>
<p>&quot;). The parser fills the</p>
<pre><code>PostTcType</code></pre>
<p>field with an error thunk</p>
<pre><code>HsTypes.placeHolderType</code></pre>
<p>; and the renamer does not touch it. The typechecker figures out the type, and fills in the value. So until the type checker, we cannot examine or print the</p>
<pre><code>PostTcType</code></pre>
<p>fields.</p>
<p><code> The error thunks mean that we can't conveniently pretty-print the </code></p>
<pre><code>PostTcType` fields, because the pretty-printer would poke the error thunks when run on pre-typchecked code.  We could have defined `PostTcType` to be `Maybe Type`, but that would have meant unwrapping lots of `Just` constructors, which is messy.  It would be nicer to parameterise `HsSyn` over the `PostTcType</code></pre>
<p>fields. Thus:</p>
<pre><code>  type RnHsBinds = HsBinds Name ()   -- After renaming
  type TcHsBinds = HsBinds Id Type   -- After type checking</code></pre>
<p><code> This would be a Good Thing to do.</code></p>
<ul>
<li>In a few cases, the typechecker moves from one constructor to another. Example:</li>
</ul>
<pre><code>data HsPat id
  = ...
  | ConPatIn    (Located id)
        (HsConDetails id (LPat id))

  | ConPatOut   (Located DataCon)
        [TyVar]         -- Existentially bound type variables
        [id]            -- Ditto dictionaries
        (DictBinds id)      -- Bindings involving those dictionaries
        (HsConDetails id (LPat id))
        Type            -- The type of the pattern
  ...</code></pre>
<p><code> The parser and renamer use </code></p>
<pre><code>ConPatIn</code></pre>
<p>; the typechecker generates a</p>
<pre><code>ConPatOut</code></pre>
<p>. This naming convention is used consistently.</p>
<ul>
<li>There are a few constructors added by type checker (rather than replacing an input constructor), particularly:
<ul>
<li><pre><code>HsWrap</code></pre>
<p>, in the</p>
<pre><code>HsExpr</code></pre>
<p>type.</p></li>
<li><pre><code>AbsBinds</code></pre>
<p>, in the</p>
<pre><code>HsBinds</code></pre>
<p>type.</p></li>
</ul></li>
</ul>
<p><code> These are invariably to do with type abstraction and application, since Haskell source is implicitly generalized and instantiated, whereas GHC's intermediate form is explicitly generalized and instantiated.</code></p>
<h2 id="source-locations">Source Locations</h2>
<pre><code>HsSyn` makes heavy use of the `Located</code></pre>
<p>type (<a href="GhcFile(compiler/basicTypes/SrcLoc.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/SrcLoc.hs)</a>):</p>
<pre><code>data Located e = L SrcSpan e</code></pre>
<p>A</p>
<pre><code>Located t` is just a pair of a `SrcSpan` (which describes the source location of `t`) and a syntax tree `t`.  The module `SrcLoc</code></pre>
<p>defines two other types:</p>
<ul>
<li><pre><code>SrcLoc</code></pre>
<p>specifies a particular source location: (filename, line number, character position)</p></li>
<li><pre><code>SrcSpan</code></pre>
<p>specifes a range of source locations: (filename, start line number and character position, end line number and character position)</p></li>
</ul>
<p>More details in <a href="GhcFile(compiler/basicTypes/SrcLoc.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/SrcLoc.hs)</a>.</p>
<p>Naming convention within the code: &quot;</p>
<pre><code>LHs</code></pre>
<p>&quot; means located Haskell, e.g.</p>
<pre><code>type LHsBinds n = Located (HsBinds n)</code></pre>
<h1 id="interface-files">Interface files</h1>
<p>An <strong>interface file</strong> supports separate compilation by recording the information gained by compiling</p>
<pre><code>M.hs</code></pre>
<p>in its interface file</p>
<pre><code>M.hi</code></pre>
<p>. Morally speaking, the interface file</p>
<pre><code>M.hi</code></pre>
<p>is part of the object file</p>
<pre><code>M.o</code></pre>
<p>; it's like a super symbol-table for</p>
<pre><code>M.o</code></pre>
<p>.</p>
<p>Interface files are kept in binary, GHC-specific format. The format of these files changes with each GHC release, but not with patch-level releases. The contents of the interface file is, however, completely independent of the back end you are using (</p>
<pre><code>-fviaC`, `-fasm`, `-fcmm</code></pre>
<p>etc).</p>
<p>Although interface files are kept in binary format, you can print them in human-readable form using the command:</p>
<pre><code>  ghc --show-iface M.hi</code></pre>
<p>This textual format is not particularly designed for machine parsing. Doing so might be possible, but if you want to read GHC interface files you are almost certainly better off using the [wiki:Commentary/Compiler/API GHC API] to do so. If you are wondering how some particular language feature is represented in the interface file, this command is really useful! Cross-reference its output with the</p>
<pre><code>Outputable</code></pre>
<p>instance defined in <a href="GhcFile(compiler/iface/LoadIface.hs)" class="uri" title="wikilink">GhcFile(compiler/iface/LoadIface.hs)</a></p>
<p>Here are some of the things stored in an interface file</p>
<pre><code>M.hi</code></pre>
<ul>
<li>The version of GHC used to compile the module, as well as the compilation way and other knick-knacks</li>
<li>A list of what
<pre><code>M</code></pre>
<p>exports.</p></li>
<li>The types of exported functions, definition of exported types, and so on.</li>
<li>Version information, used to drive the [wiki:Commentary/Compiler/RecompilationAvoidance recompilation checker].</li>
<li>The strictness, arity, and unfolding of exported functions. This is crucial for cross-module optimisation; but it is only included when you compile with
<pre><code>-O</code></pre>
<p>.</p></li>
</ul>
<p>The contents of an interface file is the result of serialising the '''</p>
<pre><code>IfaceSyn</code></pre>
<p>''' family of data types. The data types are in <a href="GhcFile(compiler/iface/IfaceSyn.lhs)" class="uri" title="wikilink">GhcFile(compiler/iface/IfaceSyn.lhs)</a> and <a href="GhcFile(compiler/iface/IfaceType.lhs)" class="uri" title="wikilink">GhcFile(compiler/iface/IfaceType.lhs)</a>; the binary serialisation code is in <a href="GhcFile(compiler/iface/BinIface.hs)" class="uri" title="wikilink">GhcFile(compiler/iface/BinIface.hs)</a>. The definition of a module interface is the '''</p>
<pre><code>ModIface</code></pre>
<p>''' data type in <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a>.</p>
<p>Details of some of the types involved in GHC's representation of Modules and Interface files can be found [wiki:Commentary/Compiler/ModuleTypes here].</p>
<h2 id="when-is-an-interface-file-loaded">When is an interface file loaded?</h2>
<p>The act of loading an interface file can cause various parts of the compiler to behave differently; for instance, a type class instance will only be used if the interface file which defines it was loaded. Additionally, GHC tries to avoid loading interface files if it can avoid it, since every loaded interface file requires going to the file system and parsing the result.</p>
<p>The big situations when we load an interface file:</p>
<ul>
<li>When you import it (either explicitly using an
<pre><code>import`, or implicitly, e.g. through `-fimplicit-import-qualified` in GHCi; `loadSrcInterface</code></pre>
<p>)</p></li>
<li>When we need to get the type for an identifier (
<pre><code>loadInterface` in `importDecl</code></pre>
<p>)</p></li>
<li>When it is listed as an orphan of an imported module (
<pre><code>loadModuleInterfaces &quot;Loading orphan modules&quot;</code></pre>
<p>)</p></li>
</ul>
<p>We also load interface files in some more obscure situations:</p>
<ul>
<li>When it is used as the backing implementation of a signature (
<pre><code>loadSysInterface` in `tcRnSignature</code></pre>
<p>)</p></li>
<li>When we look up its family instances (
<pre><code>loadSysInterface` in `getFamInsts</code></pre>
<p>)</p></li>
<li>When its information or safety (
<pre><code>getModuleInterface` in `hscGetSafe</code></pre>
<p>)</p></li>
<li>When we an identifier is explicitly used (including a use from Template Haskell), we load the interface to check if the identifier is deprecated (
<pre><code>loadInterfaceForName` in `warnIfDeprecated`/`loadInterfaceforName` in `rn_bracket</code></pre>
<p>)</p></li>
<li>Recompilation checking (
<pre><code>needInterface` in `checkModUsage</code></pre>
<p>)</p></li>
<li>When we need the fixity for an identifier (
<pre><code>loadInterfaceForName` in `lookupFixityRn</code></pre>
<p>)</p></li>
<li>When we reify a module for Template Haskell (
<pre><code>loadInterfaceForModule` in `reifyModule</code></pre>
<p>)</p></li>
<li>When we use a wired-in type constructor, since otherwise the interface file would not be loaded because the compiler already has the type for the identifier. (
<pre><code>Loading instances for wired-in things</code></pre>
<p>)</p></li>
<li>When
<pre><code>-XParallelArrays` or `-fvectorise` are specified for DPH (`loadModule` in `initDs</code></pre>
<p>)</p></li>
<li>When we load a plugin (
<pre><code>DynamicLoading</code></pre>
<p>)</p></li>
<li>To check consistency against the
<pre><code>hi-boot</code></pre>
<p>of a module</p></li>
<li>To check the old interface file for recompilation avoidance</li>
</ul>
<h1 id="immix-garbage-collector">Immix Garbage Collector</h1>
<p>In a <a href="http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760695">Google Summer of Code project</a>, <a href="http://wiki.debian.org/MarcoSilva">marcot</a> started an implementation of the Immix Garbage Collector in GHC. It's not in a state where it can be included in GHC yet, but it's functional, don't have known bugs and gets better results than the default GC in the <a href="http://www.dcs.gla.ac.uk/fp/software/ghc/nofib.html">nofib</a> suite. On the other hand, it gets worse results than the default GC for the nofib/gc suite. The implementation was reported on these blog posts: <a href="http://marcotmarcot.wordpress.com/2010/05/17/google-summer-of-code-weekly-report-1/">1</a> <a href="http://marcotmarcot.wordpress.com/2010/05/31/summer-of-code-weekly-report-3/">3</a> <a href="http://marcotmarcot.wordpress.com/2010/06/04/summer-of-code-weekly-report-4/">4</a> <a href="http://marcotmarcot.wordpress.com/2010/06/15/summer-of-code-weekly-report-5/">5</a> <a href="http://marcotmarcot.wordpress.com/2010/06/18/immix-on-ghc-summer-of-code-weekly-report-6/">6</a> <a href="http://marcotmarcot.wordpress.com/2010/06/29/immix-on-ghc-summer-of-code-weekly-report-7/">7</a> <a href="http://marcotmarcot.wordpress.com/2010/07/05/immix-on-ghc-summer-of-code-weekly-report-8/">8</a> <a href="http://marcotmarcot.wordpress.com/2010/07/07/immix-on-ghc-summer-of-code-weekly-report-9/">9</a> <a href="http://marcotmarcot.wordpress.com/2010/07/21/immix-on-ghc-summer-of-code-weekly-report-10/">10</a> <a href="http://marcotmarcot.wordpress.com/2010/08/10/immix-on-ghc-summer-of-code-report-11/">11</a> <a href="http://marcotmarcot.wordpress.com/2010/08/13/immix-on-ghc-summer-of-code-report-12-debconf-debian-day-bh/">12</a></p>
<h1 id="the-patches">The patches</h1>
<p>There are <a href="http://people.debian.org/~marcot/immix/">some patches available</a>.</p>
<h2 id="the-main-patch">The main patch</h2>
<ul>
<li><a href="http://people.debian.org/~marcot/immix/immix.patch">Generated with darcs diff -u</a></li>
<li><a href="http://people.debian.org/~marcot/immix/immix.dpatch">Darcs bundle</a></li>
</ul>
<p>This patch includes the basic implementation of Immix. It's tested, and has no known bugs. In <a href="http://people.debian.org/~marcot/immix/log.tar.gz">the measurements</a>, it has shown these results:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><p><strong>Runtime</strong></p></td>
<td align="left"><p><strong>Memory used</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>nofib</strong></p></td>
<td align="left"><p>-2.9%</p></td>
<td align="left"><p>-1.7%</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>nofib/gc</strong></p></td>
<td align="left"><p>+4.3%</p></td>
<td align="left"><p>+1.2%</p></td>
</tr>
</tbody>
</table>
<p>Currently, it overwrites the [wiki:Commentary/Rts/Storage/GC/Sweeping mark/sweep algorithm]. It uses the same mark bits as [wiki:Commentary/Rts/Storage/GC/Marking mark/compact and mark/sweep], but consider these bits in groups of 32 or 64, depending on the architecture used, which are called lines. It creates a list of free lines for each <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Aging">generation</a>, and allocates on them when possible.</p>
<p>As only the first part of each object in memory is marked in the [wiki:Commentary/Rts/Storage/GC/Marking bitmap], it skips the first free line for each group of subsequent lines, because it's possible that an object that starts in the previous line is using part of it. Also, it doesn't deal with [wiki:Commentary/Rts/Storage/BlockAlloc blocks] that objects bigger than the size of a line, called medium sized objects, marked with</p>
<pre><code>BF_MEDIUM</code></pre>
<p>.</p>
<p>The mark stack is used to ensure that the objects allocated on lines get scavenged.</p>
<h2 id="line-before-inscreasing-block-size">Line before inscreasing block size</h2>
<ul>
<li><a href="http://people.debian.org/~marcot/immix/order.patch">Generated with darcs diff -u</a></li>
<li><a href="http://people.debian.org/~marcot/immix/order.dpatch">Darcs bundle</a></li>
</ul>
<p>Before the implementation of Immix, the code in todo_block_full did the following:</p>
<ol>
<li>Try to increase the block size.</li>
<li>If it could not be increased, get a new block.</li>
</ol>
<p>With Immix, it turned to:</p>
<ol>
<li><ol>
<li>If we were allocating in a block, try to increase the block size.</li>
<li>If it could not be increased, search for a line.</li>
<li>If there're no free lines, get a new block.</li>
</ol></li>
</ol>
<p>Another possibility for it is:</p>
<ol>
<li><ol>
<li>Search for a line.</li>
<li>If there are no free lines <strong>and</strong> we were allocating in a block, try to increase the block.</li>
<li>If it could not be increased, get a new block.</li>
</ol></li>
</ol>
<p>Basically, this swaps 1 and 2, making it prefer allocating on lines than increasing the block size. In the measurements done so far, it has not shown significative improvements over the way the code is now, so I'll keep it here to benchmark again when another thing changes, like:</p>
<h2 id="allocate-in-lines-in-minor-gcs">Allocate in lines in minor GCs</h2>
<ul>
<li><a href="http://people.debian.org/~marcot/immix/minor.patch">Generated with darcs diff -u</a></li>
<li><a href="http://people.debian.org/~marcot/immix/minor.dpatch">Darcs bundle</a></li>
</ul>
<p>This small patch makes it possible to allocate on lines during minor GCs, removing the check about being in a major GC for the search for lines and for the creating of the mark stack. Maybe it shouldn't be so small, because it's not working. The code is being debugged, and possibly there will be a fix soon.</p>
<h2 id="remove-partial-list">Remove partial list</h2>
<p>With the allocation on lines, it's possible not to allocate on partially full blocks. By making all blocks full (with possibly free lines), there'll be no need to use the list of partial blocks. This is not done yet.</p>
<h1 id="to-do">To do</h1>
<ul>
<li>Make it faster and use less memory than the default GC for all benchmarks</li>
<li>Correct &quot;Allocate in lines in minor GCs&quot;</li>
<li>Implement and bechmark &quot;Remove partial lists&quot;</li>
</ul>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="ghc-source-tree-roadmap-includes">GHC Source Tree Roadmap: includes/</h1>
<p>This directory contains C header files that are included in a GHC distribution. The headers fall into several categories.</p>
<h2 id="external-apis">External APIs</h2>
<p>These are header files that define an external API to the RTS that can be used by client code. These interfaces are intended to be relatively stable:</p>
<dl>
<dt>[source:includes/HsFFI.h HsFFI.h]</dt>
<dd>The external FFI api, as required by the FFI spec
</dd>
</dl>
<dl>
<dt>[source:includes/RtsAPI.h RtsAPI.h]</dt>
<dd>The API for calling into the RTS. Used by the implementation
</dd>
</dl>
<p><code> of </code></p>
<pre><code>foreign export</code></pre>
<p>calls, but may also be used by external</p>
<p><code> clients.</code></p>
<dl>
<dt>[source:includes/Rts.h Rts.h]</dt>
<dd>This header file defines everything that is visible
</dd>
</dl>
<p><code> externally to the RTS.  It includes </code></p>
<pre><code>Stg.h</code></pre>
<p>and everything</p>
<p><code> in the </code></p>
<pre><code>rts</code></pre>
<p>subdirectory.</p>
<h2 id="derived-constants">Derived Constants</h2>
<p>The canonical definition of certain structures are in C header files. For example, the layout of closures and info tables are defined in the headers [source:includes/rts/storage/Closures.h Closures.h] and [source:includes/rts/storage/InfoTables.h InfoTables.h] respectivesly. How do we get the information about the layout of these structures to the parts of the system that are not written in C, such as the compiler itself, or the C-- code in the RTS?</p>
<p>Our solution is the Haskell program in [source:utils/deriveConstants/DeriveConstants.hs]. It determines the sizes and fields offsets from the C header files by invoking the C compiler for the target platform, and then looking at the resulting object file (we can't <em>run</em> the code generated by the target C compiler, because this is the host platform).</p>
<p>The DeriveConstants program generates a few header files, notably</p>
<pre><code>includes/dist-derivedconstants/header/DerivedConstants.h`, which contains C `#define`s for each of the derived constants; this file is used by C-- code in the RTS.  It also generates a few files of Haskell code which are included into GHC itself, in the `DynFlags</code></pre>
<p>module.</p>
<h2 id="used-when-compiling-via-c">Used when compiling via C</h2>
<p>These header files are</p>
<pre><code>#included` into the `.hc</code></pre>
<p>file generated by GHC when it compiles Haskell code to C. They are also</p>
<pre><code>#included` by `Rts.h</code></pre>
<p>, so the definitions from these files are shared by the RTS code.</p>
<p>These days the amount of stuff included this way is kept to a minimum. In particular, there are no function prototypes: all calls to C functions from</p>
<pre><code>.hc</code></pre>
<p>files are given types at the call site.</p>
<dl>
<dt>[source:includes/Stg.h Stg.h]</dt>
<dd>The top of the hierarchy is
<pre><code>Stg.h</code></pre>
<p>, which includes everything</p>
</dd>
</dl>
<p><code> required by </code></p>
<pre><code>.hc` code.  Most files `#included` by `Stg.h</code></pre>
<p>are in the</p>
<pre><code>stg</code></pre>
<p>subdirectory.</p>
<dl>
<dt>[source:includes/ghcconfig.h ghcconfig.h]</dt>
<dd>Configuration info derived by the
<pre><code>configure</code></pre>
<p>script.</p>
</dd>
<dt>[source:includes/MachDeps.h MachDeps.h]</dt>
<dd>Sizes of various basic types (should be in the
<pre><code>stg</code></pre>
<p>subdirectory,</p>
</dd>
</dl>
<p><code> but left here for backwards-compatibility reasons).</code></p>
<dl>
<dt>[source:includes/stg/DLL.h stg/DLL.h]</dt>
<dd>Stuff related to Windows DLLs.
</dd>
<dt>[source:includes/stg/MachRegs.h stg/MachRegs.h]</dt>
<dd>Global register assignments for this processor.
</dd>
<dt>[source:includes/stg/MiscClosures.h stg/MiscClosures.h]</dt>
<dd>Declarations for closures &amp; info tables built-in to the RTS
</dd>
<dt>[source:includes/stg/Regs.h stg/Regs.h]</dt>
<dd>&quot;registers&quot; in the virtual machine.
</dd>
<dt>[source:includes/stg/SMP.h stg/SMP.h]</dt>
<dd>Atomic memory operations for SMP support
</dd>
<dt>[source:includes/stg/Ticky.h stg/Ticky.h]</dt>
<dd>Declarations for ticky-ticky counters
</dd>
<dt>[source:includes/stg/Types.h stg/Types.h]</dt>
<dd>Basic types specific to the virtual machine (eg.
<pre><code>StgWord</code></pre>
<p>).</p>
</dd>
</dl>
<h2 id="the-rts-external-apis">The RTS external APIs</h2>
<p>The header [source:includes/Rts.h Rts.h] includes all the headers below the</p>
<pre><code>rts</code></pre>
<p>subdirectory, which together define the RTS external API. Virtually all RTS code</p>
<pre><code>#includes</code></pre>
<pre><code>Rts.h</code></pre>
<p>.</p>
<p>The rts header files are divided into a few directories:</p>
<ul>
<li>[source:includes/rts includes/rts]: Most of</li>
</ul>
<p><code>  the external RTS APIs, in separate header files per-subsystem</code></p>
<ul>
<li>[source:includes/rts/storage includes/rts/storage]: Definitions of the layout of heap and stack</li>
</ul>
<p><code>  objects, info tables, structures that define memory areas managed</code><br />
<code>  by the GC, and memory management APIs.</code></p>
<ul>
<li>[source:includes/rts/prof includes/rts/prof]:</li>
</ul>
<p><code>  Interfaces and definitions for profiling.</code></p>
<p>== Included into C-- (</p>
<pre><code>.cmm</code></pre>
<p>) code ==</p>
<dl>
<dt>[source:includes/Cmm.h Cmm.h]</dt>
<dd>included into
<pre><code>.cmm</code></pre>
<p>source only; provides useful macros for writing</p>
</dd>
</dl>
<p><code> low-level C-- code for GHC.</code></p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="installing-using-the-llvm-back-end">Installing &amp; Using the LLVM Back-end</h1>
<h2 id="installing">Installing</h2>
<p>The LLVM backend is now included in GHC HEAD. Just grab the git HEAD version of GHC and build it. The backend now also supports all modes that GHC can be built in so you shouldn't need to change your build.mk file either.</p>
<p>For instructions on building GHC go <a href="http://hackage.haskell.org/trac/ghc/wiki/Building">here</a></p>
<h2 id="llvm-support">LLVM Support</h2>
<p>The LLVM backend only supports LLVM version <strong>2.7</strong> or later. Problems with LLVM &gt;= 2.9 and GHC 7.0.3 currently exist (see bug #5103). GHC 7.2 and later works fine with LLVM &gt;= 2.9.</p>
<p>Simply install GHC and make sure the various llvm tools (opt, llc) are available on your path.</p>
<h2 id="using">Using</h2>
<p>Once built you can check that you have the LLVM backend GHC will support these extra options:</p>
<ul>
<li><em>-fllvm</em> - Compile code using the llvm backend</li>
<li><em>-pgmlo</em> - The program to use as the llvm optimiser</li>
<li><em>-pgmlc</em> - The program to use as the llvm compiler</li>
<li><em>-optlo</em> - Extra options to pass to the llvm optimiser</li>
<li><em>-optlc</em> - Extra options to pass to the llvm compiler</li>
<li><em>-ddump-llvm</em> - Dumps the llvm IR while compiling</li>
<li><em>-keep-llvm-files</em> - Keep a copy of the llvm intermediate file around</li>
</ul>
<h2 id="supported-platforms-correctness">Supported Platforms &amp; Correctness</h2>
<ul>
<li>Linux x86-32/x86-64: Currently well supported. The back-end can pass the test suite and build a working version of GHC (bootstrap test).</li>
<li>Windows x86-32: Currently well supported. The back-end can pass the test suite and build a working version of GHC (bootstrap test).</li>
<li>Mac OS X 10.5/10.6 (x86-32/x86-64): Currently well supported. The back-end can pass the test suite and bootstrap GHC. OS X has caused a lot more problems then Linux or Windows and does a few things slightly differently then them. It is quite stable these days though.</li>
<li>ARM: Work is currently progressing to fully support GHC using the LLVM backend on ARM. You can see a blog with info about this <a href="http://ghcarm.wordpress.com/">here</a>.</li>
<li>Other platforms haven't been tested at all.</li>
</ul>
<h2 id="shared-libraries">Shared Libraries</h2>
<p>Shared libraries are supported on Linux x64 and Mac OSX x64. Other platforms aren't supported.</p>
<h2 id="performance">Performance</h2>
<p>(All done on linux/x86-32)</p>
<p>A quick summary of the results are that for the 'nofib' benchmark suite, the LLVM code generator was 3.8% slower than the NCG (the C code generator was 6.9% slower than the NCG). The DPH project includes a benchmark suite which I (David Terei) also ran and for this type of code using the LLVM back-end shortened the runtime by an average of 25% compared to the NCG. Also, while not included in my thesis paper as I ran out of time, I did do some benchmarking with the 'nobench' benchmark suite. It gave performance ratios for the back-ends of around:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>NCG</p></td>
<td align="left"><p>1.11</p></td>
</tr>
<tr class="even">
<td align="left"><p>C</p></td>
<td align="left"><p>1.05</p></td>
</tr>
<tr class="odd">
<td align="left"><p>LLVM</p></td>
<td align="left"><p>1.14</p></td>
</tr>
</tbody>
</table>
<p>A nice demonstration of the improvements the LLVM back-end can bring to some code though can be see at <a href="http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/" class="uri">http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/</a></p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="ghc-commentary-librariesinteger">GHC Commentary: Libraries/Integer</h1>
<p>GHC is set up to allow different implementations of the</p>
<pre><code>Integer</code></pre>
<p>type to be chosen at build time.</p>
<h2 id="selecting-an-integer-implementation">Selecting an Integer implementation</h2>
<p>You can select which implementation of Integer is used by defining</p>
<pre><code>INTEGER_LIBRARY` in `mk/build.mk`. This tells the build system to build the library in `libraries/$(INTEGER_LIBRARY)`, and the `cIntegerLibrary` and `cIntegerLibraryType` values in `Config.hs</code></pre>
<p>are defined accordingly.</p>
<p>The default value is</p>
<pre><code>integer-gmp</code></pre>
<p>, which uses the <a href="http://gmplib.org/">GNU Multiple Precision Arithmetic Library (GMP)</a> to define the Integer type and its operations.</p>
<p>The other implementation currently available is</p>
<pre><code>integer-simple</code></pre>
<p>, which uses a simple (but slow, for larger Integers) pure Haskell implementation.</p>
<h2 id="the-integer-interface">The Integer interface</h2>
<p>All Integer implementations should export the same set of types and functions from</p>
<pre><code>GHC.Integer` (within whatever `integer` package you are using). These exports are used by the `base` package However, all of these types and functions must actually be defined in `GHC.Integer.Type</code></pre>
<p>, so that GHC knows where to find them. Specifically, the interface is this:</p>
<pre><code>#!hs
data Integer 

mkInteger :: Bool   -- True &lt;=&gt; non-negative
          -&gt; [Int]  -- Absolute value in 31 bit chunks, least significant first
                    -- ideally these would be Words rather than Ints, but
                    -- we don&#39;t have Word available at the moment. (why?)
          -&gt; Integer
    
smallInteger  :: Int# -&gt; Integer
integerToInt  :: Integer -&gt; Int#
 
wordToInteger :: Word# -&gt; Integer
integerToWord :: Integer -&gt; Word#

-- And similarly for Int64#, Word64# on 64-bit

floatFromInteger  :: Integer -&gt; Float#
decodeFloatInteger :: Float# -&gt; (# Integer, Int# #)
encodeFloatInteger :: Integer -&gt; Int# -&gt; Float#

-- And similarly Double

plusInteger :: Integer -&gt; Integer -&gt; Integer
-- And similarly: minusInteger, timesInteger, negateInteger,
-- eqInteger, neqInteger, absInteger, signumInteger,
--  leInteger, gtInteger, ltInteger, geInteger, compareInteger,
--  divModInteger, quotRemInteger, quotInteger, remInteger,
--  andInteger, orInteger, xorInteger, complementInteger,
--  shiftLInteger, shiftRInteger,
--  hashInteger,</code></pre>
<h2 id="how-integer-is-handled-inside-ghc">How Integer is handled inside GHC</h2>
<ul>
<li><strong>Front end</strong>. Integers are represented using the
<pre><code>HsInteger` constructor of `HsLit</code></pre>
<p>for the early phases of compilation (e.g. type checking)</p></li>
</ul>
<ul>
<li><strong>Core</strong>. In
<pre><code>Core` representation, an integer literal is represented by the `LitInteger` constructor of the `Literal</code></pre>
<p>type.</p></li>
</ul>
<pre><code>#!hs
data Literal = ... | LitInteger Integer Type</code></pre>
<p><code>While </code></p>
<pre><code>Integer`s aren&#39;t &quot;machine literals&quot; like the other `Core` `Literal` constructors, it is more convenient when writing constant folding RULES to pretend that they are literals rather than having to understand their concrete representation. (Especially as the concrete representation varies from package to package.) We also carry around a `Type`, representing the `Integer` type, in the constructor, as we need access to it in a few functions (e.g. `literalType</code></pre>
<p>).</p>
<ul>
<li><strong>Constant folding</strong>. There are many constant-folding optimisations for
<pre><code>Integer` expressed as built-in rules in [[GhcFile(compiler/prelude/PrelRules.lhs)]]; look at `builtinIntegerRules`.  All of the types and functions in the `Integer` interface have built-in names, e.g. `plusIntegerName`, defined in [[GhcFile(compiler/prelude/PrelNames.lhs)]] and included in `basicKnownKeyNames`. This allows us to match on all of the functions in `builtinIntegerRules` in [[GhcFile(compiler/prelude/PrelRules.lhs)]], so we can constant-fold Integer expressions. An important thing about constant folding of Integer divisions is that they depend on inlining. Here&#39;s a fragment of `Integral Integer` instance definition from `libraries/base/GHC/Real.lhs</code></pre>
<dl>

<dd>
</dd>
</dl></li>
</ul>
<pre><code>#!hs
instance Integral Integer where
    toInteger n      = n

    {-# INLINE quot #-}
    _ &lt;pre&gt;quot</code></pre>
<p>0 = divZeroError</p>
<p><code>   n </code></p>
<pre><code>quot` d = n `quotInteger</code></pre>
<p>d</p>
</pre>
<p><code>Constant folding rules for divisions are defined for </code></p>
<pre><code>quotInteger` and other division functions from `integer-gmp` library. If `quot` was not inlined constant folding rules would not fire. The rules would also not fire if call to `quotInteger</code></pre>
<p>was inlined, but this does not happen because it is marked with NOINLINE pragma - see below.</p>
<ul>
<li><strong>Converting between Int and Integer</strong>. It's quite commonly the case that, after some inlining, we get something like
<pre><code>integerToInt (intToInteger i)`, which converts an `Int` to an `Integer` and back.  This &#39;&#39;must&#39;&#39; optimise away (see #5767).  We do this by requiring that the `integer</code></pre>
<p>package exposes</p></li>
</ul>
<pre><code>#!hs
smallInteger :: Int# -&gt; Integer</code></pre>
<p><code>Now we can define </code></p>
<pre><code>intToInteger` (or, more precisely, the `toInteger` method of the `Integral Int` instance in `GHC.Real</code></pre>
<p>) thus</p>
<pre><code>#!hs
toInteger (I# i) = smallInteger i</code></pre>
<p><code>And we have a RULE for </code></p>
<pre><code>integerToInt (smallInteger i)</code></pre>
<p>.</p>
<ul>
<li><strong>Representing integers</strong>. We stick to the
<pre><code>LitInteger` representation (which hides the concrete representation) as late as possible in the compiler.   In particular, it&#39;s important that the `LitInteger</code></pre>
<p>representation is used in unfoldings in interface files, so that constant folding can happen on expressions that get inlined.</p></li>
</ul>
<p><code>We finally convert </code></p>
<pre><code>LitInteger` to a proper core representation of Integer in [[GhcFile(compiler/coreSyn/CorePrep.lhs)]], which looks up the Id for `mkInteger` and uses it to build an expression like `mkInteger True [123, 456]` (where the `Bool` represents the sign, and the list of `Int</code></pre>
<p>s are 31 bit chunks of the absolute value from lowest to highest).</p>
<p><code>However, there is a special case for </code></p>
<pre><code>Integer`s that are within the range of `Int` when the `integer-gmp` implementation is being used; in that case, we use the `S#` constructor (via `integerGmpSDataCon</code></pre>
<p>in <a href="GhcFile(compiler/prelude/TysWiredIn.lhs)" class="uri" title="wikilink">GhcFile(compiler/prelude/TysWiredIn.lhs)</a>) to break the abstraction and directly create the datastructure.</p>
<ul>
<li><strong>Don't inline integer functions</strong>. Most of the functions in the Integer implementation in the
<pre><code>integer` package are marked `NOINLINE`. For example in `integer-gmp</code></pre>
<p>we have</p></li>
</ul>
<pre><code>#!hs
plusInteger :: Integer -&gt; Integer -&gt; Integer
plusInteger (S# i1) (S# i2) = ...
plusInteger (S# i1) (J# j1 j2) = ...
-- ...two more cases...</code></pre>
<p><code>Not only is this a big function to inline, but inlining it typically does no good because the representation of literals is abstact, so no pattern-matching cancellation happens.  And even if you have </code></p>
<pre><code>(a+b+c)</code></pre>
<p>, the conditionals mean that no cancellation happens, or you get an exponential code explosion!</p>
<h1 id="an-integrated-code-generator-for-ghc">An Integrated Code Generator for GHC</h1>
<p>We propose reworking GHC's back end into an <strong>Integrated Code Generator</strong>, which will widen the interface between machine-independent and machine-dependent parts of the back end. We wish to <strong>dissolve the barrier</strong> between the current machine-independent transformations (CPS conversion, stack layout, etc) and the native-code generators (instruction selection, calling conventions, register allocation -- including spilling to the C stack, etc). The goal is instead to have a code generator that <strong>integrates both machine-independent and machine-dependent components</strong>, which will interact through wide but well-specified interfaces. From this refactoring we expect the following benefits:</p>
<ul>
<li><strong>The back end will be simpler overall</strong>, primarily because the</li>
</ul>
<p><code>  refactoring will reduce or eliminate duplication of code</code></p>
<ul>
<li><strong>Complexity will be isolated</strong> in two modules with well-defined</li>
</ul>
<p><code>  interfaces: a dataflow engine and a register allocator</code></p>
<ul>
<li><strong>GHC will generate better machine code</strong>, primarily because</li>
</ul>
<p><code>  important decisions about register usage will be made at a later</code><br />
<code>  stage of translation and will exploit knowledge of the actual</code><br />
<code>  target machine. </code></p>
<h2 id="design-elements">Design elements</h2>
<p>The important elements of our design are as follows:</p>
<ol>
<li>Build two big hammers, and hit as many nails as possible. (The big hammers are the <strong>dataflow optimization engine</strong> and a <strong>coalescing register allocator.</strong> For more on their uses, see our [wiki:Commentary/Compiler/IntegratedCodeGen#Designphilosophy design philosophy].) The hammer itself may be big and complicated, but <strong>using a big hammer should be easy</strong> and should give easily predictable results.</li>
<li>Load all back ends into every instance of the compiler, and <strong>treat every compilation as a cross-compilation.</strong> Despite having been used in production compilers for at least twenty years, this technique is still seen as somewhat unorthodox, but it removes many
<pre><code>#ifdef</code></pre>
<p>s and saves significant complexity at compiler-configuration time. Removing</p>
<pre><code>#ifdef</code></pre>
<p>s also mitigates problems with validating the compiler under different build configurations.</p></li>
</ol>
<h2 id="design-philosophy">Design philosophy</h2>
<p>State-of-the art dataflow optimization and register allocation both require complex implementations. We live with this complexity because <strong>creating new clients is easy.</strong></p>
<ul>
<li><strong>Dataflow optimization:</strong> We can define a new</li>
</ul>
<p><code>  optimization simply by defining a lattice of dataflow facts (akin</code><br />
<code>  to a specialized logic) and then writing the dataflow-transfer</code><br />
<code>  functions found in compiler textbooks.   Handing these functions to</code><br />
<code>  the dataflow engine produces a new optimization that is not only</code><br />
<code>  useful on its own, but that can easily be composed with other</code><br />
<code>  optimizations to create an integrated &quot;superoptimization&quot; that is</code><br />
<code>  strictly more powerful than any sequence of individual optimizations,</code><br />
<code>  no matter how many times they are re-run.</code><br />
<code>  The dataflow engine is based on </code><br />
<code>  </code><a href="http://citeseer.ist.psu.edu/old/lerner01composing.html"><code>(Lerner,</code> <code>Grove,</code> <code>and</code> <code>Chambers</code> <code>2002)</code></a><code>;</code><br />
<code>  you can find a functional implementation of the dataflow engine presented in</code><br />
<code>  </code><a href="http://www.cs.tufts.edu/~nr/pubs/zipcfg-abstract.html"><code>(Ramsey</code> <code>and</code> <code>Dias</code> <code>2005)</code></a><code>.</code></p>
<ul>
<li><strong>Coalescing register allocator:</strong> The back end can use fresh temporaries and register-register moves</li>
</ul>
<p><code>  with abandon, knowing that a state-of-the-art register allocator</code><br />
<code>  will eliminate almost all move instructions.</code></p>
<ul>
<li><strong>Back ends:</strong> Our ultimate goal is to make adding a new back end easy as well.</li>
</ul>
<p><code>  In the long run, we wish to apply John Dias's dissertation work to GHC.</code><br />
<code>  In the short run, however, we</code><br />
<code>  think it more sensible to represent each target-machine instruction</code><br />
<code>  set with an algebraic datatype.  We propose to use type classes to</code><br />
<code>  define common functions such as identifying the registers read and</code><br />
<code>  written by each instruction.</code></p>
<h2 id="proposed-compilation-pipeline">Proposed compilation pipeline</h2>
<ol>
<li><ol>
<li>Convert from
<pre><code>STG</code></pre>
<p>to an control flow graph</p>
<pre><code>CmmGraph</code></pre>
<dl>

<dd>
</dd>
</dl></li>
<li>Instruction selection:</li>
<li>Optimise:</li>
<li>Proc-point analysis, and transformation</li>
<li>Register allocation</li>
<li>Stack layout</li>
<li>Tidy up</li>
</ol></li>
</ol>
<h3 id="convert-from-stg-to-control-flow-graph">Convert from STG to control flow graph</h3>
<p>Convert from</p>
<pre><code>STG</code></pre>
<p>to an control flow graph</p>
<pre><code>CmmGraph</code></pre>
<p>(<a href="GhcFile(compiler/cmm/ZipCfg.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/ZipCfg.hs)</a>, <a href="GhcFile(compiler/cmm/ZipCfgCmmRep.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/ZipCfgCmmRep.hs)</a>). This step is Simon PJ's &quot;new code generator&quot; from September 2007. This conversion may introduce new variables, stack slots, and compile-time constants.</p>
<pre><code>STG -&gt; CmmGraph Cmm.Middle Cmm.Last</code></pre>
<ul>
<li>Implements calling conventions for call, jump, and return instructions: all parameter passing is turned into data-movement instructions (register-to-register move, load, or store), and stack-pointer adjustments are inserted. After this point, calls, returns, and jumps are just control-transfer instructions -- the parameter passing has been compiled away.</li>
<li>How do we refer to locations on the stack when we haven't laid it out yet? The compiler names a stack slot using the idea of a &quot;late compile-time constant,&quot; which is just a symbolic constant that will be replaced with an actual stack offset when the stack layout is chosen.One departure from the old code generator is that '''we do not build a
<pre><code>Cmm</code></pre>
<p>abstract-syntax tree;''' instead we go straight to a control-flow graph.</p></li>
</ul>
<p>In practice, we first generate an &quot;abstract control flow graph&quot;,</p>
<pre><code>CmmAGraph`, which makes the business of generating fresh `BlockId`s more convenient, and convert that to a `CmmGraph</code></pre>
<p>. The former is convenient for <em>construction</em> but cannot be analysed; the latter is concrete, and can be analyzed, transformed, and optimized.</p>
<h3 id="instruction-selection">Instruction selection</h3>
<p>Instruction selection: each</p>
<pre><code>Cmm</code></pre>
<pre><code>Middle</code></pre>
<p>and</p>
<pre><code>Last</code></pre>
<p>node in the control-flow graph is replaced with a new graph in which the nodes are machine instructions.</p>
<pre><code>CmmGraph Cmm.Middle Cmm.Last -&gt; CmmGraph I386.Middle I386.Last</code></pre>
<p>The</p>
<pre><code>I386.Middle</code></pre>
<p>type represents computational machine instructions; the</p>
<pre><code>I386.Last</code></pre>
<p>type represents control-transfer instructions. The choice of representation is up to the author of the back end, but for continuity with the existing native code generators, we expect to begin by using algebraic data types inspired by the existing definitions in <a href="GhcFile(compiler/nativeGen/MachInstrs.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/MachInstrs.hs)</a>.</p>
<p>Note that the graph still contains:</p>
<ul>
<li><strong>Variables</strong> (ie local register that are not yet mapped to particular machine registers)</li>
<li><strong>Stack-slot addressing modes</strong>, which include late-bound compile-time constants, such as the offset in the frame of the a variable spill location, or BlockId stack-top-on-entry.</li>
</ul>
<p>The invariant is that each node could be done by one machine instruction, provided each</p>
<pre><code>LocalReg</code></pre>
<p>maps to a (suitable) physical register; and an instruction involving a stack-slot can cope with (Sp+n).</p>
<p>An <strong>extremely important distinction</strong> from the existing code is that we plan to eliminate</p>
<pre><code>#ifdef</code></pre>
<p>and instead provide multiple datatypes, e.g., in</p>
<pre><code>I386.hs</code></pre>
<p>,</p>
<pre><code>PpcInstrs.hs</code></pre>
<p>,</p>
<pre><code>Sparc.hs</code></pre>
<p>, and so on.</p>
<p>Similarly, we expect a an instruction selector for <em>each</em> back end, so for example, we might have a transformation that maps</p>
<pre><code>LGraph Cmm.Middle Cmm.Last</code></pre>
<p>(with variables, stack slots, and compile-time constants)</p>
<pre><code>-&gt; LGraph I86.Middle I386.Last</code></pre>
<p>(with variables, stack slots, and compile-time constants).</p>
<p>We expect to <strong>abstract away from the details of these representations</strong> by borrowing some abstractions from <a href="http://www.eecs.harvard.edu/hube/software/nci/overview.html">Machine SUIF</a>. In the longer term we would like to support RTL-based representations such as are used in gcc, vpo and Quick C--. What this means is that</p>
<pre><code>I386.Middle</code></pre>
<p>(etc) is an abstract type, an instance of type class that supports the functions that the rest of the pipeline needs. For example:</p>
<pre><code>class Instr i where
  defs :: i -&gt; [LocalReg]
  uses :: i -&gt; [LocalReg]
  ..etc..</code></pre>
<p>This allows us to <strong>make code improvements machine-independent</strong>, by using machine-dependent functions to capture the semantics of instructions. Figuring out precisely what the interface should be is a key step. For example, to support copy propagation we might want an operation</p>
<pre><code> 
  isCopy :: i -&gt; Maybe (LocalReg,LocalReg)</code></pre>
<p>Similarly, to support peephole optimsation (eg transform</p>
<pre><code>x = y+2; p = bits32[x]` to `p = bits32[y+2]</code></pre>
<p>) we might want something like</p>
<pre><code>  availExprs :: i -&gt; [(LocalReg,CmmExpr)]
  substExprs :: [(LocalReg,CmmExpr)] -&gt; i -&gt; Maybe i</code></pre>
<p>The</p>
<pre><code>substExprs` operation returns a `Just</code></pre>
<p>iff a substitution took place.</p>
<p>Interfaces like these would require the machine-specific abstract type</p>
<pre><code>i` to contain enough information to reconstruct a `LocalReg` or `CmmExpr</code></pre>
<p>. Later one, we'll need to construct SRTs too, so we must continue to track pointer-hood.</p>
<p>One possible implementation for</p>
<pre><code>I386` or `Sparc` would be to use a generic RTL representation, together with a recogniser to maintain the machine invariant.  Our initial idea, though, is that  is an implementation choice.  It&#39;s still possible that a machine-independent optimisation could take advantage of the representation being an RTL. For example, we could provide a function in the `Instr</code></pre>
<p>class</p>
<pre><code>   rtl :: i -&gt; RTL</code></pre>
<p>which is particularly cheap for architectures that do use</p>
<pre><code>RTL</code></pre>
<p>as the representation type.</p>
<h3 id="optimisation">Optimisation</h3>
<p>Optimise the code.</p>
<pre><code>LGraph Instrs</code></pre>
<p>(with variables, stack slots, and compile-time constants)</p>
<pre><code>-&gt; LGraph Instrs</code></pre>
<p>(with variables, stack slots, and compile-time constants), such as</p>
<ul>
<li>Branch chain elimination.</li>
<li>Remove unreachable blocks (dead code).</li>
<li>Constant propagation.</li>
<li>Copy propagation.</li>
<li>Lazy code motion (hoisting, sinking, partial redundancy elimination).</li>
<li>Block concatenation. branch to K; and this is the only use of K.</li>
<li>Common Block Elimination (like CSE). This essentially implements the Adams optimisation, we believe.</li>
<li>Consider (sometime): block duplication. branch to K; and K is a short block. Branch chain elimination is just a special case of this.</li>
<li>Peephole optimisation. The difficulty of implementing a good peephole optimizer varies greatly with the representation of instructions. We propose to postpone serious work on peephole optimization until we have a back end capable of representing machine instructions as RTLs, which makes peephole optimization trivial.</li>
</ul>
<h3 id="proc-point-analysis">Proc-point analysis</h3>
<pre><code>analyse :: CmmGraph I386.Middle I386.Last -&gt; [BlockId]
transform :: [BlockId] -&gt; CmmGraph I386.Middle I386.Last -&gt; CmmGraph I386.Middle I386.Last</code></pre>
<p>Both input and output still have variables and stack-slot addressing modes.</p>
<ul>
<li>Proc points are found, and the appropriate control-transfer instructions are inserted.</li>
<li>Why so early(before register allocation, stack layout)? Depending on the back end (think of C as the worst case), the proc-point analysis might have to satisfy some horrible calling convention. We want to make these requirements explicit before we get to the register allocator. We also want to <strong>exploit the register allocator</strong> to make the best possible decisions about <em>which live variables (if any) should be in registers at a proc point</em>.</li>
</ul>
<h3 id="register-allocation">Register allocation</h3>
<p>Register allocation replaces variable references with machine register and stack slots. This may introduce spills and reloads (to account for register shortage), which which is why we may get new stack-slot references.</p>
<p>That is, register allocation takes</p>
<pre><code>LGraph Instrs</code></pre>
<p>(with variables, stack slots)</p>
<pre><code>-&gt; LGraph Instrs</code></pre>
<p>(with stack slots only). No more variables!</p>
<p>We no longer need to spill to the C stack, because we have fully allocated everything to machine registers.</p>
<h3 id="stack-layout">Stack layout</h3>
<p>Stack Layout:</p>
<pre><code>LGraph Instrs</code></pre>
<p>(with stack slots, and compile-time constants)</p>
<pre><code>-&gt; LGraph Instrs</code></pre>
<ul>
<li>Choose a stack layout.</li>
<li>Replace references to stack slots with addresses on the stack.</li>
<li>Replace compile-time constants with offsets into the stack.</li>
</ul>
<p>No more stack-slot references.</p>
<h3 id="tidy-up">Tidy up</h3>
<ol>
<li>Proc-point splitting:
<pre><code>LGraph Instrs -&gt; [LGraph Instrs]</code></pre></li>
</ol>
<ul>
<li>Each proc point gets its own procedure.</li>
</ul>
<ol>
<li><ol>
<li>Code layout:
<pre><code>LGraph Instrs -&gt; [String]</code></pre></li>
</ol></li>
</ol>
<ul>
<li>A reverse postorder depth-first traversal simultaneously converts the graph to sequential code and converts each instruction into an assembly-code string: <strong>Assembly code ahoy</strong>!</li>
</ul>
<h2 id="machine-dependence">Machine-dependence</h2>
<p>A key property of the design is that the scopes of machine-dependent code and machine-dependent static types are limited as much as possible:</p>
<ol>
<li><ol>
<li>The representation of machine instructions may be machine-dependent (algebraic data type), or we may use a machine-independent representation that satisfies a machine-dependent dynamic invariant (RTLs). The back end should be designed in such a way that most passes don't know the difference; we intend to borrow heavily from Machine SUIF. To define the interface used to conceal the difference, Machine SUIF uses C++ classes; we will use Haskell's type classes.</li>
<li>Instruction selection is necessarily machine-dependent, and moreover, it must know the representation of machine instructions</li>
<li>Most of the optimizer need not know the representation of machine instructions.</li>
<li>Other passes, including register allocation, stack layout, and so on, should be completely machine-independent.</li>
<li>RTLs are not a new representation; they are a trivial extension of existing
<pre><code>Cmm</code></pre>
<p>representations.</p></li>
</ol></li>
</ol>
<h1 id="ghc-commentary-the-byte-code-interpreter-and-dynamic-linker">GHC Commentary: The byte-code interpreter and dynamic linker</h1>
<h2 id="linker">Linker</h2>
<p>The linker lives in</p>
<pre><code>rts/Linker.c</code></pre>
<p>and is responsible for handling runtime loading of code into a Haskell process. This is something of a big blob of unpleasant code, and see DynamicGhcPrograms for information about efforts to reduce our dependence on this linker.</p>
<p>Nevertheless, GHC's linker certainly adds functionality, and this has been enough to earn its keep (for now). In particular, the linker knows how to **relocate static libraries** (e.g.</p>
<pre><code>.o` and `.a</code></pre>
<p>libraries). This is a pretty rare feature to find: ordinarily, libraries that are to be loaded at runtime are compiled as position independent code (-fPIC), which allows the same physical code pages to be shared between processes, reducing physical memory usage. At runtime, GHC rewrites the relocations, meaning that the resulting page cannot be shared across processes, but that the result is just as efficient as if the code had been statically linked to begin with.</p>
<p>Implementation of the linker cuts three axes: object file format (ELF, Mach-O, PEi386), operating system (Linux, MingW, Darwin, etc), and architecture (i386, x86_64, powerpc, arm), and there are corresponding sets of macros for fiddling with each (</p>
<pre><code>OBJFORMAT_*`, `*_HOST_OS` and `*_HOST_ARCH</code></pre>
<p>). Are large part of the unpleasantness of the current linker is the fact that all of these different concerns are jumbled in one file; refactoring these out to separate files would be a very nice service.</p>
<p>(write more here)</p>
<h2 id="bytecode-interpreter">Bytecode Interpreter</h2>
<hr />
<p>CategoryStub</p>
<h1 id="the-io-manager">The I/O Manager</h1>
<p>This page describes the internals of the I/O manager, the latest version of which can be found in <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Event.html">GHC.Event</a>. The I/O manager's job is to to provide a blocking I/O API to the user without forcing the RTS to create one operating system thread per Haskell thread. We here focus on the <em>threaded</em> RTS on non-Windows platforms.</p>
<p>ezyang: <strong>WARNING: some of this information may be out of date</strong></p>
<p>The RTS keeps a global list of pending events, unsuprising called</p>
<pre><code>pendingEvents</code></pre>
<p>, containing a elements of the following data type:</p>
<pre><code>data IOReq
  = Read   {-# UNPACK #-} &lt;nowiki&gt;Fd&lt;/nowiki&gt; {-# UNPACK #-} &lt;nowiki&gt;(MVar&lt;/nowiki&gt; ())
  | Write  {-# UNPACK #-} &lt;nowiki&gt;Fd&lt;/nowiki&gt; {-# UNPACK #-} &lt;nowiki&gt;(MVar&lt;/nowiki&gt; ())</code></pre>
<p>When a thread wants to read from a file descriptor</p>
<pre><code>fd` it calls `threadWaitRead` which in turn calls `waitForReadEvent</code></pre>
<p>.</p>
<pre><code>waitForReadEvent :: Fd -&gt; IO ()
waitForReadEvent fd = do
  m &lt;- newEmptyMVar
  atomicModifyIORef pendingEvents (\xs -&gt; (Read fd m : xs, ()))
  prodServiceThread
  takeMVar m</code></pre>
<pre><code>waitForReadEvent` creates a new `MVar`, adds it to `pendingEvents` and finally blocks on it. `pendingEvents` gets read by the I/O manager thread which runs the event loop, in GHC called `service_loop</code></pre>
<p>. It roughly performs these steps:</p>
<ol>
<li>Pick up new I/O requests from
<pre><code>pendingRequests</code></pre>
<p>and set the variable to the empty list.</p></li>
<li>Create data structures appropriate for calling
<pre><code>select</code></pre>
<p>.</p></li>
<li>For each
<pre><code>Read` request in `pendingEvents` check if the file descriptor is in the ready set returned by `select`. If so perform a `putMVar` on the `MVar</code></pre>
<p>associated with that request to wake up the blocked thread.</p></li>
<li>Repeat from step 1.</li>
</ol>
<h1 id="key-data-types">Key data types</h1>
<p>The key to understanding GHC is to understand its key data types. There are pages describing many of them here (please add new pages). The diagram below shows their inter-dependencies.</p>
<ul>
<li>[wiki:Commentary/Compiler/HsSynType The source language: HsSyn]</li>
<li>[wiki:Commentary/Compiler/RdrNameType RdrNames, Modules, and OccNames]</li>
<li>[wiki:Commentary/Compiler/ModuleTypes ModIface, ModDetails, ModGuts]</li>
<li>[wiki:Commentary/Compiler/Unique Uniques]: Not drawn in the diagram, because nearly everything depends on Uniques.</li>
<li>[wiki:Commentary/Compiler/NameType Names]</li>
<li>[wiki:Commentary/Compiler/EntityTypes Entities]: variables, type constructors, data constructors, and classes.</li>
<li>Types: [wiki:Commentary/Compiler/TypeType Type and Kind], [wiki:Commentary/Compiler/FC equality types and coercions]</li>
<li>[wiki:Commentary/Compiler/CoreSynType The core language]</li>
<li>[wiki:Commentary/Compiler/StgSynType The STG language]</li>
<li>[wiki:Commentary/Compiler/CmmType The Cmm language]</li>
<li>[wiki:Commentary/Compiler/BackEndTypes Back end types]</li>
</ul>
<p><a href="Image(types.png)" class="uri" title="wikilink">Image(types.png)</a></p>
<h1 id="kinds">Kinds</h1>
<p>Kinds classify types. So for example:</p>
<pre><code>* 
** 
* -&gt; *
   Int# :: #
   (# Int, Int #) :: #</code></pre>
<p>The base kinds are these:</p>
<ul>
<li>&quot;
<pre><code>*`&quot; is the kind of boxed values. Things like `Int` and `Maybe Float` have kind `*</code></pre>
<p>.</p></li>
<li>&quot;
<pre><code>#`&quot; is the kind of unboxed values. Things like `Int#` have kind `#</code></pre>
<p>.</p></li>
<li>With the advent of [wiki:GhcKinds data type promotion and kind polymorphism] we can have a lot more kinds.</li>
</ul>
<p>(Unboxed tuples used to have a distinct kind, but in 2012 we combined unboxed tuples with other unboxed values in a single kind &quot;</p>
<pre><code>#</code></pre>
<p>&quot;.)</p>
<h2 id="representing-kinds">Representing kinds</h2>
<p>Kinds are represented by the data type</p>
<pre><code>Type</code></pre>
<p>(see [wiki:Commentary/Compiler/TypeType]):</p>
<pre><code>type Kind = Type</code></pre>
<p>Basic kinds are represented using type constructors, e.g. the kind</p>
<pre><code>*</code></pre>
<p>is represented as</p>
<pre><code>liftedTypeKind :: Kind
liftedTypeKind = TyConApp liftedTypeKindTyCon []</code></pre>
<p>where</p>
<pre><code>liftedTypeKindTyCon` is a built-in `PrimTyCon</code></pre>
<p>. The arrow type constructor is used as the arrow kind constructor, e.g. the kind</p>
<pre><code>* -&gt; *</code></pre>
<p>is represented internally as</p>
<pre><code>FunTy liftedTypeKind liftedTypeKind</code></pre>
<p>It's easy to extract the kind of a type, or the sort of a kind:</p>
<pre><code>typeKind :: Type -&gt; Kind</code></pre>
<p>The &quot;sort&quot; of a kind is always one of the sorts:</p>
<pre><code>TY` (for kinds that classify normal types) or `CO</code></pre>
<p>(for kinds that classify coercion evidence). The coercion kind,</p>
<pre><code>T1 :=: T2</code></pre>
<p>, is represented by</p>
<pre><code>PredTy (EqPred T1 T2)</code></pre>
<p>.</p>
<h2 id="kind-subtyping">Kind subtyping</h2>
<p>There is a small amount of sub-typing in kinds. Suppose you see</p>
<pre><code>(t1 -&gt; t2)`.  What kind must `t1` and `t2` have?  It could be `*` or `#`.  So we have a single kind `OpenKind</code></pre>
<p>, which is a super-kind of both, with this simple lattice:</p>
<p><a href="Image(https://docs.google.com/drawings/pub?id=1M5yBP8iAWTgqdI3oG1UNnYihVlipnvvk2vLInAFxtNM&amp;w=359&amp;h=229)" class="uri" title="wikilink">Image(https://docs.google.com/drawings/pub?id=1M5yBP8iAWTgqdI3oG1UNnYihVlipnvvk2vLInAFxtNM&amp;w=359&amp;h=229)</a></p>
<p>(You can edit this picture <a href="https://docs.google.com/drawings/d/1M5yBP8iAWTgqdI3oG1UNnYihVlipnvvk2vLInAFxtNM/edit?hl=en_GB">here</a>.)</p>
<h1 id="linearity">Linearity</h1>
<p>The solution is to distinguish call demands from product demands. Consider again:</p>
<pre><code>let f = \ x. \ y. ... in
  ...(f 1 2)...(f 3 4)...</code></pre>
<p>The demands placed on</p>
<pre><code>f</code></pre>
<p>by the first and second call get bothed together to yield</p>
<pre><code>SM(SM(T))</code></pre>
<p>. But this is incorrect. Consider:</p>
<pre><code>let f = \ x. \ y. ... 
    frob = f 1 in
  ...(f 1 2)...(frob 2)...(frob 3)...</code></pre>
<p>Here, the demands placed on</p>
<pre><code>f</code></pre>
<p>by the body of</p>
<pre><code>frob</code></pre>
<p>and by the call to</p>
<pre><code>f</code></pre>
<p>in the</p>
<pre><code>let</code></pre>
<p>-body get bothed together:</p>
<pre><code>S1(T) &amp; S1(S1(T)) = SM(SM(T))</code></pre>
<p>. Note that this is the same as the demand placed on</p>
<pre><code>f</code></pre>
<p>above, yet we want to distinguish between the two situations, because in the first example, the inner lambda in</p>
<pre><code>f</code></pre>
<p>'s rhs is only called once.</p>
<p>The solution is to treat call demands and product demands differently, and to define the</p>
<pre><code>both</code></pre>
<p>function for call demands to have the same behavior as</p>
<pre><code>lub</code></pre>
<p>. Then in the first example,</p>
<pre><code>f</code></pre>
<p>has demand</p>
<pre><code>SM(S1(T))</code></pre>
<p>placed on it, and in the second,</p>
<pre><code>SM(T)</code></pre>
<p>. This is what we want; now, if</p>
<pre><code>f</code></pre>
<p>has demand</p>
<pre><code>D(D(T)</code></pre>
<p>placed on it, that implies</p>
<pre><code>f</code></pre>
<p>is always called with two arguments.</p>
<p>Why does this make sense? Consider what it means if we see an example like:</p>
<pre><code>let baz = lazyF p in
  case p of
    (a,b) -&gt; strictF a b</code></pre>
<p>(where</p>
<pre><code>lazyF</code></pre>
<p>is lazy in</p>
<pre><code>p</code></pre>
<p>, and</p>
<pre><code>strictF</code></pre>
<p>is strict in</p>
<pre><code>a</code></pre>
<p>and</p>
<pre><code>b</code></pre>
<p>).</p>
<pre><code>p</code></pre>
<p>is used both with demand</p>
<pre><code>L</code></pre>
<p>(in the call to</p>
<pre><code>lazyF</code></pre>
<p>and with demand</p>
<pre><code>S(SS)</code></pre>
<p>(in the call to</p>
<pre><code>strictF</code></pre>
<p>). This means it's perfectly same to strictly evaluate</p>
<pre><code>p</code></pre>
<p>, so when we both together the two demands, we should get</p>
<pre><code>S(SS)</code></pre>
<p>. On the other hand, if a function is <em>called</em> once with one argument and once with two, we don't want to treat it as a function that's always called with two arguments; we're only interested in functions that are <em>always</em> called with <em>n</em> arguments for a given <em>n</em>. Hence, both should behave the same way as lub for call demands.</p>
<h1 id="ticky">Ticky</h1>
<p>(NB out-of-date, but maybe historically useful; cf [wiki:Debugging/TickyTicky])</p>
<p>The following code inserts extra fields into closures when ticky is enabled (and so had to be commented out):</p>
<pre><code>staticTickyHdr :: [CmmLit]
-- The ticky header words in a static closure
-- Was SET_STATIC_TICKY_HDR
staticTickyHdr = 
  | not opt_DoTickyProfiling = []
  | otherwise            = [zeroCLit]</code></pre>
<p>in <a href="GhcFile(compiler/codeGen/CgTicky.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/CgTicky.hs)</a>.</p>
<p>Other relevant functions:</p>
<pre><code>emitTickyCounter</code></pre>
<p>in <a href="GhcFile(compiler/codeGen/CgTicky.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/CgTicky.hs)</a> (called by</p>
<pre><code>closureCodeBody</code></pre>
<p>in <a href="GhcFile(compiler/codeGen/CgClosure.lhs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/CgClosure.lhs)</a>).</p>
<p>Argh! I spent days tracking down this bug:</p>
<pre><code>idInfoLabelType</code></pre>
<p>in <a href="GhcFile(compiler/cmm/CLabel.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CLabel.hs)</a> needs to return</p>
<pre><code>DataLabel</code></pre>
<p>for labels of type</p>
<pre><code>RednCount</code></pre>
<p>(i.e., labels for ticky counters.) By default, it was returning</p>
<pre><code>CodeLabel</code></pre>
<p>, which caused the ticky counter labels to get declared with the wrong type in the generated C, which caused C compiler errors.</p>
<h2 id="declarations-for-ticky-counters">Declarations for ticky counters</h2>
<pre><code>emitTickyCounter</code></pre>
<p>spits out C declarations that look like this:</p>
<pre><code>static char c16O_str[] = &quot;main:Main.$wrepeated{v r4}&quot;;

static char c16Q_str[] = &quot;i&quot;;

StgWord Main_zdwrepeated_ct[] = {
0x0, 0x1U, 0x1U, 0x0, (W_)&amp;c16O_str, (W_)&amp;c16Q_str, 0x0, 0x0, 0x0
};</code></pre>
<p>Here,</p>
<pre><code>Main_zdwrepeated_ct</code></pre>
<p>is actually an</p>
<pre><code>StgEntCounter</code></pre>
<p>(this type is declared in <a href="GhcFile(includes/StgTicky.h)" class="uri" title="wikilink">GhcFile(includes/StgTicky.h)</a>). The counters get used by</p>
<pre><code>printRegisteredCounterInfo</code></pre>
<p>in <a href="GhcFile(rts/Ticky.c)" class="uri" title="wikilink">GhcFile(rts/Ticky.c)</a>, which prints out the ticky reports. The counter fields are accessed using offsets defined in <a href="GhcFile(includes/GHCConstants.h)" class="uri" title="wikilink">GhcFile(includes/GHCConstants.h)</a> (</p>
<pre><code>oFFSET_StgEntCounter_*</code></pre>
<p>), which in turn get generated from <a href="GhcFile(includes/mkDerivedConstants.c)" class="uri" title="wikilink">GhcFile(includes/mkDerivedConstants.c)</a> (change it and then run</p>
<pre><code>make</code></pre>
<p>in</p>
<pre><code>includes/</code></pre>
<p>.</p>
<p><s>Note that the first 3 fields of the counters are 16-bit ints and so the generated ticky-counter registration code has to reflect that (I fixed a bug where the first field was getting treated as a 32-bit int.)</s> I modified the</p>
<pre><code>StgEntCounter</code></pre>
<p>type so that all fields are</p>
<pre><code>StgWord</code></pre>
<p>s, because it seems that the code generator can't cope with anything else anyway (i.e., in the declaration above,</p>
<pre><code>Main_zdwrepeated_ct[]</code></pre>
<p>is an array of</p>
<pre><code>StgWord</code></pre>
<p>s, even though the C type declaration implies that some fields are halfwords.)</p>
<p>In</p>
<pre><code>emitBlackHoleCode</code></pre>
<p>in <a href="GhcFile(compiler/codeGen/CgClosure.lhs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/CgClosure.lhs)</a>, &quot;eager blackholing&quot; was getting employed in the case where ticky was turned on; this was causing programs to &lt;pre&gt;&lt;<loop>&gt;</p>
</pre>
<p>when they wouldn't with ticky disabled, so I turned that off.</p>
<h1 id="strictness-and-let-floating">Strictness and let-floating</h1>
<p>We run into the following problem in the</p>
<pre><code>transform</code></pre>
<p>nofib benchmark: suppose we have:</p>
<pre><code>f x = 
  let foo = stuff in
     foo + x</code></pre>
<p>where</p>
<pre><code>stuff</code></pre>
<p>doesn't depend on</p>
<pre><code>x</code></pre>
<p>. Demand analysis says that</p>
<pre><code>foo</code></pre>
<p>has a strict demand placed on it. Later,</p>
<pre><code>foo</code></pre>
<p>gets floated to the top level because it doesn't depend on</p>
<pre><code>x</code></pre>
<p>(in reality it's more complicated because in this case</p>
<pre><code>foo</code></pre>
<p>probably would have gotten floated out before demand analysis, but bear with me).</p>
<pre><code>foo</code></pre>
<p>still has a strict demand signature, which a top-level binding isn't allowed to have. Currently this manifests itself as an assertion failure in <a href="GhcFile(compiler/simplCore/SimplEnv.lhs)" class="uri" title="wikilink">GhcFile(compiler/simplCore/SimplEnv.lhs)</a>.</p>
<p>There are two possible easy solutions: don't float out bindings for strict things, or &quot;both&quot; the demand for a binder with Lazy when its binding gets floated out. The question is, is it better to do the let-floating and lose the strictness into or to evaluate something strictly but lose sharing?</p>
<h1 id="coercions">Coercions</h1>
<p>When we run into an expression like</p>
<pre><code>(Cast e co)</code></pre>
<p>that we're placing demand</p>
<pre><code>d</code></pre>
<p>on, we analyze</p>
<pre><code>e</code></pre>
<p>to get</p>
<pre><code>dmd_ty</code></pre>
<p>, then check whether the depth of</p>
<pre><code>e</code></pre>
<p>is equal to the depth of</p>
<pre><code>dmd_ty</code></pre>
<p>or not. This is necessary because we might be casting a function to a non-function type. So, if</p>
<pre><code>d</code></pre>
<p>and</p>
<pre><code>dmd_ty</code></pre>
<p>have equal depth, we return</p>
<pre><code>dmd_ty</code></pre>
<p>as is; if</p>
<pre><code>d</code></pre>
<p>'s arity is less, we drop the appropriate number of args from</p>
<pre><code>dmd_ty</code></pre>
<p>; if</p>
<pre><code>dmd_ty</code></pre>
<p>'s arity is less, we add the appropriate number of dummy argument demands to it.</p>
<h1 id="warn-arity">WARN: arity /</h1>
<p>dmdTypeDepth rhs_dmd_ty &amp;&amp; not (exprIsTrivial rhs) =</p>
<p>This warning was happening for (at least) two reasons: - lambdas with a strict non-call demand placed on them were being handled wrong (see the first two examples in [wiki:Commentary/Compiler/StrictnessAnalysis/Examples]) - coercions were being handled wrong, resulting in a demand type with depth 0 being assigned to an rhs consisting of a cast from/to a function type</p>
<h1 id="explaining-demand-transformers">Explaining demand transformers</h1>
<p>For those who, like me, are a little slow, this example might go in section 5.1 of the paper:</p>
<p>(a):</p>
<pre><code>f = \ x -&gt; 
      case x of
        ... -&gt; \ y -&gt; ...
        ... -&gt; \ y -&gt; ...</code></pre>
<p>(b):</p>
<pre><code>f = \ x -&gt;
     \ y -&gt;
        case x of
           ...</code></pre>
<p>In both (a) and (b),</p>
<pre><code>f</code></pre>
<p>'s rhs places a strict demand on</p>
<pre><code>x</code></pre>
<p>. So if we see:</p>
<pre><code>(f x)</code></pre>
<p>with a strict demand placed on it, it wouldn't be sound to look at</p>
<pre><code>f</code></pre>
<p>'s demand signature and say that</p>
<pre><code>(f x)</code></pre>
<p>places a strict demand on</p>
<pre><code>x</code></pre>
<p>under</p>
<pre><code>f</code></pre>
<p>-- because we don't know whether</p>
<pre><code>f</code></pre>
<p>is like (a) or like (b). This is why when we see a partial application of</p>
<pre><code>f</code></pre>
<p>, we discard all of the argument information in</p>
<pre><code>f</code></pre>
<p>'s demand type.</p>
<h1 id="nofib-stuff">Nofib stuff</h1>
<p>I've had weird problems with the</p>
<pre><code>time</code></pre>
<p>and</p>
<pre><code>sed</code></pre>
<p>commands under MSYS but I think it's just when running nofib. At some point I wrote down:</p>
<p>TIME needs to be</p>
<pre><code>time</code></pre>
<p>not</p>
<pre><code>/bin/time</code></pre>
<p>and</p>
<p>MSYS</p>
<pre><code>sed</code></pre>
<p>does not work, use cygwin</p>
<pre><code>sed</code></pre>
<p>but of *course* I no longer remember what I meant.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="ghc-commentary-libraries">GHC Commentary: Libraries</h1>
<p>All GHC build trees contain a set of libraries, called the <strong>Boot Packages</strong>. These are the libraries that GHC's source code imports. Obviously you need the boot packages to build GHC at all. The boot packages are those packages in the file [source:packages] that have a</p>
<pre><code>-</code></pre>
<p>in the &quot;tag&quot; column.</p>
<p>The repository structure of a GHC source tree is described in [wiki:Repositories].</p>
<p>You can see exactly which versions of what packages GHC depends on by looking in [source:compiler/ghc.cabal.in]. The versions of the boot packages (including the</p>
<pre><code>base</code></pre>
<p>library) associated with each GHC release are tabulated in <a href="wiki:Commentary/Libraries/VersionHistory" title="wikilink">GHC Boot Library Version History</a>.</p>
<h1 id="building-packages-that-ghc-doesnt-depend-on">Building packages that GHC doesn't depend on</h1>
<p>You can make the build system build extra packages, on which GHC doesn't strictly depend, by adding them to the</p>
<pre><code>$(TOP)/packages` file, with an `extra` tag. Then set `BUILD_EXTRA_PKGS=YES` in your `mk/build.mk</code></pre>
<p>file.</p>
<p>It should be exceptional, but you can make the build system provide per-package compiler flags, by adding some definitions in</p>
<pre><code>$(TOP)/ghc.mk</code></pre>
<p>, just below the comment</p>
<pre><code># Per-package compiler flags
# 
# If you want to add per-package compiler flags, this 
# is the place to do it.  Do it like this for package &lt;pkg&gt;
#   
#   libraries/&lt;pkg&gt;_dist-boot_HC_OPTS += -Wwarn
#   libraries/&lt;pkg&gt;_dist-install_HC_OPTS += -Wwarn</code></pre>
<hr />
<h1 id="classifying-boot-packages">Classifying boot packages</h1>
<p>A <strong>boot package</strong> is, by definition, a package that can be built by GHC's build system.</p>
<p>Boot packages can be classified in four different ways:</p>
<ul>
<li>Required vs optional</li>
<li>Wired-in vs independent</li>
<li>Zero-boot vs not zero-boot</li>
<li>Installed vs not installed</li>
</ul>
<p>These distinctions are described in the following sub-sections.</p>
<h2 id="required-or-optional">Required or optional</h2>
<p>Most boot packages <strong>required</strong> to build</p>
<pre><code>ghc-stage2`, or one of the supporting utilities such as `ghc-pkg`, `hsc2hs</code></pre>
<p>, etc.</p>
<p>However a few are <strong>optional</strong>, and are built only</p>
<ul>
<li>To ensure that they do indeed build cleanly; they are stress tests of GHC. E.g.
<pre><code>dph</code></pre></li>
<li>Because they are used in regression tests</li>
</ul>
<h2 id="coupling-to-ghc">Coupling to GHC</h2>
<p>An important classification of the boot packages is as follows:</p>
<ul>
<li><strong>Wired in packages</strong> are totally specific to GHC. See the list in
<pre><code>compiler/main/Packages.lhs` function `findWiredInPackages</code></pre>
<p>, and c.f. [wiki:Commentary/Compiler/Packages]. At the moment these are:</p>
<ul>
<li><pre><code>ghc-prim</code></pre></li>
<li><pre><code>integer-gmp`, `integer-simple</code></pre></li>
<li><pre><code>base</code></pre></li>
<li><pre><code>template-haskell</code></pre></li>
<li><pre><code>dph</code></pre></li>
</ul></li>
</ul>
<ul>
<li><strong>Independent</strong> packages are loosely coupled to GHC, and often maintained by others. Most boot packages are independent; e.g.
<pre><code>containers`, `binary`, `haskeline</code></pre>
<p>and so on.</p></li>
</ul>
<p>Independent libraries may have a master repository somewhere separate from the GHC repositories. Whenever we release GHC, we ensure that the installed boot libraries (i.e. that come with GHC) that are also independent are precisely sync'd with a particular released version of that library.</p>
<h2 id="zero-boot-packages">Zero-boot packages</h2>
<p>Since GHC's source code imports the boot packages, <em>even the bootstrap compiler must have the boot packages available</em>. (Or, more precisely, all the types and values that are imported must be available from some package in the bootstrap compiler; the exact set of packages does not need to be identical.)</p>
<p>For the most part we simply assume that the bootstrap compiler already has the boot packages installed. The <strong>Zero-boot Packages</strong> are a set of packages for which this assumption does not hold. Two reasons dominate:</p>
<ul>
<li>For certain fast-moving boot packages (notably
<pre><code>Cabal</code></pre>
<p>), we don't want to rely on the user having installed a bang-up-to-date version of the package.</p></li>
<li>The only packages that we can &quot;assume that the bootstrap compiler already has&quot; are those packages that come with GHC itself; i.e. the installed boot packages. So non-installed boot packages are also zero-boot packages. Example:
<pre><code>bin-package-db` or `hoopl</code></pre>
<p>.</p></li>
</ul>
<p>So we begin the entire build process by installing the zero-boot packages in the bootstrap compiler. (This installation is purely local to the build tree.) This is done in</p>
<pre><code>ghc.mk` by setting `PACKAGES_STAGE0</code></pre>
<p>to the list of zero-boot packages; indeed this is the only way in which zero-boot packages are identified in the build system.</p>
<p>As time goes on, a Zero-boot package may become an ordinary boot package, because the bootstrap compiler is expected to have (a sufficiently up to date) version of the package already. Remember that we support bootstrapping with two previous versions of GHC.</p>
<p>To find out which packages are currently zero-boot packages, do the following in a GHC build:</p>
<pre><code>$ make show VALUE=BOOT_PKGS</code></pre>
<p>Some Zero-boot packages are <strong>maintained by other people</strong>. In order to avoid GHC being exposed to day-by-day changes in these packages, we maintain a &quot;lagging&quot; Git repository for each that we occasionally sync with the master repository. We never push patches to lagging repository; rather we push to the master (in discussion with the package maintainer), and pull the patches into the lagging repo. The current Zero-boot packages of this kind are:</p>
<ul>
<li><pre><code>Cabal</code></pre>
<dl>

<dd>we frequently update Cabal and GHC in sync
</dd>
</dl></li>
<li><pre><code>binary` (renamed to `ghc-binary` in the 6.12 branch): required by `bin-package-db</code></pre>
<p>.</p></li>
</ul>
<p>Other Zero-boot packages are <strong>maintained by us</strong>. There is just one Git repo for each, the master. When we make a GHC release, we simultaneously tag and release each of these packages. They are:</p>
<ul>
<li><pre><code>hpc</code></pre></li>
<li><pre><code>extensible-exceptions`: this is a shim that provides an API to older versions of GHC that is compatible with what the current `base` package now exports.  So, unusually, `extensible-exceptions</code></pre>
<p>is a zero-boot package, but not a boot package.</p></li>
<li><pre><code>bin-package-db`: a GHC-specific package that provides binary serialisation of the package database, use by `ghc-pkg</code></pre>
<p>and GHC itself.</p></li>
</ul>
<h2 id="installation">Installation</h2>
<p>When we build a distribution of GHC, it includes at least some libraries, otherwise it would be utterly useless. Since GHC is part of the Haskell Platform, any library that is installed with GHC is necessarily part of the Haskell Platform, so we have to be a bit careful what we include.</p>
<p>Alas, since the</p>
<pre><code>ghc` package (implementing the GHC API) is certainly an installed package, all the packages on which it depends must also be installed, and hence willy-nilly become part of the Haskell Platform.  In practice that means that almost all the Boot Packages are installed.  In some cases that is unfortunate.  For example, we currently have a special version of the `binary` library, which we don&#39;t really expect Haskell users to use; in this case, we call it `ghc-binary</code></pre>
<p>, and informally discourage its use.</p>
<p>Currently the Boot Packages that are not installed are</p>
<pre><code>haskeline`, `mtl`, and `terminfo`; these are needed to build the GHC front-end, but not to build the `ghc</code></pre>
<p><em>package</em>.</p>
<p><strong>QUESTION</strong>: where in the build system is the list of installed packages defined?</p>
<hr />
<h1 id="boot-packages-dependencies">Boot packages dependencies</h1>
<ul>
<li>At the root of the hierarchy we have '''
<pre><code>ghc-prim`&#39;&#39;&#39;. As the name implies, this package contains the most primitive types and functions. It only contains a handful of modules, including `GHC.Prim` (which contains `Int#`, `+#`, etc) and `GHC.Bool`, containing the `Bool</code></pre>
<p>datatype. See &quot;WARNING: pattern matching&quot; below.</p></li>
</ul>
<ul>
<li>Above
<pre><code>ghc-prim</code></pre>
<p>are the packages</p>
<ul>
<li><pre><code>integer-gmp</code></pre></li>
<li><pre><code>integer-simple</code></pre></li>
</ul></li>
</ul>
<p><code>The two have the same interface, and only one of the two is used. (When we want to be vague about which one, we call it </code></p>
<pre><code>integer-impl`.)  They provide a definition of the `Integer` type (on top of the C `gmp` library, or in plain Haskell, respectively). Which functionality is provided in `ghc-prim` is mostly driven by what functionality the `integer-impl` packages need. By default `integer-gmp` is used; to use `integer-simple` define `INTEGER_LIBRARY=integer-simple` in `mk/build.mk</code></pre>
<p>.</p>
<p><code>  See &quot;WARNING: pattern matching&quot; below.</code></p>
<ul>
<li>Next is the '''
<pre><code>base`&#39;&#39;&#39; package. This contains a large number of modules, many of which are in one big cyclic import knot, mostly due to the `Exception</code></pre>
<p>type.</p></li>
</ul>
<ul>
<li>On top of base are a number of other, more specialised packages, whose purpose is generally clear from their name. If not, you can get more detail from the descriptions in their Cabal files. The up-to-date list of packages can be found in the file [source:packages].</li>
</ul>
<p>The</p>
<pre><code>haskell98`, `old-time`, `old-locale` and `random` packages are mostly only needed for Haskell 98 support, although `dph` currently uses `random</code></pre>
<p>too.</p>
<p>== WARNING: Pattern matching in</p>
<pre><code>ghc-prim`, `integer-simple`, and `integer-gmp</code></pre>
<p>==</p>
<p>Note that</p>
<pre><code>ghc-prim` and `integer-impl` are below the dependency chain from Exception (in `base</code></pre>
<p>), which means they must not raise generate code to raise an exception (it's not enough that this code will never run). One particularly subtle case of GHC exception-raising code is in the case of (complete) pattern matches. Consider the unboxed form of Integers, which has the constructor S# or J#.</p>
<pre><code>f (S# _) (S# _) = ...
f x (S# _) = ...
f (S# _) y = ...
f (J# _ _) (J# _ _) = ...</code></pre>
<p>GHC will incorrectly generate core that pattern matches against the second argument twice, the second match being a partial one with (dead) exception raising code. When compiled with optimizations, the dead code is eliminated. However, this breaks with -O0, thus:</p>
<pre><code>Loading package integer-simple ... linking ... 
ghc: /usr/local/ghc/7.2.0.20110728/lib/ghc-7.2.0.20110728/integer-simple-0.1.0.0/HSinteger-simple-0.1.0.0.o: 
unknown symbol `base_ControlziExceptionziBase_patError_info&#39;</code></pre>
<p>The fix is to explicitly spell out the constructor in the second and third line, so that GHC does not generate calls to</p>
<pre><code>patError</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>f (S# _) (S# _) = ...
f (J# _ _) (S# _) = ...
f (S# _) (J# _ _) = ...
f (J# _ _) (J# _ _) = ...</code></pre>
<h1 id="repositories">Repositories</h1>
<p>The list of repository locations has moved to [wiki:Repositories].</p>
<h1 id="the-llvm-backend">The LLVM backend</h1>
<p>David Terei wrote a new code generator for GHC which targets the LLVM compiler infrastructure. Most of the work was done as part of an honours thesis at the University of New South Wales under the supervision of Manuel Chakravarty. It was merged into GHC Head around May of 2010 and has been included in GHC since the 7.0 release.</p>
<p>Documentation:</p>
<ul>
<li>[wiki:Commentary/Compiler/Backends/LLVM/Installing Installing &amp; Using]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM/Design Design &amp; Implementation]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM/Mangler LLVM Mangler]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM/DevelopmentNotes Bugs &amp; Other Problems]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM/GHC_LLVMPorting Porting GHC/LLVM to another platform]</li>
</ul>
<p>Work in Progress:</p>
<ul>
<li>[wiki:SIMD SIMD instructions and LLVM]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM/Alias Improving Alias Analysis]</li>
</ul>
<p>Future Ideas:</p>
<ul>
<li>[wiki:Commentary/Compiler/Backends/LLVM/WIP ToDo List of Sorts]</li>
<li>[wiki:Commentary/Compiler/Backends/LLVM/ReplacingNCG Replacing the Native Code Generator]</li>
<li><a href="http://dterei.blogspot.com/2011/09/ghc-project-for-all.html">David Terei blog post of LLVM-related projects</a></li>
</ul>
<p>Other information:</p>
<ul>
<li>The <a href="http://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf">thesis paper</a> which offers a detailed performance evaluation, as well as the motivation and design of the back-end.</li>
<li><a href="http://blog.llvm.org/2010/05/glasgow-haskell-compiler-and-llvm.html">Blog post</a> on the LLVM blog about the backend.</li>
<li>A more recent <a href="http://www.cse.unsw.edu.au/~chak/papers/TC10.html">paper</a> submitted to the Haskell Symposium '10, gives updated design overview and performance numbers.</li>
</ul>
<h1 id="loopification">Loopification</h1>
<p>Loopification is a C-- optimisation pass that turns tail recursion into proper loops.</p>
<p>Here is a summary of relevant links and tickets</p>
<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/tmp/wos-diss-draft.pdf">Krzysztof Wos's project</a> in which he reports great performance improvements by turning tail recursion into loops in C--.</li>
</ul>
<ul>
<li>Tickets:</li>
<li><ol>
<li>8285</li>
</ol></li>
<li><ol>
<li>8793, #11372; see comment 15 of #8793) etc, where it seems that we are missing loopification for a simple IO function</li>
</ol></li>
<li><ol>
<li>8585 concerned getting the loop to start <em>after</em> the stack check</li>
</ol></li>
</ul>
<h1 id="llvm-mangler">LLVM Mangler</h1>
<p>The LLVM backend sadly includes a 'mangler'. This is a Haskell written program (well pass of GHC) that runs on the assembly code generated by the LLVM compiler. We do this as there are a few issues with communicating to LLVM exactly what we want generated as object code and so, for now, it is easiest to post-process the assembly.</p>
<p>Long term we ideally would submit patches to LLVM and get rid of the mangler. The work required to do that may be quite high and the patches needed potentially fairly specific to GHC. So no one has done that yet.</p>
<p>Below are the issues that the LLVM Mangler addresses in the assembly code.</p>
<h2 id="tables_next_to_code-tntc">TABLES_NEXT_TO_CODE (TNTC)</h2>
<p>TODO</p>
<h2 id="stack-alignment">Stack Alignment</h2>
<p>LLVM requires that the C stack be properly aligned for spills. One Win32 the stack is 4-byte aligned, which is not enough for SSE spills, and even on x64 platforms the stack is only 16-byte aligned, which is not enough for AVX spills. When the stack is not properly aligned for spills, LLVM generates prologue/epilogue code that fiddles with the base pointer, which GHC uses as its stack pointer, and disables tail call optimization. Both are very bad. Therefore we currently tell LLVM to always assume the stack is properly aligned and then rewrite all aligned SSE/AVX move instructions to their unaligned counterparts inside the mangler.</p>
<h2 id="simd-avx">SIMD / AVX</h2>
<h1 id="migrating-old-commentary">Migrating Old Commentary</h1>
<p>Below you will find a table with a line for each section of the <a href="http://darcs.haskell.org/ghc/docs/comm/">old commentary</a>. Please replace <em>unknown</em> with <strong>done</strong> if you believe that the wiki commentary completely captures <em>all</em> of the information in that section of the old commentary, and that there is no longer any reason for people to read that section of the commentary.</p>
<h2 id="before-the-show-begins">Before the Show Begins</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Feedback</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p>Other Sources of Wisdom</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
</tbody>
</table>
<h2 id="genesis">Genesis</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Outline of the Genesis</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p>Mindboggling Makefiles</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
<tr class="odd">
<td align="left"><p>GHC's Marvellous Module Structure</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
</tbody>
</table>
<h2 id="the-beast-dissected">The Beast Dissected</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Coding style used in the compiler</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p>The Glorious Driver</p></td>
<td align="left"><p>Sections 1 &amp; 2 <strong>done</strong>, <em>Other sections mostly outdated</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Primitives and the Prelude</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>Just Syntax</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>The Basics</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>Modules, ModuleNames and Packages</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>The truth about names: Names and OccNames</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>The Real Story about Variables, Ids, TyVars, and the like</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Data types and constructors</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>The Glorious Renamer</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Hybrid Types</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>Checking Types</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Sugar Free: From Haskell To Core</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>The Mighty Simplifier</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>The Evil Mangler</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p>Alien Functions</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>You Got Control: The STG-language</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>The Native Code Generator</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>GHCi</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>Implementation of foreign export</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Compiling and running the Main module</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
</tbody>
</table>
<h2 id="rts-libraries">RTS &amp; Libraries</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Coding Style Guidelines</p></td>
<td align="left"><p><strong>done</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p>Spineless Tagless C</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Primitives</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>Prelude Foundations</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Cunning Prelude Code</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>On why we have ForeignPtr</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>Non-blocking I/O for Win32</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>Supporting multi-threaded interoperation</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
</tbody>
</table>
<h2 id="extensions-or-making-a-complicated-system-more-complicated">Extensions, or Making a Complicated System More Complicated</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Template Haskell</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>Parallel Arrays</p></td>
<td align="left"><p><em>unknown</em></p></td>
</tr>
</tbody>
</table>
<h1 id="the-marvellous-module-structure-of-ghc">The Marvellous Module Structure of GHC</h1>
<ul>
<li><strong>See also: [ModuleDependencies/Hierarchical Proposal for hierarchical module structure]</strong></li>
</ul>
<ul>
<li><strong>NOTE:</strong> Possibly outdated.</li>
</ul>
<p>GHC is built out of about 245 Haskell modules. It can be quite tricky to figure out what the module dependency graph looks like. It can be important, too, because loops in the module dependency graph need to be broken carefully using .hi-boot interface files.</p>
<p>This section of the commentary documents the subtlest part of the module dependency graph, namely the part near the bottom.</p>
<ul>
<li>The list is given in compilation order: that is, module near the top are more primitive, and are compiled earlier.</li>
<li>Each module is listed together with its most critical dependencies in parentheses; that is, the dependencies that prevent it being compiled earlier.</li>
<li>Modules in the same bullet don't depend on each other.</li>
<li>Loops are documented by a dependency such as &quot;loop Type.Type&quot;. This means tha the module imports Type.Type, but module Type has not yet been compiled, so the import comes from Type.hi-boot.</li>
</ul>
<h2 id="compilation-order-is-as-follows">Compilation order is as follows:</h2>
<ul>
<li>First comes a layer of modules that have few interdependencies, and which implement very basic data types:
<ul>
<li>Util</li>
<li>OccName</li>
<li>Pretty</li>
<li>Outputable</li>
<li>StringBuffer</li>
<li>ListSetOps</li>
<li>Maybes</li>
<li>etc</li>
</ul></li>
</ul>
<ul>
<li>Now comes the main subtle layer, involving types, classes, type constructors identifiers, expressions, rules, and their operations.
<ul>
<li>Name, PrimRep</li>
<li>PrelNames</li>
<li>Var (Name, loop IdInfo.!IdInfo, loop Type.Type, loop Type.Kind)</li>
<li>VarEnv, VarSet, ThinAir</li>
<li>Class (loop TyCon.!TyCon, loop Type.Type)</li>
<li>TyCon (loop Type.Type, loop DataCon.!DataCon, loop Generics.GenInfo)</li>
<li>TypeRep (loop DataCon.!DataCon, loop Subst.substTyWith)</li>
<li>Type (loop PprType.pprType, loop Subst.substTyWith)</li>
<li>FieldLabel (Type), TysPrim (Type)</li>
<li>Literal (TysPrim, PprType), DataCon (loop PprType, loop Subst.substTyWith, FieldLabel.!FieldLabel)</li>
<li>TysWiredIn (loop MkId.mkDataConIds)</li>
<li>TcType ( lots of TysWiredIn stuff)</li>
<li>PprType ( lots of TcType stuff )</li>
<li>PrimOp (PprType, TysWiredIn)</li>
<li>CoreSyn [does not import Id]</li>
<li>IdInfo (CoreSyn.Unfolding, CoreSyn.!CoreRules)</li>
<li>Id (lots from IdInfo)</li>
<li>CoreFVs, PprCore</li>
<li>CoreUtils (PprCore.pprCoreExpr, CoreFVs.exprFreeVars, CoreSyn.isEvaldUnfolding CoreSyn.maybeUnfoldingTemplate)</li>
<li>CoreLint ( CoreUtils ), OccurAnal (CoreUtils.exprIsTrivial), CoreTidy (CoreUtils.exprArity )</li>
<li>CoreUnfold (OccurAnal.occurAnalyseGlobalExpr)</li>
<li>Subst (CoreUnfold.Unfolding, CoreFVs), Generics (CoreUnfold.mkTopUnfolding), Rules (CoreUnfold.Unfolding, PprCore.pprTidyIdRules)</li>
<li>MkId (CoreUnfold.mkUnfolding, Subst, Rules.addRule)</li>
<li>PrelInfo (MkId), HscTypes ( Rules.RuleBase )</li>
</ul></li>
</ul>
<ul>
<li>That is the end of the infrastructure. Now we get the main layer of modules that perform useful work.
<ul>
<li>CoreTidy (HscTypes.!PersistentCompilerState)</li>
</ul></li>
</ul>
<h2 id="typechecker-stuff">Typechecker stuff</h2>
<ul>
<li>TcType</li>
<li>TcEvidence( TcType )</li>
<li>TcMType( TcEvidence )</li>
<li>TcUnify( TcMType )</li>
<li>TcSMonad( TcMType )</li>
<li>TcSimplify( TcSMonad )</li>
<li>TcValidity( TcSimplify.simplifyTop, TcUnify.tcSubType )</li>
<li>TcHsType( TcValidity.checkValidType, TcValidity.checkValidInstance )</li>
</ul>
<h2 id="hssyn-stuff">HsSyn stuff</h2>
<ul>
<li>HsPat.hs-boot</li>
<li>HsExpr.hs-boot (loop HsPat.LPat)</li>
<li>HsTypes (loop HsExpr.!HsSplice)</li>
<li>HsBinds (HsTypes.LHsType, loop HsPat.LPat, HsExpr.pprFunBind and others) HsLit (HsTypes.!SyntaxName)</li>
<li>HsPat (HsBinds, HsLit) HsDecls (HsBinds)</li>
<li>HsExpr (HsDecls, HsPat)</li>
</ul>
<h2 id="library-stuff-base-package">Library stuff: base package</h2>
<ul>
<li>GHC.Base</li>
<li>Data.Tuple (GHC.Base), GHC.Ptr (GHC.Base)</li>
<li>GHC.Enum (Data.Tuple)</li>
<li>GHC.Show (GHC.Enum)</li>
<li>GHC.Num (GHC.Show)</li>
<li>GHC.ST (GHC.Num), GHC.Real (GHC.Num)</li>
<li>GHC.Arr (GHC.ST) GHC.STRef (GHC.ST)</li>
<li>GHC.IOBase (GHC.Arr)</li>
<li>Data.Bits (GHC.Real)</li>
<li>Data.HashTable (Data.Bits, Control.Monad)</li>
<li>Data.Typeable (GHC.IOBase, Data.HashTable)</li>
<li>GHC.Weak (Data.Typeable, GHC.IOBase)</li>
</ul>
<h2 id="high-level-dependency-graph">High-level Dependency Graph</h2>
<p>Dark red edges indicate that only one module in one group depends on a module in the other group. Dark green means 11 or more dependencies. Arrows point from the importing module to the imported module.</p>
<p><a href="Image(dep5.png)" class="uri" title="wikilink">Image(dep5.png)</a></p>
<h1 id="module-types">Module Types</h1>
<p>Here we attempt to describe some of the main data structures involved in GHC's representation and handling of Haksell modules. GHC uses a number of different data types to represent modules, for efficiency (some types load less information) and categorising how other modules relate to the one being compiled. Most these types are defined in <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a>.</p>
<h2 id="module">Module</h2>
<p>Location: <a href="GhcFile(compiler/basicTypes/Module.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Module.lhs)</a></p>
<p>The <strong>Module</strong> data type is simply an identifier of a module; its fully qualified name.</p>
<pre><code>-- | A Module is a pair of a &#39;PackageId&#39; and a &#39;ModuleName&#39;.
data Module = Module {
   modulePackageId :: &lt;nowiki&gt;PackageId,&lt;/nowiki&gt;  -- pkg-1.0
   moduleName      :: &lt;nowiki&gt;ModuleName&lt;/nowiki&gt;  -- A.B.C
  }
  deriving (Eq, Ord)

newtype ModuleName = ModuleName FastString</code></pre>
<h2 id="modiface">ModIface</h2>
<p>Location: <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a></p>
<p>The <strong>ModIface''' data type is one of the fullest representations of a module. It is a complete representation of a modules interface file (</strong>.hi'''). It is this data structure that is serialised to produce a modules <strong>.hi</strong> file.</p>
<h2 id="moddetails">ModDetails</h2>
<p>Location: <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a></p>
<p>'''ModDetails''' is essentially a cache for information in the '''ModIface''' for home modules only. It stores information about a module after linking has taken place. '''ModIface''' stores information about a module before linking. Information stored in a '''ModDetails''' is created from a '''ModIface''', typically during type checking.</p>
<h3 id="modguts">ModGuts</h3>
<p>Location: <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a></p>
<p>A '''ModGuts''' is carried through the compiler, accumulating stuff as it goes. There is only one '''ModGuts''' at any time, the one for the module being compiled right now. Once it is compiled, a '''ModIface''' and '''ModDetails''' are extracted and the '''ModGuts''' is discarded.</p>
<h2 id="modsummary">ModSummary</h2>
<p>Location: <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a></p>
<p>A '''ModSummary''' stores a summary of a module that is suitable for recompilation checking. A '''ModSummary''' is a node in the compilation manager's dependency graph.</p>
<h2 id="homemodinfo">HomeModInfo</h2>
<p>Location: <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a></p>
<p>A '''HomeModInfo''' stores information about a module in the package being compiled. It simply stores for the '''ModIface''', '''ModDetails''' and linkage information about a single module.</p>
<h2 id="homepackagetable">HomePackageTable</h2>
<p>Location: <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a></p>
<p>The home package table describes already-compiled home-package modules, /excluding/ the module we are compiling right now.</p>
<h2 id="externalpackagestate">ExternalPackageState</h2>
<p>Location: <a href="GhcFile(compiler/main/HscTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/main/HscTypes.lhs)</a></p>
<p>Stores information about other packages that we have pulled in while compiling the current module.</p>
<h1 id="multi-instance-packages">Multi-instance packages</h1>
<p>This page is about how to change the package system to allow multiple instances of a package to be installed at the same time. There are two reasons we want to be able to do this:</p>
<ul>
<li>To be able to track the different &quot;ways&quot; in which a package is available: e.g. profiling, dynamic. At the moment, the package database doesn't track this information, with the result that the user has to reinstall packages with
<pre><code>--enable-profiling</code></pre>
<p>on a trial-and-error basis in order to get profiling support for packages they have already installed.</p></li>
</ul>
<p><code>  The same holds, in principle, for different flag settings or other configuration variations of a package.</code></p>
<ul>
<li>To make installing new packages more robust. When installing a new package, we sometimes need to upgrade packages that are already installed to new versions, which may require recompiling other packages against the new version. For example, if we have P1 installed, Q1 depends on P (any version), and we need to install R that depends on both P2 and Q1. We need to build P2, rebuild Q1 against P2, and finally build R against P2 and the new Q1. We would like to do this without removing P1 or the old Q1 from the package database, because other packages may be depending on the old Q1, and we don't want to break those packages (which is what currently happens with GHC 7.0).</li>
</ul>
<p>See also</p>
<ul>
<li>[wiki:Commentary/Packages Commentary pages about packages]</li>
<li>Philipp Schuster's GSoC project <a href="http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/phischu/1">proposal (DEAD)</a>, <a href="http://www.google-melange.com/gsoc/project/google/gsoc2012/phischu/19001">GSoC project page (DEAD)</a>, [wiki:Commentary/GSoCMultipleInstances Trac wiki page], <a href="https://github.com/phischu/cabal">git repo</a>, and <a href="https://www.youtube.com/watch?v=h4QmkyN28Qs">video</a>.</li>
<li><a href="http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html">Mikhail's post</a> about Cabal sandboxes.</li>
<li>Mailing list stuff <a href="http://comments.gmane.org/gmane.comp.lang.haskell.ghc.devel/443">here</a> and <a href="http://markmail.org/message/4qvegvx32lhlo66g#query:+page:1+mid:bwdgykv4g2hzqg5t+state:results">here</a>.</li>
</ul>
<h2 id="todo-list">ToDo list</h2>
<ul>
<li>ghc-pkg: do not overwrite previous instances in the package DB
<ul>
<li>but we need to think about the case where we overwrite an existing package on the file system and re-register. This will happen with local (or in-place) package registration that occurs when building a bunch of related components. In this case the tool should know it's doing that and unregister the old instance first (though reliably tracking that state may be tricky, since users can make clean etc). We should check make it a checked error to re-register in the same filesystem location with new package id, without unregistering the old one first. Perhaps we can identify some key file.</li>
</ul></li>
</ul>
<ul>
<li>GHC: discard conflicting instances during its shadowing phase
<ul>
<li>SDM: GHC will currently do *something* here, but it might end up with a result that the user didn't want/expect. One way to improve things is to prioritise packages that were installed more recently.</li>
<li>Andres suggests that GHC should be much cleverer, and look at the actual dependencies of the modules being compiled before deciding which packages to enable. This would almost certainly result in more things working and possibly less surprising behaviour sometimes, but Simon thinks that (a) it is too hard, (b) if users need this, they should use Cabal and its dependency resolver, which will do a good job, (c) you can often resolve problems by adding
<pre><code>-package X`, and (d) eventually we will want a system where users manage separate sessions, so they can set up an environment in which the packages they want are available.  This has a lot in common with `cabal-dev</code></pre>
<p>and sandboxes, so the mechanisms (and concepts) should be shared. (kosmikus: perhaps an alternative is to force the user to make an active decision in case of conflicts, i.e., to create a sandbox that exposes a consistent package set).</p></li>
</ul></li>
</ul>
<ul>
<li>GHC: allow specifying a package instance in the -package flags
<ul>
<li>SDM: already done (-package-id flag)</li>
<li>DC: already used by Cabal</li>
</ul></li>
</ul>
<ul>
<li>Cabal: allow specifying a package instance when doing Setup.hs configure
<ul>
<li>DC: currently only == version constraints can be used, not installed package id. Shouldn't be too hard to add however.</li>
<li>JT: Done according to DC.</li>
</ul></li>
</ul>
<ul>
<li>instances of packages must install in a different location
<ul>
<li>install directory includes hash?</li>
<li>SDM: not done yet. One problem is that we don't know the hash until the package is built, but we need to know the install locations earlier because we bake them into
<pre><code>Paths_foo.hs</code></pre>
<p>.</p></li>
<li>Simon and Andres discussed that one option is to let Cabal compute its own hash. However, then we'd have two hashes to deal with. Only using the Cabal-computed hash isn't an option either according to Simon, because apparently GHC's ABI hash computation is non-deterministic, so we might end up with situations where Cabal's hash is stable, but GHC computes an ABI-incompatible version. This is somewhat worrying ...</li>
<li>Duncan thinks that we should store both a package identity and a package ABI hash. Currently we form the package id from the name, version and ABI hash. We should store the ABI hash separately anyway because eventually we will want to know it, to know which packages are ABI compatible. So Cabal can compute a package Id in advance, however is sensible, and the ABI hash is calculated as now, after the build. The installation directory follows the package Id.</li>
</ul></li>
</ul>
<ul>
<li>Cabal: will the dependency solver work correctly in the presence of multiple package instances?
<ul>
<li>Andres claims it will using the new solver. (There is now no point in updating the old solver, though it'd be technically possible.) A little bit more detail: the modular solver has no concept of shadowing, only of preference. So if several instances are provided by one or more package DBs, they'll all be valid choices.</li>
</ul></li>
</ul>
<ul>
<li>ghc-pkg cleanup: remove old/unused instances of packages
<ul>
<li>how can we tell when something is unnecessary? This is actually rather hard because unlike Nix we do not track every random executable that the user compiles.</li>
</ul></li>
</ul>
<h2 id="next-step-dealing-with-ways">Next step: dealing with ways</h2>
<ul>
<li>Add the &quot;way&quot; to InstalledPackageInfo, include the way in the hash</li>
</ul>
<ul>
<li>GHC: slice the package DB during startup according to the correct way</li>
</ul>
<ul>
<li>Cabal: fix up the dep resolver (kosmikus: anything still needed there?)</li>
</ul>
<ul>
<li>Cabal: ways? (this would be really easy, if we could get more information about installed packages back from ghc-pkg)</li>
</ul>
<ul>
<li>To handle flags and other config, add two new fields to InstalledPackageInfo:
<pre><code>install-agent: {agent-id}` which identifies cabal/rpm/etc and then `configuration: {free text}</code></pre>
<p>. The interpretation of the configuration string depends on the installation agent, and need be known only to that agent. This way, agents can see if it was them that installed a package, and so they should know how to interpret the config string. For cabal this would include config flags etc. It should make it possible to reproduce a package, e.g. if we have to rebuild for some reason, or to get the profiling equiv of a normal instance.</p></li>
</ul>
<p>= The</p>
<pre><code>Name</code></pre>
<p>type =</p>
<p>Every entity (type constructor, class, identifier, type variable) has a</p>
<pre><code>Name</code></pre>
<p>. The Name type is pervasive in GHC, and is defined in <a href="GhcFile(compiler/basicTypes/Name.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Name.hs)</a>. Here is what a</p>
<pre><code>Name</code></pre>
<p>looks like, though it is private to the Name module:</p>
<pre><code>data Name = Name {
          n_sort :: NameSort,   -- What sort of name it is
          n_occ  :: &lt;nowiki&gt;OccName,&lt;/nowiki&gt;   -- Its occurrence name
          n_uniq :: Int#,       -- Its identity
          n_loc  :: &lt;nowiki&gt;SrcLoc&lt;/nowiki&gt;     -- Definition site
      }</code></pre>
<ul>
<li>The
<pre><code>n_sort</code></pre>
<p>field says what sort of name this is: see <strong>[wiki:Commentary/Compiler/NameType#TheNameSortofaName NameSort]</strong> below.</p></li>
<li>The
<pre><code>n_occ</code></pre>
<p>field gives the &quot;occurrence name&quot;, or <strong>[wiki:Commentary/Compiler/RdrNameType#TheOccNametype OccName]</strong>, of the Name.</p></li>
<li>The
<pre><code>n_uniq</code></pre>
<p>field allows fast tests for equality of Names.</p></li>
<li>The
<pre><code>n_loc</code></pre>
<p>field gives some indication of where the name was bound.</p></li>
</ul>
<p>== The</p>
<pre><code>NameSort</code></pre>
<p>of a Name ==</p>
<p>There are four flavours of Name:</p>
<pre><code>data NameSort
  = External Module (Maybe Name)
    -- (Just parent) =&gt; this Name is a subordinate name of &#39;parent&#39;
    -- e.g. data constructor of a data type, method of a class
    -- Nothing =&gt; not a subordinate
 
  | WiredIn Module (Maybe Name) TyThing BuiltInSyntax
    -- A variant of External, for wired-in things

  | Internal        -- A user-defined Id or TyVar
            -- defined in the module being compiled

  | System      -- A system-defined Id or TyVar.  Typically the
            -- OccName is very uninformative (like &#39;s&#39;)</code></pre>
<pre><code>Internal</code></pre>
<p>,</p>
<pre><code>System</code></pre>
<dl>

<dd><dl>

<dd>
</dd>
</dl>
</dd>
</dl>
<p><code>   An </code></p>
<pre><code>Internal</code></pre>
<pre><code>Name</code></pre>
<p>has only an occurrence name. Distinct</p>
<pre><code>Internal</code></pre>
<pre><code>Names</code></pre>
<p>may have the same occurrence name; the</p>
<pre><code>n_uniq</code></pre>
<p>distinguishes them.</p>
<p><code>There is only a tiny difference between </code></p>
<pre><code>Internal</code></pre>
<p>and</p>
<pre><code>System</code></pre>
<dl>
<dt>the former simply remembers that the name was originally written by the programmer, which helps when generating error messages.</dt>

</dl>
<pre><code>External</code></pre>
<dl>

<dd><dl>

<dd>
</dd>
</dl>
</dd>
</dl>
<p><code>   An </code></p>
<pre><code>External</code></pre>
<pre><code>Name</code></pre>
<p>has a globally-unique (module, occurrence name) pair, namely the original name of the entity, that describes where the thing was originally defined. So for example, if we have</p>
<pre><code>module M where
  f = e1
  g = e2

module A where
  import qualified M as Q
  import M
  a = Q.f + g</code></pre>
<p><code>   then in module </code></p>
<pre><code>A</code></pre>
<p>, the function</p>
<pre><code>Q.f</code></pre>
<p>has an External Name</p>
<pre><code>M.f</code></pre>
<p>.</p>
<p><code> During any invocation of GHC, each (module, occurrence-name) gets one, and only one, </code></p>
<pre><code>Unique</code></pre>
<p>, stored in the</p>
<pre><code>n_uniq</code></pre>
<p>field of the</p>
<pre><code>Name</code></pre>
<p>. This association remains fixed even when GHC finishes one module and starts to compile another. This association between (module, occurrence-name) pairs and the corresponding</p>
<pre><code>Name</code></pre>
<p>(with its</p>
<pre><code>n_uniq</code></pre>
<p>field) is maintained by the Name Cache.</p>
<p>;</p>
<pre><code>WiredIn</code></pre>
<dl>

<dd>A
<pre><code>WiredIn</code></pre>
<pre><code>Name</code></pre>
<p>is a special sort of</p>
<pre><code>External</code></pre>
<pre><code>Name</code></pre>
<p>, one that is completely known to the compiler (e.g. the</p>
<pre><code>Bool</code></pre>
<p>type constructor). See [wiki:Commentary/Compiler/WiredIn].</p>
</dd>
</dl>
<p><code> The </code></p>
<pre><code>BuiltInSyntax</code></pre>
<p>field is just a boolean yes/no flag that identifies entities that are denoted by built-in syntax, such as</p>
<pre><code>[]</code></pre>
<p>for the empty list. These</p>
<pre><code>Names</code></pre>
<p>aren't &quot;in scope&quot; as such, and we occasionally need to know that.</p>
<p>== Entities and</p>
<pre><code>Names</code></pre>
<p>==</p>
<p>Here are the sorts of Name an entity can have:</p>
<ul>
<li>Class: always has an
<pre><code>External</code></pre>
<p>Name.</p></li>
</ul>
<ul>
<li>TyCon: always has an
<pre><code>External</code></pre>
<p>or</p>
<pre><code>WiredIn</code></pre>
<p>Name.</p></li>
</ul>
<ul>
<li>TyVar: can have
<pre><code>Internal</code></pre>
<p>, or</p>
<pre><code>System</code></pre>
<p>Names; the former are ones arise from instantiating programmer-written type signatures.</p></li>
</ul>
<ul>
<li>Ids: can have
<pre><code>External</code></pre>
<p>,</p>
<pre><code>Internal</code></pre>
<p>, or</p>
<pre><code>System</code></pre>
<p>Names.</p>
<ul>
<li>Before CoreTidy, the Ids that were defined at top level in the original source program get
<pre><code>External</code></pre>
<p>Names, whereas extra top-level bindings generated (say) by the type checker get</p>
<pre><code>Internal</code></pre>
<p>Names. This distinction is occasionally useful for filtering diagnostic output; e.g. for</p>
<pre><code>-ddump-types</code></pre>
<p>.</p></li>
<li>After CoreTidy: An Id with an
<pre><code>External</code></pre>
<p>Name will generate symbols that appear as external symbols in the object file. An Id with an</p>
<pre><code>Internal</code></pre>
<p>Name cannot be referenced from outside the module, and so generates a local symbol in the object file. The CoreTidy pass makes the decision about which names should be External and which Internal.</p></li>
</ul></li>
</ul>
<h1 id="native-code-generator-ncg">Native Code Generator (NCG)</h1>
<p>For other information related to this page, see:</p>
<ul>
<li>[wiki:BackEndNotes] for optimisation ideas regarding the current NCG</li>
<li>[wiki:Commentary/Compiler/CmmType The Cmm language] (the NCG code works from Haskell's implementation of C-- and many optimisations in the NCG relate to Cmm)</li>
<li>[wiki:Commentary/Compiler/Backends/NCG/RegisterAllocator The register allocator].</li>
</ul>
<p>On some platforms (currently x86 and x86_64, with possibly bitrotted support for PowerPC and Sparc), GHC can generate assembly code directly. The NCG is enabled by default on supported platforms.</p>
<p>The NCG has always been something of a second-class citizen inside GHC, an unloved child, rather. This means that its integration into the compiler as a whole is rather clumsy, which brings some problems described below. That apart, the NCG proper is fairly cleanly designed, as target-independent as it reasonably can be, and so should not be difficult to retarget.</p>
<p>NOTE! The native code generator was largely rewritten as part of the C-- backend changes, around May 2004. Unfortunately the rest of this document still refers to the old version, and was written with relation to the CVS head as of end-Jan 2002. Some of it is relevant, some of it isn't.</p>
<h3 id="files-parts">Files, Parts</h3>
<p>After GHC has produced [wiki:Commentary/Compiler/CmmType Cmm] (use -ddump-cmm or -ddump-opt-cmm to view), the Native Code Generator (NCG) transforms Cmm into architecture-specific assembly code. The NCG is located in <a href="GhcFile(compiler/nativeGen)" class="uri" title="wikilink">GhcFile(compiler/nativeGen)</a> and is separated into eight modules:</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/AsmCodeGen.lhs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/AsmCodeGen.lhs)</a><br />
</li>
</ul>
<p><code>  top-level module for the NCG, imported by </code><a href="GhcFile(compiler/main/CodeOutput.lhs)" title="wikilink"><code>GhcFile(compiler/main/CodeOutput.lhs)</code></a><code>; also defines the Monad for optimising generic Cmm code, </code></p>
<pre><code>CmmOptM</code></pre>
<p><br />
<br />
* <a href="GhcFile(compiler/nativeGen/MachCodeGen.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/MachCodeGen.hs)</a><br />
 generates architecture-specific instructions (a Haskell-representation of assembler) from Cmm code<br />
<br />
* <a href="GhcFile(compiler/nativeGen/MachInstrs.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/MachInstrs.hs)</a><br />
 contains data definitions and some functions (comparison, size, simple conversions) for machine instructions, mostly carried out through the</p>
<pre><code>Instr</code></pre>
<p>data type, defined here<br />
<br />
* <a href="GhcFile(compiler/nativeGen/NCGMonad.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/NCGMonad.hs)</a><br />
 defines the the main monad in the NCG: the Native code Machine instruction Monad,</p>
<pre><code>NatM</code></pre>
<p>, and related functions. ''Note: the NCG switches between two monads at times, especially in</p>
<pre><code>AsmCodeGen</code></pre>
<dl>

<dd><pre><code>NatM</code></pre>
<p>and the</p>
<pre><code>UniqSM</code></pre>
<p>Monad used throughout the compiler.''<br />
<br />
</p>
</dd>
</dl>
<ul>
<li><a href="GhcFile(compiler/nativeGen/PIC.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/PIC.hs)</a><br />
</li>
</ul>
<p><code>  handles generation of position independent code and issues related to dynamic linking in the NCG; related to many other modules outside the NCG that handle symbol import, export and references, including </code></p>
<pre><code>CLabel</code></pre>
<p>,</p>
<pre><code>Cmm</code></pre>
<p>,</p>
<pre><code>codeGen</code></pre>
<p>and the RTS, and the Mangler<br />
<br />
* <a href="GhcFile(compiler/nativeGen/PprMach.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/PprMach.hs)</a><br />
 Pretty prints machine instructions (</p>
<pre><code>Instr</code></pre>
<p>) to assembler code (currently readable by GNU's</p>
<pre><code>as</code></pre>
<p>), with some small modifications, especially for comparing and adding floating point numbers on x86 architectures<br />
<br />
* <a href="GhcFile(compiler/nativeGen/RegAllocInfo.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegAllocInfo.hs)</a><br />
 defines the main register information function,</p>
<pre><code>regUsage</code></pre>
<p>, which takes a set of real and virtual registers and returns the actual registers used by a particular</p>
<pre><code>Instr</code></pre>
<p>; register allocation is in AT&amp;T syntax order (source, destination), in an internal function,</p>
<pre><code>usage</code></pre>
<p>; defines the</p>
<pre><code>RegUsage</code></pre>
<p>data type<br />
<br />
* <a href="GhcFile(compiler/nativeGen/RegisterAlloc.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegisterAlloc.hs)</a><br />
 one of the most complicated modules in the NCG,</p>
<pre><code>RegisterAlloc</code></pre>
<p>manages the allocation of registers for each <em>basic block</em> of Haskell-abstracted assembler code: management involves <em>liveness</em> analysis, allocation or deletion of temporary registers, <em>spilling</em> temporary values to the <em>spill stack</em> (memory) and many optimisations. ''See [wiki:Commentary/Compiler/CmmType The Cmm language] for the definition of a <em>basic block</em> (in Haskell, ''</p>
<pre><code>type CmmBasicBlock =  GenBasicBlock CmmStmt</code></pre>
<p><em>).</em></p>
<p>and one header file:</p>
<ul>
<li><a href="GhcFile(compiler/nativeGen/NCG.h)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/NCG.h)</a><br />
</li>
</ul>
<p><code>  defines macros used to separate architecture-specific code in the Haskell NCG files; since GHC currently only generates machine code for the architecture on which it was compiled (GHC is not currently a cross-compiler), the Haskell NCG files become considerably smaller after preprocessing; ideally all architecture-specific code would reside in separate files and GHC would have them available to support cross-compiler capabilities.</code></p>
<p>The NCG has <strong>machine-independent</strong> and <strong>machine-dependent</strong> parts.</p>
<p>The <strong>machine-independent</strong> parts relate to generic operations, especially optimisations, on Cmm code. The main machine-independent parts begin with <em>Cmm blocks.</em> (A <em>Cmm block</em> is a compilation unit of Cmm code, a file. See [wiki:Commentary/Compiler/CmmType The Cmm language] for a discussion of what a <em>Cmm block</em> is but note that <em>Cmm</em> is a type synonym for</p>
<pre><code>GenCmmTop CmmStatic CmmStmt</code></pre>
<p>.) A machine-specific (assembler) instruction is represented as a</p>
<pre><code>Instr</code></pre>
<p>. The machine-independent NCG parts:</p>
<ol>
<li>optimise each Cmm block by reordering its basic blocks from the original order (the
<pre><code>Instr</code></pre>
<p>order from the</p>
<pre><code>Cmm</code></pre>
<p>) to minimise the number of branches between basic blocks, in other words, by maximising fallthrough of execution from one basic block to the next.<br />
<br />
</p></li>
<li>lazily convert each Cmm block to abstract machine instructions (
<pre><code>Instr</code></pre>
<p>) operating on an infinite number of registers--since the NCG Haskell files only contain instructions for the host computer on which GHC was compiled, these</p>
<pre><code>Instr</code></pre>
<p>are machine-specific; and,<br />
<br />
</p></li>
<li>lazily allocate real registers for each basic block, based on the number of available registers on the target (currently, only the host) machine; for example, 32 integer and 32 floating-point registers on the PowerPC architecture. The NCG does not currently have support for SIMD registers such as the vector registers for Altivec or any variation of SSE.<br />
<em>Note</em>: if a basic block simultaneously requires more registers than are available on the target machine and the temporary variable needs to be used (would sill be <em>live</em>) after the current instruction, it will be moved (<em>spilled</em>) into memory.</li>
</ol>
<p>The <strong>machine-dependent</strong> parts:</p>
<ol>
<li><ol>
<li>define the abstract (Haskell) assembler
<pre><code>Instr</code></pre>
<p>for the target (host) machine and convert every Cmm block into it;</p></li>
<li>define, manage and allocate the real registers available on the target system;</li>
<li>pretty-print the Haskell-assembler to GNU AS (GAS) assembler code</li>
</ol></li>
</ol>
<h2 id="overview-3">Overview</h2>
<p>The top-level code generator function is</p>
<pre><code>absCtoNat :: AbstractC -&gt; UniqSM (SDoc, Pretty.Doc)</code></pre>
<p>The returned</p>
<pre><code>SDoc` is for debugging, so is empty unless you specify `-ddump-stix`. The `Pretty.Doc</code></pre>
<p>bit is the final assembly code. Translation involves three main phases, the first and third of which are target-independent.</p>
<h4 id="translation-into-the-stix-representation">Translation into the Stix representation</h4>
<p>Stix is a simple tree-like RTL-style language, in which you can mention:</p>
<ul>
<li>An infinite number of temporary, virtual registers.</li>
<li>The STG &quot;magic&quot; registers (
<pre><code>MagicId</code></pre>
<p>), such as the heap and stack pointers.</p></li>
<li>Literals and low-level machine ops (
<pre><code>MachOp</code></pre>
<p>).</p></li>
<li>Simple address computations.</li>
<li>Reads and writes of: memory, virtual regs, and various STG regs.</li>
<li>Labels and
<pre><code>if ... goto ...</code></pre>
<p>style control-flow.</p></li>
</ul>
<p>Stix has two main associated types:</p>
<ul>
<li><pre><code>StixStmt</code></pre>
<p>-- trees executed for their side effects: assignments, control transfers, and auxiliary junk such as segment changes and literal data.</p></li>
<li><pre><code>StixExpr</code></pre>
<p>-- trees which denote a value.</p></li>
</ul>
<p>Translation into Stix is almost completely target-independent. Needed dependencies are knowledge of word size and endianness, used when generating code to do deal with half-word fields in info tables. This could be abstracted out easily enough. Also, the Stix translation needs to know which</p>
<pre><code>MagicId`s map to registers on the given target, and which are stored in offsets from `BaseReg</code></pre>
<p>.</p>
<p>After initial Stix generation, the trees are cleaned up with constant-folding and a little copy-propagation (&quot;Stix inlining&quot;, as the code misleadingly calls it). We take the opportunity to translate</p>
<pre><code>MagicId</code></pre>
<p>s which are stored in memory on the given target, into suitable memory references. Those which are stored in registers are left alone. There is also a half-hearted attempt to lift literal strings to the top level in cases where nested strings have been observed to give incorrect code in the past.</p>
<p>Primitive machine-level operations will already be phrased in terms of</p>
<pre><code>MachOp`s in the presented Abstract C, and these are passed through unchanged. We comment only that the `MachOp</code></pre>
<p>s have been chosen so as to be easy to implement on all targets, and their meaning is intended to be unambiguous, and the same on all targets, regardless of word size or endianness.</p>
<p>'''A note on</p>
<pre><code>MagicId`s&#39;&#39;&#39;. Those which are assigned to registers on the current target are left unmodified. Those which are not are stored in memory as offsets from `BaseReg` (which is assumed to permanently have the value (`&amp;MainCapability.r`)), so the constant folder calculates the offsets and inserts suitable loads/stores. One complication is that not all archs have `BaseReg` itself in a register, so for those (sparc), we instead generate the address as an offset from the static symbol `MainCapability</code></pre>
<p>, since the register table lives in there.</p>
<p>Finally,</p>
<pre><code>BaseReg` does occasionally itself get mentioned in Stix expression trees, and in this case what is denoted is precisely (`&amp;MainCapability.r`), not, as in all other cases, the value of memory at some offset from the start of the register table. Since what it denotes is an r-value and not an l-value, assigning `BaseReg</code></pre>
<p>is meaningless, so the machinery checks to ensure this never happens. All these details are taken into account by the constant folder.</p>
<h4 id="instruction-selection-1">Instruction selection</h4>
<p>This is the only majorly target-specific phase. It turns Stix statements and expressions into sequences of</p>
<pre><code>Instr`, a data type which is different for each architecture. Instr, unsurprisingly, has various supporting types, such as `Reg`, `Operand`, `Imm</code></pre>
<p>, etc. The generated instructions may refer to specific machine registers, or to arbitrary virtual registers, either those created within the instruction selector, or those mentioned in the Stix passed to it.</p>
<p>The instruction selectors live in</p>
<pre><code>MachCode.lhs</code></pre>
<p>. The core functions, for each target, are:</p>
<pre><code>getAmode :: StixExpr -&gt; NatM Amode
getRegister :: StixExpr -&gt; NatM Register
assignMem_IntCode :: PrimRep -&gt; StixExpr -&gt; StixExpr -&gt; NatM InstrBlock
assignReg_IntCode :: PrimRep -&gt; StixReg -&gt; StixExpr -&gt; NatM InstrBlock</code></pre>
<p>The insn selectors use the &quot;maximal munch&quot; algorithm. The bizarrely-misnamed</p>
<pre><code>getRegister</code></pre>
<p>translates expressions. A simplified version of its type is:</p>
<pre><code>getRegister :: StixExpr -&gt; NatM (OrdList Instr, Reg)</code></pre>
<p>That is: it (monadically) turns a StixExpr into a sequence of instructions, and a register, with the meaning that after executing the (possibly empty) sequence of instructions, the (possibly virtual) register will hold the resulting value. The real situation is complicated by the presence of fixed registers, and is detailed below.</p>
<p>Maximal munch is a greedy algorithm and is known not to give globally optimal code sequences, but it is good enough, and fast and simple. Early incarnations of the NCG used something more sophisticated, but that is long gone now.</p>
<p>Similarly,</p>
<pre><code>getAmode` translates a value, intended to denote an address, into a sequence of insns leading up to a (processor-specific) addressing mode. This stuff could be done using the general `getRegister</code></pre>
<p>selector, but would necessarily generate poorer code, because the calculated address would be forced into a register, which might be unnecessary if it could partially or wholly be calculated using an addressing mode.</p>
<p>Finally,</p>
<pre><code>assignMem_IntCode` and `assignReg_IntCode</code></pre>
<p>create instruction sequences to calculate a value and store it in the given register, or at the given address. Because these guys translate a statement, not a value, they just return a sequence of insns and no associated register. Floating-point and 64-bit integer assignments have analogous selectors.</p>
<p>Apart from the complexities of fixed vs floating registers, discussed below, the instruction selector is as simple as it can be. It looks long and scary but detailed examination reveals it to be fairly straightforward.</p>
<h4 id="register-allocation-1">Register allocation</h4>
<p>The register allocator,</p>
<pre><code>AsmRegAlloc.lhs` takes sequences of Instrs which mention a mixture of real and virtual registers, and returns a modified sequence referring only to real ones. It is gloriously and entirely target-independent. Well, not exactly true. Instead it regards `Instr` (instructions) and `Reg</code></pre>
<p>(virtual and real registers) as abstract types, to which it has the following interface:</p>
<pre><code>insnFuture :: Instr -&gt; InsnFuture
regUsage :: Instr -&gt; RegUsage
patchRegs :: Instr -&gt; (Reg -&gt; Reg) -&gt; Instr</code></pre>
<pre><code>insnFuture` is used to (re)construct the graph of all possible control transfers between the insns to be allocated. `regUsage` returns the sets of registers read and written by an instruction. And `patchRegs</code></pre>
<p>is used to apply the allocator's final decision on virtual-to-real reg mapping to an instruction.</p>
<p>Clearly these 3 fns have to be written anew for each architecture. They are defined in</p>
<pre><code>RegAllocInfo.lhs</code></pre>
<p>. Think twice, no, thrice, before modifying them: making false claims about insn behaviour will lead to hard-to-find register allocation errors.</p>
<pre><code>AsmRegAlloc.lhs</code></pre>
<p>contains detailed comments about how the allocator works. Here is a summary. The head honcho</p>
<pre><code>allocUsingTheseRegs :: [Instr] -&gt; [Reg] -&gt; (Bool, [Instr])</code></pre>
<p>takes a list of instructions and a list of real registers available for allocation, and maps as many of the virtual regs in the input into real ones as it can. The returned</p>
<pre><code>Bool` indicates whether or not it was successful. If so, that&#39;s the end of it. If not, the caller of `allocUsingTheseRegs` will attempt spilling. More of that later. What `allocUsingTheseRegs</code></pre>
<p>does is:</p>
<ul>
<li>Implicitly number each instruction by its position in the input list.</li>
<li>Using
<pre><code>insnFuture</code></pre>
<p>, create the set of all flow edges -- possible control transfers -- within this set of insns.</p></li>
<li>Using
<pre><code>regUsage</code></pre>
<p>and iterating around the flow graph from the previous step, calculate, for each virtual register, the set of flow edges on which it is live.</p></li>
<li>Make a real-register committment map, which gives the set of edges for which each real register is committed (in use). These sets are initially empty. For each virtual register, attempt to find a real register whose current committment does not intersect that of the virtual register -- ie, is uncommitted on all edges that the virtual reg is live. If successful, this means the vreg can be assigned to the realreg, so add the vreg's set to the realreg's committment.</li>
<li>If all the vregs were assigned to a realreg, use
<pre><code>patchInstr</code></pre>
<p>to apply the mapping to the insns themselves.</p></li>
</ul>
<h3 id="spilling">Spilling</h3>
<p>If</p>
<pre><code>allocUsingTheseRegs</code></pre>
<p>fails, a baroque mechanism comes into play. We now know that much simpler schemes are available to do the same thing and give better results. Anyways:</p>
<p>The logic above</p>
<pre><code>allocUsingTheseRegs`, in `doGeneralAlloc` and `runRegAllocate`, observe that allocation has failed with some set R of real registers. So they apply `runRegAllocate` a second time to the code, but remove (typically) two registers from R before doing so. This naturally fails too, but returns a partially-allocated sequence. `doGeneralAlloc` then inserts spill code into the sequence, and finally re-runs `allocUsingTheseRegs</code></pre>
<p>, but supplying the original, unadulterated R. This is guaranteed to succeed since the two registers previously removed from R are sufficient to allocate all the spill/restore instructions added.</p>
<p>Because x86 is very short of registers, and in the worst case needs three removed from R, a softly-softly approach is used.</p>
<pre><code>doGeneralAlloc` first tries with zero regs removed from R, then if that fails one, then two, etc. This means `allocUsingTheseRegs` may get run several times before a successful arrangement is arrived at. `findReservedRegs</code></pre>
<p>cooks up the sets of spill registers to try with.</p>
<p>The resulting machinery is complicated and the generated spill code is appalling. The saving grace is that spills are very rare so it doesn't matter much. I did not invent this -- I inherited it.</p>
<h3 id="dealing-with-common-cases-fast">Dealing with common cases fast</h3>
<p>The entire reg-alloc mechanism described so far is general and correct, but expensive overkill for many simple code blocks. So to begin with we use</p>
<pre><code>doSimpleAlloc`, which attempts to do something simple. It exploits the observation that if the total number of virtual registers does not exceed the number of real ones available, we can simply dole out a new realreg each time we see mention of a new vreg, with no regard for control flow. `doSimpleAlloc</code></pre>
<p>therefore attempts this in a single pass over the code. It gives up if it runs out of real regs or sees any condition which renders the above observation invalid (fixed reg uses, for example).</p>
<p>This clever hack handles the majority of code blocks quickly. It was copied from the previous reg-allocator (the Mattson/Partain/Marlow/Gill one).</p>
<h2 id="complications-observations-and-possible-improvements">Complications, observations, and possible improvements</h2>
<h3 id="real-vs-virtual-registers-in-the-instruction-selectors">Real vs virtual registers in the instruction selectors</h3>
<p>The instruction selectors for expression trees, namely</p>
<pre><code>getRegister</code></pre>
<p>, are complicated by the fact that some expressions can only be computed into a specific register, whereas the majority can be computed into any register. We take x86 as an example, but the problem applies to all archs.</p>
<p>Terminology:</p>
<pre><code>rreg` means real register, a real machine register. `vreg` means one of an infinite set of virtual registers. The type `Reg` is the sum of `rreg` and `vreg</code></pre>
<p>. The instruction selector generates sequences with unconstrained use of vregs, leaving the register allocator to map them all into rregs.</p>
<p>Now, where was I ? Oh yes. We return to the type of</p>
<pre><code>getRegister</code></pre>
<p>, which despite its name, selects instructions to compute the value of an expression tree.</p>
<pre><code>getRegister :: StixExpr -&gt; NatM Register

data Register
  = Fixed   PrimRep Reg InstrBlock
  | Any     PrimRep (Reg -&gt; InstrBlock)

type InstrBlock -- sequence of instructions</code></pre>
<p>At first this looks eminently reasonable (apart from the stupid name).</p>
<pre><code>getRegister`, and nobody else, knows whether or not a given expression has to be computed into a fixed rreg or can be computed into any rreg or vreg. In the first case, it returns `Fixed` and indicates which rreg the result is in. In the second case it defers committing to any specific target register by returning a function from `Reg` to `InstrBlock</code></pre>
<p>, and the caller can specify the target reg as it sees fit.</p>
<p>Unfortunately, that forces</p>
<pre><code>getRegister`&#39;s callers (usually itself) to use a clumsy and confusing idiom in the common case where they do not care what register the result winds up in. The reason is that although a value might be computed into a fixed rreg, we are forbidden (on pain of segmentation fault :) from subsequently modifying the fixed reg. This and other rules are record in &quot;Rules of the game&quot; inside `MachCode.lhs</code></pre>
<p>.</p>
<p>Why can't fixed registers be modified post-hoc? Consider a simple expression like</p>
<pre><code>Hp+1`. Since the heap pointer `Hp` is definitely in a fixed register, call it R, `getRegister` on subterm `Hp` will simply return Fixed with an empty sequence and R. But we can&#39;t just emit an increment instruction for R, because that trashes `Hp</code></pre>
<dl>
<dt>instead we first have to copy it into a fresh vreg and increment that.</dt>

</dl>
<p>With all that in mind, consider now writing a</p>
<pre><code>getRegister` clause for terms of the form `(1 + E)`. Contrived, yes, but illustrates the matter. First we do `getRegister` on `E</code></pre>
<p>. Now we are forced to examine what comes back.</p>
<pre><code>getRegister (OnePlus e)
   = getRegister e           &lt;pre&gt;thenNat</code></pre>
<p>\ e_result -&gt;</p>
<p><code>    case e_result of</code><br />
<code>       Fixed e_code e_fixed </code><br />
<code>          -&gt; returnNat (Any IntRep (\dst -&gt; e_code ++ [MOV e_fixed dst, INC dst]))</code><br />
<code>       Any e_any </code><br />
<code>          -&gt; Any (\dst -&gt; e_any dst ++ [INC dst])</code></p>
</pre>
<p>This seems unreasonably cumbersome, yet the instruction selector is full of such idioms. A good example of the complexities induced by this scheme is shown by</p>
<pre><code>trivialCode` for x86 in `MachCode.lhs</code></pre>
<p>. This deals with general integer dyadic operations on x86 and has numerous cases. It was difficult to get right.</p>
<p>An alternative suggestion is to simplify the type of</p>
<pre><code>getRegister</code></pre>
<p>to this:</p>
<pre><code>getRegister :: StixExpr -&gt; NatM (InstrBloc, VReg)
type VReg = .... a vreg ...</code></pre>
<p>and then we could safely write</p>
<pre><code>getRegister (OnePlus e)
   = getRegister e        &lt;pre&gt;thenNat</code></pre>
<p>\ (e_code, e_vreg) -&gt;</p>
<p><code>    returnNat (e_code ++ [INC e_vreg], e_vreg)</code></p>
</pre>
<p>which is about as straightforward as you could hope for. Unfortunately, it requires</p>
<pre><code>getRegister</code></pre>
<p>to insert moves of values which naturally compute into an rreg, into a vreg. Consider:</p>
<pre><code>1 + ccall some-C-fn</code></pre>
<p>On x86 the ccall result is returned in rreg</p>
<pre><code>%eax</code></pre>
<p>. The resulting sequence, prior to register allocation, would be:</p>
<pre><code># push args
call some-C-fn
# move %esp to nuke args
movl   %eax, %vreg
incl   %vreg</code></pre>
<p>If, as is likely,</p>
<pre><code>%eax` is not held live beyond this point for any other purpose, the move into a fresh register is pointless; we&#39;d have been better off leaving the value in `%eax</code></pre>
<p>as long as possible.</p>
<p>The simplified</p>
<pre><code>getRegister</code></pre>
<p>story is attractive. It would clean up the instruction selectors significantly and make it simpler to write new ones. The only drawback is that it generates redundant register moves. I suggest that eliminating these should be the job of the register allocator. Indeed:</p>
<ul>
<li>There has been some work on this already (&quot;Iterated register coalescing&quot; ?), so this isn't a new idea.</li>
</ul>
<ul>
<li>You could argue that the existing scheme inappropriately blurs the boundary between the instruction selector and the register allocator. The instruction selector should .. well .. just select instructions, without having to futz around worrying about what kind of registers subtrees get generated into. Register allocation should be <em>entirely</em> the domain of the register allocator, with the proviso that it should endeavour to allocate registers so as to minimise the number of non-redundant reg-reg moves in the final output.</li>
</ul>
<h2 id="selecting-insns-for-64-bit-valuesloadsstores-on-32-bit-platforms">Selecting insns for 64-bit values/loads/stores on 32-bit platforms</h2>
<p>Note that this stuff doesn't apply on 64-bit archs, since the</p>
<pre><code>getRegister</code></pre>
<p>mechanism applies there. The relevant functions are:</p>
<pre><code>assignMem_I64Code :: StixExpr -&gt; StixExpr -&gt; NatM InstrBlock
assignReg_I64Code :: StixReg  -&gt; StixExpr -&gt; NatM InstrBlock
iselExpr64        :: StixExpr -&gt; NatM ChildCode64

data ChildCode64     -- a.k.a &quot;Register64&quot;
   = ChildCode64 
        InstrBlock   -- code
        VRegUnique   -- unique for the lower 32-bit temporary</code></pre>
<pre><code>iselExpr64` is the 64-bit, plausibly-named analogue of `getRegister`, and `ChildCode64` is the analogue of `Register`. The aim here was to generate working 64 bit code as simply as possible. To this end, I used the simplified `getRegister</code></pre>
<p>scheme described above, in which iselExpr64generates its results into two vregs which can always safely be modified afterwards.</p>
<p>Virtual registers are, unsurprisingly, distinguished by their</p>
<pre><code>Unique`s. There is a small difficulty in how to know what the vreg for the upper 32 bits of a value is, given the vreg for the lower 32 bits. The simple solution adopted is to say that any low-32 vreg may also have a hi-32 counterpart which shares the same unique, but is otherwise regarded as a separate entity. `getHiVRegFromLo</code></pre>
<p>gets one from the other.</p>
<pre><code>data VRegUnique
   = VRegUniqueLo Unique          -- lower part of a split quantity
   | VRegUniqueHi Unique          -- upper part thereof</code></pre>
<p>Apart from that, 64-bit code generation is really simple. The sparc and x86 versions are almost copy-n-pastes of each other, with minor adjustments for endianness. The generated code isn't wonderful but is certainly acceptable, and it works.</p>
<h2 id="shortcomings-and-inefficiencies-in-the-register-allocator">Shortcomings and inefficiencies in the register allocator</h2>
<h3 id="redundant-reconstruction-of-the-control-flow-graph">Redundant reconstruction of the control flow graph</h3>
<p>The allocator goes to considerable computational expense to construct all the flow edges in the group of instructions it's allocating for, by using the</p>
<pre><code>insnFuture` function in the `Instr</code></pre>
<p>pseudo-abstract type.</p>
<p>This is really silly, because all that information is present at the abstract C stage, but is thrown away in the translation to Stix. So a good thing to do is to modify that translation to produce a directed graph of Stix straight-line code blocks, and to preserve that structure through the insn selector, so the allocator can see it.</p>
<p>This would eliminate the fragile, hacky, arch-specific</p>
<pre><code>insnFuture</code></pre>
<p>mechanism, and probably make the whole compiler run measurably faster. Register allocation is a fair chunk of the time of non-optimising compilation (10% or more), and reconstructing the flow graph is an expensive part of reg-alloc. It would probably accelerate the vreg liveness computation too.</p>
<h3 id="really-ridiculous-method-for-doing-spilling">Really ridiculous method for doing spilling</h3>
<p>This is a more ambitious suggestion, but ... reg-alloc should be reimplemented, using the scheme described in &quot;Quality and speed in linear-scan register allocation.&quot; (Traub?) For straight-line code blocks, this gives an elegant one-pass algorithm for assigning registers and creating the minimal necessary spill code, without the need for reserving spill registers ahead of time.</p>
<p>I tried it in Rigr, replacing the previous spiller which used the current GHC scheme described above, and it cut the number of spill loads and stores by a factor of eight. Not to mention being simpler, easier to understand and very fast.</p>
<p>The Traub paper also describes how to extend their method to multiple basic blocks, which will be needed for GHC. It comes down to reconciling multiple vreg-to-rreg mappings at points where control flow merges.</p>
<h3 id="redundant-move-support-for-revised-instruction-selector-suggestion">Redundant-move support for revised instruction selector suggestion</h3>
<p>As mentioned above, simplifying the instruction selector will require the register allocator to try and allocate source and destination vregs to the same rreg in reg-reg moves, so as to make as many as possible go away. Without that, the revised insn selector would generate worse code than at present. I know this stuff has been done but know nothing about it. The Linear-scan reg-alloc paper mentioned above does indeed mention a bit about it in the context of single basic blocks, but I don't know if that's sufficient.</p>
<h2 id="x86-arcana-that-you-should-know-about">x86 arcana that you should know about</h2>
<p>The main difficulty with x86 is that many instructions have fixed register constraints, which can occasionally make reg-alloc fail completely. And the FPU doesn't have the flat register model which the reg-alloc abstraction (implicitly) assumes.</p>
<p>Our strategy is: do a good job for the common small subset, that is integer loads, stores, address calculations, basic ALU ops (+, -, and, or, xor), and jumps. That covers the vast majority of executed insns. And indeed we do do a good job, with a loss of less than 2% compared with gcc.</p>
<p>Initially we tried to handle integer instructions with awkward register constraints (mul, div, shifts by non-constant amounts) via various jigglings of the spiller et al. This never worked robustly, and putting platform-specific tweaks in the generic infrastructure is a big No-No. (Not quite true; shifts by a non-constant amount are still done by a giant kludge, and should be moved into this new framework.)</p>
<p>Fortunately, all such insns are rare. So the current scheme is to pretend that they don't have any such constraints. This fiction is carried all the way through the register allocator. When the insn finally comes to be printed, we emit a sequence which copies the operands through memory (</p>
<pre><code>%esp`-relative), satisfying the constraints of the real instruction. This localises the gruesomeness to just one place. Here, for example, is the code generated for integer divison of `%esi` by `%ecx</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code># BEGIN IQUOT %ecx, %esi
pushl $0
pushl %eax  
pushl %edx
pushl %ecx
movl  %esi,% eax
cltd
idivl 0(%esp)
movl %eax, 12(%esp)
popl %edx  
popl %edx
popl %eax
popl %esi
# END   IQUOT %ecx, %esi</code></pre>
<p>This is not quite as appalling as it seems, if you consider that the division itself typically takes 16+ cycles, whereas the rest of the insns probably go through in about 1 cycle each.</p>
<p>This trick is taken to extremes for FP operations.</p>
<p>All notions of the x86 FP stack and its insns have been removed. Instead, we pretend, to the instruction selector and register allocator, that x86 has six floating point registers,</p>
<pre><code>%fake0` .. `%fake5</code></pre>
<p>, which can be used in the usual flat manner. We further claim that x86 has floating point instructions very similar to SPARC and Alpha, that is, a simple 3-operand register-register arrangement. Code generation and register allocation proceed on this basis.</p>
<p>When we come to print out the final assembly, our convenient fiction is converted to dismal reality. Each fake instruction is independently converted to a series of real x86 instructions.</p>
<pre><code>%fake0` .. `%fake5` are mapped to `%st(0)` .. `%st(5)`. To do reg-reg arithmetic operations, the two operands are pushed onto the top of the FP stack, the operation done, and the result copied back into the relevant register. When one of the operands is also the destination, we emit a slightly less scummy translation. There are only six `%fake</code></pre>
<p>registers because 2 are needed for the translation, and x86 has 8 in total.</p>
<p>The translation is inefficient but is simple and it works. A cleverer translation would handle a sequence of insns, simulating the FP stack contents, would not impose a fixed mapping from</p>
<pre><code>%fake` to `%st</code></pre>
<p>regs, and hopefully could avoid most of the redundant reg-reg moves of the current translation.</p>
<p>There are, however, two unforeseen bad side effects:</p>
<ul>
<li>This doesn't work properly, because it doesn't observe the normal conventions for x86 FP code generation. It turns out that each of the 8 elements in the x86 FP register stack has a tag bit which indicates whether or not that register is notionally in use or not. If you do a FPU operation which happens to read a tagged-as-empty register, you get an x87 FPU (stack invalid) exception, which is normally handled by the FPU without passing it to the OS: the program keeps going, but the resulting FP values are garbage. The OS can ask for the FPU to pass it FP stack-invalid exceptions, but it usually doesn't.</li>
</ul>
<p><code>Anyways: inside NCG created x86 FP code this all works fine. However, the NCG's fiction of a flat register set does not operate the x87 register stack in the required stack-like way. When control returns to a gcc-generated world, the stack tag bits soon cause stack exceptions, and thus garbage results.</code></p>
<p><code>The only fix I could think of -- and it is horrible -- is to clear all the tag bits just before the next STG-level entry, in chunks of code which use FP insns. </code></p>
<pre><code>i386_insert_ffrees` inserts the relevant `ffree` insns into such code blocks. It depends critically on `is_G_instr</code></pre>
<p>to detect such blocks.</p>
<ul>
<li>It's very difficult to read the generated assembly and reason about it when debugging, because there's so much clutter. We print the fake insns as comments in the output, and that helps a bit.</li>
</ul>
<h2 id="generating-code-for-ccalls">Generating code for ccalls</h2>
<p>For reasons I don't really understand, the instruction selectors for generating calls to C (genCCall) have proven surprisingly difficult to get right, and soaked up a lot of debugging time. As a result, I have once again opted for schemes which are simple and not too difficult to argue as correct, even if they don't generate excellent code.</p>
<p>The sparc ccall generator in particular forces all arguments into temporary virtual registers before moving them to the final out-registers (</p>
<pre><code>%o0` .. `%o5</code></pre>
<p>). This creates some unnecessary reg-reg moves. The reason is explained in a comment in the code.</p>
<h2 id="duplicate-implementation-for-many-stg-macros">Duplicate implementation for many STG macros</h2>
<p>This has been discussed at length already. It has caused a couple of nasty bugs due to subtle untracked divergence in the macro translations. The macro-expander really should be pushed up into the Abstract C phase, so the problem can't happen.</p>
<p>Doing so would have the added benefit that the NCG could be used to compile more &quot;ways&quot; -- well, at least the 'p' profiling way.</p>
<h2 id="how-to-debug-the-ncg-without-losing-your-sanityhaircool">How to debug the NCG without losing your sanity/hair/cool</h2>
<p>Last, but definitely not least ...</p>
<p>The usual syndrome is that some program, when compiled via C, works, but not when compiled via the NCG. Usually the problem is fairly simple to fix, once you find the specific code block which has been mistranslated. But the latter can be nearly impossible, since most modules generate at least hundreds and often thousands of them.</p>
<p>My solution: cheat.</p>
<p>Because the via-C and native routes diverge only late in the day, it is not difficult to construct a 1-1 correspondence between basic blocks on the two routes. So, if the program works via C but not on the NCG, do the following:</p>
<ul>
<li>Recompile
<pre><code>AsmCodeGen.lhs` in the afflicted compiler with `-DDEBUG_NCG`, so that it inserts `___ncg_debug_markers</code></pre>
<p>into the assembly it emits.</p></li>
<li>Using a binary search on modules, find the module which is causing the problem.</li>
<li>Compile that module to assembly code, with identical flags, twice, once via C and once via NCG. Call the outputs
<pre><code>ModuleName.s-gcc` and `ModuleName.s-nat`. Check that the latter does indeed have `___ncg_debug_markers</code></pre>
<p>in it; otherwise the next steps fail.</p></li>
<li>Build (with a working compiler) the program
<pre><code>utils/debugNCG/diff_gcc_nat</code></pre>
<p>.</p></li>
<li>Run:
<pre><code>diff_gcc_nat ModuleName.s</code></pre>
<p>. This will construct the 1-1 correspondence, and emits on stdout a cppable assembly output. Place this in a file -- I always call it synth.S. Note, the capital S is important; otherwise it won't get cpp'd. You can feed this file directly to ghc and it will automatically get cpp'd; you don't have to do so yourself.</p></li>
<li>By messing with the
<pre><code>#define`s at the top of `synth.S`, do a binary search to find the incorrect block. Keep a careful record of where you are in the search; it is easy to get confused. Remember also that multiple blocks may be wrong, which also confuses matters. Finally, I usually start off by re-checking that I can build the executable with all the `#define`s set to 0 and then all to 1. This ensures you won&#39;t get halfway through the search and then get stuck due to some snafu with gcc-specific literals. Usually I set `UNMATCHED_GCC` to 1 all the time, and this bit should contain only literal data. `UNMATCHED_NAT</code></pre>
<p>should be empty.</p></li>
</ul>
<pre><code>diff_gcc_nat</code></pre>
<p>was known to work correctly last time I used it, in December 01, for both x86 and sparc. If it doesn't work, due to changes in assembly syntax, or whatever, make it work. The investment is well worth it. Searching for the incorrect block(s) any other way is a total time waster.</p>
<h2 id="historical-page-1">Historical page</h2>
<p>This page describes state of the new code generator sometime back in 2008. It is completely outdated and is here only for historical reasons. See [wiki:Commentary/Compiler/CodeGen Code Generator] page for a description of current code generator.</p>
<h1 id="overview-of-modules-in-the-new-code-generator">Overview of modules in the new code generator</h1>
<p>This page gives an overview of the new code generator, including discussion of:</p>
<ul>
<li>the [wiki:Commentary/Compiler/NewCodeGenModules#ThenewCmmdatatype new Cmm type]</li>
<li>the [wiki:Commentary/Compiler/NewCodeGenModules#Modulestructureofthenewcodegenerator module structure of the new code generator]</li>
</ul>
<p>See also [wiki:Commentary/Compiler/NewCodeGenPipeline the description of the new code generation pipeline].</p>
<h2 id="the-new-cmm-data-type">The new Cmm data type</h2>
<p>There is a new Cmm data type:</p>
<ul>
<li><a href="GhcFile(compiler/cmm/ZipCfg.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/ZipCfg.hs)</a> contains a generic zipper-based control-flow graph data type. It is generic in the sense that it's polymorphic in the type of <strong>middle nodes</strong> and <strong>last nodes</strong> of a block. (Middle nodes don't do control transfers; last nodes only do control transfers.) There are extensive notes at the start of the module.<br />
<br />
</li>
</ul>
<p><code>The key types it defines are:</code></p>
<ul>
<li>Block identifiers:
<pre><code>BlockId`, `BlockEnv`, `BlockSet</code></pre></li>
<li>Control-flow blocks:
<pre><code>Block</code></pre></li>
<li>Control-flow graphs:
<pre><code>Graph</code></pre>
<p><br />
<br />
</p></li>
</ul>
<p><code>'''</code></p>
<pre><code>ZipDataFlow`&#39;&#39;&#39; contains a generic framework for solving dataflow problems over `ZipCfg</code></pre>
<p>. It allows you to define a new optimization simply by defining a lattice of dataflow facts (akin to a specialized logic) and then writing the dataflow-transfer functions found in compiler textbooks. Handing these functions to the dataflow engine produces a new optimization that is not only useful on its own, but that can easily be composed with other optimizations to create an integrated &quot;superoptimization&quot; that is strictly more powerful than any sequence of individual optimizations, no matter how many times they are re-run. The dataflow engine is based on <a href="http://citeseer.ist.psu.edu/old/lerner01composing.html">(Lerner, Grove, and Chambers 2002)</a>; you can find a functional implementation of the dataflow engine presented in <a href="http://www.cs.tufts.edu/~nr/pubs/zipcfg-abstract.html">(Ramsey and Dias 2005)</a>.<br />
<br />
 <strong><a href="GhcFile(compiler/cmm/ZipCfgCmmRep.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/ZipCfgCmmRep.hs)</a></strong> instantiates</p>
<pre><code>ZipCfg` for Cmm, by defining types `Middle` and `Last` and using these to instantiate the polymorphic fields of `ZipCfg`.  It also defines a bunch of smart constructor (`mkJump`, `mkAssign`, `mkCmmIfThenElse` etc) which make it easy to build `CmmGraph</code></pre>
<p>.<br />
<br />
 '''</p>
<pre><code>CmmExpr</code></pre>
<p>''' contains the data types for Cmm expressions, registers, and the like. Here is a fuller description of these types is at [wiki:Commentary/Compiler/BackEndTypes]. It does not depend on the dataflow framework at all.</p>
<h2 id="module-structure-of-the-new-code-generator">Module structure of the new code generator</h2>
<p>The new code generator has a fair number of modules, which can be split into three groups:</p>
<ul>
<li>basic datatypes and infrastructure</li>
<li>analyses and transformations</li>
<li>linking the pipeline</li>
</ul>
<p>All the modules mentioned are in the</p>
<pre><code>cmm/</code></pre>
<p>directory, unless otherwise indicated.</p>
<h3 id="basic-datatypes-and-infrastructure">Basic datatypes and infrastructure</h3>
<p>Ubiquitous types:</p>
<ul>
<li><pre><code>CLabel` (`CLabel</code></pre>
<p>): All sorts of goo for making and manipulating labels.</p></li>
</ul>
<ul>
<li><pre><code>BlockId` (`BlockId`, `BlockEnv`, `BlockSet</code></pre>
<p>):</p></li>
</ul>
<p><code>  The type of a basic-block id, along with sets and finite maps.</code></p>
<ul>
<li><pre><code>CmmExpr` (`CmmType`, `LocalReg`, `GlobalReg`, `Area`, `CmmExpr</code></pre>
<p>):</p></li>
</ul>
<p><code>  Lots of type definitions: for Cmm types (bit width, GC ptr, float, etc),</code><br />
<code>  registers, stack areas, and Cmm expressions.</code></p>
<ul>
<li><pre><code>Cmm` (`GenCmm`, `CmmInfo`, `CmmInfoTable</code></pre>
<p>):</p></li>
</ul>
<p><code>  More type definitions: the parameterized top-level Cmm type (</code></p>
<pre><code>GenCmm</code></pre>
<p>),</p>
<p><code>  along with the type definitions for info tables.</code></p>
<p>Control-flow graphs:</p>
<ul>
<li><pre><code>ZipCfg` (`Graph`, `LGraph`, `Block</code></pre>
<p>):</p></li>
</ul>
<p><code>  Describes a zipper-like representation for true basic-block</code><br />
<code>  control-flow graphs.  A block has a single entry point,</code><br />
<code>  which is a always a label, followed by zero or mode 'middle</code><br />
<code>  nodes', each of which represents an uninterruptible</code><br />
<code>  single-entry, single-exit computation, then finally a 'last</code><br />
<code>  node', which may have zero or more successors.</code><br />
<code>  </code></p>
<pre><code>ZipCFG</code></pre>
<p>is polymorphic in the type of middle and last nodes.</p>
<ul>
<li><pre><code>ZipCfgCmmRep` (`Middle`, `Last`, `CmmGraph</code></pre>
<p>)</p></li>
</ul>
<p><code>  Types to instantiate </code></p>
<pre><code>ZipCfg</code></pre>
<p>for C--: middle and last nodes,</p>
<p><code>  and a bunch of abbreviations of types in </code></p>
<pre><code>ZipCfg` and `Cmm</code></pre>
<p>.</p>
<ul>
<li><pre><code>MkZipCfg` (`AGraph`, `mkLabel`, `mkMiddle`, `mkBranch</code></pre>
<p>)</p></li>
</ul>
<p><code>  Smart constructors for control-flow graphs (and the constructors have</code><br />
<code>  non-monadic types).</code><br />
<code>  Like </code></p>
<pre><code>ZipCfg`, `MkZipCfg</code></pre>
<p>is polymorphic in the types of middle and last nodes.</p>
<ul>
<li><pre><code>MkZipCfgCmm` (`mkNop`, `mkAssign`, `mkStore`, `mkCall</code></pre>
<p>, ...)</p></li>
</ul>
<p><code>  Smart constructors for creating middle and last nodes in</code><br />
<code>  control-flow graphs (and the constructors have non-monadic types).</code></p>
<p>Calling conventions:</p>
<ul>
<li><pre><code>CmmInfo` (`cmmToRawCmm`, `mkBareInfoTable</code></pre>
<p>):</p></li>
</ul>
<p><code>  Converts Cmm code to &quot;raw&quot; Cmm.  What this means is: convert a </code></p>
<pre><code>CmmInfo` data structure describing the info table for each `CmmProc` to a `[CmmStatic]</code></pre>
<p>.</p>
<pre><code>mkBareInfoTable` is the workhorse that produces the `[CmmStatic]</code></pre>
<p>. It is also used to produce the info table required for safe foreign calls (a middle node).</p>
<ul>
<li><pre><code>CmmCallConv` (`ArgumentFormat`, `assignArgumentsPos</code></pre>
<p>):</p></li>
</ul>
<p><code>  Implements Cmm calling conventions: given arguments and a calling convention,</code><br />
<code>  this module decides where to put the arguments.</code><br />
<code>  (JD: Crufty. Lots of old code in here, needs cleanup.)</code></p>
<p>Dataflow analysis:</p>
<ul>
<li><pre><code>CmmTx` (`Tx`, `TxRes</code></pre>
<p>):</p></li>
</ul>
<p><code>  A simple monad for tracking when a transformation has</code><br />
<code>  occurred (something has changed).</code><br />
<code>  Used by the dataflow analysis to keep track of when the graph is rewritten.</code></p>
<ul>
<li><pre><code>OptimizationFuel` (`OptimizationFuel`, `FuelMonad`, `maybeRewriteWithFuel</code></pre>
<p>)</p></li>
</ul>
<p><code>  We can use a measure of &quot;fuel&quot; to limit the number of rewrites performed</code><br />
<code>  by a transformation. This module defines a monad for tracking (and limiting)</code><br />
<code>  fuel use.</code><br />
<code>  (JD: Largely untested.)</code></p>
<ul>
<li><pre><code>DFMonad` (`DataflowLattice`, `DataflowAnalysis`, `runDFM</code></pre>
<p>):</p></li>
</ul>
<p><code>  Defines the type of a dataflow lattice and an analysis.</code><br />
<code>  Defines the monad used by the dataflow framework.</code><br />
<code>  The monad keeps track of dataflow facts, along with fuel,</code><br />
<code>  and it can provide unique id's.</code><br />
<code>  All in support of the dataflow module.</code></p>
<ul>
<li><pre><code>ZipDataflow` (`ForwardTransfers`, `BackwardTransfers`, `ForwardRewrites`, `BackwardRewrites</code></pre>
<p>,</p></li>
</ul>
<pre><code>zdfSolveFrom`, `zdfRewriteFrom</code></pre>
<p>, etc)</p>
<p><code>  This module implements the Lerner/Grove/Chambers dataflow analysis frameword.</code><br />
<code>  Given the definitions of a lattice and dataflow transfer/rewrite functions,</code><br />
<code>  this module provides all the work of running the dataflow analysis and transformation.</code><br />
<code>  A number of the phases of the back end rely on this code,</code><br />
<code>  and hopefully more optimizations will target it in the future.</code></p>
<p>And a few basic utilities:</p>
<ul>
<li><pre><code>CmmZipUtil</code></pre>
<dl>

<dd>(JD: Unused, I believe, but probably should be used in a few places.)
</dd>
</dl></li>
</ul>
<p><code>  A few utility functions for manipulating a zipcfg.</code></p>
<ul>
<li><pre><code>PprC</code></pre>
<dl>

<dd>Prettyprinting to generate C code.
</dd>
</dl></li>
<li><pre><code>PprCmm</code></pre>
<dl>

<dd>Prettyprinting the C-- code.
</dd>
</dl></li>
<li><pre><code>PprCmmZ</code></pre>
<dl>

<dd>(JD: Unused, I believe.)
</dd>
</dl></li>
</ul>
<p><code>  Prettyprinting functions related to </code></p>
<pre><code>ZipCfg` and `ZipCfgCmm</code></pre>
<p>.</p>
<h3 id="analyses-and-transformations">Analyses and transformations</h3>
<ul>
<li><pre><code>CmmLint` (`cmmLint`, `cmmLintTop</code></pre>
<p>):</p></li>
</ul>
<p><code>  Some sanity checking on the old Cmm graphs.</code><br />
<code>  Not sure how effective this is.</code></p>
<ul>
<li><pre><code>CmmLiveZ` (`CmmLive`, `livelattice`, `cmmLivenessZ</code></pre>
<p>):</p></li>
</ul>
<p><code>  Liveness analysis for registers (uses dataflow framework).</code></p>
<ul>
<li><pre><code>CmmProcPointZ` (`ProcPointSet`, `callProcPoints`, `minimalProcPointSet</code></pre>
<p>,</p></li>
</ul>
<pre><code>procPointAnalysis`, `splitAtProcPoints</code></pre>
<p>)</p>
<p><code>  A proc point is a block in a control-flow graph that must be the</code><br />
<code>  entry point of a new procedure when we generate C code.</code><br />
<code>  For example, successors of calls and joinpoints that follow calls</code><br />
<code>  are procpoints.</code><br />
<code>  This module provides the analyses to find procpoints, as well as</code><br />
<code>  the transformation to split the procedure into pieces.</code><br />
<code>  The procpoint analysis doesn't use the dataflow framework,</code><br />
<code>  but it really should - dominators are the way forward.</code></p>
<ul>
<li><pre><code>CmmSpillReload` (`DualLive`, `dualLiveLattice`, `dualLiveness</code></pre>
<p>,</p></li>
</ul>
<pre><code>dualLivenessWithInsertion`, `insertLateReloads</code></pre>
<p>,</p>
<pre><code>removeDeadAssignmentsAndReloads</code></pre>
<p>):</p>
<p><code>  Inserts spills and reloads to establish the invariant that</code><br />
<code>  at a safe call, there are no live variables in registers.</code></p>
<ul>
<li><pre><code>CmmCommonBlockElimZ` (`elimCommonBlocks</code></pre>
<p>):</p></li>
</ul>
<p><code>  Find blocks in the CFG that are identical; merge them.</code></p>
<ul>
<li><pre><code>CmmContFlowOpt` (`branchChainElimZ`, `removeUnreachableBlocksZ</code></pre>
<p>,</p></li>
</ul>
<pre><code>runCmmOpts</code></pre>
<p>):</p>
<p><code>  Branch-chain elimination and elimination of unreachable code.</code></p>
<ul>
<li><pre><code>CmmStackLayout` (`SlotEnv`, `liveSlotAnal`, `manifestSP`, `stubSlotsOnDeath</code></pre>
<p>):</p></li>
</ul>
<p><code>  The live-slot analysis discovers which stack slots are live</code><br />
<code>  at each basic block.</code><br />
<code>  We use the results for two purposes:</code><br />
<code>  stack layout (manifestSP) and info tables (in CmmBuildInfoTables).</code><br />
<code>  The function `stubSlotsOnDeath' is used as a debugging pass:</code><br />
<code>  it stubs each stack slot when it dies, hopefully causing bad</code><br />
<code>  programs to fail faster.</code></p>
<ul>
<li><pre><code>CmmBuildInfoTables` (`CAFEnv`, `cafAnal`, `lowerSafeForeignCalls</code></pre>
<p>,</p></li>
</ul>
<pre><code>setInfoTableSRT`, `setInfoTableStackMap</code></pre>
<p>):</p>
<p><code>  This module is responsible for building info tables.</code><br />
<code>  Specifically, it builds the maps of live variables (stack maps)</code><br />
<code>  and SRTs.</code><br />
<code>  It also has code to lower safe foreign calls into a sequence</code><br />
<code>  that makes them safe (but suspending and resuming threads very carefully).</code><br />
<code>  (JD: The latter function probably shouldn't be here.)</code></p>
<h3 id="linking-the-pipeline">Linking the pipeline</h3>
<ul>
<li><pre><code>CmmCvt`: Converts between `Cmm` and `ZipCfgCmm</code></pre>
<p>representations.</p></li>
</ul>
<p><code>  (JD: The Zip -&gt; Cmm path definitely works; haven't tried the</code><br />
<code>  other in a long time -- there's no reason to use it with</code><br />
<code>  the new Stg -&gt; Cmm path).</code></p>
<ul>
<li><pre><code>CmmCPSZ</code></pre>
<dl>

<dd>Links the phases of the back end in sequence, along with
</dd>
</dl></li>
</ul>
<p><code>  some possible debugging output.</code></p>
<h3 id="dead-code">Dead code</h3>
<ul>
<li><pre><code>CmmCPSGen`, `CmmCPS` (Michael Adams), `CmmBrokenBlock`, `CmmLive`, `CmmPprCmmZ`, `StackColor`, `StackPlacements</code></pre></li>
</ul>
<h2 id="historical-page-2">Historical page</h2>
<p>This page stores notes about progress of work on the &quot;new&quot; code generator. This page is here for historical reasons. See [wiki:Commentary/Compiler/CodeGen Code Generator] page for an up-to-date description of the current code generator.</p>
<h1 id="ghcs-glorious-new-code-generator">GHC's glorious new code generator</h1>
<p>This page summarises work that Norman Ramsey, Simon M, Simon PJ, and John Dias are doing on re-architecting GHC's back end. Here is the state of play; see also [wiki:Commentary/Compiler/Backends/LLVM work on the LLVM back end].</p>
<ul>
<li>Bug list (code-gen related bugs that we may be able to fix):
<ul>
<li><ol>
<li>1498 (avoid redundant heap check on the fast path)</li>
</ol></li>
<li><ol>
<li>3552 (unreachable code)</li>
</ol></li>
<li><ol>
<li>3462 (a feature)</li>
</ol></li>
<li><ol>
<li>2249</li>
</ol></li>
<li><ol>
<li>2253</li>
</ol></li>
<li><ol>
<li>2289</li>
</ol></li>
<li><ol>
<li>7219 (reinstate constant-prop)</li>
</ol></li>
<li><ol>
<li>7213 (massive array)</li>
</ol></li>
</ul></li>
</ul>
<ul>
<li>(Sept 12) New code generator is live. Here's the [wiki:Commentary/Compiler/NewCodeGen/Cleanup page listing clean-up tasks] that we can now do.</li>
</ul>
<ul>
<li>Simon M added a [blog:newcg-update Blog Post] about the new code generator status</li>
</ul>
<ul>
<li>Link to <a href="http://research.microsoft.com/en-us/um/people/simonpj/tmp/wos-diss-draft.pdf">Krzysztof Wos's project</a>, in which he reports great performance improvements by turning tail recursion into loops in C--.</li>
</ul>
<ul>
<li>Norman added a [wiki:Commentary/Compiler/HooplPerformance Hoopl performance page]</li>
</ul>
<ul>
<li>Edward Yang has a wiki page that describes shortcomings of the code generated by the new pipeline: [wiki:Commentary/Compiler/NewCodeGenStupidity]</li>
</ul>
<ul>
<li>John D has built a complete new codegen pipeline, running alongside the old one, enabled by
<pre><code>-fuse-new-codegen`. It is described here: [wiki:Commentary/Compiler/NewCodeGenPipeline].  It uses a new representation for `Cmm`, mostly with &quot;Z&quot; in the name.  (Let&#39;s call the original Cmm `OldCmm` and this new one `CmmZ</code></pre>
<p>.) It has a new conversion STG-&gt;CmmZ, and then sequence of passes that optimise and cps-convert the Cmm. Finally, it is converted back to the old Cmm so that it can flow to the old code generators.</p></li>
</ul>
<ul>
<li>Compiling through the new pipeline passes all tests and GHC is bootstrappable.</li>
</ul>
<ul>
<li>Separately, we have developed yet another, and still better, Cmm representation, the subject of an upcoming ICFP 2010 submission. It uses phantom types and GADTs to add very useful open/closed invariants. This isn't in GHC at all yet. I'll call it
<pre><code>CmmGADT</code></pre>
<p>for easy reference.</p></li>
</ul>
<p>Generally we want to keep old and new pipelines working simultaneously, so that we can switch only when we are sure the new stuff works. Next steps in this grand plan are:</p>
<ul>
<li>Check the impact on compilation time of the new route.</li>
</ul>
<ul>
<li>Finalise
<pre><code>CmmGADT</code></pre>
<p>and make the new pipeline use it.</p></li>
</ul>
<ul>
<li>Make the Cmm parser (which parses
<pre><code>.cmm` files from the RTS) produce `CmmGADT</code></pre>
<p>, and push that down the new pipeline.</p></li>
</ul>
<ul>
<li>Implement the many refactorings and improvements to the new pipeline described in <a href="http://darcs.haskell.org/ghc/compiler/cmm/cmm-notes" class="uri">http://darcs.haskell.org/ghc/compiler/cmm/cmm-notes</a>. See also: [wiki:Commentary/Compiler/NewCodeGenStupidity]</li>
</ul>
<ul>
<li>Instead of converting new Cmm to old Cmm, make the downstream code generators consume
<pre><code>CmmGADT`, and convert old Cmm to `CmmGADT</code></pre>
<p>.</p></li>
</ul>
<p>Longer term</p>
<ul>
<li>Expand the capability of the new pipeline so that it does native code generation too, and we can ultimately discard the existing code generators. The design of this stage is here: [wiki:Commentary/Compiler/IntegratedCodeGen]</li>
</ul>
<h2 id="workflow-for-the-new-code-generator-and-hoopl">Workflow for the new code generator and Hoopl</h2>
<p>We have the following repositories:</p>
<ul>
<li>HEAD: the main GHC git repo.
<pre><code>http://darcs.haskell.org/ghc.git</code></pre></li>
</ul>
<ul>
<li>HooplMaster: the master Hoopl Git repository.</li>
</ul>
<p><code>  </code><br />
<code> </code><strong><code>Location</code></strong><code>: </code></p>
<pre><code>http://ghc.cs.tufts.edu/hoopl/hoopl.git/</code></pre>
<p><code>  </code><br />
<code> (Physical location: </code></p>
<pre><code>linux.cs.tufts.edu:/r/ghc/www/hoopl/hoopl.git</code></pre>
<p>)</p>
<ul>
<li>HooplLag: a Git repo that is guaranteed to work with GHC HEAD. It is</li>
</ul>
<p><code>  not automatically updated by pushes to HooplMaster.  Instead a manual</code><br />
<code>  process (below) updates it; hence &quot;lag&quot;.</code><br />
<code>  </code><br />
<code> </code><strong><code>Location</code></strong><code>: </code></p>
<pre><code>http://darcs.haskell.org/packages/hoopl.git</code></pre>
<p>.</p>
<p>Normal GHC developers, who are uninterested in Hoopl, ignore all this. If they download HEAD including all submodules, they'll get HooplLag, which is always guaranteed to work with HEAD.</p>
<p>Developers who work on GHC and also need to modify Hoopl need to ensure their changes end up in both repositories.</p>
<ul>
<li>In your hoopl directory in your development tree, add HooplMaster as a remote and update your reference there.</li>
<li>Hack away in the development tree.</li>
<li>Record Hoopl commits.</li>
<li>Run validate in the development tree</li>
<li>Push the commits in hoopl to the HooplMaster Git repo</li>
<li>Wait for the mirrors to update (the impatient can run
<pre><code>/srv/darcs/do_mirrors</code></pre>
<p>on darcs.haskell.org)</p></li>
<li>Push the commits in hoopl to the HooplLag Git repo (probably the origin remote)</li>
</ul>
<h2 id="status-report-april-2011">Status report April 2011</h2>
<p>Term</p>
<h2 id="historical-page-3">Historical page</h2>
<p>This page stores historical information about Cmm Pipeline in the new code generator. This description has been updated and is maintained on the [wiki:Commentary/Compiler/CodeGen Code Generator] page. This page has also historical notes about Adams optimisation. That optimisation is also described in Note [sharing continuations] in <a href="GhcFile(compiler/codeGen/StgCmmMonad.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmMonad.hs)</a> and probably deserves its own wiki page.</p>
<h1 id="design-of-the-new-code-generator">Design of the new code generator</h1>
<p>This page contains notes about the design of the new code generator. See also: [wiki:Commentary/Compiler/NewCodeGenModules overview of the module structure in the new code generator].</p>
<h2 id="overview-4">Overview</h2>
<p>Code generation now has three stages:</p>
<ol>
<li>Convert STG to Cmm, with implicit stack implicit, and native Cmm calls.</li>
<li>Optimise the Cmm, and CPS-convert it to have an explicit stack, and no native calls.</li>
</ol>
<p><code>    This part of the pipeline is stitched together in </code></p>
<pre><code>cmm/CmmPipeline.hs</code></pre>
<p>.</p>
<ol>
<li><ol>
<li>Feed the CPS-converted Cmm to the existing, unmodified native code generators.</li>
</ol></li>
</ol>
<p>Ultimately our plan is to expand the capability of the new pipeline so that it does native code generation too, and we can ultimately discard the existing code generators. The design of this stage is here: [wiki:Commentary/Compiler/IntegratedCodeGen]</p>
<h2 id="the-cmm-pipeline">The Cmm pipeline</h2>
<p>The first two steps are described in more detail here:</p>
<ul>
<li><strong>Code generator</strong> converts STG to
<pre><code>CmmGraph`.  Implemented in `StgCmm*` modules (in directory `codeGen</code></pre>
<p>).</p>
<ul>
<li><pre><code>Cmm.CmmGraph` is pretty much a Hoopl graph of `CmmNode.CmmNode</code></pre>
<p>nodes. Control transfer instructions are always the last node of a basic block.</p></li>
<li>Parameter passing is made explicit; the calling convention depends on the target architecture. The key function is
<pre><code>CmmCallConv.assignArgumentsPos</code></pre>
<p>.</p>
<ul>
<li>Parameters are passed in virtual registers R1, R2 etc. [These map 1-1 to real registers.]</li>
<li>Overflow parameters are passed on the stack using explicit memory stores, to locations described abstractly using the [wiki:Commentary/Compiler/StackAreas <em>Stack Area</em> abstraction.].</li>
<li>Making the calling convention explicit includes an explicit store instruction of the return address, which is stored explicitly on the stack in the same way as overflow parameters. This is done (obscurely) in
<pre><code>MkGraph.mkCall</code></pre>
<p>.</p></li>
</ul></li>
</ul></li>
</ul>
<ul>
<li><strong>Simple control flow optimisation</strong>, implemented in
<pre><code>CmmContFlowOpt</code></pre>
<p>. It's called both at the beginning and end of the pipeline.</p>
<ul>
<li>Branch chain elimination.</li>
<li>Remove unreachable blocks.</li>
<li>Block concatenation. branch to K; and this is the only use of K.</li>
</ul></li>
</ul>
<ul>
<li><strong>More control flow optimisations</strong>.
<ul>
<li>Common Block Elimination (like CSE). This essentially implements the Adams optimisation, we believe.</li>
<li>Consider (sometime): block duplication. branch to K; and K is a short block. Branch chain elimination is just a special case of this.</li>
</ul></li>
</ul>
<ul>
<li><strong>Proc-point analysis</strong> and <strong>transformation</strong>, implemented in
<pre><code>CmmProcPoint</code></pre>
<p>. The transformation part adds a function prologue to the front of each proc-point, following a standard entry convention.</p>
<ul>
<li>The analysis produces a set of
<pre><code>BlockId</code></pre>
<p>that should become proc-points</p></li>
<li>The transformation inserts a function prologue at the start of each proc-point, and a function epilogue just before each branch to a proc-point.</li>
</ul></li>
</ul>
<ul>
<li><strong>(OUTDATED - CmmSpillReload does not exist any more)</strong> <strong>Add spill/reload</strong>, implemented in
<pre><code>CmmSpillReload`, to spill live C-- variables before a call and reload them afterwards.  The spill and reload instructions are simply memory stores and loads respectively, using symbolic stack offsets (see [wiki:Commentary/Compiler/StackAreas#Layingoutthestack stack layout]).  For example, a spill of variable &#39;x&#39; would look like `Ptr32[SS(x)] = x</code></pre>
<p>.</p>
<ul>
<li><pre><code>dualLivenessWithInsertion</code></pre>
<p>does two things:</p>
<ul>
<li>Spills at the definition of any variable that is subequently live across a call (uses a backward analysis)</li>
<li>Adds a reload at each return (or proc) point</li>
</ul></li>
</ul></li>
</ul>
<p><code>  At this point, no (</code></p>
<pre><code>LocalReg</code></pre>
<p>) variables are live across a call.</p>
<ul>
<li>TODO: avoid
<pre><code>f();g()` turning into `spill x; f(); reload x; spill x; g(); reload x</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><strong>(OUTDATED - CmmRewriteAssignments is not used any more)</strong> <strong>Rewrite assignments</strong> (assignments to local regs, that is, not stores).
<ul>
<li>Convert graph to annotated graph whose nodes are
<pre><code>CmmRewriteAssignments.WithRegUsage`.  Specifically, `CmmAssign` is decorated with a flag `RegUsage</code></pre>
<p>saying whether it is used once or many times.</p></li>
<li>Sink or inline assignments nearer their use points</li>
<li>Do constant mach-op folding. This is done in this phase, because folded mach-ops can be inlined, and inlining exposes opportunities for mach-op folding.</li>
</ul></li>
</ul>
<ul>
<li><strong>Remove dead assignments and stores</strong>, implemented in
<pre><code>CmmLive`, removes assignments to dead variables and things like ``a = a`` or ``I32[Hp] = I32[Hp]`</code></pre>
<p>. The latter may more appropriately be done in a general optimization pass, as it doesn't take advantage of liveness information.</p></li>
</ul>
<ul>
<li><strong>Figure out the stack layout</strong>, implemented in
<pre><code>CmmStackLayout</code></pre>
<p>.</p>
<ul>
<li>Each variable 'x', and each proc-point label 'K', has an associated <em>Area</em>, written SS(x) and SS(k) resp, that names a contiguous portion of the stack frame.</li>
<li>The stack layout pass produces a mapping of: ''(
<pre><code>Area` -&gt; `StackOffset</code></pre>
<p>)''. For more detail, see [wiki:Commentary/Compiler/StackAreas#Layingoutthestack the description of stack layout.]</p></li>
<li>A
<pre><code>StackOffset</code></pre>
<p>is the byte offset of a stack slot from the old end (high address) of the frame. It doesn't vary as the physical stack pointer moves.</p></li>
</ul></li>
</ul>
<ul>
<li><strong>Manifest the stack pointer</strong>, implemented in
<pre><code>CmmStackLayout`.  Once the stack layout mapping has been determined, a second pass walks over the graph, making the stack pointer, `Sp` explicit. Before this pass, there is no `Sp` at all.  After this, `Sp</code></pre>
<p>is completely manifest.</p>
<ul>
<li>replacing references to
<pre><code>Areas` with offsets from `Sp</code></pre>
<p>.</p></li>
<li>adding adjustments to
<pre><code>Sp</code></pre>
<p>.</p></li>
</ul></li>
</ul>
<ul>
<li>'''Split into multiple CmmProcs''', implemented in
<pre><code>CmmProcPointZ</code></pre>
<p>. At this point we build an info-table for each of the CmmProcs, including SRTs. Done on the basis of the live local variables (by now mapped to stack slots) and live CAF statics.</p>
<ul>
<li><pre><code>LastCall` and `LastReturn` nodes are replaced by `Jump</code></pre>
<p>s.</p></li>
</ul></li>
</ul>
<ul>
<li><strong>Build info tables</strong>, implemented in
<pre><code>CmmBuildInfoTables</code></pre>
<p>..</p>
<ul>
<li>Find each safe
<pre><code>MidForeignCall` node, &quot;lowers&quot; it into the suspend/call/resume sequence (see `Note [Foreign calls]` in `CmmNode.hs</code></pre>
<p>.), and build an info table for them.</p></li>
<li>Convert the
<pre><code>CmmInfo` for each `CmmProc` into a `[CmmStatic]</code></pre>
<p>, using the live variable information computed just before &quot;Figure out stack layout&quot;.</p></li>
</ul></li>
</ul>
<h3 id="branches-to-continuations-and-the-adams-optimisation">Branches to continuations and the &quot;Adams optimisation&quot;</h3>
<p>A GC block for a heap check after a call should only take one or two instructions. However the natural code:</p>
<pre><code>    ...put params in R1 R2 etc...
    call foo returns to L
 L: r = R1   -- get return value
    goto M
 M: Hp = Hp + 20
    if (Hp &gt; HpLim) { call do_gc returns to K;
                   K: goto M; }</code></pre>
<p>The label M is the head of the call-gc-and-try-again loop. If we do this, we'll generate two info tables, one for L and one for K.</p>
<p>We can do better like this:</p>
<pre><code>    ...put params in R1 R2 etc...
    call foo returns to L
 L: r = R1
    goto M
 M: Hp = Hp + 20
    if (Hp &gt; HpLim) { R1 = r
                      call do_gc_p returns to K;
                   K: r = R1; goto M; }</code></pre>
<p>Now the</p>
<pre><code>do_gc_p</code></pre>
<p>call has the same return signature as</p>
<pre><code>foo</code></pre>
<p>and can use the same continuation, thus:</p>
<pre><code>    ...put params in R1 R2 etc...
    call foo returns to L
 L: r = R1
    goto M
 M: Hp = Hp + 20
    if (Hp &gt; HpLim) { R1 = r
                      call do_gc_p returns to L }</code></pre>
<p>Now we can coalesce the uniquely-used block M into L, thus:</p>
<pre><code>    ...put params in R1 R2 etc...
    call foo returns to L
 L: r = R1
    Hp = Hp + 20
    if (Hp &gt; HpLim) { R1 = r
                      call do_gc_p returns to L }</code></pre>
<p>(A call followed by a</p>
<pre><code>goto</code></pre>
<p>thus gets optimized down to just the call.)</p>
<p>Now things are good. Simple common block elimination (CBE) will common up K and L, so both calls share the same info table.</p>
<h2 id="runtime-system">Runtime system</h2>
<ul>
<li><strong>Garbage collector entry points</strong>: see
<pre><code>Note [Heap checks]` in `StgCmmHeapery</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><strong>PAPs</strong></li>
</ul>
<ul>
<li><strong>Update frames</strong> and <strong>exception handling</strong>. Also STM frames.</li>
</ul>
<ul>
<li><strong>Primitives</strong> can be rewritten:
<ul>
<li>Use parameters</li>
<li>In a few cases, use native calls (notably eval)</li>
</ul></li>
</ul>
<h1 id="note-historical-page">NOTE: Historical page</h1>
<p>This page is here for historical reasons. Most of the issues described here are now fixed (2 Aug 2012), and the new code generator produces code approximately as good as the old code generator. Any remaining issues will be made into tickets as necessary. See [wiki:Commentary/Compiler/CodeGen Code Generator] page for an up-to-date description of the current code generator.</p>
<h1 id="stupidity-in-the-new-code-generator">Stupidity in the New Code Generator</h1>
<p>Presently compiling using the new code generator results in a fairly sizable performance hit, because the new code generator produces sub-optimal (and sometimes absolutely terrible code.) There are <a href="http://darcs.haskell.org/ghc/compiler/cmm/cmm-notes">a lot of ideas for how to make things better</a>; the idea for this wiki page is to document all of the stupid things the new code generator is doing, to later be correlated with specific refactorings and fixes that will hopefully eliminate classes of these stupid things. The hope here is to develop a sense for what the most endemic problems with the newly generated code is.</p>
<h2 id="cantankerous-comparisons">Cantankerous Comparisons</h2>
<p>FIXED in newcg branch, 15/2/2012</p>
<p>In</p>
<pre><code>cgrun065</code></pre>
<p>we have</p>
<pre><code>test_sizeofArray :: [Int]
test_sizeofArray = runST $ ST $ \ s# -&gt; go 0# [] s#
  where
    go i acc s#
        | i &lt;# 1000# = case newArray# i 0 s# of
            (# s2#, marr# #) -&gt; go (i +# 1#) ((I# 1#):acc) s2#
        | otherwise = (# s#, acc #)</code></pre>
<p>Which compiles to the nice STG code</p>
<pre><code>                let-no-escape {
                    go_sew =
                        sat-only \r srt:SRT:[] [i_seo acc_ser s#1_seq]
                            case &lt;# [i_seo 1000] of wild_seN {
                              GHC.Types.False -&gt; (#,#) [s#1_seq acc_ser];
                              GHC.Types.True -&gt;
                                  let { sat_seJ = NO_CCS GHC.Integer.Type.S#! [0];
                                  } in </code></pre>
<p>But the comparison is compiled into stupid code:</p>
<pre><code>  cg0:
      // outOfLine should follow:
      _cgm::I64 = %MO_S_Lt_W64(_seo::I64, 1000);
      // emitReturn: Sequel: Assign
      _seN::I64 = I64[GHC.Types.Bool_closure_tbl + (_cgm::I64 &lt;&lt; 3)];
      _cgn::I64 = _seN::I64 &amp; 7;
      if (_cgn::I64 &gt;= 2) goto cgc; else goto cg5;
  cgc:</code></pre>
<p>etc.</p>
<p>We're actually converting to a</p>
<pre><code>Bool</code></pre>
<p>and then doing an algebraic case! This is a StgCmm issue, not a pipeline issue.</p>
<h2 id="dead-stackheap-checks">Dead stack/heap checks</h2>
<p>FIXED in newcg branch, but in an ad-hoc way (the stack allocator does it). We probably want to do this as part of a more general optimisation pass.</p>
<p>See in</p>
<pre><code>cgrun065</code></pre>
<pre><code>     cgr:
         if (0) goto cgx;
         R1 = R2;
         jump stg_ap_0_fast ();
     cgx: jump stg_gc_fun ();</code></pre>
<h2 id="instruction-reordering">Instruction reordering</h2>
<p>NEW. We should be able to reorder instructions in order to decrease register pressure. Here's an example from 3586.hs</p>
<pre><code>        _cPY::I32 = I32[Sp - 24];
        I32[R1 + 4] = _cPY::I32;
        I32[R1] = stg_IND_STATIC_info;
        I32[Sp - 8] = _cPY::I32;
        I32[Sp - 12] = stg_upd_frame_info;</code></pre>
<p>R1 and Sp probably don't clobber each other, so we ought to use _cPY twice in quick succession. Fortunately stg_IND_STATIC_info is a constant so in this case the optimization doesn't help to much, but in other cases it might make sense. TODO Find better example</p>
<h2 id="stack-space-overuse">Stack space overuse</h2>
<p>FIXED in the newcg branch. (stack layout algorithm redesigned)</p>
<p>CONFIRMED.</p>
<pre><code>T1969.hs</code></pre>
<p>demonstrates this:</p>
<pre><code> Simp.c_entry()
         { update_frame: &lt;none&gt;
           has static closure: True type: 0
           desc: 0
           tag: 15
           ptrs: 0
           nptrs: 0
           srt: (srt_Sc2_srt,0,3)
           fun_type: 5
           arity: 1
           slow: Simp.c_slow
         }
     cbG:
         _sbe::I32 = I32[Sp + 0];
         if (Sp - 4 &lt; SpLim) goto cbN;
         // outOfLine should follow:
         if (_sbe::I32 &amp; 3 &lt;nowiki&gt;=&lt;/nowiki&gt; 0) goto cbP;
         // emitCall: Sequel: Assign
         R1 = _sbe::I32;
         I32[Sp - 4] = block_cbA_info;
         Sp = Sp - 4;
         jump I32[_sbe::I32] ();
     cbN:
         // outOfLine here
         R1 = Simp.c_closure;
         jump stg_gc_fun ();
     cbP:
         // emitReturn: Sequel: Assign
         _sbg::I32 = _sbe::I32;
         Sp = Sp + 4;
         jump block_cbR_entry ();
 }</code></pre>
<p>The call area for the jump in cbG is using an extra word on the stack, but in fact Sp + 0 at the entry of the function immediately becomes dead after the assignment, so we ought to be able to save some space in our layout. Simon Marlow suggests we distinguish between the return address and the old call area; however, since this can also happen for the return parameters from call areas, we need a more general scheme.</p>
<p>After I discussed this with SPJ, we've decided that we need to teach the stack layout how to handle partial conflicts. There is a complication here, in that if we do this naively, the interference graph will blow up (since, rather than conflicting call areas, we now have conflicting words of call areas.) Simon suggested that we bound the amount of conflicts we track: either up to 3 or conflict with everything (in which case we just place the area as far down as necessary rather than try to be clever.) I plan on doing this once I understand the current layout code...</p>
<h2 id="double-temp-use-means-no-inlinining">Double temp-use means no inlinining?</h2>
<p>CONFIRMED. Here's a curious piece of code that fails to get inlined (from</p>
<pre><code>cc004</code></pre>
<p>):</p>
<pre><code>        _sG5::I32 = I32[Sp + 48];
        I32[Sp - 4] = _sG5::I32;</code></pre>
<p>Why is that? Because the temp gets reused later on:</p>
<pre><code>    u1bF:
        Sp = Sp + 56;
        // outOfLine here
        R1 = a13_rAk_closure;
        I32[Sp - 8] = _sG5::I32;</code></pre>
<p>In this case, we want more aggressive inlining because there are too many temps and they're going to have to get spilled to the stack anyway. IS THAT TRUE? For comparison's sake, the old codegen doesn't appear to do any rewriting, because it just reuses the call area.</p>
<h2 id="stupid-spills">Stupid spills</h2>
<p>CONFIRMED. If something is already in memory, why do we have to spill it again?</p>
<pre><code>module Foo where
foo a b c d e f g h
    = case baz a of
        True -&gt; bar a b c d e f g h
        False -&gt; 0

baz 3 = True
baz _ = False
bar a b c d e f g h = a * b + c * d + e * f * g * h</code></pre>
<p>Well, it's because the spiller isn't clever enough:</p>
<pre><code>  cs3:
      _smw::I32 = I32[(old + 8)];
      I32[(slot&lt;_smw::I32&gt; + 4)] = _smw::I32;
      _smv::I32 = I32[(old + 12)];
      I32[(slot&lt;_smv::I32&gt; + 4)] = _smv::I32;
      _smu::I32 = I32[(old + 16)];
      I32[(slot&lt;_smu::I32&gt; + 4)] = _smu::I32;
      _smt::I32 = I32[(old + 20)];
      I32[(slot&lt;_smt::I32&gt; + 4)] = _smt::I32;
      _sms::I32 = I32[(old + 24)];
      I32[(slot&lt;_sms::I32&gt; + 4)] = _sms::I32;
      _smr::I32 = I32[(old + 28)];
      I32[(slot&lt;_smr::I32&gt; + 4)] = _smr::I32;
      _smq::I32 = I32[(old + 32)];
      I32[(slot&lt;_smq::I32&gt; + 4)] = _smq::I32;
      _smn::I32 = I32[(old + 36)];
      I32[(slot&lt;_smn::I32&gt; + 4)] = _smn::I32;
      _smm::I32 = I32[(old + 40)];
      I32[(slot&lt;_smm::I32&gt; + 4)] = _smm::I32;
      if (Sp - &lt;highSp&gt; &lt; SpLim) goto cs9; else goto cs5;
  cs5:
      // outOfLine should follow:
      // directEntry else
      // emitCall: Sequel: Assign
      I32[(young&lt;crz&gt; + 8)] = _smn::I32;
      I32[(young&lt;crz&gt; + 12)] = _smm::I32;
      I32[(young&lt;crz&gt; + 4)] = crz;
      call Foo.baz_info(...) returns to Just crz (12) (4) with update frame 4;
  crz:
      _smm::I32 = I32[(slot&lt;_smm::I32&gt; + 4)];
      _smn::I32 = I32[(slot&lt;_smn::I32&gt; + 4)];
      _smq::I32 = I32[(slot&lt;_smq::I32&gt; + 4)];
      _smr::I32 = I32[(slot&lt;_smr::I32&gt; + 4)];
      _sms::I32 = I32[(slot&lt;_sms::I32&gt; + 4)];
      _smt::I32 = I32[(slot&lt;_smt::I32&gt; + 4)];
      _smu::I32 = I32[(slot&lt;_smu::I32&gt; + 4)];
      _smv::I32 = I32[(slot&lt;_smv::I32&gt; + 4)];
      _smw::I32 = I32[(slot&lt;_smw::I32&gt; + 4)];
      _smx::I32 = R1;
      I32[(slot&lt;_smx::I32&gt; + 4)] = _smx::I32;
      _csp::I32 = _smx::I32 &amp; 3;
      if (_csp::I32 &gt;= 2) goto csk; else goto usu;</code></pre>
<p>Ick! The old codegen was much better...</p>
<pre><code>Foo.foo_entry()
        { [const Foo.foo_slow-Foo.foo_info;, const 9;,
       const Foo.foo_srt-Foo.foo_info;, const 589824;, const 0;,
const 196623;]
        }
    cqM:
        if ((Sp + -12) &lt; I32[BaseReg + 84]) goto cqO;
        I32[Sp - 8] = I32[Sp + 4];
        I32[Sp - 12] = I32[Sp + 0];
        I32[Sp - 4] = smz_info;
        Sp = Sp - 12;
        jump Foo.baz_info ();
    cqO:
        R1 = Foo.foo_closure;
        Sp = Sp + 0;
        jump (I32[BaseReg - 4]) ();
}

smz_ret()
        { [const Foo.foo_srt-smz_info;, const 9;, const 65568;]
        }
    cqx:
        if (R1 &amp; 3 &gt;= 2) goto cqC;
        Hp = Hp + 8;
        if (Hp &gt; I32[BaseReg + 92]) goto cqA;
        I32[Hp - 4] = sat_smA_info;
        I32[Sp + 36] = Hp - 4;
        I32[Sp + 32] = stg_ap_p_info;
        I32[Sp + 28] = I32[Sp + 4];
        Sp = Sp + 28;
        jump GHC.Num.fromInteger_info ();
    cqC:
        Sp = Sp + 4;
        jump Foo.bar_info ();
    cqB: jump (I32[BaseReg - 8]) ();
    cqA:
        I32[BaseReg + 112] = 8;
        goto cqB;
}</code></pre>
<p>The trouble is that the spiller doesn't know that the old call area is also valid game for locations that variables can live in. So, the solution is to rewrite the spiller to know about existing incoming memory locations. Make sure that this information gets to the stack layout engine when we do partial layouts (it should automatically notice, but double check)</p>
<h2 id="noppy-proc-points">Noppy proc-points</h2>
<p>CONFIRMED. Consider</p>
<pre><code>f :: Int -&gt; Int -&gt; Int -&gt; Int
f a b c
    = let x = a + b
          y = b + c
          z = a + c
      in x &lt;pre&gt;seq</code></pre>
<p>case g x y z of</p>
<p><code>           True  -&gt; x</code><br />
<code>           False -&gt; 0</code></p>
<p>{-# NOINLINE g #-} g :: Int -&gt; Int -&gt; Int -&gt; Bool g x y 0 = x == y g _ _ _ = False</p>
</pre>
<pre><code>      cnm:
          // directEntry else
          // emitCall: Sequel: Assign
          I32[(young&lt;cmM&gt; + 8)] = base_GHCziNum_zdfNumInt_closure;
          I32[(young&lt;cmM&gt; + 4)] = cmM;
          call base_GHCziNum_zp_info(...) returns to Just cmM (8) (4) with update frame 4;
      cmM:
          _cmN::I32 = R1;
          // slow_call for _cmN::I32 with pat stg_ap_pp
          R1 = _cmN::I32;
          // emitCall: Sequel: Assign
          I32[(young&lt;cmP&gt; + 8)] = _skO::I32;
          I32[(young&lt;cmP&gt; + 12)] = _skN::I32;
          I32[(young&lt;cmP&gt; + 4)] = cmP;
          call stg_ap_pp_fast(...) returns to Just cmP (12) (4) with update frame 4;</code></pre>
<p>We generate an extra proc-point for</p>
<pre><code>`cmM``, where in theory we ought to be able to stick the subsequent ``stg_ap_pp_fast`</code></pre>
<p>onto the stack as another return point.</p>
<h2 id="lots-of-temporary-variables">Lots of temporary variables</h2>
<p>WONTFIX. Lots of temporary variables (these can tickle other issues when the temporaries are long-lived, but otherwise would be optimized away). You can at least eliminate some of them by looking at the output of</p>
<pre><code>-ddump-opt-cmm`, which utilizes some basic temporary inlining when used with the native backend `-fasm</code></pre>
<p>, but this doesn't currently apply to the GCC or LLVM backends.</p>
<p><strike>At least one major culprit for this is</p>
<pre><code>allocDynClosure`, described in Note `Return a LocalReg`; this pins down the value of the `CmmExpr</code></pre>
<p>to be something for one particular time, but for a vast majority of use-cases the expression is used immediately afterwards. Actually, this is mostly my patches fault, because the extra rewrite means that the inline pass is broken.</strike> Fixed in latest version of the pass; we don't quite manage to inline enough but there's only one extra temporary.</p>
<p>Another cause of all of these temporary variables is that the new code generator immediately assigns any variables that were on the stack to temporaries immediately upon entry to a function. This is on purpose. The idea is we optimize these temporary variables away.</p>
<h2 id="double-proc-points">Double proc points</h2>
<p>FIXED in newcg branch.</p>
<p>Given a simple case expression</p>
<pre><code>f x = case x of
         I# y -&gt; y</code></pre>
<p>we generate *two* proc points, not one.</p>
<pre><code>  cbR:
      if (_sbl::I64 &amp; 7 &lt;nowiki&gt;=&lt;/nowiki&gt; 0) goto cbU; else goto cbV;
  cbU:
      _sbp::I64 = _sbl::I64;
      goto cbW;
  cbV:
      R1 = _sbl::I64;
      I64[(young&lt;cbE&gt; + 8)] = cbE;
      call (I64[_sbl::I64])(...) returns to Just cbE (8) (8) with update frame 8;
  cbE:
      _sbp::I64 = R1;
      goto cbW;
  cbW:
      _sbo::I64 = I64[_sbp::I64 + 7];
      _cbJ::I64 = _sbo::I64 + 1;
      // emitReturn: Sequel: Return
      R1 = _cbJ::I64;
      call (I64[(old + 8)])(...) returns to Nothing (8) (0) with update frame 8;</code></pre>
<p>Both</p>
<pre><code>cbE` and `cbW</code></pre>
<p>are going to become proc points.</p>
<p>To avoid it we should generate code that re-uses</p>
<pre><code>cbE` as the destination for the first `if</code></pre>
<dl>
<dt>that is, we need to load up the registers as if we were returning from the call. This needs some refactoring in the code generator.</dt>

</dl>
<h2 id="rewriting-stacks">Rewriting stacks</h2>
<p>FIXED.</p>
<pre><code>3586.hs</code></pre>
<p>emits the following code:</p>
<pre><code> Main.$wa_entry()
         { [const Main.$wa_slow-Main.$wa_info;, const 3591;, const 0;,
    const 458752;, const 0;, const 15;]
         }
     c17W:
         _s16B::F64 = F64[Sp + 20];
         F64[Sp - 8] = _s16B::F64;
         _s16h::I32 = I32[Sp + 16];
         _s16j::I32 = I32[Sp + 12];
         _s16y::I32 = I32[Sp + 8];
         _s16x::I32 = I32[Sp + 4];
         _s16w::I32 = I32[Sp + 0];
         if (Sp - 12 &lt; SpLim) goto u1bR;
         Sp = Sp + 32;
// [SNIP]
         // directEntry else
         // emitCall: Sequel: Return
         F64[Sp - 12] = _s17a::F64;
         I32[Sp - 16] = _s17b::I32;
         I32[Sp - 20] = _s16j::I32;
         I32[Sp - 24] = _s16y::I32;
         I32[Sp - 28] = _s16x::I32;
         I32[Sp - 32] = _s16w::I32;
         Sp = Sp - 32;
         jump Main.$wa_info ();
     u1bR:
         Sp = Sp + 32;
         // outOfLine here
         R1 = Main.$wa_closure;
         F64[Sp - 12] = _s16B::F64;
         I32[Sp - 16] = _s16h::I32;
         I32[Sp - 20] = _s16j::I32;
         I32[Sp - 24] = _s16y::I32;
         I32[Sp - 28] = _s16x::I32;
         I32[Sp - 32] = _s16w::I32;
         Sp = Sp - 32;
         jump stg_gc_fun ();</code></pre>
<p>We see that these temporary variables are being repeatedly rewritten to the stack, even when there are no changes.</p>
<p>Since these areas on the stack are all old call areas, one way to fix this is to inline all of the memory references. However, this has certain undesirable properties for other code, so we need to be a little more clever. The key thing to notice is that these accesses are only used once per control flow path, in which case sinking the loads down and then inlining them should be OK (it will increase code size but not execution time.) However, the other difficulty is that the CmmOpt inliner, as it stands, won't inline things that look like this because although the variable is only used once in different branches, the same name is used, so it can't distinguish between the temporaries with mutually exclusive live ranges. Building a more clever inliner with Hoopl is also a bit tricky, because inlining is a forward analysis/transformation, but usage counting is a backwards analysis.</p>
<p>This looks fixed with the patch from April 14.</p>
<h2 id="spilling-hpsp">Spilling Hp/Sp</h2>
<p>FIXED.</p>
<pre><code>3586.hs</code></pre>
<p>emits the following code:</p>
<pre><code>     _c1ao::I32 = Hp - 4;
     I32[Sp - 20] = _c1ao::I32;
     foreign &quot;ccall&quot;
       newCAF((BaseReg, PtrHint), (R1, PtrHint))[_unsafe_call_];
     _c1ao::I32 = I32[Sp - 20];</code></pre>
<p>We see</p>
<pre><code>Hp - 4` being allocated to a temp, and then consequently being spilled to the stack even though `newCAF` definitely will not change `Hp</code></pre>
<p>, so we could have floated the expression down.</p>
<p>This seems to happen whenever there's a</p>
<pre><code>newCAF</code></pre>
<p>ccall.</p>
<p>We also seem to reload these values multiple times.</p>
<pre><code>        _c7Yt::I32 = Hp - 4;
        I32[Sp - 28] = _c7Yt::I32;
        foreign &quot;ccall&quot;
          newCAF((BaseReg, PtrHint), (R1, PtrHint))[_unsafe_call_];
        _c7Yt::I32 = I32[Sp - 28];
        I32[R1 + 4] = _c7Yt::I32;
        I32[R1] = stg_IND_STATIC_info;
        _c7Yt::I32 = I32[Sp - 28];  &lt;--- totally unnecessary
        I32[Sp - 8] = _c7Yt::I32;
        I32[Sp - 12] = stg_upd_frame_info;</code></pre>
<p><del>We need to not spill across certain foreign calls, but for which calls this is OK for is unclear.</del> Variables stay live across all unsafe foreign calls (foreign calls in the middle), except for the obvious cases (the return registers), so no spilling should happen at all. The liveness analysis is too conservative.</p>
<p>This is not fixed in the April 14 version of the patch... we still need to fix the liveness analysis? I thought I fixed that... that's because the transform did extra spilling for CmmUnsafeForeignCalls. Removed that code, and now it's fixed.</p>
<h2 id="up-and-down">Up and Down</h2>
<p>FIXED. A frequent pattern is the stack pointer being bumped up and then back down again, for no particular reason.</p>
<pre><code>         Sp = Sp + 4;
         Sp = Sp - 4;
         jump block_c7xh_entry ();</code></pre>
<p>This is mentioned at the very top of</p>
<pre><code>cmm-notes</code></pre>
<p>. This was a bug in the stack layout code that I have fixed.</p>
<h2 id="sp-is-generally-stupid">Sp is generally stupid</h2>
<p>FIXED. Here is an optimized C-- sample from</p>
<pre><code>arr016.hs</code></pre>
<p>.</p>
<pre><code>Main.D:Arbitrary_entry()
        { [const 131084;, const 0;, const 15;]
        }
    c7J5:
        _B1::I32 = I32[Sp + 4];
        _B2::I32 = I32[Sp + 0];
        if ((Sp + 0) &lt; I32[BaseReg + 84]) goto u7Jf;
        Sp = Sp + 12;
        Hp = Hp + 12;
        if (Hp &gt; I32[BaseReg + 92]) goto c7Jc;
        I32[Hp - 8] = Main.D:Arbitrary_con_info;
        I32[Hp - 4] = _B2::I32;
        I32[Hp + 0] = _B1::I32;
        _c7J4::I32 = Hp - 7;
        R1 = _c7J4::I32;
        Sp = Sp - 4;
        jump (I32[Sp + 0]) ();
    u7Jf:
        Sp = Sp + 12;
        goto c7Jd;
    c7Jc:
        I32[BaseReg + 112] = 12;
        goto c7Jd;
    c7Jd:
        R1 = Main.D:Arbitrary_closure;
        Sp = Sp - 12;
        jump (I32[BaseReg - 4]) ();
}</code></pre>
<p>Compare with the old code:</p>
<pre><code>Main.D:Arbitrary_entry()
        { [const 131084;, const 0;, const 15;]
        }
    c4pX:
        Hp = Hp + 12;
        if (Hp &gt; I32[BaseReg + 92]) goto c4pU;
        I32[Hp - 8] = Main.D:Arbitrary_con_info;
        I32[Hp - 4] = I32[Sp + 0];
        I32[Hp + 0] = I32[Sp + 4];
        R1 = Hp - 7;
        Sp = Sp + 8;
        jump (I32[Sp + 0]) ();
    c4pV:
        R1 = Main.D:Arbitrary_closure;
        jump (I32[BaseReg - 4]) ();
    c4pU:
        I32[BaseReg + 112] = 12;
        goto c4pV;
}</code></pre>
<p>You can see the up and down behavior here, but that's been fixed, so ignore it for now. (Update the C--) The unfixed problem is this (some of the other problems were already addressed): we do an unnecessary stack check on entry to this function. We should eliminate the stack check (and by dead code analysis, the GC call) in such cases.</p>
<p>This pattern essentially happens for every function, since we always assign incoming parameters to temporary variables before doing anything.</p>
<h2 id="heap-and-r1-aliasing">Heap and R1 aliasing</h2>
<p>FIXED. Values on the heap and values from R1 don't necessarily clobber each other. allocDynClosure seems like a pretty safe bet they don't. But is this true in general? ANSWER: Memory writes with Hp are always new allocations, so they don't clobber anything.</p>
<pre><code>        _s14Y::F64 = F64[_s1uN::I32 + 8];
        _s152::F64 = F64[_s1uN::I32 + 16];
        _s156::F64 = F64[_s1uN::I32 + 24];
        _s15a::F64 = F64[_s1uN::I32 + 32];
        _s15e::F64 = F64[_s1uN::I32 + 40];
        _s15i::F64 = F64[_s1uN::I32 + 48];
        _s15m::F64 = F64[_s1uN::I32 + 56];
        _c39O::I32 = Hp - 60;
        // calling allocDynClosure
        // allocDynClosure
        I32[Hp - 60] = sat_s1uQ_info;
        F64[Hp - 52] = _s14Y::F64;
        F64[Hp - 44] = _s152::F64;
        F64[Hp - 36] = _s156::F64;
        F64[Hp - 28] = _s15a::F64;
        F64[Hp - 20] = _s15e::F64;
        F64[Hp - 12] = _s15i::F64;
        F64[Hp - 4] = _s15m::F64;</code></pre>
<h1 id="old-code-generator-prior-to-ghc-7.8">Old Code Generator (prior to GHC 7.8)</h1>
<p>Material below describes old code generator that was used up to GHC 7.6 and was retired in 2012. This page is not maintained and is here only for historical purposes. See [wiki:Commentary/Compiler/CodeGen Code generator] page for an up to date description of the current code generator.</p>
<h2 id="storage-manager-representations">Storage manager representations</h2>
<p>See [wiki:Commentary/Rts/Storage The Storage Manager] for the [wiki:Commentary/Rts/Storage/Stack Layout of the stack].</p>
<p>The code generator needs to know the layout of heap objects, because it generates code that accesses and constructs those heap objects. The runtime also needs to know about the layout of heap objects, because it contains the garbage collector. How can we share the definition of storage layout such that the code generator and the runtime both have access to it, and so that we don't have to keep two independent definitions in sync?</p>
<p>Currently we solve the problem this way:</p>
<ul>
<li>C types representing heap objects are defined in the C header files, see for example <a href="GhcFile(includes/rts/storage/Closures.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/Closures.h)</a>.</li>
</ul>
<ul>
<li>A C program, <a href="GhcFile(includes/mkDerivedConstants.c)" class="uri" title="wikilink">GhcFile(includes/mkDerivedConstants.c)</a>,
<pre><code>#includes</code></pre>
<p>the runtime headers.</p></li>
</ul>
<p><code>  This program is built and run when you type </code></p>
<pre><code>make` or `make boot` in `includes/</code></pre>
<p>. It is</p>
<p><code>  run twice: once to generate </code></p>
<pre><code>includes/DerivedConstants.h</code></pre>
<p>, and again to generate</p>
<pre><code>includes/GHCConstants.h</code></pre>
<p>.</p>
<ul>
<li>The file
<pre><code>DerivedConstants.h` contains lots of `#defines</code></pre>
<p>like this:</p></li>
</ul>
<pre><code>#define OFFSET_StgTSO_why_blocked 18</code></pre>
<p><code>  which says that the offset to the why_blocked field of an </code></p>
<pre><code>StgTSO</code></pre>
<p>is 18 bytes. This file</p>
<p><code>  is </code></p>
<pre><code>#included</code></pre>
<p>into <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a>, so these offests are available to the</p>
<p><code>  [wiki:Commentary/Rts/Cmm hand-written .cmm files].</code></p>
<ul>
<li>The file
<pre><code>GHCConstants.h</code></pre>
<p>contains similar definitions:</p></li>
</ul>
<pre><code>oFFSET_StgTSO_why_blocked = 18::Int</code></pre>
<p><code> This time the definitions are in Haskell syntax, and this file is </code></p>
<pre><code>#included</code></pre>
<p>directly into</p>
<p><code> </code><a href="GhcFile(compiler/main/Constants.lhs)" title="wikilink"><code>GhcFile(compiler/main/Constants.lhs)</code></a><code>.  This is the way that these offsets are made</code><br />
<code> available to GHC's code generator.</code></p>
<h2 id="generated-cmm-naming-convention">Generated Cmm Naming Convention</h2>
<p>See <a href="GhcFile(compiler/cmm/CLabel.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/CLabel.hs)</a></p>
<p>Labels generated by the code generator are of the form</p>
<pre><code>&lt;name&gt;_&lt;type&gt;</code></pre>
<p>where</p>
<pre><code>&lt;name&gt;</code></pre>
<p>is</p>
<pre><code>&lt;Module&gt;_&lt;name&gt;</code></pre>
<p>for external names and</p>
<pre><code>&lt;unique&gt;</code></pre>
<p>for internal names.</p>
<pre><code>&lt;type&gt;</code></pre>
<p>is one of the following:</p>
<p><code> info::                   Info table</code><br />
<code> srt::                    Static reference table</code><br />
<code> srtd::                   Static reference table descriptor</code><br />
<code> entry::                  Entry code (function, closure)</code><br />
<code> slow::                   Slow entry code (if any)</code><br />
<code> ret::                    Direct return address    </code><br />
<code> vtbl::                   Vector table</code><br />
<code> </code><em><code>n</code></em><code>_alt::              Case alternative (tag </code><em><code>n</code></em><code>)</code><br />
<code> dflt::                   Default case alternative</code><br />
<code> btm::                    Large bitmap vector</code><br />
<code> closure::                Static closure</code><br />
<code> con_entry::              Dynamic Constructor entry code</code><br />
<code> con_info::               Dynamic Constructor info table</code><br />
<code> static_entry::           Static Constructor entry code</code><br />
<code> static_info::            Static Constructor info table</code><br />
<code> sel_info::               Selector info table</code><br />
<code> sel_entry::              Selector entry code</code><br />
<code> cc::                     Cost centre</code><br />
<code> ccs::                    Cost centre stack</code></p>
<p>Many of these distinctions are only for documentation reasons. For example, _ret is only distinguished from _entry to make it easy to tell whether a code fragment is a return point or a closure/function entry.</p>
<h2 id="modules">Modules</h2>
<p>===</p>
<pre><code>CodeGen</code></pre>
<p>=== Top level, only exports</p>
<pre><code>codeGen</code></pre>
<p>.</p>
<p>Called from</p>
<pre><code>HscMain</code></pre>
<p>for each module that needs to be converted from Stg to Cmm.</p>
<p>For each such module</p>
<pre><code>codeGen</code></pre>
<p>does three things:</p>
<ul>
<li><pre><code>cgTopBinding</code></pre>
<p>for the</p>
<pre><code>StgBinding</code></pre></li>
<li><pre><code>cgTyCon</code></pre>
<p>for the</p>
<pre><code>TyCon</code></pre>
<p>(These are constructors not constructor calls).</p></li>
<li><pre><code>mkModuleInit</code></pre>
<p>for the module</p></li>
</ul>
<pre><code>mkModuleInit</code></pre>
<p>generates several boilerplate initialization functions that:</p>
<ul>
<li>regiser the module,</li>
<li>creates an Hpc table,</li>
<li>setup its profiling info (
<pre><code>InitConstCentres</code></pre>
<p>, code coverage info</p>
<pre><code>initHpc</code></pre>
<p>), and</p></li>
<li>calls the initialization functions of the modules it imports.</li>
</ul>
<p>If neither SCC profiling or HPC are used, then the initialization code short circuits to return.</p>
<p>If the module has already been initialized, the initialization function just returns.</p>
<p>The</p>
<pre><code>Ghc.TopHandler</code></pre>
<p>and</p>
<pre><code>Ghc.Prim</code></pre>
<p>modules get special treatment.</p>
<pre><code>cgTopBinding</code></pre>
<p>is a small wrapper around</p>
<pre><code>cgTopRhs</code></pre>
<p>which in turn disptaches to:</p>
<ul>
<li><pre><code>cgTopRhsCons</code></pre>
<p>for</p>
<pre><code>StgRhsCons</code></pre></li>
</ul>
<p><code>  (these are bindings of constructor applications not constructors themselves) and</code></p>
<ul>
<li><pre><code>cgTopRhsClosure</code></pre>
<p>for</p>
<pre><code>StgRhsClosure</code></pre>
<p>.</p></li>
</ul>
<pre><code>cgTopRhsCons</code></pre>
<p>and</p>
<pre><code>cgTopRhsClosure</code></pre>
<p>are located in</p>
<pre><code>CgCon</code></pre>
<p>and</p>
<pre><code>CgClosure</code></pre>
<p>which are the primary modules called by</p>
<pre><code>CodeGen</code></pre>
<p>.</p>
<p>===</p>
<pre><code>CgCon</code></pre>
<p>=== TODO</p>
<p>===</p>
<pre><code>CgClosure</code></pre>
<p>=== TODO</p>
<p>===</p>
<pre><code>CgMonad</code></pre>
<p>=== The monad that most of codeGen operates inside</p>
<ul>
<li>Reader</li>
<li>State</li>
<li>(could be Writer?)</li>
<li>fork</li>
<li>flatten</li>
</ul>
<p>===</p>
<pre><code>CgExpr</code></pre>
<p>=== Called by</p>
<pre><code>CgClosure</code></pre>
<p>and</p>
<pre><code>CgCon</code></pre>
<p>.</p>
<p>Since everything in STG is an expression, almost everything branches off from here.</p>
<p>This module exports only one function</p>
<pre><code>cgExpr</code></pre>
<p>, which for the most part just dispatches to other functions to handle each specific constructor in</p>
<pre><code>StgExpr</code></pre>
<p>.</p>
<p>Here are the core functions that each constructor is disptached to (though some may have little helper functions called in addition to the core function):</p>
<pre><code>StgApp</code></pre>
<dl>

<dd><dl>

<dd>Calls to
<pre><code>cgTailCall</code></pre>
<p>in</p>
<pre><code>CgTailCall</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>StgConApp</code></pre>
<dl>

<dd><dl>

<dd>Calls to
<pre><code>cgReturnDataCon</code></pre>
<p>in</p>
<pre><code>CgCon</code></pre>
</dd>
</dl>
</dd>
</dl>
<p>;</p>
<pre><code>StgLit</code></pre>
<dl>

<dd>Calls to
<pre><code>cgLit</code></pre>
<p>in</p>
<pre><code>CgUtil</code></pre>
</dd>
</dl>
<p><code>   and </code></p>
<pre><code>performPrimReturn</code></pre>
<p>in</p>
<pre><code>CgTailCall</code></pre>
<p>;</p>
<pre><code>StgOpApp</code></pre>
<dl>

<dd>Is a bit more complicated see below.
</dd>
</dl>
<pre><code>StgCase</code></pre>
<dl>

<dd><dl>

<dd>Calls to
<pre><code>cgCase</code></pre>
<p>in</p>
<pre><code>CgCase</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>StgLet</code></pre>
<dl>

<dd><dl>

<dd>Calls to
<pre><code>cgRhs</code></pre>
<p>in</p>
<pre><code>CgExpr</code></pre>
</dd>
</dl>
</dd>
</dl>
<p>;</p>
<pre><code>StgLetNoEscape</code></pre>
<dl>

<dd>Calls to
<pre><code>cgLetNoEscapeBindings</code></pre>
<p>in</p>
<pre><code>CgExpr</code></pre>
<p>, but with a little bit of wrapping</p>
</dd>
</dl>
<p><code>  by </code></p>
<pre><code>nukeDeadBindings</code></pre>
<p>and</p>
<pre><code>saveVolatileVarsAndRegs</code></pre>
<p>.</p>
<pre><code>StgSCC</code></pre>
<dl>

<dd><dl>

<dd>Calls to
<pre><code>emitSetCCC</code></pre>
<p>in</p>
<pre><code>CgProf</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>StgTick</code></pre>
<dl>

<dd><dl>

<dd>Calls to
<pre><code>cgTickBox</code></pre>
<p>in</p>
<pre><code>CgHpc</code></pre>
</dd>
</dl>
</dd>
</dl>
<p>;</p>
<pre><code>StgLam</code></pre>
<dl>

<dd>Does not have a case because it is only for
<pre><code>CoreToStg</code></pre>
<p>'s work.</p>
</dd>
</dl>
<p>Some of these cases call to functions defined in</p>
<pre><code>cgExpr</code></pre>
<p>. This is because they need a little bit of wrapping and processing before calling out to their main worker function.</p>
<p>;</p>
<pre><code>cgRhs</code></pre>
<dl>

<dd><ul>
<li>For
<pre><code>StgRhsCon</code></pre>
<p>calls out to</p>
<pre><code>buildDynCon</code></pre>
<p>in</p>
<pre><code>CgCon</code></pre>
<p>.</p></li>
</ul>
</dd>
</dl>
<ul>
<li>For
<pre><code>StgRhsClosure</code></pre>
<p>calls out to</p>
<pre><code>mkRhsClosure</code></pre>
<p>.</p></li>
</ul>
<p><code>  In turn, </code></p>
<pre><code>mkRhsClosure</code></pre>
<p>calls out to</p>
<pre><code>cgStdRhsClosure</code></pre>
<p>for selectors and thunks,</p>
<p><code>  and calls out to </code></p>
<pre><code>cgRhsClosure</code></pre>
<p>in the default case.</p>
<p><code>  Both these are defined in </code></p>
<pre><code>CgClosure</code></pre>
<p>.</p>
<p>;</p>
<pre><code>cgLetNoEscapeBindings</code></pre>
<dl>

<dd><ul>
<li>Wraps a call to
<pre><code>cgLetNoEscapeRhs</code></pre>
<p>with</p>
<pre><code>addBindsC</code></pre></li>
</ul>
</dd>
</dl>
<p><code>  depending on whether it is called on a recursive or a non-recursive binding.</code><br />
<code>  In turn </code></p>
<pre><code>cgLetNoEscapeRhs</code></pre>
<p>wraps</p>
<pre><code>cgLetNoEscapeClosure</code></pre>
<p><code>  defined in </code></p>
<pre><code>CgLetNoEscapeClosure</code></pre>
<p>.</p>
<pre><code>StgOpApp</code></pre>
<p>has a number of sub-cases.</p>
<ul>
<li><pre><code>StgFCallOp</code></pre></li>
<li><pre><code>StgPrimOp</code></pre>
<p>of a TagToEnumOp</p></li>
<li><pre><code>StgPrimOp</code></pre>
<p>that is primOpOutOfLine</p></li>
<li><pre><code>StgPrimOp</code></pre>
<p>that returns Void</p></li>
<li><pre><code>StgPrimOp</code></pre>
<p>that returns a single primitive</p></li>
<li><pre><code>StgPrimOp</code></pre>
<p>that returns an unboxed tuple</p></li>
<li><pre><code>StgPrimOp</code></pre>
<p>that returns an enumeration type</p></li>
</ul>
<p>(It appears that non-foreign-call, inline [wiki:Commentary/PrimOps PrimOps] are not allowed to return complex data types (e.g. a |Maybe|), but this fact needs to be verified.)</p>
<p>Each of these cases centers around one of these three core calls:</p>
<ul>
<li><pre><code>emitForeignCall</code></pre>
<p>in</p>
<pre><code>CgForeignCall</code></pre></li>
<li><pre><code>tailCallPrimOp</code></pre>
<p>in</p>
<pre><code>CgTailCall</code></pre></li>
<li><pre><code>cgPrimOp</code></pre>
<p>in</p>
<pre><code>CgPrimOp</code></pre></li>
</ul>
<p>There is also a little bit of argument and return marshelling with the following functions</p>
<dl>
<dt>Argument marshelling</dt>
<dd><pre><code>shimForeignCallArg</code></pre>
<p>,</p>
<pre><code>getArgAmods</code></pre>
</dd>
<dt>Return marshelling</dt>
<dd><pre><code>dataReturnConvPrim</code></pre>
<p>,</p>
<pre><code>primRepToCgRep</code></pre>
<p>,</p>
<pre><code>newUnboxedTupleRegs</code></pre>
</dd>
<dt>Performing the return</dt>
<dd><pre><code>emitReturnInstr</code></pre>
<p>,</p>
<pre><code>performReturn</code></pre>
<p>,</p>
</dd>
</dl>
<pre><code>returnUnboxedTuple</code></pre>
<p>,</p>
<pre><code>ccallReturnUnboxedTuple</code></pre>
<p>In summary the modules that get called in order to handle a specific expression case are: ==== Also called for top level bindings by</p>
<pre><code>CodeGen</code></pre>
<p>====</p>
<pre><code>CgCon</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgConApp</code></pre>
<p>and the</p>
<pre><code>StgRhsCon</code></pre>
<p>part of</p>
<pre><code>StgLet</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>CgClosure</code></pre>
<dl>

<dd><dl>

<dd>for the
<pre><code>StgRhsClosure</code></pre>
<p>part of</p>
<pre><code>StgLet</code></pre>
</dd>
</dl>
</dd>
</dl>
<h4 id="core-code-generation">Core code generation</h4>
<pre><code>CgTailCall</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgApp</code></pre>
<p>,</p>
<pre><code>StgLit</code></pre>
<p>, and</p>
<pre><code>StgOpApp</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>CgPrimOp</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgOpApp</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>CgLetNoEscapeClosure</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgLetNoEscape</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>CgCase</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgCase</code></pre>
</dd>
</dl>
</dd>
</dl>
<h4 id="profiling-and-code-coverage-related">Profiling and Code coverage related</h4>
<pre><code>CgProf</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgSCC</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>CgHpc</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgTick</code></pre>
</dd>
</dl>
</dd>
</dl>
<h4 id="utility-modules-that-happen-to-have-the-functions-for-code-generation">Utility modules that happen to have the functions for code generation</h4>
<pre><code>CgForeignCall</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>StgOpApp</code></pre>
</dd>
</dl>
</dd>
</dl>
<pre><code>CgUtil</code></pre>
<dl>

<dd><dl>

<dd>for
<pre><code>cgLit</code></pre>
</dd>
</dl>
</dd>
</dl>
<p>Note that the first two are the same modules that are called for top level bindings by</p>
<pre><code>CodeGen</code></pre>
<p>, and the last two are really utility modules, but they happen to have the functions needed for those code generation cases.</p>
<h3 id="memory-and-register-management">Memory and Register Management</h3>
<p>;</p>
<pre><code>CgBindery</code></pre>
<dl>

<dd>Module for
<pre><code>CgBindings</code></pre>
<p>which maps variable names</p>
</dd>
</dl>
<p><code>  to all the volitile or stable locations where they are stored</code><br />
<code>  (e.g. register, stack slot, computed from other expressions, etc.)</code><br />
<code>  Provides the </code></p>
<pre><code>addBindC</code></pre>
<p>,</p>
<pre><code>modifyBindC</code></pre>
<p>and</p>
<pre><code>getCgIdInfo</code></pre>
<p>functions</p>
<p><code>  for adding, modifying and looking up bindings.</code></p>
<p>;</p>
<pre><code>CgStackery</code></pre>
<dl>

<dd>Mostly utility functions for allocating and freeing stack slots.
</dd>
</dl>
<p><code>  But also has things on setting up update frames.</code></p>
<p>;</p>
<pre><code>CgHeapery</code></pre>
<dl>

<dd>Functions for allocating objects that appear on the heap such as closures and constructors.
</dd>
</dl>
<p><code>  Also includes code for stack and heap checks and </code></p>
<pre><code>emitSetDynHdr</code></pre>
<p>.</p>
<h3 id="function-calls-and-parameter-passing">Function Calls and Parameter Passing</h3>
<p>(Note: these will largely go away once CPS conversion is fully implemented.)</p>
<p>;</p>
<pre><code>CgPrimOp</code></pre>
<p>,</p>
<pre><code>CgTailCall</code></pre>
<p>,</p>
<pre><code>CgForeignCall</code></pre>
<dl>

<dd>Handle different types of calls.
</dd>
</dl>
<p>;</p>
<pre><code>CgCallConv</code></pre>
<dl>

<dd>Use by the others in this category to determine liveness and
</dd>
</dl>
<p><code>  to select in what registers and stack locations arguments and return</code><br />
<code>  values get stored.</code></p>
<h3 id="misc-utilities">Misc utilities</h3>
<p>;</p>
<pre><code>Bitmap</code></pre>
<dl>

<dd>Utility functions for making bitmaps (e.g.
<pre><code>mkBitmap</code></pre>
<p>with type</p>
<pre><code>[Bool] -&gt; Bitmap</code></pre>
<p>)</p>
</dd>
</dl>
<p>;</p>
<pre><code>ClosureInfo</code></pre>
<dl>

<dd>Stores info about closures and bindings.
</dd>
</dl>
<p><code>  Includes information about memory layout, how to call a binding (</code></p>
<pre><code>LambdaFormInfo</code></pre>
<p>)</p>
<p><code>  and information used to build the info table (</code></p>
<pre><code>ClosureInfo</code></pre>
<p>).</p>
<p>;</p>
<pre><code>SMRep</code></pre>
<dl>

<dd>Storage manager representation of closures.
</dd>
</dl>
<p><code>  Part of ClosureInfo but kept separate to &quot;keep nhc happy.&quot;</code><br />
</p>
<pre><code>CgUtils</code></pre>
<dl>

<dd><dl>

<dd>TODO
</dd>
</dl>
</dd>
</dl>
<pre><code>CgInfoTbls</code></pre>
<dl>

<dd><dl>

<dd>TODO
</dd>
</dl>
</dd>
</dl>
<h3 id="special-runtime-support">Special runtime support</h3>
<pre><code>CgTicky</code></pre>
<dl>

<dd><dl>

<dd>Ticky-ticky profiling
</dd>
</dl>
</dd>
</dl>
<pre><code>CgProf</code></pre>
<dl>

<dd><dl>

<dd>Cost-centre profiling
</dd>
</dl>
</dd>
</dl>
<pre><code>CgHpc</code></pre>
<dl>

<dd><dl>

<dd>Support for the Haskell Program Coverage (hpc) toolkit, inside GHC.
</dd>
</dl>
</dd>
</dl>
<p>;</p>
<pre><code>CgParallel</code></pre>
<dl>

<dd>Code generation for GranSim (GRAN) and parallel (PAR).
</dd>
</dl>
<p><code>  All the functions are dead stubs except </code></p>
<pre><code>granYield</code></pre>
<p>and</p>
<pre><code>granFetchAndReschedule</code></pre>
<p>.</p>
<h1 id="ordering-the-core-to-core-optimisation-passes">Ordering the Core-to-Core optimisation passes</h1>
<p>This page has notes about the ordering of optimisation phases. An overview of the whole Core-to-Core optimisation pipeline can be found [wiki:Commentary/Compiler/Core2CorePipeline here].</p>
<p><strong>NOTE:</strong> This is old documentation and may not be very relevant any more!</p>
<h2 id="this-ordering-obeys-all-the-constraints-except-5">This ordering obeys all the constraints except (5)</h2>
<ul>
<li>full laziness</li>
<li>simplify with foldr/build</li>
<li>float-in</li>
<li>simplify</li>
<li>strictness</li>
<li>float-in</li>
</ul>
<p>[check FFT2 still gets benefits with this ordering]</p>
<h2 id="constraints-1">Constraints</h2>
<h3 id="float-in-before-strictness">1. float-in before strictness</h3>
<p>Reason: floating inwards moves definitions inwards to a site at which the binding might well be strict.</p>
<pre><code>Example     let x = ... in
            y = x+1
        in 
        ...
===&gt;
        let y = let x = ... in x+1
        in ...</code></pre>
<p>The strictness analyser will do a better job of the latter than the former.</p>
<h3 id="dont-simplify-between-float-in-and-strictness">2. Don't simplify between float-in and strictness</h3>
<p>...unless you disable float-let-out-of-let, otherwise the simiplifier's local floating might undo some useful floating-in.</p>
<pre><code>Example     let f = let y = .. in \x-&gt; x+y
        in ...
===&gt;
        let y = ... 
            f = \x -&gt; x+y
        in ...</code></pre>
<p>This is a bad move, because now y isn't strict. In the pre-float case, the binding for y is strict. Mind you, this isn't a very common case, and it's easy to disable float-let-from-let.</p>
<h3 id="want-full-laziness-before-foldrbuild">3. Want full-laziness before foldr/build</h3>
<p>Reason: Give priority to sharing rather than deforestation.</p>
<pre><code>Example     \z -&gt; let xs = build g 
              in foldr k z xs
===&gt;
        let xs = build g
        in \x -&gt; foldr k z xs</code></pre>
<p>In the post-full-laziness case, xs is shared between all applications of the function. If we did foldr/build first, we'd have got</p>
<pre><code>        \z -&gt; g k z</code></pre>
<p>and now we can't share xs.</p>
<h3 id="want-strictness-after-foldrbuild">4. Want strictness after foldr/build</h3>
<p>Reason: foldr/build makes new function definitions which can benefit from strictness analysis.</p>
<pre><code>Example:    sum [1..10]
===&gt; (f/b)
        let g x a | x &gt; 10    = a
                  | otherwise = g (x+1) (a+x)</code></pre>
<p>Here we clearly want to get strictness analysis on g.</p>
<h3 id="want-full-laziness-after-strictness">5. Want full laziness after strictness</h3>
<p>Reason: absence may allow something to be floated out which would not otherwise be.</p>
<pre><code>Example     \z -&gt; let x = f (a,z) in ...
===&gt; (absence anal + inline wrapper of f)
        \z -&gt; let x = f.wrk a in ...
===&gt; (full laziness)
        let x= f.wrk a in  \z -&gt; ...</code></pre>
<p>TOO BAD. This doesn't look a common case to me.</p>
<h3 id="want-float-in-after-foldrbuild">6. Want float-in after foldr/build</h3>
<p>Reason: Desugaring list comprehensions + foldr/build gives rise to new float-in opportunities.</p>
<pre><code>Example     ...some list comp...
==&gt; (foldr/build)
        let v = h xs in
        case ... of
          []     -&gt; v
          (y:ys) -&gt; ...(t v)...
==&gt; (simplifier)
        let v = h xs in
        case ... of
          [] -&gt; h xs
          (y:ys) -&gt; ...(t v)...</code></pre>
<p>Now v could usefully be floated into the second branch.</p>
<h3 id="want-simplify-after-float-inwards">7. Want simplify after float-inwards</h3>
<p>(Occurred in the prelude, compiling</p>
<pre><code>ITup2.hs`, function `dfun.Ord.(*,*)</code></pre>
<p>) This is due to the following (that happens with dictionaries):</p>
<pre><code>let a1 = case v of (a,b) -&gt; a
in let m1 = \ c -&gt; case c of I# c# -&gt; case c# of 1 -&gt; a1 5
                                                 2 -&gt; 6
in let m2 = \ c -&gt; case c of I# c# -&gt; 
                     case c# +# 1# of cc# -&gt; let cc = I# cc#
                                             in m1 cc 
   in (m1,m2)</code></pre>
<p>floating inwards will push the definition of a1 into m1 (supposing it is only used there):</p>
<pre><code>in let m1 = let a1 = case v of (a,b) -&gt; a
            in \ c -&gt; case c of I# c# -&gt; case c# of 1 -&gt; a1 5
                                            2 -&gt; 6
in let m2 = \ c -&gt; case c of I# c# -&gt; 
                     case c# +# 1# of cc# -&gt; let cc = I# cc#
                                             in m1 cc 
   in (m1,m2)</code></pre>
<p>if we do strictness analysis now we will not get a worker-wrapper for m1, because of the &quot;let a1 ...&quot; (notice that a1 is not strict in its body).</p>
<p>Not having this worker wrapper might be very bad, because it might mean that we will have to rebox arguments to m1 if they are already unboxed, generating extra allocations, as occurs with m2 (cc) above.</p>
<p>To solve this problem we have decided to run the simplifier after float-inwards, so that lets whose body is a HNF are floated out, undoing the float-inwards transformation in these cases. We are then back to the original code, which would have a worker-wrapper for m1 after strictness analysis and would avoid the extra let in m2.</p>
<p>What we lose in this case are the opportunities for case-floating that could be presented if, for example, a1 would indeed be demanded (strict) after the floating inwards.</p>
<p>The only way of having the best of both is if we have the worker/wrapper pass explicitly called, and then we could do with</p>
<ul>
<li>float-in</li>
<li>strictness analysis</li>
<li>simplify</li>
<li>strictness analysis</li>
<li>worker-wrapper generation</li>
</ul>
<p>as we would</p>
<ul>
<li>be able to detect the strictness of m1 after the first call to the strictness analyser, and exploit it with the simplifier (in case it was strict).</li>
<li>after the call to the simplifier (if m1 was not demanded) it would be floated out just like we currently do, before stricness analysis II and worker/wrapperisation.</li>
</ul>
<p>The reason to not do worker/wrapperisation twice is to avoid generating wrappers for wrappers which could happen.</p>
<h3 id="if-full-laziness-is-ever-done-after-strictness">8. If full laziness is ever done after strictness</h3>
<p>...remember to switch off demandedness flags on floated bindings! This isn't done at the moment.</p>
<h3 id="ignore-inline-pragmas-flag-for-final-simplification">9. Ignore-inline-pragmas flag for final simplification</h3>
<p>[Occurred in the prelude, compiling ITup2.hs, function dfun.Ord.(*,*)] Sometimes (e.g. in dictionary methods) we generate worker/wrappers for functions but the wrappers are never inlined. In dictionaries we often have</p>
<pre><code>dict = let f1 = ...
           f2 = ...
           ...
       in (f1,f2,...)</code></pre>
<p>and if we create worker/wrappers for f1,...,fn the wrappers will not be inlined anywhere, and we will have ended up with extra closures (one for the worker and one for the wrapper) and extra function calls, as when we access the dictionary we will be acessing the wrapper, which will call the worker. The simplifier never inlines workers into wrappers, as the wrappers themselves have INLINE pragmas attached to them (so that they are always inlined, and we do not know in advance how many times they will be inlined).</p>
<p>To solve this problem, in the last call to the simplifier we will ignore these inline pragmas and handle the workers and the wrappers as normal definitions. This will allow a worker to be inlined into the wrapper if it satisfies all the criteria for inlining (e.g. it is the only occurrence of the worker etc.).</p>
<h3 id="run-float-inwards-once-more-after-strictness-simplify">10. Run Float Inwards once more after strictness-simplify</h3>
<p>[Occurred in the prelude, compiling</p>
<pre><code>IInt.hs`, function `const.Int.index.wrk</code></pre>
<p>] When workers are generated after strictness analysis (worker/wrapper), we generate them with &quot;reboxing&quot; lets, that simply reboxes the unboxed arguments, as it may be the case that the worker will need the original boxed value:</p>
<pre><code>f x y = case x of 
          (a,b) -&gt; case y of 
                     (c,d) -&gt; case a == c of
                                True -&gt; (x,x)
                                False -&gt; ((1,1),(2,2))

==&gt; (worker/wrapper)

f_wrapper x y = case x of
                  (a,b) -&gt; case y of 
                             (c,d) -&gt; f_worker a b c d 

f_worker a b c d = let x = (a,b)
                       y = (c,d)
                   in case a == c of
                        True -&gt; (x,x)
                        False -&gt; ((1,1),(2,2))</code></pre>
<p>in this case the simplifier will remove the binding for y as it is not used (we expected this to happen very often, but we do not know how many &quot;reboxers&quot; are eventually removed and how many are kept), and will keep the binding for x. But notice that x is only used in *one* of the branches in the case, but is always being allocated! The floating inwards pass would push its definition into the True branch. A similar benefit occurs if it is only used inside a let definition. These are basically the advantages of floating inwards, but they are only exposed after the S.A./worker-wrapperisation of the code! As we also have reasons to float inwards before S.A. we have to run it twice.</p>
<h1 id="overall-organisation-of-ghc">Overall organisation of GHC</h1>
<p>Start at the <a href="http://haskell.org/ghc">GHC home page</a>. The most important links are in the left-hand column:</p>
<ul>
<li><a href="http://haskell.org/haskellwiki/GHC">Documentation</a>. This is the <em>user</em> documentation, aimed at people who use GHC, but don't care how it works. It's on the Haskell Wiki (powered by MediaWiki), and we strongly encourage people to edit and improve it.</li>
</ul>
<ul>
<li><a href="http://hackage.haskell.org/trac/ghc">Developers</a>. This link takes you to the home page for <em>developers</em>; that is, people interested in hacking on GHC itself (i.e. you). It's a Wiki too, but powered by Trac, and includes bug-tracking etc. There is a big section called Developer Documentation: <strong>please help us to improve it</strong>.</li>
</ul>
<ul>
<li><a href="http://www.haskell.org/ghc/download.html">Download</a>. At any moment, GHC has a <strong>STABLE branch</strong> and the <strong>HEAD</strong>, both of which you can download from this page.<br />
<br />
* The STABLE branch is the current released version. It has an even version number (e.g. 6.4, 6.6), with an extra suffix for patch-level release (e.g. 6.4.2). Patch-level releses fix bugs; they do not change any APIs.<br />
<br />
* The HEAD is simply the latest, greatest version that we are working on; it may be broken on any given day, although you are encouraged not to break it gratuitiously. The HEAD has an odd version numbers (e.g 6.5, 6.7). Every night we build the HEAD, and dump the result on the download site under &quot;Development snapshots&quot;, with a version number that encodes the date (e..g 6.5.20060831).</li>
</ul>
<p><code>  A very useful link on the download page is the </code><a href="http://www.haskell.org/ghc/dist/current/docs/"><code>documentation</code> <code>for</code> <code>the</code> <code>HEAD</code></a><code> (under Development snapshots).  Useful because typesetting the documentation uses DocBook, which easy to install on every platform.</code></p>
<h1 id="ghc-source-code">GHC source code</h1>
<p>GHC's source code is several Darcs repositories. The important ones are:</p>
<p><a href="http://darcs.haskell.org/ghc" class="uri">http://darcs.haskell.org/ghc</a>:: All of GHC: compiler, run-time system, support utilities.</p>
<p><a href="http://darcs.hasekll.org/packages/pkg" class="uri">http://darcs.hasekll.org/packages/pkg</a>:: A library package <em>pkg</em>. A certain number of packages are essential to build GHC. They are listed in</p>
<pre><code>libraries/core-packages</code></pre>
<p>and currently comprise:</p>
<pre><code>base</code></pre>
<p>,</p>
<pre><code>Cabal</code></pre>
<p>,</p>
<pre><code>haskell98</code></pre>
<p>,</p>
<pre><code>readline</code></pre>
<p>,</p>
<pre><code>regex-base</code></pre>
<p>,</p>
<pre><code>regex-compat</code></pre>
<p>,</p>
<pre><code>regex-posix</code></pre>
<p>,</p>
<pre><code>parsec</code></pre>
<p>,</p>
<pre><code>stm</code></pre>
<p>,</p>
<pre><code>template-haskell</code></pre>
<p>,</p>
<pre><code>unix</code></pre>
<p>,</p>
<pre><code>Win32</code></pre>
<p>.</p>
<p><a href="http://darcs.haskell.org/testsuite" class="uri">http://darcs.haskell.org/testsuite</a>:: GHC's test suite.</p>
<h1 id="package-compatibility">Package Compatibility</h1>
<p>In GHC 6.8.1 we reorganised some of the contents of the packages we ship with GHC, see #710. The idea was to lessen the problem caused by the base package being essentially static between GHC major releases. By separating modules out of base and putting them into separate packages, it is possible to updgrade these modules independently of GHC.</p>
<p>The reorganisations unfortunately exposed some problems with our package infrastructure, in particular most packages that compiled with 6.6 do not compile with 6.8.1 because they don't depend on the new packages. Some instructions for upgrading packages are here: <a href="http://haskell.org/haskellwiki/Upgrading_packages">Upgrading packages</a>.</p>
<p>We anticipated the problem to some extent, adding &quot;configurations&quot; to Cabal to make it possible to write conditional package specifications that work with multiple sets of dependencies. We are still left with the problem that the</p>
<pre><code>.cabal</code></pre>
<p>files for all packages need to be updated for GHC 6.8.1. This seems like the wrong way around: the change we made to a few packages has to be propagated everywhere, when there should be a way to confine it locally, at least for the purposes of continued compatibility with existing source code. In many cases, the underlying APIs are still available, just from a different place. (in general this may not be true - modifications to packages may make changes to APIs which require real changes to dependent packages).</p>
<p>Some of the problems that contributed to this situation can be addressed. We wrote the <a href="http://haskell.org/haskellwiki/Package_versioning_policy">Package Versioning Policy</a> so that packages can start using versions that reflect API changes, and so that dependencies can start being precise about which dependencies they work with. If we follow these guidelines, then</p>
<ul>
<li>failures will be more predictable</li>
<li>failures will be more informative</li>
</ul>
<p>because dependencies and API changes are better documented. However, we have no fewer failures than before, in fact we have more because packages cannot now &quot;accidentally work&quot; by specifying loose dependency ranges.</p>
<p>So the big question is, what changes do we need to make in the future to either prevent this happening, or to reduce the pain when it does happen? Below are collected various proposals. If the proposals get too long we can separate them out into new pages.</p>
<h2 id="dont-reorganise-packages">1. Don't reorganise packages</h2>
<p>We could do this, but that just hides the problem and we're still left with a monolithic base package. We still have to contend with API changes causing breakage.</p>
<h2 id="provide-older-versions-of-base-with-a-new-ghc-release">2. Provide older version(s) of base with a new GHC release</h2>
<p>We could fork the base package for each new release, and keep compiling the old one(s). Unfortunately we would then have to compile every other package two (or more) times, once against each version of base. And if we were to give the same treatment to any other library, we end up with exponential blowup in the number of copies.</p>
<p>The GHC build gets slower, and the testing surface increases for each release.</p>
<p>Furthermore, the package database cannot currently understand multiple packages compiled against different versions of dependencies. One workaround is to have multiple package databases, but that's not too convenient.</p>
<h2 id="allow-packages-to-re-export-modules">4. Allow packages to re-export modules</h2>
<p>Packages currently cannot re-export modules from other packages. Well, that's not strictly true, it is possible to do this but it currently requires an extra package and two stub modules per module to be re-exported (see <a href="http://www.haskell.org/pipermail/haskell-cafe/2007-October/033141.html">5</a>).</p>
<p>This could be made easier. Suppose you could write this:</p>
<pre><code>module Data.Maybe (module Old.Data.Maybe) where
import &quot;base-2.0&quot; Data.Maybe as Old.Data.Maybe</code></pre>
<p>to construct a module called</p>
<pre><code>Data.Maybe` that re-exports the module `Data.Maybe` from package `base-2.0</code></pre>
<p>. This extension to the import syntax was proposed in PackageImports.</p>
<p>Using this extension, we can construct packages that re-export modules using only one stub module per re-exported module, and Cabal could generate the stubs for us given a suitable addition to the</p>
<pre><code>.cabal</code></pre>
<p>file syntax.</p>
<p>Package re-exports are useful for</p>
<ul>
<li>Constructing packages that are backwards-compatible with old packages by re-exporting parts of the new API.</li>
<li>Providing a single wrapper for choosing one of several underlying providers</li>
</ul>
<h2 id="provide-backwards-compatible-versions-of-base">4.1 Provide backwards-compatible versions of base</h2>
<p>So using re-exports we can construct a backwards-compatible version of base (</p>
<pre><code>base-2.0` that re-exports `base-3.0</code></pre>
<p>and the other packages that were split from it). We can do this for other packages that have changed, too. This is good because:</p>
<ul>
<li>Code is shared between the two versions of the package</li>
<li>Multiple versions of each package can coexist in the same program easily (unlike in proposal 2)</li>
</ul>
<p>However, this approach runs into problems when types or classes, rather than just functions, change. Suppose in</p>
<pre><code>base-3.0` we changed a type somewhere; for example, we remove a constructor from the `Exception` type.  Now `base-2.0` has to provide the old `Exception` type.  It can do this, but the `Exception` type in `base-2.0` is now incompatible with the `Exception` type in `base-3.0`, so every function that refers to `Exception` must be copied into `base-2.0`.  At this point we start to need to recompile other packages against `base-2.0</code></pre>
<p>too, and before long we're back in the state of proposal (2) above.</p>
<p>This approach therefore doesn't scale to API changes that include types and classes, but it can cope with changes to functions only.</p>
<h2 id="rename-base-and-provide-a-compatibility-wrapper">4.2 Rename base, and provide a compatibility wrapper</h2>
<p>This requires the re-exporting functionality described above. When splitting base, we would rename the base package, creating several new packages. e.g.</p>
<pre><code>base-3.0` would be replaced by `newbase-1.0`, `concurrent-1.0`, `generics-1.0`, etc.  Additionally, we would provide a wrapper called `base-4.0</code></pre>
<p>that re-exports all of the new packages.</p>
<p>Advantages:</p>
<ul>
<li>Updates to existing packages are much easier (no configurations required)</li>
<li>Doesn't fall into the trap of trying to maintain a completely backwards-compatible version of the old API, as in 4.1</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>All packages still break when the base API changes (if they are using precise dependencies on base, which they should be)</li>
<li>Backwards compatibility cruft in the form of the
<pre><code>base</code></pre>
<p>wrapper will be hard to get rid of; there's no</p></li>
</ul>
<p><code>  incentive for packages to stop using it.  Perhaps we need a deprecation marker on packages.</code></p>
<ul>
<li>Each time we split base we have to invent a new name for it, and we accumulate a new compatibility wrapper</li>
</ul>
<p><code>  for the old one.</code></p>
<h2 id="dont-rename-base">4.3 Don't rename base</h2>
<p>This is a slight variation on 4.2, in which instead of renaming</p>
<pre><code>base` to `newbase`, we simply provide two versions of `base` after the split.  Take the example of splitting `base-3.0` into `base + concurrent + generics</code></pre>
<p>again:</p>
<ul>
<li><pre><code>base-4.0` is the remaining contents of `base-3.0</code></pre>
<p>after the split</p></li>
<li><pre><code>base-3.1` is a compatibility wrapper, re-exporting `base-4.0 + concurrent-1.0 + generics-1.0</code></pre>
<p>.</p></li>
</ul>
<p>The idea is that all existing packages that worked with</p>
<pre><code>base-3.0</code></pre>
<p>will have</p>
<pre><code>  build-depends: base-3.0</code></pre>
<p>or similar. To make these work after the split, all that is needed is to modify the upper bound:</p>
<pre><code>  build-depends: base &gt;= 3.0 &amp;&amp; &lt; 3.1</code></pre>
<p>which is better than requiring a conditional dependency, as was the case with the</p>
<pre><code>base-3.0` split.  In due course, these packages can be updated to use the new `base-4.0</code></pre>
<p>.</p>
<p>Advantages: the same as 4.2, plus there's no need to rename</p>
<pre><code>base` for each split.  Disadvantages: multiple versions of `base</code></pre>
<p>could get confusing. The upgrade path is still not completely smooth (existing packages all need to be modified manually).</p>
<h2 id="do-some-kind-of-providesrequires-interface-in-cabal">5. Do some kind of provides/requires interface in Cabal</h2>
<p>Currently, Cabal's idea of API is asymmetric and very coarse: the client depends on a package by name and version only, the provider implements a single package name and version by exposing a list of modules. That has several disadvantages:</p>
<ul>
<li>Cabal cannot ensure build safety: most errors will not show up before build-time (contrast that with Haskell's usual model of static type safety).</li>
<li>Cabal has no idea what a dependency consists of unless it is installed. even if it is installed, it only knows the modules exposed. The actual API might be defined in Haddock comments, but is not formally specified or verified.</li>
</ul>
<h3 id="make-api-specifications-more-symmetric">5.1 Make API specifications more symmetric</h3>
<p>Just as a provider lists the modules it exposes, clients should list the modules they import (this field should be inferred by a 'ghc -M'-style dependency analysis). Advantages:</p>
<ul>
<li>Cabal would have an idea which parts of a package a client depends on instead of defaulting to &quot;every client needs everything&quot; (example: clients using only parts of the old base not split off should be happy with the new base)</li>
<li>Cabal would have an idea what a missing dependency was meant to provide (example: clients using parts of the old base that have been split off could be offered the split-off packages as alternative providers of the modules imported)</li>
</ul>
<h3 id="make-api-specifications-explicit">5.2 Make API specifications explicit</h3>
<p>Currently, the name and version of a package are synonymous with its API. That is like modules depending on concrete data type representations instead of abstract types. It should not really matter that the functionality needed by package P was only available in package Q-2.3.42 at the time P was written. What should matter is which parts of Q are needed for P, and which packages are able to provide those parts when P is built.</p>
<p>Section 5.1 above suggests to make this specification at least at the level of modules, in both providers and clients. But even if one wanted to stay at the coarser level of API names and versions, one should distinguish between an API and one of its implementing packages. Each client should list the APIs it depends on, each provider should list the APIs it can be called upon to provide.</p>
<p>One can achieve some of this in current Cabal by introducing intermediate packages that represent named APIs to clients while re-exporting implementations of those APIs by providers. Apart from needing re-export functionality, this is more complicated than it should be.</p>
<h3 id="make-api-specifications-more-specific">5.3 Make API specifications more specific</h3>
<p>If one compares Cabal's ideas of packages and APIs with Standard ML's module language, with its structures, functors, and interfaces forming part of a statically typed functional program composition language, one can see a lot of room for development.</p>
<h2 id="distributions-at-the-hackage-level">6. Distributions at the Hackage level</h2>
<p>The idea here is to group packages into &quot;distributions&quot; in Hackage, with the property that all packages within a distribution are mutually compatible. Todo... expand.</p>
<h2 id="allow-package-overlaps">7. Allow package overlaps</h2>
<p>This is not a solution to the problem of splitting a package but helps in the case that we want to use a new package that provides an updated version of some modules in an existing package. An example of this is the bytestring and base package. The base-2.0 package included Data.ByteString but it was split off into a bytestring package and not included in base-3.0. At the moment ghc allows local .hs files to provide modules that can shadow modules from a package but does not packages to shadow each other.</p>
<p>So an extension that would help this case would be to let packages shadow each other. The user would need to specify an ordering on packages so ghc knows which way round the shadowing should go. This could be specified by the order of the -package flags on the command line, which is equivalent to the order in which they are listed in the build-depends field in a .cabal file. This would be a relatively easy extension to implement.</p>
<p>Note that it only solves the problem of backporting packages to be used on top of older versions of the package they were split from. It also provides a way for people to experiment with packages that provide alternative implementations of standard modules.</p>
<p>There is potential for confusion if this is used too heavily however. For example two packages built against standard and replacement modules may not be able to be used together because they will re-export different types.</p>
<h2 id="the-problem-of-lax-version-dependencies">The problem of lax version dependencies</h2>
<p>Supposing that we used solution 2 above and had a base-2.x and a base-3.x. If we take an old package and build it against base-2.x then it will work and if we build it against base-3.x then it'll fail because it uses modules from the split out packages like directory, bytestring etc. So obviously Cabal should select base-2.x, but how is this decision actually supposed to be made automatically? From a quick survey of the packages on hackage we find that 85% specify unversioned dependencies on the base package and none of them specify upper bounds for the version of base. So presented with a package that says:</p>
<pre><code>build-depends: base</code></pre>
<p>how are we to know if we should use base-2.x or base-3.x. It may be that this package has been updated to work with base-3.x or that it only ever used the parts of base-2.x that were not split off. This dependency does not provide us with enough information to know which to choose. So we are still left with the situation that every package must be updated to specify an api version of base.</p>
<p>One possible remedy would be to call version 3 something other than base. Any dependency on 'base' would then refer to the set of modules that comprise base-2.x (this is (4.2) above, incedentally).</p>
<h1 id="note-about-this-page">Note about this page</h1>
<p><code>   </code><em><code>Apparently,</code> <code>this</code> <code>page</code> <code>is</code> <code>out</code> <code>of</code> <code>date</code> <code>and</code> <code>the</code> <code>issue</code> <code>has</code> <code>been</code> <code>settled</code> <code>in</code> <code>favour</code> <code>of</code> <code>the</code> <code>syntax:</code></em><br />
<code>   </code></p>
<pre><code>    import &quot;somepackage&quot; Some.Module
    </code></pre>
<p><code>   See also:</code><br />
<code>   </code><a href="http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports"><code>6</code></a></p>
<h1 id="explicit-package-imports">Explicit package imports</h1>
<p>This proposal is one possibility for addressing the question of identifying which package is meant in an import declaration. For the context, read the [wiki:Commentary/Packages/GhcPackagesProposal GHC packages summary page] first.</p>
<p>The main idea of this proposal is to allow the programmer to specify the source package in the import line, something like this:</p>
<pre><code>  import A.B.C from &quot;base&quot; ( map, filter )</code></pre>
<p>That would presumably get the most recent installed incarnation of the</p>
<pre><code>base</code></pre>
<p>package. If you want a particular version of the package, we could allow</p>
<pre><code>  import A.B.C from &quot;base-3.4&quot; ( map, filter )</code></pre>
<p>The exact syntax is unimportant. The important thing is that the programmer can specify the package in the source text. Note that this fundamentally conflicts with the second assumption we started with. We were trying to avoid specifying &quot;provenance&quot; at the same time as &quot;purpose&quot;, on the grounds that we wanted to avoid editing lots of source text when the provenance changed. (And so it begs the question, if we need to edit the source anyway, why separate the syntax of packages from modules at all?)</p>
<p>If we adopt the idea that an import statement can specify the source package, several design choices arise:</p>
<h2 id="is-the-from-compulsory">Is the 'from <package>' compulsory?</h2>
<p>If you want to import A.B.C, a module exported by package &quot;foo&quot;, can you say just</p>
<pre><code>import A.B.C</code></pre>
<p>, or must you say</p>
<pre><code>import A.B.C from &quot;foo&quot;</code></pre>
<p>?</p>
<p>We think of this as rather like the question &quot;If you import f from module M, can you refer to it as plain &quot;f&quot;, or must you refer to it as &quot;M.f&quot;? The answer in Haskell 98 is that you can refer to it as plain &quot;f&quot; so long as plain &quot;f&quot; is umambiguous; otherwise you can use a qualified reference &quot;M.f&quot; to disambiguate.</p>
<p>We propose to adopt the same principle for imports. That is, an import with no package specified, such as &quot;</p>
<pre><code>import A.B.C</code></pre>
<p>&quot;, means:</p>
<p><code>  Find all modules A.B.C exported by all exposed packages, or the package or program being compiled. If there is exactly one such module, that's the one to import. Otherwise report &quot;ambiguous import&quot;.</code></p>
<p>If the reference to A.B.C is ambiguous, you can qualify the import by adding &quot;</p>
<pre><code>from &quot;foo&quot;</code></pre>
<p>&quot;.</p>
<h2 id="package-versions">Package versions</h2>
<p>We probably want some special treatment for multiple versions of the same package. What if you have both &quot;foo-3.9&quot; and &quot;foo-4.0&quot; installed, both exporting A.B.C? This is jolly useful when you want to install new packages, but keep old ones around so you can try your program with the older one. So we propose that this is not regarded as ambiguous: importing A.B.C gets the latest version, unless some compiler flag (-hide-package) takes it of the running.</p>
<p>In short, an installed package can be of two kinds:</p>
<ul>
<li><strong>Exposed</strong>: the package's modules populate the global module namespace, and can be imported without mentioning the pacckage name explicitly (
<pre><code>import A.B.C</code></pre>
<p>). Explicit &quot;from&quot; imports may be used to resolve ambiguity.</p></li>
<li><strong>Available</strong>, but not exposed: the package can be used only by an explicit &quot;from&quot; import. This is rather like &quot;
<pre><code>import qualified M</code></pre>
<p>, except at the package level.</p></li>
</ul>
<p>Typically, if multiple versions of the same package are installed, then all will be available, but only one will be exposed.</p>
<p>GHC's command-line flags (</p>
<pre><code>-hide-package</code></pre>
<p>,</p>
<pre><code>-package</code></pre>
<p>) can be used to manipulate which packages are exposed, but typically an entire package or program will be compiled with a single set of such flags. GHC does not curretly support in-module control, thus</p>
<pre><code> {-# OPTIONS_GHC -hide-package foo #-} </code></pre>
<p>, and we do not propose to change that.</p>
<p>Simon suggested that an installed package might be hidden (so that it cannot be used at all) but I'm not sure why we need that.</p>
<h2 id="importing-from-the-home-package">Importing from the home package</h2>
<p>If A.B.C is in the package being compiled (which we call &quot;the home package&quot;), and in an exposed package, and you say</p>
<pre><code>import A.B.C</code></pre>
<p>, do you get an &quot;ambiguous import&quot; error , or does the current package override. And if the former, how can you say &quot;import A.B.C from the current package&quot;?</p>
<p>One possibility is to reuqire the code to know its own package name, and mention that in the import. For exmaple, in a module that is being compiled as part package &quot;foo&quot;, you'd say</p>
<pre><code>import A.B.C from &quot;foo&quot;</code></pre>
<p>. What about modules that are part of the main program (not a package at all). Perhaps you could then say</p>
<pre><code>import A.B.C from &quot;main&quot;</code></pre>
<p>.</p>
<p>Another way is to have a special package name meaning &quot;the home package&quot;. The special name could be</p>
<ul>
<li>&quot;&quot;</li>
<li>&quot;home&quot;</li>
<li>&quot;this&quot;</li>
<li>this (with no quotes)</li>
</ul>
<h2 id="the-as-p-alias">The 'as P' alias</h2>
<p>We propose to maintain the local, within-module &quot;as P&quot; alias mechanism unchanged. Thus:</p>
<pre><code>   import A.B.C( T ) from &quot;foo&quot; as M
   type S = M.T -&gt; M.T</code></pre>
<p>Here, the qualified name &quot;M.T&quot; refers to the T imported from A.B.C in package &quot;foo&quot;.</p>
<h2 id="qualified-names">Qualified names</h2>
<p>We propose that the default qualified name of an entity within a module is just the module name plus the entity name. Thus</p>
<pre><code>  import A.B.C( T ) from &quot;foo&quot; 
  type S = A.B.C.T -&gt; A.B.C.T</code></pre>
<p>If you want to import multiple A.B.C's (from different packages) then perhaps they define different entities, in which case there is no problem:</p>
<pre><code>  import A.B.C( T1 ) from &quot;foo&quot; 
  import A.B.C( T2 ) from &quot;bar&quot; 
  type S = A.B.C.T1 -&gt; A.B.C.T2</code></pre>
<p>But if they both export entities with the same name, there is no alternative to using the 'as M' mechanism:</p>
<pre><code>  import A.B.C( T ) from &quot;foo&quot; as M1
  import A.B.C( T ) from &quot;bar&quot; as M2
  type S = M1.T -&gt; M2.T</code></pre>
<h2 id="exporting-modules-from-other-packages">Exporting modules from other packages</h2>
<p>It is perfectly OK to export entities, or whole modules, imported from other packages:</p>
<pre><code>  module M( f, g, module Q ) where
  import A.B( f, g ) from &quot;foo&quot;
  import X.Y.Z from &quot;bar&quot; as Q</code></pre>
<h2 id="syntax">Syntax</h2>
<p>Should package names be in quotes? Probably yes, because they have a different lexcal syntax to the rest of Haskell. (&quot;foo-2.3&quot; would parse as three tokens, &quot;foo&quot;, &quot;-&quot;, and &quot;2.3&quot;.</p>
<p>It's been suggested that one might want to import several modules from one package in one go:</p>
<pre><code> 
    from &quot;base&quot; import
        Prelude hiding (length)
        Control.Exception
        qualified Data.List as List</code></pre>
<p>What we don't like about that is that it needs a new keyword &quot;</p>
<pre><code>from</code></pre>
<p>&quot;. Perhaps all imports can start with the keyword</p>
<pre><code>import</code></pre>
<p>, and then we are free to use extra (context-specific) keywords. (Haskell already has several of these, such as</p>
<pre><code>hiding</code></pre>
<p>. Something like this:</p>
<pre><code> 
    import from &quot;base&quot; {
        Prelude hiding (length) ;
        Control.Exception ;
        qualified Data.List as List }
    import from &quot;foo&quot; M( x, y )</code></pre>
<p>Here the layout is explicit, but the braces and semicolons could be avoided by making use of the layout rule as usual.</p>
<p>Indeed, we could allow this multiple form even for ordinary imports:</p>
<pre><code>   import { A(f); B(g); C(S,T) }</code></pre>
<p>It is clear from the above examples that the keyword</p>
<pre><code>from</code></pre>
<p>is redundant - the presence of a string literal (or special keyword to denote the home package) after the keyword</p>
<pre><code>import</code></pre>
<p>is sufficient to distinguish per-package imports from the ordinary shared-namespace imports, so the above could instead be written as</p>
<pre><code>    import &quot;base&quot;
        Prelude hiding (length)
        Control.Exception
        qualified Data.List as List
    import &quot;foo&quot; M( x, y )

    import
           A(f)
           B(g)
           C(S,T)</code></pre>
<h3 id="syntax-formalised-and-summarised">Syntax formalised and summarised</h3>
<p>A possible syntax which covers everything in this proposal is therefore:</p>
<p><code>  </code><strong><code>import</code></strong><code> [</code><em><code>package-name</code></em><code>] </code><strong><code>{</code></strong><code> </code><em><code>import-specifier</code></em><code> [</code><strong><code>;</code></strong><code> </code><em><code>import-specifier</code></em><code>] </code><strong><code>}</code></strong></p>
<p>where <em>package-name</em> is a string literal or the keyword</p>
<pre><code>home</code></pre>
<p>, the <em>import-specifier</em> corresponds to everything that is currently allowed after the keyword</p>
<pre><code>import</code></pre>
<p>, and the braces and semicolons would be added by the layout rule.</p>
<pre><code>    import &quot;base&quot; -- searches in &quot;base&quot; package only
        Prelude hiding (length)
        Control.Exception
        qualified Data.List as List

    import &quot;&quot;   -- searches in home package only
        A.B.C

    import P.Q.R -- searches in home + exposed packages</code></pre>
<h3 id="proposal-for-package-mounting">Proposal for Package Mounting</h3>
<p>It may help to refer to [wiki:Commentary/Packages/GhcPackagesProposal] for an introduction to some of the issues mentioned here.</p>
<p>A message by Frederik Eaton to the Haskell mailing list describing the present proposal is archived: <a href="http://www.haskell.org/pipermail/libraries/2005-June/004009.html">7</a>. (Also, see note at the end of this document regarding an earlier proposal by Simon Marlow)</p>
<p>This document will go over Frederik's proposal again in brief. The proposal doesn't involve any changes to syntax, only an extra command line option to</p>
<pre><code>ghc</code></pre>
<p>, etc., and a small change to Cabal syntax.</p>
<p>In this proposal, during compilation of a module, every package would have a &quot;mount point&quot; with respect to which its particular module namespace would be resolved. Each package should have a default &quot;mount point&quot;, but this default would be overridable with an option to</p>
<pre><code>ghc</code></pre>
<p>, etc.</p>
<p>For example, the</p>
<pre><code>X11</code></pre>
<p>library currently has module namespace:</p>
<pre><code>  Graphics.X11.Types
  Graphics.X11.Xlib
  Graphics.X11.Xlib.Atom
  Graphics.X11.Xlib.Event
  Graphics.X11.Xlib.Display
  ...</code></pre>
<p>In this proposal, it might instead have default mount point</p>
<pre><code>Graphics.X11</code></pre>
<p>and (internal) module namespace:</p>
<pre><code>  Types
  Xlib
  Xlib.Atom
  Xlib.Event
  Xlib.Display
  ...</code></pre>
<p>To most users of the X11 package, there would be no change - because of the mounting, modules in that package would still appear with the same names in places where the X11 package is imported:</p>
<pre><code>Graphics.X11.Types</code></pre>
<p>, etc. However, if someone wanted to specify a different the mount point, he could use a special compiler option, for instance</p>
<pre><code>-package-base</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>  ghc -package X11 -package-base Graphics.Unix.X11 ...</code></pre>
<p>(so the imported namespace would appear as</p>
<pre><code>Graphics.Unix.X11.Types</code></pre>
<p>,</p>
<pre><code>Graphics.Unix.X11.Xlib</code></pre>
<p>, etc.) Note that the intention is for each</p>
<pre><code>-package-base</code></pre>
<p>option to refer to the package specified in the preceding</p>
<pre><code>-package</code></pre>
<p>option, so to give package</p>
<pre><code>PACKAGE</code></pre>
<p>a mount point of</p>
<pre><code>BASE</code></pre>
<p>we use the syntax</p>
<pre><code>  ghc ... -package PACKAGE -package-base BASE ...</code></pre>
<p>Ideally one would also be able to link to two different versions of the same package, at different mount points:</p>
<pre><code>  ghc -package X11-1.2 -package-base NewX11 -package X11-1.0 -package-base OldX11 ...</code></pre>
<p>(yielding</p>
<pre><code>NewX11.Types</code></pre>
<p>,</p>
<pre><code>NewX11.Xlib</code></pre>
<p>, ...;</p>
<pre><code>OldX11.Types</code></pre>
<p>,</p>
<pre><code>OldX11.Xlib</code></pre>
<p>, ...)</p>
<p>However, usually the default mount point would be sufficient, so most users wouldn't have to learn about</p>
<pre><code>-package-base</code></pre>
<p>.</p>
<p>Additionally, Cabal syntax should be extended to support mounting. I would suggest that the optional mount point should appear after a package in the Build-Depends clause of a Cabal file:</p>
<pre><code>  Build-Depends: X11(Graphics.Unix.X11.Xlib)</code></pre>
<p>And in the package Cabal file, a new clause to specify the default mount point:</p>
<pre><code>  Default-Base: Graphics.X11</code></pre>
<h3 id="evaluation">Evaluation</h3>
<p>This proposal has several advantages over the [wiki:Commentary/Packages/PackageImportsProposal] proposal.</p>
<ul>
<li><em>No package names in code</em>. In this proposal, package names would be decoupled from code. This is very important. It should be possible to rename a package (or create a new version of a package with a new name), and use it in a project, without editing every single module of the project and/or package. Even if the edits could be done automatically, they would still cause revision control headaches. Any proposal which puts package names in Haskell source code should be considered unacceptable.</li>
</ul>
<ul>
<li><em>No syntax changes</em>. The [wiki:Commentary/Packages/PackageImportsProposal] proposal requires new syntax, but this proposal does not. Of course, in this proposal it would be slightly more difficult for the programmer to find out which package a module is coming from. He would have to look at the command line that compiles the code he's reading. However, I think that that is appropriate. Provenance should not be specified in code, since it changes all the time. (And there could be a simple debugging option to GHC which outputs a description of the namespace used when compiling each file)</li>
</ul>
<ul>
<li><em>Simpler module names</em>. This proposal would allow library authors to use simpler module names in their packages, which would in turn make library code more readable, and more portable between projects. For instance, imagine that I wanted to import some of the code from the
<pre><code>X11</code></pre>
<p>library into my own project. Currently, I would have to delete every occurrence of</p>
<pre><code>Graphics.X11</code></pre>
<p>in those modules. Merging future changes after such an extensive modification would become difficult. This is a real problem, which I have encountered while using John Meacham's curses library. There are several different versions of that library being used by different people in different projects, and it is difficult to consolidate them because they all have different module names. The reason they have different module names is that package mounting hasn't been implemented yet. The [wiki:Commentary/Packages/PackageImportsProposal] proposal would not fix the problem.</p></li>
</ul>
<ul>
<li><em>Development decoupled from naming</em>. (there is a bit of overlap with previous points here) In the present proposal, programmers would be able to start writing a library before deciding on a name for the library. For instance, every module in the
<pre><code>Parsec</code></pre>
<p>library contains the prefix</p>
<pre><code>Text.ParserCombinators.Parsec</code></pre>
<p>. This means that either the author of the library had to choose the name</p>
<pre><code>Parsec</code></pre>
<p>at the very beginning, or he had to make several changes to the text of each module after deciding on the name. Under the present proposal, he would simply call his modules</p>
<pre><code>Char</code></pre>
<p>,</p>
<pre><code>Combinator</code></pre>
<p>,</p>
<pre><code>Error</code></pre>
<p>, etc.; the</p>
<pre><code>Text.ParserCombinators</code></pre>
<p>prefix would be specified in the build system, for instance in the Cabal file.</p></li>
</ul>
<p>Frederik's mailing list message discusses some other minor advantages, but the above points are the important ones. In summary, it is argued that the above proposal should be preferred to [wiki:Commentary/Packages/PackageImportsProposal] because it is both easier to implement (using command line options rather than syntax), and more advantageous for the programmer.</p>
<h3 id="note-on-package-grafting">Note on Package Grafting</h3>
<p>A proposal by Simon Marlow for &quot;package grafting&quot; predates this one: <a href="http://www.haskell.org/pipermail/libraries/2003-August/001310.html">8</a>. However, the &quot;package grafting&quot; proposal is different in that it suggests selecting a &quot;mount point&quot; at library installation time, where in the present proposal, the &quot;mount point&quot; is selected each time a module using the library in question is compiled. The difference is important, as one doesn't really want to have to install a new copy of a library just to use it with a different name. Also, Simon Marlow's proposal puts package versions in the module namespace and therefore source code, where we argue for decoupling source code from anything to do with provenance - be it package names or version numbers.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h2 id="alternative-proposal-for-packages-with-explicit-namespaces">Alternative Proposal for Packages (with explicit namespaces)</h2>
<p>This proposal is an alternative to [wiki:Commentary/Packages/GhcPackagesProposal]. Large parts overlap with that proposal. To motivate this new proposal, let's consider another proposed and desirable feature of the import/export language, which may interact in interesting ways with packages.</p>
<h2 id="a-different-but-related-problem">A different, but related, problem</h2>
<p>A problem that has been mentioned several times on mailing lists, is grafting part of a directory hierarchy into an arbitrary location elsewhere in the hierarchy. (See <a href="http://www.haskell.org/pipermail/libraries/2005-June/004009.html">9</a>)</p>
<p>Another way of expressing a similar wish is the ability to re-export imports with a different qualified name, as in the scenario suggested by the developers of the package gtk2hs: <a href="http://www.haskell.org/pipermail/libraries/2004-December/002800.html">10</a></p>
<p>There are several desires in play here:</p>
<ul>
<li>a desire to minimise typing of long qualified names</li>
<li>a desire to refer to &quot;leaf&quot; nodes of the hierarchy in a way that makes it easy to relocate those modules in the hierarchy, without needing to edit every import declaration that uses them</li>
<li>a desire to partially-qualify names for disambiguation</li>
</ul>
<h2 id="proposal">Proposal</h2>
<p>We introduce the new concept of <em>namespace</em> as something that can be declared in source code. A namespace can contain only module names. (The specification of what module names are contained in a namespace is rather like our current concept of a package, i.e. not declared in the source code, but rather by some external mechanism e.g. grouping of files in a filesystem hierarchy.)</p>
<p>There are now two separate kinds of</p>
<pre><code>import</code></pre>
<p>.</p>
<ul>
<li><pre><code>import namespace &quot;foo-1.3&quot; Data.Foo</code></pre></li>
<li><pre><code>import Bar</code></pre></li>
</ul>
<p>The new semi-reserved word</p>
<pre><code>namespace</code></pre>
<p>is introduced, having special meaning only directly after the</p>
<pre><code>import</code></pre>
<p>keyword. There is a <em>level</em> difference in what this new form of import means. The declaration</p>
<pre><code>import namespace</code></pre>
<p>brings into availability the subset of the hierarchy of <em>module</em> names rooted in the package</p>
<pre><code>&quot;foo-1.3&quot;</code></pre>
<p>, at the position</p>
<pre><code>Data.Foo</code></pre>
<p>. That is, if the package</p>
<pre><code>foo</code></pre>
<p>version</p>
<pre><code>1.3</code></pre>
<p>contains the modules</p>
<ul>
<li>Data.Foo.Bar</li>
<li>Data.Foo.Baz</li>
<li>Data.Bar</li>
</ul>
<p>then the namespace import brings into the &quot;importable&quot; namespace only the modules</p>
<ul>
<li>Data.Foo.Bar</li>
<li>Data.Foo.Baz</li>
</ul>
<p>However, for the program to use those modules, it is still necessary to go ahead and actually</p>
<pre><code>import</code></pre>
<p>them in the normal way, although the names used to import them will now be <em>relative</em> to the available namespaces, rather than absolute. So the declaration</p>
<pre><code>import Bar</code></pre>
<p>brings into scope all the entities defined in</p>
<pre><code>Data.Foo.Bar</code></pre>
<p>. Like any normal import, these can be qualified or hidden.</p>
<p>Thus,</p>
<ul>
<li><pre><code>import namespace</code></pre>
<p>brings into scope a bunch of names for modules</p></li>
</ul>
<p><code>  from the given provenance.</code></p>
<ul>
<li><pre><code>import</code></pre>
<p>brings into scope a bunch of entities from the given</p></li>
</ul>
<p><code>  module.</code></p>
<h3 id="naming-a-namespace">Naming a namespace</h3>
<p>Are namespaces first class? Can we give them a name? Indeed, why not?</p>
<ul>
<li><pre><code>import namespace &quot;foo-1.3&quot; Data.Foo as OldFoo</code></pre></li>
<li><pre><code>import OldFoo.Bar</code></pre></li>
</ul>
<p>Here, we have declared that we want to be able to refer to the namespace as</p>
<pre><code>OldFoo</code></pre>
<p>, and so, a subsequent</p>
<pre><code>import OldFoo.Bar</code></pre>
<p>specifically asks for the</p>
<pre><code>Data.Foo.Bar</code></pre>
<p>from the package</p>
<pre><code>foo-1.3</code></pre>
<p>, just in case there might be a</p>
<pre><code>Bar</code></pre>
<p>module also available from another namespace.</p>
<h3 id="what-namespaces-are-available-by-default">What namespaces are available by default?</h3>
<p>If no namespaces are explicitly brought into scope, what modules are implicitly available?</p>
<ul>
<li>Anything in the <em>current</em> package, i.e. the executable or library</li>
</ul>
<p><code>  whose modules are all physically rooted at the same location in the</code><br />
<code>  filesystem as this module.</code></p>
<ul>
<li>Is there an implicit
<pre><code>import namespace &quot;base&quot;</code></pre>
<p>, just as there is an</p></li>
</ul>
<p><code>  implicit </code></p>
<pre><code>import Prelude</code></pre>
<p>?</p>
<h3 id="namespace-resolution">Namespace resolution</h3>
<p>In essence, namespaces take over the role formerly played by commandline arguments like</p>
<pre><code>-Iproject</code></pre>
<p>and</p>
<pre><code>-package foo</code></pre>
<p>. The search path used by the compiler for finding modules is now partially declared in the source code itself. (Note however that that the search path is declared symbolically, involving package names, not directories. This is a very important separation of the thing itself from where it is stored.)</p>
<p>Resolution of which module is referred to by an import statement (taking into account the namespaces) is just like the current process of resolving which entity is referred to by program text (taking into account the imported modules). The source text may import multiple namespaces. If any module import is ambiguous (i.e. the module exists in more than one namespace), it is a static error. Resolution is lazy, in the sense that there is no error if namespaces contain the same module name, only if the program tries to import that module name.</p>
<p>So when you say &quot;import A.B.C&quot;, from what package does A.B.C come?</p>
<p>There must be a single namespace in scope containing a module called</p>
<pre><code>A.B.C</code></pre>
<p>. (Sidenote: or in fact a namespace called</p>
<pre><code>A</code></pre>
<p>, containing a module named</p>
<pre><code>B.C</code></pre>
<p>)</p>
<h3 id="syntax-1">Syntax</h3>
<p>The precise syntax can be debated. New keywords like</p>
<pre><code>use</code></pre>
<p>or</p>
<pre><code>from</code></pre>
<p>could be substituted for</p>
<pre><code>import namespace</code></pre>
<p>. The key important features however are the inclusion of:</p>
<ul>
<li>the package name (mandatory)</li>
<li>an optional package version, if several are available</li>
<li>an optional path to use as the root of the available namespace</li>
<li>an optional renaming</li>
</ul>
<h3 id="exports-1">Exports</h3>
<p>One might wonder whether it is now either necessary or desirable to permit <em>namespaces</em> to be re-exported in the same way that <em>modules</em> can be? For instance:</p>
<pre><code>module Aggregate
  ( module Aggregate
  , namespace OldFoo
  ) where
import namespace &quot;foo-1.3&quot; Data.Foo as OldFoo</code></pre>
<p>The idea is that any module saying</p>
<pre><code>import Aggregate</code></pre>
<p>would thereby implicitly open the namespace of package</p>
<pre><code>&quot;foo-1.3&quot;</code></pre>
<p>at the root</p>
<pre><code>Data.Foo</code></pre>
<p>, in addition to having access to entities defined in</p>
<pre><code>Aggregate</code></pre>
<p>itself.</p>
<p>Note that, just as with a current module re-export it is no longer possible for the importing location to use the original module name as a qualifier; so with a namespace re-export, there is no way to refer to the namespace in the importing location either. It is purely a signal to the compiler telling it where to look for modules when resolving imports.</p>
<p>I argue that namespace export <em>is</em> desirable, because it allows (but does not require) all package (namespace) dependencies to be gathered together in a single module for an entire project. With such an organising principle, when dependencies change, there is only one source file to update. But without namespace re-exports, it would be impossible to localise those dependencies to a single file.</p>
<p>Note how this feature addresses several of the initial stated desires, of reducing the verbosity of imports, and of referring to leaf modules conveniently. For instance:</p>
<pre><code>module Gtk (namespace AllOfGtk) where
import namespace &quot;gtk-2.4&quot; Graphics.UI.Gtk as AllOfGtk

module MyGUI where
import Gtk
import Button
..... Button.label .....</code></pre>
<h3 id="implicit-imports">Implicit imports</h3>
<p>One could go further. If I write a qualified name</p>
<pre><code>M.e</code></pre>
<p>in the source text, must I also write</p>
<pre><code>import M</code></pre>
<p>at the top? The qualified entity is unambiguous, whether or not there is an explicit import for it, because the module qualification</p>
<pre><code>M</code></pre>
<p>must be unambiguous within the current namespaces. In the Gtk example above, this would eliminate the need for</p>
<pre><code>import Button</code></pre>
<p>, and who knows how many other imports, leaving a single</p>
<pre><code>import Gtk</code></pre>
<p>to bring all of the qualified entities into scope.</p>
<h3 id="exposed-vs-hidden-packages">Exposed vs Hidden packages</h3>
<p>GHC's scheme of exposed vs hidden packages can now be replaced with full source-code control of namespace visibility. To setup a default set of exposed packages, you just write a module to export their namespaces:</p>
<pre><code>module ExposedPackages
  ( namespace FGL
  , namespace Parsec
  , namespace HaXml
  ) where

import namespace &quot;fgl&quot; as FGL
import namespace &quot;parsec-0.1&quot; as Parsec
import namespace &quot;HaXml&quot; as HaXml</code></pre>
<p>and import it in every module of your project. Or if importing it everywhere sounds too painful, one can even imagine that a compiler might provide a command-line option (or use a configuration file) to specify one distinguished module to be implicitly imported everywhere:</p>
<pre><code>$ ghc --make -implicit-prelude=ExposedPackages MyProject.hs

$ cat .ghci
set -implicit-prelude ExposedPackages</code></pre>
<h3 id="what-if-you-wanted-to-import-a.b.c-from-p1-and-a.b.c-from-p2-into-the-same-module">What if you wanted to import A.B.C from P1 and A.B.C from P2 into the <em>same</em> module?</h3>
<pre><code>module C1 (module A.B.C) where
import namespace &quot;P1&quot;
import A.B.C

module C2 (module A.B.C) where
import namespace &quot;P2&quot;
import A.B.C

module User where
import qualified C1
import qualified C2</code></pre>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="package-reorg">Package Reorg</h1>
<p>In this page we collect proposals and design discussion for reorganising the packages that come with compilers, and the contents of those packages.</p>
<p>None of the ideas herein are claimed to belong to any particular person, many of the ideas have been extracted from mailing list discussions, eg.</p>
<p><a href="http://www.haskell.org/pipermail/libraries/2006-November/006396.html"><code>11</code></a></p>
<p>Some of the points are GHC-specific. Please feel free to insert points specific to other compilers.</p>
<h2 id="goals-1">Goals</h2>
<ul>
<li>It would be good to have set of 'core' packages that is installed with</li>
</ul>
<p><code>  every Haskell implementation.  More on this at PackageReorg/Rationale page</code></p>
<ul>
<li>Forwards compatibility. Users would like their programs written against the 'core' packages to continue to work, without</li>
</ul>
<p><code>  modification to source text or build system, after upgrading the</code><br />
<code>  compiler, or its packages, or switching to a different compiler.</code></p>
<ul>
<li>Backwards compatibility. Users would like to be able to take a</li>
</ul>
<p><code>  program written against some version of the 'core' packages, and</code><br />
<code>  build it with an older compiler, accepting that they may have to</code><br />
<code>  install newer versions of the 'core' packages in order to do so.</code></p>
<p>It may not be possible to fully achieve these goals (in particular, backwards compatibility), but that does not mean we should not aim for them.</p>
<h2 id="proposal-1">Proposal</h2>
<p>Here's a straw-man proposal</p>
<ul>
<li>There is a set of packages that come with every conforming Haskell</li>
</ul>
<p><code>  implementation.  Let's call these the </code><strong><code>Core</code> <code>Packages</code></strong><code> to</code><br />
<code>  avoid confusion (Bulat called these the &quot;base packages&quot;, but that's an </code><br />
<code>  over-used term given that there is a package called </code></p>
<pre><code>base</code></pre>
<p>).</p>
<p><code>  The good thing about the Core Packages is that</code><br />
<code>  users know that they will be there, and they are consistent with</code><br />
<code>  each other.</code></p>
<ul>
<li>Any particular implementation may install more packages by default;</li>
</ul>
<p><code>  for example GHC will install the </code></p>
<pre><code>template-haskell` and `stm</code></pre>
<p><code>  packages.  Let's call these the </code><strong><code>GHC</code> <code>Install</code> <code>Packages</code></strong><code>, '''Hugs</code><br />
<code>  Install Packages''' etc; the Install Packages are a superset of the</code><br />
<code>  Core Packages.</code></p>
<h3 id="what-is-in-the-core-packages">What is in the Core Packages?</h3>
<p>The Core Packages are installed with every conforming Haskell implementation. What should be in the Core? There is a tension:</p>
<ol>
<li><strong>As much as possible</strong>; which means in practice widely-used and reasonably stable packages. It is convenient for programmers to have as much as possible in a consistent, bundle that is (a) known to work together bundle, and (b) known to work on all implementations.<br />
<br />
</li>
<li><strong>As little as possible</strong>; which in practice means enough to run Cabal so that you can run the Setup files that come when downloading new packages. As Ian puts it: the less we force the implementations to come with, the quicker compilation will be when developing, the smaller Debian packages (for example) can be, the lower the disk space requirements to build GHC, the lower the time wasted when a Debian package (for example) build fails and the fewer packages we are tangling up with compiler release schedules.</li>
</ol>
<p>There's a real choice here: Bulat wants (1) and Ian wants (2).</p>
<p>Initial stab at (1):</p>
<ul>
<li><pre><code>base</code></pre></li>
<li><pre><code>Cabal</code></pre></li>
<li><pre><code>haskell98</code></pre></li>
<li>Some
<pre><code>regex</code></pre>
<p>packages (precisely which?)</p></li>
<li><pre><code>unix` or `Win32`. Questionable, partly because it means the Core interface becomes platform-dependent; and partly because `Win32</code></pre>
<p>would double the size of the Hugs distribution.</p></li>
<li><pre><code>parsec</code></pre></li>
<li><pre><code>mtl</code></pre></li>
<li><pre><code>time</code></pre></li>
<li><pre><code>network</code></pre></li>
<li><pre><code>QuickCheck</code></pre>
<p>(questionable)</p></li>
<li><pre><code>HUnit</code></pre>
<p>(questionable)</p></li>
</ul>
<p>Initial stab at (2):</p>
<ul>
<li><pre><code>base</code></pre></li>
<li><pre><code>haskell98</code></pre></li>
<li><pre><code>Cabal</code></pre></li>
<li><pre><code>filepath</code></pre>
<p>(?)</p></li>
</ul>
<p>Bulat: i think that all regex packages should be included and of course libs that helps testing. overall, it should be any general-purpose lib that porters accept (enlarging this set makes users live easier, and porters live harder)</p>
<p>about unix/win32 - these libs provide access to OS internals, not some everywhere-portable API. moreover, other world-interfacing libs (i/o, networking) should use APIs provided by these libs with a conditional compilation (CPPery) tricks in order to provide portable APIs! current situation where such libs use FFI isn't ideal. WinHugs size problem is rather technical - it includes a lot of DLLs which contains almost the same code</p>
<p>i agree to start with minimal stub, and then proceed with discussing inclusion of each library. what we need now is requirements to include library in this set and lifetime support procedure. so:</p>
<h3 id="requirements-to-libraries-to-be-included-in-core-set">Requirements to libraries to be included in core set</h3>
<ul>
<li>BSD-licensed, and even belongs to Haskell community?</li>
<li>portable (is sense of compiler and OS), may be just Haskell' compatible?</li>
<li>already widely used</li>
<li>shouldn't duplicate existing core libs functionality (?)</li>
</ul>
<p>Exact inclusion, support and exclusion processes?</p>
<h3 id="the-base-package">The base package</h3>
<p>The base package is a bit special</p>
<ul>
<li>Package
<pre><code>base</code></pre>
<p>is rather big at the moment.</p></li>
</ul>
<ul>
<li>From a user's point of view it would be nicer to give it a</li>
</ul>
<p><code>  compiler-independent API.  (A module like </code></p>
<pre><code>GHC.Exts</code></pre>
<p>would move to</p>
<p><code>  a new package </code></p>
<pre><code>ghc-base</code></pre>
<p>.)</p>
<p>Thinking of GHC alone for a moment, we could have a package</p>
<pre><code>ghc-base</code></pre>
<p>(which is pretty much the current</p>
<pre><code>base</code></pre>
<p>) and a thin wrapper package</p>
<pre><code>base` that re-exposes some, but not all, of what `ghc-base</code></pre>
<p>exposes. To support this re-exposing, we need a small fix to both GHC and Cabal, but one that is independently desirable.</p>
<p>Similarly, Hugs could build</p>
<pre><code>hugs-base</code></pre>
<p>from the same souce code, by using CPP-ery, exactly as now. The thin</p>
<pre><code>base</code></pre>
<p>wrapper package would not change.</p>
<p>To make</p>
<pre><code>base</code></pre>
<p>smaller, we could remove stuff, and put it into separate packages. But be careful: packages cannot be cyclic, so anything that is moved out can't be used in</p>
<pre><code>base</code></pre>
<p>. Some chunks that would currently be easy to split off are:</p>
<ul>
<li>Data.ByteString.* (plus future packed Char strings)</li>
<li>Control.Applicative (?), Data.Foldable, Data.Monoid (?), Data.Traversable, Data.Graph, Data.IntMap, Data.IntSet, Data.Map, Data.Sequence, Data.Set, Data.Tree</li>
<li>System.Console.GetOpt</li>
<li>Text.PrettyPrint.*</li>
<li>Text.Printf</li>
</ul>
<p>Some other things, such as arrays and concurrency, have nothing else depending on them, but are so closely coupled with GHC's internals that extracting them would require exposing these internals in the interface of</p>
<pre><code>base</code></pre>
<p>.</p>
<p>Bulat: my ArrayRef library contains portable implementation of arrays. there is only thin ghc/hugs-specific layer which should be provided by ghcbase/hugsbase libs. except for MPTC problem (IArray/MArray classes has multiple parameters), this library should be easily portable to any other haskell compiler</p>
<p>See also BaseSplit.</p>
<h3 id="other-packages">Other packages</h3>
<p>Other non-core packages would probably have their own existence. That is, they don't come with an implementation; instead you use</p>
<pre><code>cabal-get</code></pre>
<p>, or some other mechanism, such as your OS's package manager. Some of these currently come with GHC, and would no longer do so</p>
<ul>
<li><pre><code>GLUT</code></pre></li>
<li><pre><code>ALUT</code></pre></li>
<li><pre><code>OpenAL</code></pre></li>
<li><pre><code>OpenGL</code></pre></li>
<li><pre><code>HGL</code></pre></li>
<li><pre><code>HUnit</code></pre></li>
<li><pre><code>ObjectIO</code></pre></li>
<li><pre><code>X11</code></pre></li>
<li><pre><code>arrows</code></pre></li>
<li><pre><code>cgi</code></pre></li>
<li><pre><code>fgl</code></pre></li>
<li><pre><code>html</code></pre></li>
<li><pre><code>xhtml</code></pre></li>
</ul>
<p>Bulat: i propose to unbundle only graphics/sound libs because these solves particular problems and tends to be large, non-portable (?) and some are just legacy ones - like ObjectIO. we should keep everything small &amp; general purpose, including HUnit, arrows, fgl, html and xhtml, and include even more: ByteString, regex-*, Edison, Filepath, MissingH, NewBinary, QuickCheck, monads</p>
<h2 id="testing-1">Testing</h2>
<p>We should separate out package-specifc tests, which should be part of the repository for each package. Currently they are all squashed together into the testsuite repository.</p>
<h2 id="implementation-specific-notes">Implementation-specific notes</h2>
<h3 id="notes-about-ghc">Notes about GHC</h3>
<p>Currently GHC installs a set of packages by default, the so-called <strong>GHC Boot Packages</strong>. They are graphed here, with arrows representing dependencies between them: <a href="Image(packagegraph.png,_800)" title="wikilink">Image(packagegraph.png, 800)</a></p>
<p>These are exactly the libraries required to build GHC. That shouldn't be the criterion for the core packages.</p>
<p>One reason we do this is because it means that every GHC installation can build GHC. Less configure-script hacking. (NB: even today if you upgrade any of these packages, and then build GHC, the build might fail because the CPP-ery in GHC's sources uses only the version number of GHC, not the version number of the package.)</p>
<p>Still, for convenience we'd probably arrange that the GHC Install Packages included all the GHC Boot Packages.</p>
<p>Every GHC installation must include packages:</p>
<pre><code>base`, `ghc-prim</code></pre>
<p>,</p>
<pre><code>integer</code></pre>
<p>and</p>
<pre><code>template-haskell</code></pre>
<p>, else GHC itself will not work. (In fact</p>
<pre><code>haskell98</code></pre>
<p>is also required, but only because it is linked by default.)</p>
<p>So GHC's Install Packages would be the Core Packages plus</p>
<ul>
<li><pre><code>template-haskell</code></pre></li>
<li><pre><code>editline</code></pre></li>
<li><pre><code>integer</code></pre></li>
<li><pre><code>ghc-prim</code></pre></li>
</ul>
<p>You can upgrade any package, including</p>
<pre><code>base</code></pre>
<p>after installing GHC. However, you need to take care. You must not change a number of things that GHC &quot;knows about&quot;. In particular, these things must not change</p>
<ul>
<li>Name</li>
<li>Defining module</li>
</ul>
<p>GHC knows even more about some things, where you must not change</p>
<ul>
<li>Type signature</li>
<li>For data types, the names, types, and order of the constructors</li>
</ul>
<p>The latter group are confined to packages base and template-haskell.</p>
<p>(Note: a few other packages are used by tests in GHC's test suite, currently:</p>
<pre><code>mtl`, `QuickCheck</code></pre>
<p>. We should probably eliminate the mtl dependency; but</p>
<pre><code>QuickCheck</code></pre>
<p>is used as part of the test infrastructure itself, so we'll make it a GHC Boot Package.)</p>
<h3 id="notes-about-hugs">Notes about Hugs</h3>
<p>Recent distributions of Hugs come in two sizes, jumbo and minimal. Minimal distributions include only the packages</p>
<pre><code>base`, `haskell98` and `Cabal</code></pre>
<p>. (Hugs includes another package</p>
<pre><code>hugsbase</code></pre>
<p>containing interfaces to Hugs primitives.) The requirements for this set are to</p>
<ul>
<li>run Haskell 98 programs</li>
<li>allow packages to be added and upgraded using Cabal</li>
</ul>
<p>(Currently</p>
<pre><code>cpphs</code></pre>
<p>is a Haskell 98 program, so the latter implies the former.)</p>
<p>It should be possible to upgrade even the core packages using Cabal.</p>
<h1 id="commentary-the-package-system">Commentary: The Package System</h1>
<p>See also: [wiki:Commentary/Compiler/Packages Packages], where we describe how this is implemented in GHC.</p>
<h2 id="architecture">Architecture</h2>
<p>GHC maintains a package database, that is basically a list of</p>
<pre><code>InstalledPackageInfo`.  The `InstalledPackageInfo` type is defined in `Distribution.InstalledPackageInfo` in Cabal, and both `ghc-pkg</code></pre>
<p>and GHC itself import it directly from there.</p>
<p>There are four main components of the package system:</p>
<dl>
<dt>Cabal</dt>
<dd>Cabal is a Haskell library, which provides basic data types for the package system, and support for building,
</dd>
</dl>
<p><code>  configuring, and installing packages.</code></p>
<dl>
<dt>GHC itself</dt>
<dd>GHC reads the package database(s), understands the flags
<pre><code>-package`, `-hide-package</code></pre>
<p>, etc., and uses the package database</p>
</dd>
</dl>
<p><code>  to find </code></p>
<pre><code>.hi</code></pre>
<p>files and library files for packages. GHC imports modules from Cabal.</p>
<p>;</p>
<pre><code>ghc-pkg</code></pre>
<dl>

<dd>The
<pre><code>ghc-pkg</code></pre>
<p>tool manages the package database, including registering/unregistering packages, queries, and</p>
</dd>
</dl>
<p><code>  checking consistency.  </code></p>
<pre><code>ghc-pkg </code></pre>
<p>also imports modules from Cabal.</p>
<p>;</p>
<pre><code>cabal-install</code></pre>
<dl>

<dd>A tool built on top of Cabal, which adds support for downloading packages from Hackage, and building and installing
</dd>
</dl>
<p><code>  multiple packages with a single command.</code></p>
<p>For the purposes of this commentary, we are mostly concerned with GHC and</p>
<pre><code>ghc-pkg</code></pre>
<p>.</p>
<h2 id="identifying-packages">Identifying Packages</h2>
<p>;</p>
<pre><code>Cabal.PackageName</code></pre>
<p>(&quot;base&quot;)</p>
<dl>

<dd>A string. Defined in
<pre><code>Distribution.Package</code></pre>
<p>. Does not uniquely identify a package: the package</p>
</dd>
</dl>
<p><code>   database can contain several packages with the same name.</code></p>
<p>;</p>
<pre><code>Cabal.PackageId</code></pre>
<p>(&quot;base-4.1.0.0&quot;)</p>
<dl>

<dd>A
<pre><code>PackageName` plus a `Version`.  A `PackageId` names an API.  If two `PackageId</code></pre>
<p>s are</p>
</dd>
</dl>
<p><code>   the same, they are assumed to have the same API.</code><br />
<code>   </code><br />
<br />
<code>    </code></p>
<pre><code>InstalledPackageInfo` contains the field `sourcePackageId :: PackageId</code></pre>
<p>.</p>
<p><code>   </code><br />
<br />
<code>    In GHC 6.11, the </code></p>
<pre><code>PackageId</code></pre>
<p>also uniquely identifies a package instance in the package database, but</p>
<p><code>   only by convention (we may lift this restriction in the future, and allow the database to contain</code><br />
<code>   multiple package instances with the same </code></p>
<pre><code>PackageId` (and different `InstalledPackageId</code></pre>
<p>s).</p>
<pre><code>Cabal.InstalledPackageId</code></pre>
<p>(&quot;base-4.1.0.0-1mpgjN&quot;)::</p>
<p><code>   (introduced in GHC 6.12 / Cabal 1.7.2) A string that uniquely identifies a package instance in the database.</code><br />
<code>   An </code></p>
<pre><code>InstalledPackageId` identifies an ABI: if two `InstalledPackageIds</code></pre>
<p>are the same, they have the</p>
<p><code>   same ABI.</code><br />
<code>   </code><br />
<br />
<code>    </code></p>
<pre><code>InstalledPackageInfo` contains the field `installedPackageId :: InstalledPackageId</code></pre>
<p>.</p>
<p><code>   </code><br />
<br />
<code>    Dependencies between installed packages are identified by the </code></p>
<pre><code>InstalledPackageId`.  An `InstalledPackageId</code></pre>
<p>is</p>
<p><code>   chosen when a package is registered. It is chosen by calling </code></p>
<pre><code>ghc --abi-hash</code></pre>
<p>on the compiled modules and appending</p>
<p><code>   the hash as a suffix to the string representing the </code></p>
<pre><code>PackageIdentifier</code></pre>
<p>.</p>
<p>;</p>
<pre><code>GHC.PackageId</code></pre>
<p>(these currently look like &quot;base-4.1.0.0&quot; in GHC 6.12)</p>
<dl>

<dd>Inside GHC, we use the type
<pre><code>PackageId`, which is a `FastString`.  The (Z-encoding of) `PackageId</code></pre>
<p>prefixes each</p>
</dd>
</dl>
<p><code>   external symbol in the generated code, so that the modules of one package do not clash with those of another package,</code><br />
<code>   even when the module names overlap.</code></p>
<h2 id="design-constraints">Design constraints</h2>
<ol>
<li>We want [wiki:Commentary/Compiler/RecompilationAvoidance recompilation avoidance] to work. This means that symbol names should not contain any information that varies too often, such as the ABI hash of the module or package. The ABI of an entity should depend only on its definition, and the definitions of the things it depends on.</li>
</ol>
<ol>
<li><ol>
<li>We want to be able to detect ABI incompatibility. If a package is recompiled and installed over the top of the old one, and the new version is ABI-incompatible with the old one, then packages that depended on the old version should be detectably broken using the tools.</li>
</ol></li>
</ol>
<ol>
<li><ol>
<li>ABI compatibility:</li>
</ol></li>
</ol>
<ul>
<li>We want repeatable compilations. Compiling a package with the same inputs should yield the same outputs.</li>
<li>Furthermore, we want to be able to make compiled packages that expose an ABI that is compatible (e.g. a superset)</li>
</ul>
<p><code>     of an existing compiled package.</code></p>
<ul>
<li>Modular upgrades: we want to be able to upgrade an existing package without recompiling everything that depends</li>
</ul>
<p><code>     on it, by ensuring that the replacement is ABI-compatible.</code></p>
<ul>
<li>Shared library upgrades. We want to be able to substitute a new ABI-compatible shared library for an old one, and all the existing binaries linked against the old version continue to work.</li>
<li>ABI compatibility is dependent on GHC too; changes to the compiler and RTS can introduce ABI incompatibilities. We</li>
</ul>
<p><code>     guarantee to only make ABI incompatible changes in a major release of GHC.  Between major releases, ABI compatibility</code><br />
<code>     is ensured; so for example it should be possible to use GHC 6.12.2 with the packages that came with GHC 6.12.1.</code></p>
<p>Right now, we do not have repeatable compilations, so while we cannot do (3), we keep it in mind.</p>
<h2 id="the-plan-1">The Plan</h2>
<p>We need to talk about some more package Ids:</p>
<ul>
<li><pre><code>PackageSymbolId</code></pre>
<dl>

<dd>the symbol prefix used in compiled code.
</dd>
</dl></li>
<li><pre><code>PackageLibId</code></pre>
<dl>

<dd>the package Id in the name of a compiled library file (static and shared).
</dd>
</dl></li>
</ul>
<h3 id="detecting-abi-incompatibility">Detecting ABI incompatibility</h3>
<ul>
<li>in the package database, dependencies specify the
<pre><code>InstalledPackageId</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>The package database will contain at most one instance of a given package/version combination. The tools</li>
</ul>
<p><code>   are not currently able to cope with multiple instances (e.g. GHC's -package flag selects by name/version).</code></p>
<ul>
<li>If, say, package P-1.0 is recompiled and re-installed, the new instance of the package will almost</li>
</ul>
<p><code>   certainly have an incompatible ABI from the previous version.  We give the new package a distinct</code><br />
<code>   </code></p>
<pre><code>InstalledPackageId</code></pre>
<p>, so that packages that depend on the old P-1.0 will now be detectably broken.</p>
<ul>
<li><pre><code>PackageSymbolId`: We do not use the `InstalledPackageId</code></pre>
<p>as the symbol prefix in the compiled code, because</p></li>
</ul>
<p><code>   that interacts badly with [wiki:Commentary/Compiler/RecompilationAvoidance recompilation avoidance].  Every time we pick a</code><br />
<code>   new unique </code></p>
<pre><code>InstalledPackageId</code></pre>
<p>(e.g. when reconfiguring the package), we would have to recompile</p>
<p><code>   the entire package.  Hence, the </code></p>
<pre><code>PackageSymbolId</code></pre>
<p>is picked deterministically for the package, e.g.</p>
<p><code>   it can be the </code></p>
<pre><code>PackageIdentifier</code></pre>
<p>.</p>
<ul>
<li><pre><code>PackageLibId`: we do want to put the `InstalledPackageId</code></pre>
<p>in the name of a library file, however. This allows</p></li>
</ul>
<p><code>   ABI incompatibility to be detected by the linker.  This is important for shared libraries too: we</code><br />
<code>   want an ABI-incompatible shared library upgrade to be detected by the dynamic linker.  Hence,</code><br />
<code>   </code></p>
<pre><code>PackageLibId` == `InstalledPackageId</code></pre>
<p>.</p>
<h3 id="allowing-abi-compatibilty">Allowing ABI compatibilty</h3>
<ul>
<li>The simplest scheme is to have an identifier for each distinct ABI, e.g. a pair of the package name and an integer</li>
</ul>
<p><code>  that is incremented each time an ABI change of any kind is made to the package.  The ABI identifier</code><br />
<code>  is declared by the package, and is used as the </code></p>
<pre><code>PackageSymbolId</code></pre>
<p>. Since packages with the same ABI identifier</p>
<p><code>  are ABI-compatible, the </code></p>
<pre><code>PackageLibId` can be the same as the `PackageSymbolId</code></pre>
<p>.</p>
<ul>
<li>The previous scheme does not allow ABI-compatible changes (e.g. ABI extension) to be made. Hence, we could</li>
</ul>
<p><code>  generalise it to a major/minor versioning scheme.</code></p>
<ul>
<li>the ABI major version is as before, the package name + an integer. This is also the
<pre><code>PackageSymbolId</code></pre>
<p>.</p></li>
<li>the ABI minor version is an integer that is incremented each time the ABI is extended in a compatible way.</li>
<li>package dependencies in the database specify the major+minor ABI version they require, in addition to the</li>
</ul>
<pre><code>InstalledPackageId</code></pre>
<p>. They may be satisfied by a greater minor version; when upgrading a package with an</p>
<p><code>    ABI-compatible replacement, ghc-pkg updates dependencies to point to the new </code></p>
<pre><code>InstalledPackageId</code></pre>
<p>.</p>
<ul>
<li><pre><code>PackageLibId</code></pre>
<p>is the major version. In the case of shared libraries, we may name the library using the</p></li>
</ul>
<p><code>    major + minor versions, with a symbolic link from the major version to major+minor.</code></p>
<ul>
<li>the shared library
<pre><code>SONAME</code></pre>
<p>is the major version.</p></li>
</ul>
<ul>
<li>The previous scheme only allows ABI-compatible changes to be made in a linear sequence. If we want a tree-shaped</li>
</ul>
<p><code>  compatibility structure, then something more complex is needed (ToDo).</code></p>
<ul>
<li>The previous schemes only allow compatible ABI changes to be made. If we want to allow incompatible changes to be</li>
</ul>
<p><code>  made, then we need something like ELF's symbol versioning.  This is probably overkill, since we will be making</code><br />
<code>  incompatible ABI changes in the compiler and RTS at regular intervals anyway, so long-term ABI compatibility is</code><br />
<code>  impractical at this stage.</code></p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="the-parser">The Parser</h1>
<p>[Very incomplete. Please extend as you learn more.]</p>
<p>The parser is written using</p>
<ul>
<li><a href="http://www.haskell.org/alex/">Alex</a>, for lexical analysis. Source file <a href="GhcFile(compiler/parser/Lexer.x)" class="uri" title="wikilink">GhcFile(compiler/parser/Lexer.x)</a></li>
<li><a href="http://www.haskell.org/happy/">Happy</a>, for the parser itself. Source file <a href="GhcFile(compiler/parser/Parser.y)" class="uri" title="wikilink">GhcFile(compiler/parser/Parser.y)</a>.</li>
<li><pre><code>RdrHsSyn</code></pre>
<p>, for Haskell support functions. Source file <a href="GhcFile(compiler/parser/RdrHsSyn.lhs)" class="uri" title="wikilink">GhcFile(compiler/parser/RdrHsSyn.lhs)</a></p></li>
</ul>
<h2 id="principles">Principles</h2>
<p>Making a parser parse <em>precisely</em> the right language is hard. So GHC's parser follows the following principle:</p>
<ul>
<li><strong>We often parse &quot;over-generously&quot;, and filter out the bad cases later.</strong></li>
</ul>
<p>Here are some examples:</p>
<ul>
<li>Patterns are parsed as expressions, and transformed from
<pre><code>HsExpr.HsExp` into `HsPat.HsPat` in `RdrHsSyn.checkPattern`.  An expression like `[x | x&lt;-xs]` that doesn&#39;t look like a pattern is rejected by `checkPattern</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>The context of a type is parsed as a type, and then converted into a context by
<pre><code>RdrHsSyn.checkContext</code></pre>
<p>. For example, when parsing</p></li>
</ul>
<pre><code>f :: (Read a, Num a) =&gt; a -&gt; a</code></pre>
<p><code>  the parser can only discover that </code></p>
<pre><code>(Read a, Num a)` is a context, rather than a type, when it meets the `=&gt;`.  That requires infinite lookahead.  So instead we parse `(Read a, Num a)` as a tuple type, and then convert it to a context when we see the `=&gt;</code></pre>
<p>.</p>
<p>Sometimes the over-generous parsing is only dealt with by the renamer. For example:</p>
<ul>
<li>Infix operators are parsed as if they were all left-associative. The renamer uses the fixity declarations to re-associate the syntax tree.</li>
</ul>
<p>There are plenty more examples. A good feature of this approach is that the error messages later in compilation tend to produce much more helpful error messages. Errors generated by the parser itself tend to say &quot;Parse error on line X&quot; and not much more.</p>
<p>The main point is this. If you are changing the parser, feel free to make it accept more programs than it does at the moment, provided you also add a later test that rejects the bad programs. Typically you need this flexibility if some new thing you want to add makes the pars ambiguous, and you need more context to disambiguate. Delicate hacking of the LR grammar is to be discouraged. It's very hard to maintain and debug.</p>
<h2 id="avoiding-right-recursion">Avoiding right-recursion</h2>
<p>Be sure to read <a href="https://www.haskell.org/happy/doc/html/sec-sequences.html">this section</a> of the Happy manual for tips on avoiding right recursion. In GHC, the preferred method is using a left-recursive</p>
<pre><code>OrdList</code></pre>
<p>, as below:</p>
<pre><code>foolist :: { OrdList Foo }
  : foolist &#39;,&#39; foo { $1 &lt;pre&gt;appOL</code></pre>
<p>unitOL $3 }</p>
<p><code> | foolist ','     { $1 } -- optional, but recommended</code><br />
<code> | foo             { unitOL $1 }</code></p>
</pre>
<pre><code>OrdList` operationally works the same way as building a list in reverse (as in the Happy manual), but it makes it less likely you&#39;ll forget to call `reverse` when you need to get the `final</code></pre>
<p>list out.</p>
<p>One interesting, non-obvious fact, is that if you *do* use a right-recursive parser, the &quot;extra semi-colons&quot; production should NOT be pluralized:</p>
<pre><code>foolist :: { [Foo] }
  : foo &#39;,&#39; foolist { $1 : $3 }
  | foo &#39;,&#39;         { [$1] } -- NOT foolist
  | foo             { [$1] }</code></pre>
<h2 id="indentation">Indentation</h2>
<p>Probably the most complicated interaction between the lexer and parser is with regards to //whitespace-sensitive layout.// The most important thing to know is that the lexer understands layout, and will output virtual open/close curlies (productions</p>
<pre><code>vocurly` and `vccurly`) as well as semicolons, which can then be used as part of productions in `Parser.y</code></pre>
<p>. So for example, if you are writing a rule that will make use of indentation, you should accept both virtual and literal curlies:</p>
<pre><code>body    :: { ([AddAnn]                                                             
             ,([LImportDecl RdrName], [LHsDecl RdrName])) }                      
        :  &#39;{&#39;            top &#39;}&#39;      { (moc $1:mcc $3:(fst $2)                   
                                         , snd $2) }                             
        |      vocurly    top close    { (fst $2, snd $2) </code></pre>
<p>Notice the use of</p>
<pre><code>close` rather than `vccurly`: `close` is a production that accepts both `vccurly` and a Happy `error</code></pre>
<dl>
<dt>that is, if we encounter an error in parsing, we try exiting an indentation context and trying again. This ensures, for example, that the top-level context can be closed even if no virtual curly was output.</dt>

</dl>
<p>The top-level of a Haskell file does not automatically have a layout context; when there is no</p>
<pre><code>module` keyword, a context is implicitly pushed using `missing_module_keyword</code></pre>
<p>.</p>
<p>When writing grammars that accept semicolon-separated sequences, be sure to include a rule allowing for trailing semicolons (see the previous section), otherwise, you will reject layout.</p>
<h2 id="syntax-extensions">Syntax extensions</h2>
<p>Many syntactic features must be enabled with a</p>
<pre><code>LANGUAGE</code></pre>
<p>flag, since they could cause existing Haskell programs to stop compiling, as turn some identifiers into keywords. We primarily affect this change of behavior in the lexer, by turning on/off certain tokens. This is done using predicates, which let Alex turn token rules on and off depending on what extensions are enabled:</p>
<pre><code>&lt;0&gt; {                                                                              
  &quot;[|&quot;        / { ifExtension thEnabled } { token ITopenExpQuote } 
}</code></pre>
<p>To add a new syntax extension, add a constructor to</p>
<pre><code>ExtBits` and set the bit appropriately in `mkPState</code></pre>
<p>.</p>
<h1 id="pinned-objects">Pinned Objects</h1>
<p>The GC does not support pinning arbitrary objects. Only objects that have no pointer fields can be pinned. Nevertheless, this is a useful case, because we often want to allocate garbage-collectable memory that can be passed to foreign functions via the FFI, and we want to be able to run the GC while the foreign function is still executing (for a</p>
<pre><code>safe</code></pre>
<p>foreign call). Hence, the memory we allocated must not move.</p>
<p>Bytestrings are currently allocated as pinned memory, so that the bytestring contents can be passed to FFI calls if necessary.</p>
<p>The RTS provides an API for allocating pinned memory, in <a href="GhcFile(includes/rts/storage/GC.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/GC.h)</a>:</p>
<pre><code>StgPtr  allocatePinned  ( Capability *cap, lnat n );</code></pre>
<p>This allocates memory from the given Capability's nursery.</p>
<p>Pinned objects work in the GC as follows:</p>
<ul>
<li>Pinned objects are allocated into a block of their own, not mixed up with unpinned objects.</li>
<li>The block containing pinned objects is marked as a <em>large block</em>, i.e. the
<pre><code>BF_LARGE` bit is set in `bd-&gt;flags</code></pre>
<p>.</p></li>
<li>When encountering a live object in a
<pre><code>BF_LARGE` block, the GC never copies the object, instead it just re-links the whole block onto the `large_objects</code></pre>
<p>list of the destination generation.</p></li>
<li>The GC doesn't have to scavenge the pinned object, since it does not contain any pointers. This is just as well, because we cannot scan blocks for live pinned objects, due to [wiki:Commentary/Rts/Storage/Slop slop]. Hence the restriction that pinned objects do not contain pointers.</li>
</ul>
<p>This means that using pinned objects may lead to memory fragmentation, since a single pinned object keeps alive the whole block in which it resides. If we were to implement a non-moving collector such as [wiki:Commentary/Rts/Storage/GC/Sweeping mark-region], then we would be able to reduce the impact of fragmentation due to pinned objects.</p>
<p>&lt;DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" class="uri">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</a>&quot;&gt;</p>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>
<p>Commentary/Rts/Storage/GC/Pinned</p>
<h1 id="overview-5">Overview</h1>
<p>GHC is structured into two parts:</p>
<ul>
<li>The
<pre><code>ghc` package (in subdirectory `compiler`), which implements almost all GHC&#39;s functionality. It is an ordinary Haskell library, and can be imported into a Haskell program by saying `import GHC</code></pre>
<p>.</p></li>
<li>The
<pre><code>ghc` binary (in subdirectory `ghc`) which imports the `ghc` package, and implements the I/O for the `ghci</code></pre>
<p>interactive loop.</p></li>
</ul>
<p>Here's an overview of the module structure of the top levels of GHC library. (Note: more precisly, this is the plan. Currently the module</p>
<pre><code>Make` below is glommed into the giant module `GHC</code></pre>
<p>.)</p>
<pre><code>          |---------------------------------|
          |              GHC                |
          | The root module for the GHC API |
          | Very little code;               |
          | just simple wrappers            |
          |---------------------------------|
                     /                \
                    /                  \
                   /                    \
 |------------------------|    |------------------------|
 |        GhcMake         |    |    InteractiveEval     |
 | Implements --make      |    | Stuff to support the   |
 | Deals with compiling   |    | GHCi interactive envt  |
 |    multiple modules    |    |                        |
 |------------------------|    |------------------------|
           |                                |
           |                                |
           |      --------------------      |
- - - - - -| - - -|     GhcMonad     |- - - | - - - - - - - -
           |      --------------------      |
           |                                |
           |                                |
 |-------------------------|                |
 |   DriverPipeline        |                |
 | Deals with compiling    |                |
*  single module*      |                |
 | through all its stages  |                |
 | (cpp, unlit, compile,   |                |
 |  assemble, link etc)    |                |
 |-------------------------|                |
              \                             |
               \                            |
                \                           |  
         |----------------------------------------------|
         |                    HscMain                   |
         | Compiling a single module (or expression or  |
         | stmt) to bytecode, or to a M.hc or M.s file  |
         |----------------------------------------------|
              |      |       |         |       |
            Parse Rename Typecheck Optimise CodeGen</code></pre>
<h1 id="the-driver-pipeline">The driver pipeline</h1>
<p>The driver pipeline consist of a couple of phases that call other programs and generate a series of intermediate files. Code responsible for managing the order of phases is in <a href="GhcFile(compiler/main/DriverPhases.hs)" class="uri" title="wikilink">GhcFile(compiler/main/DriverPhases.hs)</a>, while managing the driver pipeline as a whole is coded in <a href="GhcFile(compiler/main/DriverPipeline.hs)" class="uri" title="wikilink">GhcFile(compiler/main/DriverPipeline.hs)</a>. Note that driver pipeline is not the same thing as compilation pipeline: the latter is part of the former.</p>
<p>Let's take a look at the overall structure of the driver pipeline. When we compile</p>
<pre><code>Foo.hs</code></pre>
<p>or</p>
<pre><code>Foo.lhs</code></pre>
<p>(&quot;lhs&quot; extension means that Literate Haskell is being used) the following phases are being called (some of them depending on additional conditions like file extensions or enabled flags):</p>
<ul>
<li>Run the <strong>unlit pre-processor</strong>,
<pre><code>unlit</code></pre>
<p>, to remove the literate markup, generating</p>
<pre><code>Foo.lpp</code></pre>
<p>. The</p>
<pre><code>unlit</code></pre>
<p>processor is a C program kept in <a href="GhcFile(utils/unlit)" class="uri" title="wikilink">GhcFile(utils/unlit)</a>.</p></li>
</ul>
<ul>
<li>Run the <strong>C preprocessor</strong>,
<pre><code>cpp</code></pre>
<p>, (if</p>
<pre><code>-cpp</code></pre>
<p>is specified), generating</p>
<pre><code>Foo.hspp</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>Run <strong>the compiler itself</strong>. This does not start a separate process; it's just a call to a Haskell function. This step always generates an [wiki:Commentary/Compiler/IfaceFiles <strong>interface file</strong>]
<pre><code>Foo.hi</code></pre>
<p>, and depending on what flags you give, it also generates a compiled file. As GHC supports three backend code generators currently (a native code generator, a C code generator and an llvm code generator) the possible range of outputs depends on the backend used. All three support assembly output:</p>
<ul>
<li>Object code: no flags required, file
<pre><code>Foo.o</code></pre>
<p>(supported by all three backends)</p></li>
<li>Assembly code: flag
<pre><code>-S</code></pre>
<p>, file</p>
<pre><code>Foo.s</code></pre>
<p>(supported by all three backends)</p></li>
<li>C code: flags
<pre><code>-C</code></pre>
<p>, file</p>
<pre><code>Foo.hc</code></pre>
<p>(only supported by C backend)</p></li>
</ul></li>
</ul>
<ul>
<li>In the
<pre><code>-fvia-C</code></pre>
<p>case:</p>
<ul>
<li>Run the <strong>C compiler</strong> on
<pre><code>Foo.hc`, to generate `Foo.s</code></pre>
<p>.</p></li>
</ul></li>
</ul>
<ul>
<li>If
<pre><code>-split-objs` is in force, run the &#39;&#39;&#39;splitter&#39;&#39;&#39; on `Foo.s`.  This splits `Foo.s</code></pre>
<p>into lots of small files. The idea is that the static linker will thereby avoid linking dead code.</p></li>
</ul>
<ul>
<li>Run the assembler on
<pre><code>Foo.s`, or if `-split-objs</code></pre>
<p>is in force, on each individual assembly file.</p></li>
</ul>
<h1 id="the-compiler-pipeline">The compiler pipeline</h1>
<p>The <strong>compiler itself</strong>, independent of the external tools, is also structured as a pipeline. For details (and a diagram), see [wiki:Commentary/Compiler/HscMain]</p>
<h1 id="video">Video</h1>
<p>Video of compilation pipeline explanation from 2006: <a href="http://www.youtube.com/watch?v=dzSc8ACz_mw&amp;list=PLBkRCigjPwyeCSD_DFxpd246YIF7_RDDI">Compilation Pipeline</a> and interface files (17'30&quot;)</p>
<h1 id="platforms">Platforms</h1>
<p>Please read [wiki:CrossCompilation this wiki page] on cross compilation for a better understanding of the situation here. There are three platforms of interest to GHC when compiling and running:</p>
<ul>
<li>The <strong>Build</strong> platform. This is the platform on which we are building GHC.</li>
<li>The <strong>Host</strong> platform. This is the platform on which we are going to run this GHC binary, and associated tools.</li>
<li>The <strong>Target</strong> platform. This is the platform for which this GHC binary will generate code.</li>
</ul>
<h2 id="limitations">Limitations</h2>
<p>At the moment, there is limited support for having different values for build, host, and target. Please refer to the [wiki:CrossCompilation cross compilation] page for more details. In particular:</p>
<p>The build platform is currently always the same as the host platform. The build process needs to use some of the tools in the source tree, for example ghc-pkg and hsc2hs.</p>
<p>If the target platform differs from the host platform, then this is generally for the purpose of building .hc files from Haskell source for porting GHC to the target platform. Full cross-compilation isn't supported (yet).</p>
<h2 id="macros">Macros</h2>
<p>In the compiler's source code, you may make use of the following CPP symbols:</p>
<ul>
<li><em>xxx</em>
<pre><code>_TARGET_ARCH</code></pre></li>
<li><em>xxx</em>
<pre><code>_TARGET_VENDOR</code></pre></li>
<li><em>xxx</em>
<pre><code>_TARGET_OS</code></pre></li>
<li><em>xxx</em>
<pre><code>_HOST_ARCH</code></pre></li>
<li><em>xxx</em>
<pre><code>_HOST_VENDOR</code></pre></li>
<li><em>xxx</em>
<pre><code>_HOST_OS</code></pre></li>
</ul>
<p>where <em>xxx</em> is the appropriate value: eg.</p>
<pre><code>i386_TARGET_ARCH</code></pre>
<p>. However <strong>GHC is moving away from using CPP for this purpose</strong> in many cases due to the problems it creates with supporting cross compilation.</p>
<p>So instead of it the new plan is to always build GHC as a cross compiler and select the appropriate values and backend code generator to run and runtime. For this purpose there is the Platform module (<a href="GhcFile(compiler/utils/Platform.hs)" class="uri" title="wikilink">GhcFile(compiler/utils/Platform.hs)</a>). That contains various methods for querying the DynFlags (<a href="GhcFile(compiler/main/DynFlags.hs)" class="uri" title="wikilink">GhcFile(compiler/main/DynFlags.hs)</a>) value for what platform GHC is currently compiling for. You should use these when appropriate over the CPP methods.</p>
<h1 id="pointer-tagging-1">Pointer Tagging</h1>
<p>Paper: <a href="http://research.microsoft.com/pubs/67969/ptr-tagging.pdf">Faster laziness using dynamic pointer tagging</a></p>
<p>In GHC we &quot;tag&quot; pointers to heap objects with information about the object they point to. The tag goes in the low 2 bits (3 bits on a 64-bit platform) of the pointer, which would normally be zero since heap objects are always [wiki:Commentary/Rts/Word word]-aligned.</p>
<h2 id="meaning-of-the-tag-bits">Meaning of the tag bits</h2>
<p>The way the tag bits are used depends on the type of object pointed to:</p>
<ul>
<li>If the object is a <strong>constructor</strong>, the tag bits contain the <em>constructor tag</em>, if the number of</li>
</ul>
<p><code>  constructors in the datatype is less than 4 (less than 8 on a 64-bit platform).  If the number of</code><br />
<code>  constructors in the datatype is equal to or more than 4 (resp 8), then the tag bits have the value 1, and the constructor tag</code><br />
<code>  is extracted from the constructor's info table instead.</code></p>
<ul>
<li>If the object is a <strong>function</strong>, the tag bits contain the <em>arity</em> of the function, if the arity fits</li>
</ul>
<p><code>  in the tag bits.</code></p>
<ul>
<li>For a pointer to any other object, the tag bits are always zero.</li>
</ul>
<h2 id="optimisations-enabled-by-tag-bits">Optimisations enabled by tag bits</h2>
<p>The presence of tag bits enables certain optimisations:</p>
<ul>
<li>In a case-expression, if the variable being scrutinised has non-zero tag bits, then we know</li>
</ul>
<p><code>  that it points directly to a constructor and we can avoid </code><em><code>entering</code></em><code> it to evaluate it.</code><br />
<code>  Furthermore, for datatypes with only a few constructors, the tag bits will tell us </code><em><code>which</code></em><br />
<code>  constructor it is, eliminating a further memory load to extract the constructor tag from the</code><br />
<code>  info table.</code></p>
<ul>
<li>In a [wiki:Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply generic apply], if the function being applied has a tag value that indicates it has exactly the</li>
</ul>
<p><code>  right arity for the number of arguments being applied, we can jump directly to the function, instead of</code><br />
<code>  inspecting its info table first.</code></p>
<p>Pointer-tagging is a fairly significant optimisation: we measured 10-14% depending on platform. A large proportion of this comes from eliminating the indirect jumps in a case expression, which are hard to predict by branch-prediction. The paper has full results and analysis.</p>
<h2 id="garbage-collection-with-tagged-pointers">Garbage collection with tagged pointers</h2>
<p>The [wiki:Commentary/Rts/Storage/GC garbage collector] maintains tag bits on the pointers it traverses. This is easier, it turns out, than <em>reconstructing</em> tag bits. Reconstructing tag bits would require that the GC knows not only the tag of the constructor (which is in the info table), but also the family size (which is currently not in the info table), since a constructor from a large family should always have tag 1. To make this practical we would probably need different closure types for &quot;small family&quot; and &quot;large family&quot; constructors, and we already subdivide the constructor closures types by their layout.</p>
<p>Additionally, when the GC eliminates an indirection it takes the tag bits from the pointer inside the indirection. Pointers to indirections always have zero tag bits.</p>
<h2 id="invariants">Invariants</h2>
<p>Pointer tagging is <em>not</em> optional, contrary to what the paper says. We originally planned that it would be: if the GC threw away all the tags, then everything would continue to work albeit more slowly. However, it turned out that in fact we really want to assume tag bits in some places:</p>
<ul>
<li>In the continuation of an algebraic case, R1 is assumed tagged</li>
<li>On entry to a non-top-level function, R1 is assumed tagged</li>
</ul>
<p>If we don't assume the value of the tag bits in these places, then extra code is needed to untag the pointer. If we can assume the value of the tag bits, then we just take this into account when indexing off R1.</p>
<p>This means that everywhere that enters either a case continuation or a non-top-level function must ensure that R1 is correctly tagged. For a case continuation, the possibilities are:</p>
<ul>
<li>the scrutinee of the case jumps directly to the alternative if R1 is already tagged.</li>
<li>the constructor entry code returns to an alternative. This code adds the correct tag.</li>
<li>if the case alternative fails a heap or stack check, then the RTS will re-enter the alternative after</li>
</ul>
<p><code>   GC.  In this case, our re-entry arranges to enter the constructor, so we get the correct tag by</code><br />
<code>   virtue of going through the constructor entry code.</code></p>
<p>For a non-top-level function, the cases are:</p>
<ul>
<li>unknown function application goes via
<pre><code>stg_ap_XXX</code></pre>
<p>(see [wiki:Commentary/Rts/HaskellExecution/FunctionCalls#Genericapply Generic Apply]).</p></li>
</ul>
<p><code>   The generic apply functions must therefore arrange to correctly tag R1 before entering the function.</code></p>
<ul>
<li>A known function can be entered directly, if the call is made with exactly the right number of arguments.</li>
<li>If a function fails its heap check and returns to the runtime to garbage collect, on re-entry the closure</li>
</ul>
<p><code>   pointer must be still tagged.</code></p>
<ul>
<li>the PAP entry code jumps to the function's entry code, so it must have a tagged pointer to the function</li>
</ul>
<p><code>   closure in R1.  We therefore assume that a PAP always contains a tagged pointer to the function closure.</code></p>
<p>In the second case, calling a known non-top-level function must pass the function closure in R1, and this pointer <em>must</em> be correctly tagged. The code generator does not arrange to tag the pointer before calling the function; it assumes the pointer is already tagged. Since we arrange to tag the pointer when the closure is created, this assumption is normally safe. However, if the pointer has to be saved on the stack, say across a call, then when the pointer is retrieved again we must either retag it, or be sure that it is still tagged. Currently we do the latter, but this imposes an invariant on the garbage collector: all tags must be retained on non-top-level function pointers.</p>
<p>Pointers to top-level functions are not necessarily tagged, because we don't always know the arity of a function that resides in another module. When optimisation is on, we do know the arities of external functions, and this information is indeed used to tag pointers to imported functions, but when optimisation is off we do not have this information. For constructors, the interface doesn't contain information about the constructor tag, except that there may be an unfolding, but the unfolding is not necessarily reliable (the unfolding may be a constructor application, but in reality the closure may be a CAF, e.g. if any of the fields are references outside the current shared library).</p>
<h2 id="compacting-gc">Compacting GC</h2>
<p>Compacting GC also uses tag bits, because it needs to distinguish between a heap pointer and an info pointer quickly. The compacting GC has a complicated scheme to ensure that pointer tags are retained, see the comments in <a href="GhcFile(rts/sm/Compact.c)" class="uri" title="wikilink">GhcFile(rts/sm/Compact.c)</a>.</p>
<h2 id="dealing-with-tags-in-the-code">Dealing with tags in the code</h2>
<p>Every time we dereference a pointer to a heap object, we must first zero the tag bits. In the RTS, this is done with the inline function (previously: macro)</p>
<pre><code>UNTAG_CLOSURE()`; in `.cmm` code this is done with the `UNTAG()</code></pre>
<p>macro. Surprisingly few places needed untagging to be added.</p>
<h1 id="position-independent-code-and-dynamic-linking">Position-Independent Code and Dynamic Linking</h1>
<p>We need to generate position-independent code on most platforms when we want our code to go into dynamic libraries (also referred to as shared libraries or DLLs). On some platforms (AIX, powerpc64-linux, x86_64-darwin), PIC is required for all code.</p>
<p>To access things defined in a dynamic library, we might need to do special things, such as look up the address of the imported thing in a table of pointers, depending on what platform we are on.</p>
<h2 id="how-to-access-symbols">How to access symbols</h2>
<p>A C compiler is in an unfortunate position when generating PIC code, as it does not have any hints, whether an accessed symbol ends up in the same dynamic library or if it is truely an external symbol (from the dynamic library point of view). It can only generate non-PIC access for symbols generated within the same object file. In Haskell, we can do better as we assume all package code to end up in a single dynamic library. Hence, all intra-package symbol accesses can be generated as code that does direct access. For all inter-package accesses (package haskell98 accessing symbols in package base, e.g.), we have to generate PIC code. For the following we establish the following:</p>
<ul>
<li><em>object-local symbols</em>, symbols within the same object file. Always generate direct access.</li>
<li><em>package-local symbols</em>, symbols within the same Haskell package. The NCG can generate direct access code, C compilers can't.</li>
<li><em>local symbols</em>, either object-local or package-local.</li>
<li><em>global symbols</em>, symbol in different libraries/packages. Always generate PIC.</li>
</ul>
<h2 id="clabel.labeldynamic">CLabel.labelDynamic</h2>
<p>On most platforms, we can access any global symbol as if it was imported from a dynamic library; this usually means a small performance hit (an extra pointer dereference), but it is otherwise harmless. On some platforms, we have to access all global symbols this way. On Windows, we must know exactly which symbols are DLL-imported and which aren't.</p>
<p>Module</p>
<pre><code>CLabel` contains a function `labelDynamic :: CLabel -&gt; Bool` which is supposed to know whether a `CLabel</code></pre>
<p>is imported from a dynamic library. On Windows, this function needs to be exact; everywhere else, we don't mind the occasional false positive.</p>
<h2 id="info-tables-1">Info Tables</h2>
<p>Info tables are in the text segment, which is supposed to be read-only and position-independent. Therefore, an info table <em>must not</em> contain any absolute address; instead, all addresses in info tables are instead encoded as relative offsets from the info label.</p>
<p>Note that this is done even when we are generating code that is otherwise position-dependent, in order to preserve binary compatibility between PIC and non-PIC.</p>
<p>It is not possible to generate those relative references from C code, so for the via-C compilation route, we pretty-print these relative references (</p>
<pre><code>CmmLabelDiffOff</code></pre>
<p>in cmm) as absolute references and have the mangler convert them to relative references again.</p>
<h2 id="imported-labels-in-srts-windows">Imported labels in SRTs (Windows)</h2>
<p>Windows doesn't support references to imported labels in the data segment; on other platforms, the dynamic linker will just relocate the pointers in the SRTs to point to the right symbols. There is a hack in the code that tries to work around it; it might be bitrotted, and it might have been made unnecessary by the GNU linker's new auto-import on Windows.</p>
<h2 id="pic-and-dynamic-linking-support-in-the-ncg">PIC and dynamic linking support in the NCG</h2>
<p>The module</p>
<pre><code>PositionIndependentCode</code></pre>
<p>lies at the heart of PIC and dynamic linking support in the native code generator.</p>
<p>The basic idea is to call a function</p>
<pre><code>cmmMakeDynamicReference</code></pre>
<p>for all labels accessed from the code during the cmm-to-cmm transformation phase. This function will decide on the appropriate way to access the given label for the current platform and the current combination of -fPIC and -dynamic flags.</p>
<p>We extend Cmm and the</p>
<pre><code>CLabel</code></pre>
<p>module by a few things to allow us to express all the different things that occur on different platforms:</p>
<p>The</p>
<pre><code>Cmm.GlobalReg` datatype has a constructor `PicBaseReg`. This PIC base register is the register relative to which position-independent references are calculated. This can be a general-purpose register that is allocated on a per-&lt;nowiki&gt;CmmProc&lt;/nowiki&gt; basis, or it can be a dedicated register, like the instruction pointer `%rip</code></pre>
<p>on x86_64.</p>
<h2 id="how-things-are-done-on-different-platforms">How things are done on different platforms</h2>
<p>This section is a survey of how PIC and dynamic linking works on different platforms. There are small snippets of assembly code for several platforms, platforms that are similar to other platforms are left out (e.g. powerpc-darwin is left out, because the logic is the same as for i386-darwin). I hope the reader will not be too confused by irrelevant differences between the platforms, such as the fact that Darwin and Windows prefix all symbols with an underscore, and Linux doesn't.</p>
<h3 id="position-dependent-code">Position dependent code</h3>
<p>In the absence of PIC and dynamic linking, things are simple; when we use a label in assembly code, the linker will make sure it points to the right place.</p>
<pre><code># i386-linux without PIC and without dynamic linking
# i386-mingw32 and i386-darwin without dynamic linking
#         are the same with leading underscores.
# get the address of variable bar:
    movl $bar, %eax
# read a 4-byte-variable bar:
    movl bar, %eax
# call function foo:
    call foo
# tail-call foo_info:
    jmp foo_info</code></pre>
<p>Now, to access a symbol</p>
<pre><code>xfoo` that has been imported from a dynamic library, we do not want to mention the address of `xfoo</code></pre>
<p>in the text section, because it would need to be modified at load-time.</p>
<p>One solution is to allocate a pointer to the imported symbol in a writable section and have the dynamic linker fill in this pointer table. The pointer table itself resides at a statically known address. The</p>
<ul>
</ul>
<p>imp</p>
</ul>
<ul>
<li>symbols on Windows are automatically generated by the linker.</li>
</ul>
<pre><code># i386-mingw32, accessing imported symbols
# get the address of imported symbol xbar:
    movl &lt;ul&gt;imp&lt;/ul&gt;xbar, %eax
# read a 4-byte-variable xbar:
    movl &lt;ul&gt;imp&lt;/ul&gt;xbar, %eax
    movl (%eax), %eax
# call imported function xfoo:
* _imp__xfoo
# tail-call imported xfoo_info:
* _imp__xfoo_info</code></pre>
<p>On Mac OS X, the same system is used for data imports, but this time we have to define the symbol pointers ourselves. For references to code, there is an additional mechanism available; we can jump to a small piece of stub code that will resolve the symbol the first time it is used, in order to reduce application load times. Unfortunately, everything on Mac OS X requires 16-byte stack alignment, even the dynamic linker, so we cannot use this for a tail call.</p>
<pre><code># i386-darwin, accessing imported symbols
# get the address of imported symbol xbar:
    movl L_xbar$non_lazy_ptr, %eax
# read a 4-byte-variable xbar:
    movl L_xbar$non_lazy_ptr, %eax
    movl (%eax), %eax
# call imported function xfoo:
    call L_xfoo$stub
# tail-call imported xfoo_info:
* _xfoo$non_lazy_ptr

# And now we need to define those L_*$* things:

    .section &lt;ul&gt;IMPORT,&lt;/ul&gt;pointers,non_lazy_symbol_pointers
L_xbar$non_lazy_ptr:
    .indirect_symbol _xbar
    .long   0
L_xfoo$non_lazy_ptr:
    .indirect_symbol _xfoo
    .long   0

    .section &lt;ul&gt;IMPORT,&lt;/ul&gt;jump_table,symbol_stubs,self_modifying_code+pure_instructions,5
L_foo$stub:
    .indirect_symbol _foo
    hlt ; hlt ; hlt ; hlt ; hlt
    # The linker will insert a jmp instruction instead of those hlts</code></pre>
<p>In theory, dynamic linking is transparent to position-dependent code on Linux, i.e. the code for accessing imported labels should look exactly the same as for non-imported labels. Unfortunately, things just don't work as they should for strange stuff like info tables.</p>
<p>When the ELF static linker finds a jump or call to an imported symbol, it automatically redirects the jump or call to a linker generated code stub (in the so-called procedure linkage table, or PLT). The linker then considers the label to be a code label and redirects all further references to the label to the code stub, even if they are data references. If this ever happens to an info label, our program will crash, as there is no info table in front of the code stub.</p>
<p>When the ELF static linker finds a data reference to an imported symbol (that it doesn't consider a code label), it allocates space for that symbol in the executable's data section and issues an</p>
<pre><code>R_COPY</code></pre>
<p>relocation, which instructs the dynamic linker to copy the (initial) contents of the symbol to its new place in the executable's image. All references to the symbol from the dynamic library are relocated to point to the symbol's new location, instead.</p>
<p>If</p>
<pre><code>R_COPY</code></pre>
<p>is ever used for an info label, our program will also crash, because the data we're interested in is *before* the info label and is not copied to the symbol's new home.</p>
<p>Fortunately, if the static linker finds a pointer to an imported symbol in a writable section, it just instructs the dynamic linker to update that pointer to the symbols address, without doing anything &quot;funny&quot;. We can therefore work around these problems.</p>
<p>The workaround is inspired by the position-independent code that GCC generates for powerpc-linux, a platform that is amazingly broken.</p>
<pre><code># i386-linux, accessing imported symbols
# get the address of imported variable xbar:
    movl $xbar, %eax
# read a 4-byte-variable xbar:
    movl xbar, %eax
# call an imported function xfoo:
    call xfoo
    
# Up to here, everything was fine
# (assuming that xbar and xfoo are conventional variables and functions, 
#  as we would find them in foreign code)
# From here on, we have to use a workaround:
    
# tail-call imported xfoo_info:
* LC_xfoo_info
# get the address of an imported info table xfoo_info:
    movl .LC_xfoo_info, %eax
    
.section &quot;.got2&quot;, &quot;aw&quot;
.LC_xfoo_info:
    .long xfoo_info</code></pre>
<p>Things look pretty much the same on x86_64-linux, powerpc-linux and powerpc-darwin; PowerPC has the added handicap that it takes two instructions to load a 32 bit quantity into a register. On x86_64-darwin, powerpc64-linux and all versions of AIX, PIC is <em>required</em>.</p>
<h3 id="position-independent-code">Position independent code</h3>
<p>First, let it be said that there is no such thing as position-independent code on Windows. The dynamic linker will just patiently relocate all dynamic libraries that are not loaded at their preferred base address. On all other platforms, PIC is at least strongly recommended for dynamic libraries.</p>
<p>In an ideal world, there would be assembler instructions for referring to things via an offset from the current instruction pointer. Jump instructions are ip-relative on all platforms that GHC runs on, but for data accesses, only x86_64 is this ideal world.</p>
<p>On x86_64, on both Linux and Mac OS X, we can use</p>
<pre><code>foo(%rip)` to encode an instruction pointer relative data reference to `foo`, and `foo@GOTPCREL(%rip)` to encode an instruction pointer relative referece to a linker-generated symbol pointer for symbol `foo</code></pre>
<p>. A linker-generated code stub for imported code can be accessed by appending</p>
<pre><code>@PLT</code></pre>
<p>to the label on Linux, and is used implicitly when necessary on Mac OS X.</p>
<p>Again, we have to avoid the code stubs for tail-calls and use the symbol pointer instead, because there is a stack alignment requirement.</p>
<pre><code># x86_64-linux, -fPIC
# x86_64-darwin is almost the same,
#   .. but with leading underscores and no @PLT suffixes

# get the address of variable bar:
    leaq bar(%rip), %rax
# read a 4-byte-variable bar:
    movl bar(%rip), %eax
# call function foo:
    call foo
# tail-call foo_info:
    jmp foo_info

# get the address of imported symbol xbar:
    movq xbar@GOTPCREL(%rip), %rax
# read a 4-byte-variable xbar:
    movq xbar@GOTPCREL(%rip), %rax
    movl (%rax), %eax
# call imported function xfoo:
    call xfoo@PLT
# tail-call imported xfoo_info:
* foo_info@GOTPCREL(%rip)</code></pre>
<p>Other platforms are not nearly as nice; i386 and powerpc[64] do not have a way of accessing the current instruction pointer or referring to data relative to it. The *only* way to get at the current instruction pointer is to issue a call instruction. To generate PIC code, we have to do just that at the beginning of each function.</p>
<p>On Darwin, things are relatively straightforward:</p>
<pre><code># i386-darwin, -fPIC
    
# first, initialise PIC:
    call    1f
1:  pop     %ebx
    # now, %ebx contains the address of local label 1
    # (Note: local label 1 is referred to as &quot;1f&quot; before its definition,
    #        and as &quot;1b&quot; after its definition)

# get the address of variable bar:
    leal _bar-1b(%ebx), %eax
# read a 4-byte-variable bar:
    movl _bar-1b(%ebx), %eax
# call function foo:
    call foo
# tail-call foo_info:
    jmp foo_info

# get the address of imported symbol xbar:
    movl L_xbar$non_lazy_ptr-1b(%ebx), %eax
# read a 4-byte-variable xbar:
    movl L_xbar$non_lazy_ptr-1b(%ebx), %eax
    movl (%eax), %eax
# call imported function xfoo:
    call L_xfoo$stub
# tail-call imported xfoo_info:
* _xfoo$non_lazy_ptr-1b(%ebx)

# And now we need to define those L_*$* things:

    .section &lt;ul&gt;IMPORT,&lt;/ul&gt;pointers,non_lazy_symbol_pointers
L_xbar$non_lazy_ptr:
    .indirect_symbol _xbar
    .long   0
L_xfoo$non_lazy_ptr:
    .indirect_symbol _xfoo
    .long   0

    .section &lt;ul&gt;IMPORT,&lt;/ul&gt;jump_table,symbol_stubs,self_modifying_code+pure_instructions,5
L_foo$stub:
    .indirect_symbol _foo
    hlt ; hlt ; hlt ; hlt ; hlt
    # The linker will insert a jmp instruction instead of those hlts</code></pre>
<p>There is one more small additional complication on Darwin. The assembler doesn't support label difference expressions involving labels not defined in the same source file, so we have to treat all symbols not defined in the same source file as dynamically imported.</p>
<p>On Linux, we need to first calculate the address of the Global Offset Table (GOT) and then use</p>
<pre><code>bar@GOT` to refer to symbol pointers and `bar@GOTOFF</code></pre>
<p>to refer to a local symbol relative to the GOT. Also, the linker-generated code-stubs (</p>
<pre><code>xfoo@PLT`) require the address of the GOT to be in register `%ebx</code></pre>
<p>when they are invoked. The NCG currently doesn't do this, so we avoid code stubs altogether on i386.</p>
<pre><code># i386-linux, -fPIC
    
# first, initialise PIC:
    call    1f
1:  pop     %ebx
    # now, %ebx contains the address of local label 1
    addl    $_GLOBAL_OFFSET_TABLE_+(.-1b), %ebx
    # now, %ebx contains the address of the GOT

# get the address of variable bar:
    leal bar@GOTOFF(%ebx), %eax
# read a 4-byte-variable bar:
    movl bar@GOTOFF(%ebx), %eax
# call function foo:
    call foo
# tail-call foo_info:
    jmp foo_info

# get the address of imported symbol xbar:
    movl xbar@GOT(%ebx), %eax
# read a 4-byte-variable xbar:
    movl xbar@GOT(%ebx), %eax
    movl (%eax), %eax
# call imported function xfoo:
        
    # using the PLT would work here, because we happened to use %ebx,
    # but the NCG won&#39;t do it right now:
    # call xfoo@PLT
    
    # Instead, we use the symbol pointer:
* foo@GOT(%ebx)

# tail-call imported xfoo_info:
* foo@GOT(%ebx)</code></pre>
<p><strong>To be done:</strong> powerpc-linux, AIX/powerpc64-linux</p>
<h2 id="linking-on-elf">Linking on ELF</h2>
<p>To generate a DSO on ELF platform, we use GNU ld. Except for</p>
<pre><code>-Bsymbolic`, ld is invoked regularly with the `-shared` option, and `-o` pointing to the output DSO file followed objects that in its sum compose an entire package. In Haskell, we assume that there is a one-to-one mapping from packages to DSOs. So, all parts of the base package will end up in a libHSbase.so. As intra-package references are not generated as PIC code, we have to supply all objects that make up a package, so that ld is able to resolve these references before writing a (.text) relocation free DSO library file. To enable these cross-object relocations GNU ld needs `-Bsymbolic</code></pre>
<p>.</p>
<h2 id="mangling-dynamic-library-names">Mangling dynamic library names</h2>
<p>As Haskell DSOs might end up in standard library paths, and as they might not be compatible among compilers and compiler version, we need to mangle their names to include the compiler and its version.</p>
<p>The scheme is libHS<em><package></em>-<em><package-version></em>-<em><compiler><compilerversion></em>.so. E.g. libHSbase-2.1-ghc6.6.so</p>
<h1 id="ghc-commentary-the-c-code-generator">GHC Commentary: The C code generator</h1>
<p>Source: <a href="GhcFile(compiler/cmm/PprC.hs)" class="uri" title="wikilink">GhcFile(compiler/cmm/PprC.hs)</a></p>
<p>This phase takes [wiki:Commentary/Compiler/CmmType Cmm] and generates plain C code. The C code generator is very simple these days, in fact it can almost be considered pretty-printing. It is only used for unregisterised compilers.</p>
<h2 id="header-files">Header files</h2>
<p>GHC was changed (from version 6.10) so that the C backend no longer uses header files specified by the user in any way. The</p>
<pre><code>c-includes` field of a `.cabal` file is ignored, as is the `-#include</code></pre>
<p>flag on the command-line. There were several reasons for making this change:</p>
<p>This has several advantages:</p>
<ul>
<li>Via C compilation is consistent with the other backend with respect to FFI declarations:</li>
</ul>
<p><code>  all bind to the ABI, not the API.</code><br />
<code> </code></p>
<ul>
<li>foreign calls can now be inlined freely across module boundaries, since</li>
</ul>
<p><code>  a header file is not required when compiling the call.</code><br />
<code> </code></p>
<ul>
<li>bootstrapping via C will be more reliable, because this difference</li>
</ul>
<p><code>  in behavior between the two backends has been removed.</code><br />
<code> </code></p>
<p>There are some disadvantages:</p>
<ul>
<li>we get no checking by the C compiler that the FFI declaration</li>
</ul>
<p><code>  is correct.</code></p>
<ul>
<li>we can't benefit from inline definitions in header files.</li>
</ul>
<h2 id="prototypes">Prototypes</h2>
<p>When a label is referenced by an expression, the compiler needs to know whether to declare the label first, and if so, at what type.</p>
<p>C only lets us declare an external label at one type in any given source file, even if the scopes of the declarations don't overlap. So we either have to scan the whole code to figure out what the type of each label should be, or we opt for declaring all labels at the same type and then casting later. Currently we do the latter.</p>
<ul>
<li>all labels referenced as a result of an FFI declaration</li>
</ul>
<p><code>  are declared as </code></p>
<pre><code>extern StgWord[]</code></pre>
<p>, including function labels.</p>
<p><code>  If the label is called, it is first cast to the correct</code><br />
<code>  function type.  This is because the same label might be</code><br />
<code>  referred to both as a function and an untyped data label in</code><br />
<code>  the same module (e.g. Foreign.Marsal.Alloc refers to &quot;free&quot;</code><br />
<code>  this way).  </code></p>
<ul>
<li>An exception is made to the above for functions declared with</li>
</ul>
<p><code>  the </code></p>
<pre><code>stdcall</code></pre>
<p>calling convention on Windows. These functions must</p>
<p><code>  be declared with the </code></p>
<pre><code>stdcall</code></pre>
<p>attribute and a function type,</p>
<p><code>  otherwise the C compiler won't add the </code></p>
<pre><code>@n</code></pre>
<p>suffix to the symbol.</p>
<p><code>  We can't add the </code></p>
<pre><code>@n</code></pre>
<p>suffix ourselves, because it is illegal</p>
<p><code>  syntax in C.  However, we always declare these labels with the</code></p>
<ul>
<li>(void)`, to avoid conflicts if the same function</li>
</ul>
<p><code>  is called at different types in one module (see </code></p>
<pre><code>Graphics.Win32.GDI.HDC.SelectObject</code></pre>
<p>).</p>
<ul>
<li>Another exception is made for functions that are marked
<pre><code>never returns</code></pre>
<p>in C--. We</p></li>
</ul>
<p><code>  have to put an </code></p>
<pre><code>&lt;ul&gt;attribute&lt;/ul&gt;((noreturn))</code></pre>
<p>on the declaration for these functions,</p>
<p><code>  and it only works if the function is declared with a proper function type and</code><br />
<code>  called without casting it to/from a pointer.  So only the correct prototype</code><br />
<code>  will do here.</code></p>
<ul>
<li>all RTS symbols already have declarations (mostly with the correct</li>
</ul>
<p><code>  type) in </code><a href="GhcFile(includes/StgMiscClosures.h)" title="wikilink"><code>GhcFile(includes/StgMiscClosures.h)</code></a><code>, so no declarations are generated.</code></p>
<ul>
<li>certain labels are known to have been defined earlier in the same file,</li>
</ul>
<p><code>  so a declaration can be omitted (e.g. SRT labels)</code></p>
<ul>
<li>certain math functions (
<pre><code>sin()`, `cos()</code></pre>
<p>etc.) are already declared because</p></li>
</ul>
<p><code>  we #include math.h, so we don't emit declarations for these.  We need</code><br />
<code>  to #include math.h because some of these functions have inline</code><br />
<code>  definitions, and we get terrible code otherwise.</code></p>
<p>When compiling the RTS cmm code, we have almost no information about labels referenced in the code. The only information we have is whether the label is defined in the RTS or in another package: a label that is declared with an import statement in the .cmm file is assumed to be defined in another package (this is for dynamic linking, where we need to emit special code to reference these labels).</p>
<p>For all other labels referenced by RTS .cmm code, we assume they are RTS labels, and hence already declared in <a href="GhcFile(includes/StgMiscClosures.h)" class="uri" title="wikilink">GhcFile(includes/StgMiscClosures.h)</a>. This is the only choice here: since we don't know the type of the label (info, entry etc.), we can't generate a correct declaration.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="primitive-operations-primops">Primitive Operations (PrimOps)</h1>
<p>PrimOps are functions that cannot be implemented in Haskell, and are provided natively by GHC. For example, adding two</p>
<pre><code>Int#</code></pre>
<p>values is provided as the PrimOp</p>
<pre><code>+#</code></pre>
<p>, and allocating a new mutable array is the PrimOp</p>
<pre><code>newArray#</code></pre>
<p>.</p>
<p>PrimOps are made available to Haskell code through the virtual module</p>
<pre><code>GHC.Prim</code></pre>
<p>. This module has no implementation, and its interface never resides on disk: if</p>
<pre><code>GHC.Prim</code></pre>
<p>is imported, we use a built-in</p>
<pre><code>ModIface</code></pre>
<p>value - see</p>
<pre><code>ghcPrimIface</code></pre>
<p>in <a href="GhcFile(compiler/iface/LoadIface.hs)" class="uri" title="wikilink">GhcFile(compiler/iface/LoadIface.hs)</a>.</p>
<p>It would also be useful to look at the [wiki:Commentary/Compiler/WiredIn Wired-in and known-key things] wiki page to understand this topic.</p>
<h2 id="the-primops.txt.pp-file">The primops.txt.pp file</h2>
<p>The file <a href="GhcFile(compiler/prelude/primops.txt.pp)" class="uri" title="wikilink">GhcFile(compiler/prelude/primops.txt.pp)</a> includes all the information the compiler needs to know about a PrimOp, bar its actual implementation. For each PrimOp,</p>
<pre><code>primops.txt.pp</code></pre>
<p>lists:</p>
<ul>
<li>Its name, as it appears in Haskell code (eg. int2Integer#)</li>
<li>Its type</li>
<li>The name of its constructor in GHC's
<pre><code>PrimOp</code></pre>
<p>data type.</p></li>
<li>Various properties, such as whether the operation is commutable, or has side effects.</li>
</ul>
<p>For example, here's the integer multiplication PrimOp:</p>
<pre><code>primop   IntegerMulOp   &quot;timesInteger#&quot; GenPrimOp   
   Int# -&gt; ByteArr# -&gt; Int# -&gt; ByteArr# -&gt; (# Int#, ByteArr# #)
   with commutable = True
        out_of_line = True</code></pre>
<p>The</p>
<pre><code>primops.txt.pp</code></pre>
<p>file is processed first by CPP, and then by the</p>
<pre><code>genprimopcode</code></pre>
<p>program (see <a href="GhcFile(utils/genprimopcode)" class="uri" title="wikilink">GhcFile(utils/genprimopcode)</a>).</p>
<pre><code>genprimopcode</code></pre>
<p>generates the following bits from</p>
<pre><code>primops.txt.pp</code></pre>
<dl>

<dd>
</dd>
</dl>
<ul>
<li>Various files that are
<pre><code>#include</code></pre>
<p>d into <a href="GhcFile(compiler/prelude/PrimOp.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/PrimOp.hs)</a>,</p></li>
</ul>
<p><code>  containing declarations of data types and functions describing the PrimOps.  See</code><br />
<code>  </code><a href="GhcFile(compiler/Makefile)" title="wikilink"><code>GhcFile(compiler/Makefile)</code></a><code>.</code></p>
<ul>
<li><pre><code>libraries/base/GHC/PrimopWrappers.hs</code></pre>
<p>, a file that contains (curried) wrapper</p></li>
</ul>
<p><code>  functions for each of the PrimOps, so that they are accessible from byte-code, and</code><br />
<code>  so that the [wiki:Commentary/Rts/Interpreter byte-code interpreter] doesn't need to implement any PrimOps at all: it</code><br />
<code>  just invokes the compiled ones from </code></p>
<pre><code>GHC.PrimopWrappers</code></pre>
<p>.</p>
<ul>
<li><pre><code>libraries/base/GHC/Prim.hs</code></pre>
<p>, a source file containing dummy declarations for</p></li>
</ul>
<p><code>  all the PrimOps, solely so that Haddock can include documentation for </code></p>
<pre><code>GHC.Prim</code></pre>
<p><code>  in its documentation for the </code></p>
<pre><code>base</code></pre>
<p>package. The file</p>
<pre><code>GHC/Prim.hs</code></pre>
<p>is never</p>
<p><code>  actually compiled, only processed by Haddock.</code></p>
<p>Note that if you want to create a polymorphic primop, you need to return</p>
<pre><code>(# a #)</code></pre>
<p>, not</p>
<pre><code>a</code></pre>
<p>.</p>
<h2 id="implementation-of-primops">Implementation of PrimOps</h2>
<p>PrimOps are divided into two categories for the purposes of implementation: inline and out-of-line.</p>
<h3 id="inline-primops">Inline PrimOps</h3>
<p>Inline PrimOps are operations that can be compiled into a short sequence of code that never needs to allocate, block, or return to the scheduler for any reason. An inline PrimOp is compiled directly into [wiki:Commentary/Rts/Cmm Cmm] by the [wiki:Commentary/Compiler/CodeGen code generator]. The code for doing this is in <a href="GhcFile(compiler/codeGen/StgCmmPrim.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmPrim.hs)</a>.</p>
<h3 id="out-of-line-primops">Out-of-line PrimOps</h3>
<p>All other PrimOps are classified as out-of-line, and are implemented by hand-written C-- code in the file <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a>. An out-of-line PrimOp is like a Haskell function, except that</p>
<ul>
<li>PrimOps cannot be partially applied. Calls to all PrimOps are made at the correct arity; this is ensured by</li>
</ul>
<p><code>  the [wiki:Commentary/Compiler/HscMain CorePrep] pass.</code></p>
<ul>
<li>Out-of-line PrimOps have a special, fixed, [wiki:Commentary/Rts/HaskellExecution#CallingConvention calling convention]:</li>
</ul>
<p><code>  all arguments</code><br />
<code>  are in the [wiki:Commentary/Rts/HaskellExecution#Registers registers] R1-R8.  This is to make it easy to write the</code><br />
<code>  C-- code for these PrimOps: we don't have to write code for multiple calling conventions.</code></p>
<p>It's possible to provide inline versions of out-of-line PimOps. This is useful when we have enough static information to generated a short, more efficient inline version. For example, a call to</p>
<pre><code>newArray# 8# init</code></pre>
<p>can be implemented more efficiently as an inline PrimOp as the heap check for the array allocation can be combined with the heap check for the surrounding code. See</p>
<pre><code>shouldInlinePrimOp</code></pre>
<p>in <a href="GhcFile(compiler/codeGen/StgCmmPrim.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmPrim.hs)</a>.</p>
<p>=== Foreign out-of-line PrimOps and</p>
<pre><code>foreign import prim</code></pre>
<p>===</p>
<p>A new and somewhat more flexible form of out-of-line PrimOp is the foreign out-of-line PrimOp. These are essentially the same but instead of their Cmm code being included in the RTS, they can be defined in Cmm code in any package and instead of knowledge of the PrimOp being baked into the compiler, they can be imported using special FFI syntax:</p>
<pre><code>foreign import prim &quot;int2Integerzh&quot;
  int2Integer# :: Int# -&gt; (# Int#, ByteArray# #)</code></pre>
<p>The string (e.g. &quot;int2Integerzh&quot;) is the linker name of the Cmm function. Using this syntax requires the extensions</p>
<pre><code>ForeignFunctionInterface`, `GHCForeignImportPrim`, `MagicHash`, `UnboxedTuples` and `UnliftedFFITypes`. The current type restriction is that all arguments and results must be unlifted types, with two additional possibilities: An argument may (since GHC 7.5) be of type `Any</code></pre>
<p>(in which case the called function will receive a pointer to the heap), and the result type is allowed to be an unboxed tuple. The calling convention is exactly the same as for ordinary out-of-line primops. Currently it is not possible to specify any of the PrimOp attributes.</p>
<p>The</p>
<pre><code>integer-gmp</code></pre>
<p>package now uses this method for all the primops that deal with GMP big integer values. The advantage of using this technique is that it is a bit more modular. The RTS does not need to include all the primops. For example in the integer case the RTS no longer needs to link against the GMP C library.</p>
<p>The future direction is to extend this syntax to allow PrimOp attributes to be specified. The calling convention for primops and ordinary compiled Haskell functions may be unified in future and at that time it the restriction on using only unlifted types may be lifted.</p>
<p>It has been suggested that we extend this PrimOp definition and import method to cover all PrimOps, even inline ones. This would replace the current</p>
<pre><code>primops.txt.pp` system of builtin &lt;nowiki&gt;PrimOps.&lt;/nowiki&gt; The inline &lt;nowiki&gt;PrimOps&lt;/nowiki&gt; would still be defined in the compiler but they would be imported in any module via `foreign import prim` rather than appearing magically to be exported from the `GHC.Prim` module. Hugs has used a similar system for years (with the syntax `primitive seq :: a -&gt; b -&gt; b</code></pre>
<p>).</p>
<h2 id="adding-a-new-primop">Adding a new PrimOp</h2>
<p>To add a new primop, you currently need to update the following files:</p>
<ul>
<li><a href="GhcFile(compiler/prelude/primops.txt.pp)" class="uri" title="wikilink">GhcFile(compiler/prelude/primops.txt.pp)</a>, which includes the</li>
</ul>
<p><code>  type of the primop, and various other properties.  Syntax and</code><br />
<code>  examples are in the file.</code></p>
<ul>
<li>if the primop is inline, then:</li>
</ul>
<p><code>  </code><a href="GhcFile(compiler/codeGen/StgCmmPrim.hs)" title="wikilink"><code>GhcFile(compiler/codeGen/StgCmmPrim.hs)</code></a><code> defines the translation of</code><br />
<code>  the primop into </code></p>
<pre><code>Cmm</code></pre>
<p>.</p>
<ul>
<li>for an out-of-line primop:
<ul>
<li><a href="GhcFile(includes/stg/MiscClosures.h)" class="uri" title="wikilink">GhcFile(includes/stg/MiscClosures.h)</a> (just add the declaration),</li>
<li><a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a> (implement it here)</li>
<li><a href="GhcFile(rts/Linker.c)" class="uri" title="wikilink">GhcFile(rts/Linker.c)</a> (declare the symbol for GHCi)</li>
</ul></li>
</ul>
<ul>
<li>for a foreign out-of-line primop You do not need to modify the rts or compiler at all.
<ul>
<li><pre><code>yourpackage/cbits/primops.cmm</code></pre>
<dl>

<dd>implement your primops here. You have to arrange for the .cmm file to be compiled and linked into the package. The GHC build system has support for this. Cabal does not yet.
</dd>
</dl></li>
<li><pre><code>yourpackage/TheCode.hs`: use `foreign import prim</code></pre>
<p>to import the primops.</p></li>
</ul></li>
</ul>
<p>In addition, if new primtypes are being added, the following files need to be updated:</p>
<ul>
<li><a href="GhcFile(utils/genprimopcode/Main.hs)" class="uri" title="wikilink">GhcFile(utils/genprimopcode/Main.hs)</a> -- extend ppType :: Type -&gt; String function</li>
</ul>
<ul>
<li><a href="GhcFile(compiler/prelude/PrelNames.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/PrelNames.hs)</a> -- add a new unique id using mkPreludeTyConUnique</li>
</ul>
<ul>
<li><a href="GhcFile(compiler/prelude/TysPrim.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/TysPrim.hs)</a> -- there are a raft of changes here; you need to create
<pre><code>*PrimTy</code></pre>
<p>,</p>
<pre><code>*PrimTyCon</code></pre>
<p>and</p>
<pre><code>*PrimTyConName</code></pre>
<p>variables. The most important thing to make sure you get right is when you make a PrimTyCon, you pick the correct</p>
<pre><code>PrimRep</code></pre>
<p>for your type. For example, if you</p></li>
</ul>
<h1 id="profiling">Profiling</h1>
<p>GHC includes two types of profiling: cost-centre profiling and ticky-ticky profiling. Additionally, HPC code coverage is not &quot;technically&quot; profiling, but it uses a lot of the same mechanisms as cost-centre profiling (you can read more about it at [wiki:Commentary/Hpc]).</p>
<p>Cost-centre profiling operates at something close to the source level, and ticky-ticky profiling operates at something much closer to the machine level. This means that the two types of profiling are useful for different tasks. Ticky-ticky profiling is mainly meant for compiler implementors, and cost-centre profiling for mortals. However, because cost-centre profiling operates at a high level, it can be difficult (if not impossible) to use it to profile optimized code. Personally, I (Kirsten) have had a lot of success using cost-centre profiling to find problems that were due to my own bad algorithms, but less success once I was fairly sure that I wasn't doing anything obviously stupid and was trying to figure out why my code didn't get optimized as well as it could have been.</p>
<p>You can't use cost-centre profiling and ticky-ticky profiling at the same time; in the past, this was because ticky-ticky profiling relied on a different closure layout, but now that's no longer the case. You probably can't use both at the same time as it is unless you wanted to modify the build system to allow using way=p and way=t at the same time to build the RTS. I haven't thought about whether it would make sense to use both at the same time.</p>
<h2 id="cost-centre-profiling">Cost-centre profiling</h2>
<p>Cost-center profiling in GHC, e.g. of SCCs, consists of the following components:</p>
<ul>
<li>Data-structures for representing cost-centres in <a href="GhcFile(compiler/profiling/CostCentre.lhs)" class="uri" title="wikilink">GhcFile(compiler/profiling/CostCentre.lhs)</a>.</li>
<li>Front-end support in <a href="GhcFile(compiler/deSugar/DsExpr.lhs)" class="uri" title="wikilink">GhcFile(compiler/deSugar/DsExpr.lhs)</a>, for converting
<pre><code>SCC</code></pre>
<p>pragma into the</p>
<pre><code>Tick</code></pre>
<p>constructor in Core.</p></li>
<li>Modifications to optimization behavior in <a href="GhcFile(compiler/coreSyn/CoreUtils.lhs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CoreUtils.lhs)</a> and <a href="GhcFile(compiler/coreSyn/CorePrep.lhs)" class="uri" title="wikilink">GhcFile(compiler/coreSyn/CorePrep.lhs)</a> to prevent optimizations which would result in misleading profile information. Most of this is to handle the fact that SCCs also count entries (tickishCounts, also applies to [wiki:Commentary/Hpc]); otherwise the only relevant optimization is avoiding floating expressions out of SCCs. Note that the simplifier also has &quot;ticks&quot; (so it can decide when to stop optimizing); these are not the same thing at all.</li>
<li>The
<pre><code>StgSCC</code></pre>
<p>constructor in STG, and code generation for it <a href="GhcFile(compiler/codeGen/StgCmmProf.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmProf.hs)</a></p></li>
<li>A pass over STG in <a href="GhcFile(compiler/profiling/SCCfinal.lhs)" class="uri" title="wikilink">GhcFile(compiler/profiling/SCCfinal.lhs)</a> to collect cost centres so that they can be statically declared by <a href="GhcFile(compiler/profiling/ProfInit.hs)" class="uri" title="wikilink">GhcFile(compiler/profiling/ProfInit.hs)</a>, and add extra SCCs in the case of
<pre><code>-fprof-auto</code></pre>
<dl>
<dt>see also <a href="GhcFile(compiler/profiling/NOTES)" class="uri" title="wikilink">GhcFile(compiler/profiling/NOTES)</a></dt>

</dl></li>
<li>Code-generation for setting labels found in <a href="GhcFile(compiler/codeGen/StgCmmProf.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmProf.hs)</a>, in particular saving and restoring CC labels and well as counting ticks; note that cost-centres even get their own constructor in C-- as CC_Labels (cost-centre labels).</li>
<li>Runtime support for initializing and manipulating the actual runtime
<pre><code>CostCentre</code></pre>
<p>structs which store information, in <a href="GhcFile(rts/Profiling.c)" class="uri" title="wikilink">GhcFile(rts/Profiling.c)</a>; headers are located in <a href="GhcFile(includes/rts/prof/CCS.h)" class="uri" title="wikilink">GhcFile(includes/rts/prof/CCS.h)</a></p></li>
</ul>
<h2 id="ticky-ticky-profiling">Ticky-ticky profiling</h2>
<p>Ticky-ticky profiling is very simple (conceptually): instrument the C code generated by GHC with a lot of extra code that updates counters when various (supposedly) interesting things happen, and generate a report giving the values of the counters when your program terminates. GHC does this instrumentation for you when you compile your program with a special flag. Then, you use another flag to tell the RTS to generate the profiling report.</p>
<p>You might want to use ticky-ticky profiling for one of the following two reasons:</p>
<ul>
<li>You are an implementor trying to understand the effect of an optimization in GHC more precisely.</li>
</ul>
<ul>
<li>You are a user trying to observe the behavior of your programs with optimization turned on. GHC doesn't do certain transformations in the presence of cost centres, so cost-centre profiling can be less than accurate if you're trying to understand what really happens when you're compiling with
<pre><code>-O</code></pre>
<p>.</p></li>
</ul>
<p>I won't necessarily try to argue that ticky-ticky is useful at all for the second group of people, but it's better than nothing, and perhaps the ticky-ticky data could be used to build a better profiler.</p>
<p>For more info, including HOWTO details, see [wiki:Debugging/TickyTicky].</p>
<p>like &quot;computer is a net&quot;, nowadays language is a library. there is nothing exceptional in C++ and Java languages except for their huge library codebase that makes them so widely appreciated</p>
<p>while it's impossible for Haskell to have the same level of libraries maturity, we can try to do our best. Libraries was considered so important, that in H98 report libs required more pages than language itself. But, really, all libraries described there together is appropriate only for learning and small programs - to do real work, we need even much, much more</p>
<p>fortunately, now we have large enough set of libs. moreover, this set grows each year. but these libs don't have official/recommended status. now we have two languages - H98 as reported with its bare libs, which is appropriate only for teaching, and real Haskell language with many extensions and rich set of libs, used to develop real programs</p>
<p>with a language itself, now we go to standardize current practice and include into language definition all popular extensions. this will close the gap between standard and practice. Haskell' committee also plan to define new version of standard Haskell library. but what a library can be defined in this way? slightly extended version of standard Haskell98 lib? or, if it will be significantly extended - how much time this work will require and isn't that a duplication of work done at libraries list?</p>
<p>i propose not to try to define reality, but accept existing one and join committee's work on new library definition with a current discussion of core libraries, which should define a set of libs available on any Haskell compiler on any platform - aren't goals the same?</p>
<p>instead of providing rather small and meaningless standard Haskell library, now we can just include in Report docs existing and widely used libs, such as Network, mtl and so on. This will mean that language, defined in Haskell standard, can be used to write real programs, which will be guaranteed to run in any Haskell environment.</p>
<p>of course, this mind game can't change anything in one moment. but it will change *accents*</p>
<p>first, Haskell with its libraries will become language for a real work. such extended language isn't small nor easy to master in full, but it is normal for any mature programming environment. people learning Haskell should select in which area they need to specialize - be it gaming or web service development, and study appropriate subset of libs. people teaching Haskell now can show how *standard* Haskell may be used to solve real world problems, and this should change treatment of Haskell as academic language. also, we may expect that books teaching Haskell will start to teach on using standard libs, while their authors now don't consider teaching for non-standard libs</p>
<p>second, by declaring these libs as standard ones we create sort of lingua franca, common language spoken by all Haskell users. for example, now there are about 10 serialization libs. by declaring one of them as standard, we will make choice simpler for most of users (who don't need very specific features) and allow them to speak in common language. in other words, number of Haskell libs is so large now that we should define some core subset in order to escape syndrome of Babel tower. defining core libraries set is just sharing knowledge that some libraries are more portable, easier to use, faster and so on, so they become more popular than alternatives in this area</p>
<p>third. now we have Cabal that automates installation of any lib. next year we will got Hackage that automates downloading and checking dependencies. but these tools still can't replace a rich set of standard libs shipped with compiler. there are still many places and social situations where Internet downloading isn't available. Compiler can be sold on CD, transferred on USB stick. and separate Haskell libs probably will be not included here. Standard libraries bundled with compiler will ensure that at least this set of libs will be available for any haskell installation. Internet access shouldn't be a precondition for Haskell usage! :)</p>
<p>fourth. now there is tendency to write ghc-specific libs. by defining requirements to the standard libs we may facilitate development of more portable, well documented and quick-checked ones. or may be some good enough libraries will be passed to society which will &quot;polish&quot; them in order to include in the set. anyway, i hope that *extensible* set of standard libraries with a published requirements to such libs would facilitate &quot;polishing&quot; of all Haskell libs just because ;)</p>
<p>and this leads us to other question - whether this set and API of each library should be fixed in language standard or it can evolve during the time?...</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<p>=</p>
<pre><code>RdrNames</code></pre>
<p>,</p>
<pre><code>Modules</code></pre>
<p>, and</p>
<pre><code>OccNames</code></pre>
<p>=</p>
<p>When the parser parses an identifier, it generates a</p>
<pre><code>RdrName</code></pre>
<p>. A</p>
<pre><code>RdrName</code></pre>
<p>is pretty much just a string, or a pair of strings, for a qualified name, such as</p>
<pre><code>M.x</code></pre>
<p>. Here's the data type declaration, from <a href="GhcFile(compiler/basicTypes/RdrName.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/RdrName.hs)</a>:</p>
<pre><code>data RdrName 
  = Unqual OccName
    -- Used for ordinary, unqualified occurrences 

  | Qual ModuleName OccName
    -- A qualified name written by the user in 
    --  *source* code.  The module isn&#39;t necessarily 
    -- the module where the thing is defined; 
    -- just the one from which it is imported

  | Orig Module OccName
    -- An original name; the module is the *defining* module.
    -- This is used when GHC generates code that will be fed
    -- into the renamer (e.g. from deriving clauses), but where
    -- we want to say &quot;Use Prelude.map dammit&quot;.  
 
  | Exact Name
    -- We know exactly the Name. This is used 
    --  (a) when the parser parses built-in syntax like &quot;[]&quot; 
    --  and &quot;(,)&quot;, but wants a RdrName from it
    --  (b) by Template Haskell, when TH has generated a unique name</code></pre>
<p>User-written code never gets translated into the last two alternatives. They are used only internally by the compiler. For example, code generated by</p>
<pre><code>deriving</code></pre>
<p>might use an</p>
<pre><code>Orig</code></pre>
<p>to refer to</p>
<pre><code>Prelude.map</code></pre>
<p>, ignoring whatever</p>
<pre><code>map</code></pre>
<p>might happen to be in scope (dammit).</p>
<p>== The</p>
<pre><code>Module` and `ModuleName</code></pre>
<p>types ==</p>
<p>In GHC, a <em>module</em> is uniquely defined by a pair of the module name and the package where the module is defined. The details are in <a href="GhcFile(compiler/basicTypes/Module.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Module.hs)</a> and <a href="GhcFile(compiler/main/PackageConfig.hs)" class="uri" title="wikilink">GhcFile(compiler/main/PackageConfig.hs)</a>, but here are the key definitions:</p>
<pre><code>newtype PackageId = PId FastString

newtype ModuleName = ModuleName FastString

data Module = Module {
   modulePackageId :: &lt;nowiki&gt;PackageId,&lt;/nowiki&gt;  -- pkg-1.0
   moduleName      :: &lt;nowiki&gt;ModuleName&lt;/nowiki&gt;  -- A.B.C  }</code></pre>
<p>You'll notice that a</p>
<pre><code>Qual` `RdrName` contains a `ModuleName`; which module is referred to depends on the import declarations in that module.  In contrast, a `Orig` `RdrName` refers to a unique `Module</code></pre>
<p>.</p>
<p>== The</p>
<pre><code>OccName</code></pre>
<p>type ==</p>
<p>An</p>
<pre><code>OccName</code></pre>
<p>is more-or-less just a string, like &quot;foo&quot; or &quot;Tree&quot;, giving the (unqualified) name of an entity. Well, not quite just a string, because in Haskell a name like &quot;C&quot; could mean a type constructor or data constructor, depending on context. So GHC defines a type</p>
<pre><code>OccName</code></pre>
<p>that is a pair of a</p>
<pre><code>FastString</code></pre>
<p>and a</p>
<pre><code>NameSpace</code></pre>
<p>indicating which name space the name is drawn from. The data type is defined (abstractly) in <a href="GhcFile(compiler/basicTypes/OccName.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/OccName.hs)</a>:</p>
<pre><code>data OccName = OccName 
    { occNameSpace  :: &lt;nowiki&gt;NameSpace&lt;/nowiki&gt;
    , occNameFS     :: &lt;nowiki&gt;FastString&lt;/nowiki&gt;
    }</code></pre>
<p>The name spaces are:</p>
<pre><code>data NameSpace = VarName    -- Variables, including &quot;source&quot; data constructors
           | DataName   -- &quot;Real&quot; data constructors 
           | TvName     -- Type variables
           | TcClsName  -- Type constructors and classes; Haskell has them
                -- in the same name space for now.</code></pre>
<p>Attaching the names to their name spaces makes it very convenient to build mappings from names to things; where such a mapping might contain two strings that are identical, they can be distinguished by the name space, so when mapping</p>
<pre><code>OccName</code></pre>
<p>s, a single map suffices.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="recompilation-avoidance">Recompilation Avoidance</h1>
<h2 id="what-is-recompilation-avoidance">What is recompilation avoidance?</h2>
<p>When GHC is compiling a module, it tries to determine early on whether</p>
<ul>
<li>The object file (or byte-code in the case of GHCi) and [wiki:Commentary/Compiler/IfaceFiles interface file] exist from a previous compilation</li>
<li>Recompilation is sure to produce exactly the same results, so it</li>
</ul>
<p><code>  is not necessary.</code></p>
<p>If both of these hold, GHC stops compilation early, because the existing object code and interface are still valid. In GHCi and</p>
<pre><code>--make`, we must generate the `ModDetails` from the `ModIface</code></pre>
<p>, but this is easily done by calling</p>
<pre><code>MkIface.typecheckIface</code></pre>
<p>.</p>
<h2 id="example-2">Example</h2>
<p>Let's use a running example to demonstrate the issues. We'll have four modules with dependencies like this:</p>
<pre><code>      A
     / \
    B   C
     \ /
      D</code></pre>
<pre><code>A.hs</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>module A where
import B
import C

a = print (f 2)</code></pre>
<pre><code>B.hs</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>module B (f) where
import D</code></pre>
<pre><code>C.hs</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>module C where
import D</code></pre>
<pre><code>D.hs</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>module D (T, f, h) where

data T a b = C1 a | C2 b

f :: Int -&gt; Int
f x = h x

h :: Int -&gt; Int
h x = x + 3</code></pre>
<h2 id="why-do-we-need-recompilation-avoidance">Why do we need recompilation avoidance?</h2>
<p>=== GHCi and</p>
<pre><code>--make</code></pre>
<p>===</p>
<p>The simple fact is that when you make a small change to a large program, it is often not necessary to recompile every module that depends directly or indirectly on something that changed. In GHCi and</p>
<pre><code>--make</code></pre>
<p>, GHC considers every module in the program in dependency order, and decides whether it needs to be recompiled, or whether the existing object code and interface will do.</p>
<p>===</p>
<pre><code>make</code></pre>
<p>===</p>
<pre><code>make</code></pre>
<p>works by checking the timestamps on dependencies and recompiling things when the dependencies are newer. Dependency lists for</p>
<pre><code>make` look like this (generated by `ghc -M</code></pre>
<p>):</p>
<pre><code># DO NOT DELETE: Beginning of Haskell dependencies
D.o : D.hs
B.o : B.hs
B.o : D.hi
C.o : C.hs
C.o : D.hi
A.o : A.hs
A.o : C.hi
A.o : B.hi
# DO NOT DELETE: End of Haskell dependencies</code></pre>
<p>Only the</p>
<pre><code>.hi</code></pre>
<p>files of the <em>direct imports</em> of a module are listed. For example,</p>
<pre><code>A.o` depends on `C.hi` and `B.hi`, but not `D.hi</code></pre>
<p>. Nevertheless, if D is modified, we might need to recompile A. How does this happen?</p>
<ul>
<li>first, make will recompile D because its source file has changed,</li>
</ul>
<p><code>   generating a new </code></p>
<pre><code>D.o` and `D.hi</code></pre>
<p>.</p>
<ul>
<li>If after recompiling D, we notice that its interface is the same</li>
</ul>
<p><code>   as before, there is no need to modify the </code></p>
<pre><code>.hi` file.  If the `.hi</code></pre>
<p><code>   file is not modified by the compilation, then </code></p>
<pre><code>make</code></pre>
<p>will notice</p>
<p><code>   and not recompile </code></p>
<pre><code>B` or `C`, or indeed `A</code></pre>
<p>. This is an important</p>
<p><code>   optimisation.</code></p>
<ul>
<li>Suppose the change to
<pre><code>D</code></pre>
<p>did cause a change in the interface</p></li>
</ul>
<p><code>   (e.g. the type of </code></p>
<pre><code>f` changed).  Now, `make</code></pre>
<p>will recompile both</p>
<pre><code>B` and `C`.  Suppose that the interfaces to `B` and `C</code></pre>
<p><code>   remain the same: B's interface says only that it re-exports </code></p>
<pre><code>D.f</code></pre>
<p>,</p>
<p><code>   so the fact that </code></p>
<pre><code>f` has a new type does not affect `B</code></pre>
<p>'s</p>
<p><code>   interface.  </code></p>
<ul>
<li>Now,
<pre><code>A`&#39;s dependencies are unchanged, so `A</code></pre>
<p>will not be</p></li>
</ul>
<p><code>   recompiled.  But this is wrong: </code></p>
<pre><code>A</code></pre>
<p>might depend on something from</p>
<pre><code>D` that was re-exported via `B` or `C</code></pre>
<p>, and therefore need</p>
<p><code>   recompiling.</code></p>
<p>To ensure that</p>
<pre><code>A</code></pre>
<p>is recompiled, we therefore have two options:</p>
<ol>
<li>arrange that make knows about the dependency of A on D.</li>
</ol>
<ol>
<li><ol>
<li>arrange to touch
<pre><code>B.hi` and `C.hi</code></pre>
<p>even if they haven't changed.</p></li>
</ol></li>
</ol>
<p>GHC currently does (2), more about that in a minute.</p>
<p>Why not do (1)? Well, then <em>every</em> time</p>
<pre><code>D.hi</code></pre>
<p>changed, GHC would be invoked on</p>
<pre><code>A` again.  But `A` doesn&#39;t depend directly on `D</code></pre>
<dl>

<dd>it
</dd>
</dl>
<p>imports</p>
<pre><code>B`, and it might be therefore be insensitive to changes in `D</code></pre>
<p>. By telling make only about direct dependencies, we gain the ability to avoid recompiling modules further up the dependency graph, by not touching interface files when they don't change.</p>
<p>Back to (2). In addition to correctness (recompile when necessary), we also want to avoid unnecessary recompilation as far as possible. Make only knows about very coarse-grained dependencies. For example, it doesn't know that changing the type of</p>
<pre><code>D.f</code></pre>
<p>can have no effect on</p>
<pre><code>C`, so `C</code></pre>
<p>does not in fact need to be recompiled, because to do so would generate exactly the same</p>
<pre><code>.o` and `.hi</code></pre>
<p>files as last time. GHC does have enough information to figure this out, so when GHC is asked to recompile a module it invokes the <em>recompilation checker</em> to determine whether recompilation can be avoided in this case.</p>
<h2 id="how-does-it-work">How does it work?</h2>
<p>We use <a href="http://en.wikipedia.org/wiki/Fingerprint_%28computing%29">fingerprints</a> to uniquely identify the interface exposed by a module, and to detect when it changes. In particular, we currently use 128-bit hashes produced by the MD5 algorithm (see <a href="GhcFile(compiler/utils/Fingerprint.hsc)" class="uri" title="wikilink">GhcFile(compiler/utils/Fingerprint.hsc)</a>).</p>
<p>An [wiki:Commentary/Compiler/IfaceFiles interface file] contains:</p>
<ul>
<li>Various fingerprints:
<ul>
<li>The <em>interface hash</em>, which depends on the entire contents of the</li>
</ul></li>
</ul>
<p><code>    interface file.  This is used to detect whether we should</code><br />
<code>    update the interface on disk after recompiling the module.  If the</code><br />
<code>    interface didn't change at all, then we don't want to touch the</code><br />
<code>    on-disk version because that would cause </code></p>
<pre><code>make</code></pre>
<p>to perform more</p>
<p><code>    compilations.</code></p>
<ul>
<li>The <em>ABI hash</em>, which depends on everything that the module</li>
</ul>
<p><code>    exposes about its implementation: think of this as a hash of</code><br />
<code>    </code><em><code>export-list</code> <code>hash</code></em><code> and </code><em><code>decls</code></em><code>.</code></p>
<ul>
<li>The <em>export-list hash</em>, which depends on
<ul>
<li>The export list itself. The export-list hash only depends on the <em>names</em> of the exports for the modules. The <em>types</em> of these exports are ignored in calculating the hash. Only a change of name or removal or addition of an export will change the hash. Not a type change of definition change.</li>
<li>the <em>orphan hash</em>, which depends on all the orphan instances/rules in the, and the orphan hashes of all orphan modules below this module in the dependency tree (see [#Orphans Orphans]).</li>
<li>the package dependencies (see [#Packageversionchanges Package Version Changes]).</li>
</ul></li>
<li><em>exports</em>: what the module exports</li>
<li><em>dependencies</em>: modules and packages that this module depends on</li>
<li><em>usages</em>: what specific entities the module depends on</li>
<li><em>decls</em>: what the module defines</li>
<li>various other stuff, but the above are the important bits</li>
</ul>
<p>To look at the contents of an interface, use</p>
<pre><code>ghc --show-iface</code></pre>
<p>. For example, here's the output of</p>
<pre><code>ghc --show-iface D.hi</code></pre>
<p>for the module</p>
<pre><code>D</code></pre>
<p>in our example:</p>
<pre><code>interface main:D 6090
  interface hash: 413dacc4c360257e9fb06ad0c13d9fc9
  ABI hash: 0c5278c6f22844f996006259c9f551c8
  export-list hash: cb9dd0d414976d16451bdfe51a021d7d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  where
export main:D T f h
module dependencies:
package dependencies: base integer ghc-prim
orphans: base:GHC.Base base:GHC.Num
family instance modules:
import base:GHC.Num 7a6f0c12ee2413f4c07165103924bd61
import base:Prelude ae91aa1798ed1ac514cde3dc4c921717
f4be8645a3e4099b4be0cfc42e976ed7
  data T a b
      RecFlag NonRecursive
      Generics: no
      {- abstract -}
      FamilyInstance: none
0bf838776ef3bc5671e369aec15c3b16
  f :: GHC.Base.Int -&gt; GHC.Base.Int
aa9b8cdef43b6852bcc6f61f6ad6c584
  h :: GHC.Base.Int -&gt; GHC.Base.Int</code></pre>
<p>Lines beginning</p>
<pre><code>import</code></pre>
<p>are the <em>usages</em>, and after the usages are the decls.</p>
<h3 id="deciding-whether-to-recompile">Deciding whether to recompile</h3>
<p>If we already have an object file and interface file for a module, we might not have to recompile it, if we can be sure the results will be the same as last time.</p>
<ul>
<li>If the source file has changed since the object file was created,</li>
</ul>
<p><code>  we better recompile.</code></p>
<ul>
<li>If anything else has changed in a way that would affect the results</li>
</ul>
<p><code>  of compiling this module, we must recompile.</code></p>
<p>In order to determine the second point, we look at the <em>dependencies</em> and <em>usages</em> fields of the old interface file. The dependencies contains:</p>
<ul>
<li><em>dep_mods</em>: Transitive closure of home-package modules that are</li>
</ul>
<p><code>  imported by this module.  That is, all modules below the current</code><br />
<code>  one in the dependency graph.</code></p>
<ul>
<li><em>dep_pkgs</em>: Transitive closure of packages depended on by this</li>
</ul>
<p><code>  module, or by any module in </code><em><code>dep_mods</code></em><code>.</code></p>
<ul>
<li>other less important stuff.</li>
</ul>
<p>First, the direct imports of the current module are resolved to</p>
<pre><code>Module`s using `Finder.findModule` (a `Module</code></pre>
<p>contains a module name and a package identifier). If any of those</p>
<pre><code>Module</code></pre>
<p>s are not listed amongst the dependencies of the old interface file, then either:</p>
<ul>
<li>an exposed package has been upgraded</li>
<li>we are compiling with different package flags</li>
<li>a home module that was shadowing a package module has been removed</li>
<li>a new home module has been added that shadows a package module</li>
</ul>
<p>and we must recompile.</p>
<p>Second, the <em>usages</em> of the module are checked. The usages contains two types of information:</p>
<ul>
<li>for a module that was imported, the export-list fingerprint of the</li>
</ul>
<p><code>  imported module is recorded.  If any of the modules we imported now</code><br />
<code>  has a different export list we must recompile, so we check the</code><br />
<code>  current export-list fingerprints against those recorded in the</code><br />
<code>  usages.</code></p>
<ul>
<li>for every external name mentioned in the source code, the</li>
</ul>
<p><code>  fingerprint of that name is recorded in the usages.  This is so</code><br />
<code>  that if we mention for example an external function </code></p>
<pre><code>M.f</code></pre>
<p>, we'll</p>
<p><code>  recompile if </code></p>
<pre><code>M.f</code></pre>
<p>'s type has changed, or anything referred to</p>
<p><code>  by </code></p>
<pre><code>M.f`&#39;s type has changed, or `M.f</code></pre>
<p>'s unfolding has changed</p>
<p><code>  (when -O is on), and so on.</code></p>
<p>The interface files for everything in the usages are read (they'll already be in memory if we're doing</p>
<pre><code>--make</code></pre>
<p>), and the current versions for each of these entities checked against the usages from the old interface file. If any of these versions has changed, the module must be recompiled.</p>
<h3 id="example-3">Example</h3>
<p>There are some tricky cases to consider.</p>
<p>Suppose we change the definition of</p>
<pre><code>D.f</code></pre>
<p>in the example, and make it</p>
<pre><code>f x = h x + 1</code></pre>
<p>Now, ultimately we need to recompile</p>
<pre><code>A</code></pre>
<p>, because it might be using an inlined copy of the old</p>
<pre><code>D.f`, which it got via `B</code></pre>
<p>.</p>
<p>It works like this:</p>
<ul>
<li><pre><code>D` is recompiled; the fingerprint of `D.f</code></pre>
<p>changes</p></li>
<li><pre><code>B` is considered; it recorded a usage on the old `D.f</code></pre>
<p>, so</p></li>
</ul>
<p><code>  gets recompiled, and now its interface records a usage on the new </code></p>
<pre><code>D.f</code></pre>
<ul>
<li><pre><code>C</code></pre>
<p>is considered; it doesn't need to be recompiled.</p></li>
<li><pre><code>A` is considered (if we&#39;re using make, this is because `B.hi</code></pre></li>
</ul>
<p><code>  changed); it recorded a usage on the old </code></p>
<pre><code>D.f</code></pre>
<p>, and so gets</p>
<p><code>  recompiled.</code></p>
<p>Now a slightly more tricky case: suppose we add an INLINE pragma to</p>
<pre><code>D.f` (this is a trick to prevent GHC from inlining `D.h</code></pre>
<p>, so that we can demonstrate dependencies between unfoldings). The code for D.hs is now</p>
<pre><code>{-# INLINE f #-}
f :: Int -&gt; Int
f x = h x + 1

h :: Int -&gt; Int
h x = x + 3</code></pre>
<p>Looking at the interface file we can see what happened (snipped slightly):</p>
<pre><code>$ ghc --show-iface D.hi
interface main:D 6090
  interface hash: 0a7e886588b3799d909cca39be4b9232
  ABI hash: 8d5cfe1723f32a5b53ded43bf9a1e55b
  export-list hash: cb9dd0d414976d16451bdfe51a021d7d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  where
export main:D T f h
674f7fa7c2b13b368042f409007b1f29
  data T a b
      RecFlag NonRecursive
      Generics: no
      = C1 :: forall a b. a -&gt; T a b Stricts: _ |
        C2 :: forall a b. b -&gt; T a b Stricts: _
      FamilyInstance: none
790791c346a0d5965feece84894360a6
  f :: GHC.Base.Int -&gt; GHC.Base.Int
    {- Arity: 1 HasNoCafRefs Strictness: U(L)m
       Unfolding: (__inline_me (\ x :: GHC.Base.Int -&gt;
                                GHC.Base.plusInt (D.h x) (GHC.Base.I# 1))) -}
a0a944e487ebec76031e0672e70bc923
  h :: GHC.Base.Int -&gt; GHC.Base.Int
    {- Arity: 1 HasNoCafRefs Strictness: U(L)m
       Unfolding: (\ x :: GHC.Base.Int -&gt;
                   case @ GHC.Base.Int x of wild { GHC.Base.I# x1 -&gt;
                   GHC.Base.I# (GHC.Prim.+# x1 3) }) -}</code></pre>
<p>Note that the unfolding of</p>
<pre><code>D.f` mentions `D.h</code></pre>
<p>.</p>
<p>Now, let's modify</p>
<pre><code>D.h</code></pre>
<p>, and look at the interface file again:</p>
<pre><code>$ ghc -O --show-iface D.hi
interface main:D 6090
  interface hash: 55385e568aa80955acbd1b7370041890
  ABI hash: accc0413d94e27c90dff8427f4aafe6e
  export-list hash: cb9dd0d414976d16451bdfe51a021d7d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  where
export main:D T f h
674f7fa7c2b13b368042f409007b1f29
  data T a b
      RecFlag NonRecursive
      Generics: no
      = C1 :: forall a b. a -&gt; T a b Stricts: _ |
        C2 :: forall a b. b -&gt; T a b Stricts: _
      FamilyInstance: none
7f2bf159cceae5306ce709db96720f4a
  f :: GHC.Base.Int -&gt; GHC.Base.Int
    {- Arity: 1 HasNoCafRefs Strictness: U(L)m
       Unfolding: (__inline_me (\ x :: GHC.Base.Int -&gt;
                                GHC.Base.plusInt (D.h x) (GHC.Base.I# 1))) -}
5c53713aa59b760e51e6d47173f95b4e
  h :: GHC.Base.Int -&gt; GHC.Base.Int
    {- Arity: 1 HasNoCafRefs Strictness: U(L)m
       Unfolding: (\ x :: GHC.Base.Int -&gt;
                   case @ GHC.Base.Int x of wild { GHC.Base.I# x1 -&gt;
                   GHC.Base.I# (GHC.Prim.+# x1 4) }) -}</code></pre>
<p>The fingerprint for</p>
<pre><code>D.h</code></pre>
<p>has changed, because we changed its definition. The fingerprint for</p>
<pre><code>D.f</code></pre>
<p>has also changed, because it depends on</p>
<pre><code>D.h</code></pre>
<p>. And consequently, the ABI hash has changed, and so has the interface hash (although the export hash and orphan hash are still the same). Note that it is significant that we used '-O' here. If we hadn't used '-O' then a change of a definition doesn't change any of the hashes because of the lack of inlining.</p>
<p>Why did the fingerprint for</p>
<pre><code>D.f</code></pre>
<p>have to change? This is vital, because anything that referred to</p>
<pre><code>D.f</code></pre>
<p>must be recompiled, because it may now see the new unfolding for</p>
<pre><code>D.h</code></pre>
<p>.</p>
<p>So the fingerprint of an entity represents not just the definition of the entity itself, but also the definitions of all the entities reachable from it - its transitive closure. The consequence of this is that when recording usages we only have to record the fingerprints of entities that were referred to directly in the source code, because the transitive nature of the fingerprint means that we'll recompile if anything reachable from these entities changes.</p>
<h3 id="how-does-fingerprinting-work">How does fingerprinting work?</h3>
<p>We calculate fingerprints by serialising the data to be fingerprinted using the</p>
<pre><code>Binary</code></pre>
<p>module, and then running the md5 algorithm over the serlialised data. When the data contains external</p>
<pre><code>Name</code></pre>
<p>s, the serialiser emits the fingerprint of the</p>
<pre><code>Name</code></pre>
<dl>
<dt>this is the way that</dt>

</dl>
<p>the fingerprint of a declaration can be made to depend on the fingerprints of the things it mentions.</p>
<h3 id="mutually-recursive-groups-of-entities">Mutually recursive groups of entities</h3>
<p>When fingerprinting a recursive group of entities, we fingerprint the group as a whole. If any of the definitions changes, the fingerprint of every entity in the group changes.</p>
<h3 id="fixities">Fixities</h3>
<p>We include the fixity of an entity when computing its fingerprint.</p>
<h3 id="instances">Instances</h3>
<p>Instances are tricky in Haskell, because they aren't imported or exported explicitly. Haskell requires that any instance defined in a module directly or indirectly imported by the current module is visible. So how do we track instances for recompilation, such that if a relevant instance is changed, added, or removed anywhere beneath the current module we will trigger a recompilation?</p>
<p>Here's how it works. For each instance we pick a distinguished entity to attach the instance to - possibly the class itself, or a type constructor mentioned in the instance. The entity we pick must be defined in the current module; if there are none to pick, then the instance is an orphan (more about those in the section on Orphans, below).</p>
<p>Having picked the distinguished entity, when fingerprinting that entity we include the instances. For example, consider an instance for class C at type T. Any module that could use this instance must depend (directly or indirectly) on both C and T, so it doesn't matter whether we attach the instance to C or T - either way it will be included in the fingerprint of something that the module depends on. In this way we can be sure that if someone adds a new instance, or removes an existing instance, if the instance is relevant to a module then it will affect the fingerprint of something that the module depends on, and hence will trigger recompilation.</p>
<p>In fact, we don't need to include the instance itself when fingerprinting C or T, it is enough to include the DFun (dictionary function) Id, since the type of this Id includes the form of the instance. Furthermore, we <em>must</em> include the DFun anway, because we must have a dependency on the dictionary and its methods, just in case they are inlined in a client module. A DFun looks something like this:</p>
<pre><code>c3e94597bf9a532e094067b08c216493
  $fEqBool :: GHC.Base.Eq GHC.Bool.Bool
    {- HasNoCafRefs Strictness: m
       Unfolding: (GHC.Base.:DEq @ GHC.Bool.Bool GHC.Base.==2
       GHC.Base.$s$dm/=1)</code></pre>
<p>Making a type or class depend on its instances can cause a lot of recompilation when an instance changes. For example:</p>
<pre><code>module A (T) where
import B (C)
data T = ...
instance C t where ...</code></pre>
<p>now the DFun for the instance</p>
<pre><code>C T` will be attached to `T`, and so `T`&#39;s fingerprint will change when anything about the instance changes, including `C` itself.  So there is now have a dependency of `T` on `C`, which can cause a lot of recompilation whenever `C` changes.  Modules using `T` who do not care about `C</code></pre>
<p>will still be recompiled.</p>
<p>This seems like it would cause a lot of unnecessary recompilation. Indeed, in GHC 7.0.1 and earlier we tried to optimise this case, by breaking the dependency of</p>
<pre><code>T` on `C` and tracking usages of DFuns directly - whenever a DFun was used, the typechecker would record the fact, and a usage on the DFun would be recorded in the interface file.  Unfortunately, there&#39;s a bug in this plan (see #4469).  When we&#39;re using `make</code></pre>
<p>, we only recompile a module when any of the interfaces that it directly imports have changed; but a DFun dependency can refer to any module, not just the directly imported ones. Instead, we have to ensure that if an instance related to a particular type or class has changed, then the fingerprint on either the type or class changes, which is what the current plan does. It would be nice to optimise this in a safe way, and maybe in the future we will be able to do that.</p>
<h3 id="orphans">Orphans</h3>
<p>What if we have no declaration to attach the instance to? Instances with no obvious parent are called <em>orphans</em>, and GHC must read the interface for any module that contains orphan instances below the current module, just in case those instances are relevant when compiling the current module.</p>
<p>Orphans require special treatment in the recompilation checker.</p>
<ul>
<li>Every module has an <em>orphan hash</em>, which is a fingerprint of all</li>
</ul>
<p><code>  the orphan instances (and rules) in the current module.</code></p>
<ul>
<li>The <em>export hash</em> depends on the <em>orphan hash</em> of the current</li>
</ul>
<p><code>  module, and all modules below the current module in the dependency</code><br />
<code>  tree.  This models the fact that all instances defined in modules</code><br />
<code>  below the current module are available to importers of this module.</code></p>
<p>So if we add, delete, or modify an orphan instance, the orphan hash of the current module will change, and so will the export hash of the current module. This will trigger recompilation of modules that import the current module, which will cause their export hashes to change, and so on up the dependency tree.</p>
<p>This means a lot of recompilation, but it is at least safe. The trick is to avoid orphan instances as far as possible, which is why GHC has the warning flag</p>
<pre><code>-fwarn-orphans</code></pre>
<p>.</p>
<h3 id="rules">Rules</h3>
<p>RULEs are treated very much like instances: they are attached to one particular parent declaration, and if a suitable parent cannot be found, they become orphans and are handled in the same way as orphan instances.</p>
<h3 id="on-ordering">On ordering</h3>
<p>When fingerprinting a collection of things, for example the export list, we must be careful to use a canonical ordering for the collection. Otherwise, if we recompile the module without making any changes, we might get a different fingerprint due to accidental reordering of the elements.</p>
<p>Why would we get accidental reordering? GHC relies heavily on &quot;uniques&quot; internally (see <a href="GhcFile(compiler/basicTypes/Unique.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Unique.lhs)</a>): every entity has a unique, and uniques are assigned semi-randomly. Asking for the contents of a</p>
<pre><code>UniqSet` or `UniqFM</code></pre>
<p>will return the elements in order of their uniques, which may vary from run to run of the compiler.</p>
<p>The solution is to sort the elements using a stable ordering, such as lexicographic ordering.</p>
<h3 id="packages">Packages</h3>
<p>We need to record usage information about package modules too, so that we can correctly trigger recompilation if we depend on a package that has changed. But packages change rarely, so it would be wasteful to record detailed usage information for every entity that we use from an external package (imagine recording the fingerprints for</p>
<pre><code>Bool`, `Int</code></pre>
<p>, etc.). Instead, we simply record the ABI fingerprint for every package module that was imported by the current module. That way, if anything about the ABI of that package module has changed, then we can trigger a recompilation.</p>
<p>(Correctly triggering recompilation when packages change was one of the things we fixed when implementing fingerprints, see #1372).</p>
<h3 id="package-version-changes">Package version changes</h3>
<p>If the version of a package is bumped, what forces recompilation of the things that depend on it?</p>
<ol>
<li>If a module from the package is imported directly, then we will notice that the imported module is not amongst the dependencies of the module when it was compiled last, and force a recompilation (see [#Decidingwhethertorecompile Deciding whether to recompile]).</li>
</ol>
<ol>
<li><ol>
<li>If a module from the old package is imported indirectly, then the old package will be amongst the package dependencies (
<pre><code>dep_pkgs . mi_deps</code></pre>
<p>), so we must recompile otherwise these dependencies will be inconsistent. The way we handle this case is by including the package dependencies in the <em>export hash</em> of a module, so that other modules which import this module will automatically be recompiled when one of the package dependencies changes. The recompiled module will have new package dependencies, which will force recompilation of its importers, and so on. Therefore if a package version changes, the change will be propagated throughout the module dependency graph.</p></li>
</ol></li>
</ol>
<h2 id="interface-stability">Interface stability</h2>
<p>For recompilation avoidance to be really effective, we need to ensure that fingerprints do not change unnecessarily. That is, if a module is modified, it should be the case that the only fingerprints that change are related to the parts of the module that were modified. This may seem obvious, but it's surprisingly easy to get wrong. Here are some of the ways we got it wrong in the past, and some ways we still get it wrong.</p>
<ul>
<li>Prior to GHC 6.12, dictionary functions were named something like
<pre><code>M.$f23`, where `M` is the module defining the instance, and the number `23` was generated by simply assigning numbers to the dictionary functions defined by `M` sequentially.  This is a problem for recompilation avoidance, because now removing or adding an instance in `M` will change the numbering, and force recompilation of anything that depends on any instance in `M`.  Worse, the numbers are assigned non-deterministically, so simply recompiling `M` without changing its code could change the fingerprints.  In GHC 6.12 we changed it so that dictionary functions are named after the class and type(s) of the instance, e.g. `M.$fOrdInteger</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>compiler-generated bindings used to be numbered in the same way, non-deterministically. The non-determinism arises because Uniques are assigned by the compiler non-deterministically. Well, they are deterministic but not in a way that you can sensibly control, because it depends on the order in which interface bindings are read, etc. Internal mappings use Uniques as the key, so asking for the elements of a mapping gives a non-deterministic ordering. The list of bindings emitted by the simplifier, although in dependency order, can vary non-deterministically within the constraints of the dependencies. So if we number the compiler-generated bindings sequentially, the result will be a non-deterministic ABI.</li>
</ul>
<p><code>  </code><br />
<br />
<code>   In GHC 6.12 we changed this so that compiler-generated bindings are given names of the form </code></p>
<pre><code>f_x`, where `f` is the name of the exported Id that refers to the binding.  If there are multiple `f_x`s, then they are disambiguated with an integer suffix, but the numbers are assigned deterministically, by traversing the definition of `f` in depth-first left-to-right order to find references.  See `TidyPgm.chooseExternalIds</code></pre>
<p>.</p>
<ul>
<li>There are still some cases where an interface can change without changing the source code. The ones we know about are listed in #4012</li>
</ul>
<h1 id="the-register-allocator-1">The Register Allocator</h1>
<h2 id="overview-6">Overview</h2>
<p>The register allocator is responsible for assigning real/hardware regs (hregs) to each of the virtual regs (vregs) present in the code emitted by the native code generator. It also inserts spill/reload instructions to save vregs to the stack in situations where not enough hregs are available.</p>
<p>GHC currently provides three register allocation algorithms, one which does simple linear scan and two version of graph coloring. Support for linear scan is likely to be removed in a subequent version.</p>
<ul>
<li><strong>Linear scan</strong><br />
</li>
</ul>
<p><code>  The linear allocator is turned on by default. This is what you get when you compile with </code></p>
<pre><code>-fasm</code></pre>
<p>. The linear allocator does a single pass through the code, allocating registers on a first-come-first-served basis. It is quick, and does a reasonable job for code with little register pressure.</p>
<p><code> This algorithm has no look-ahead. If say, a particular hreg will be clobbered by a function call, it does not know to avoid allocating to it in the code before the call, and subsequently inserts more spill/reload instructions than strictly needed.</code></p>
<ul>
<li><strong>Graph coloring</strong> (enabled with
<pre><code>-fregs-graph</code></pre>
<p>)<br />
</p></li>
</ul>
<p><code>  The graph coloring algorithm operates on the code for a whole function at a time. From each function it extracts a register conflict graph which has a node for every vreg and an edge between two vregs if they are in use at the same time and thus cannot share the same hreg. The algorithm tries to assign hregs (imagined as colors) to the nodes so that no two adjacent nodes share the same color, if it can't then it inserts spill code, rebuilds the graph and tries again. </code></p>
<p><code> Graph coloring tends to do better than the linear allocator because the conflict graph helps it avoid the look-ahead problem. The coloring allocator also tries harder to allocate the source and destination of reg-to-reg move instructions to the same hreg. This is done by coalescing (merging) move-related nodes. If this succeeds then the associated moves can be erased.</code></p>
<ul>
<li><strong>Graph coloring with iterative coalescing</strong> (enabled with
<pre><code>-fregs-iterative</code></pre>
<p>)<br />
</p></li>
</ul>
<p><code>  Iterative coalescing is an improvement over regular graph coloring whereby coalescing passes are interleaved with coloring passes. Iterative coalescing does a better job than regular graph coloring, but is slower because it must alternate between the coloring and coalescing of nodes.</code></p>
<h2 id="code-map">Code map</h2>
<p>For an outline of the code see [wiki:Commentary/Compiler/Backends/NCG/RegisterAllocator/Code]</p>
<h2 id="references-2">References</h2>
<p>If you decide to do some hacking on the register allocator then take a look at (at least) these papers first:</p>
<p><strong>Iterated Register Coalescing</strong><br />
<em>George, Appel, 1996</em><br />
Decribes the core graph coloring algorithm used.</p>
<p><strong>A Generalised Algorithm for Graph-Coloring Register Allocation</strong><br />
<em>Smith, Ramsey, Holloway, 2004</em><br />
For a decription of how to deal with overlapping register sets, which aren't fully implemented. Explains what the</p>
<pre><code>worst</code></pre>
<p>,</p>
<pre><code>squeese</code></pre>
<p>and</p>
<pre><code>triv</code></pre>
<p>functions are for.</p>
<p><strong>Design and Implementation of a Graph Coloring Register Allocator for GCC</strong><br />
<em>Matz, 2003</em><br />
For an overview of techniques for inserting spill code.</p>
<h2 id="register-pressure-in-haskell-code">Register pressure in Haskell code</h2>
<p>Present GHC compiled code places very little pressure on the register set. Even on x86 with only 3 allocable registers, most modules do not need spill/reloads. This is a mixed blessing - on one hand the conflict graphs are small so we can avoid performance problems related to how the graph is represented, on the other hand it can be hard to find code to test against. Register pressure is expected to increase as the Stg-&gt;Cmm transform improves.</p>
<p>In the meantime, here are some good sources for test code:</p>
<ul>
<li><strong>Nofib</strong><br />
</li>
</ul>
<p><code>  Only a few nofib benchmarks create spills with </code></p>
<pre><code>-O2</code></pre>
<p>, two are</p>
<pre><code>spectral/hartel/genfft</code></pre>
<p>and</p>
<pre><code>spectral/sorting</code></pre>
<p>.</p>
<ul>
<li><strong>Turn on profiling</strong><br />
</li>
</ul>
<p><code>  Register pressure increases significantly when the module is compiled with profiling. </code><a href="attachment:checkSpills.report"><code>12</code></a><code> gives tuples of </code></p>
<pre><code>(spills, reloads, reg-reg-moves)</code></pre>
<p>present in output code generated by the three algorithms when compiled with</p>
<pre><code>-O2 -prof</code></pre>
<p>. Left to right are the stats for the linear, graph coloring and iterative coalescing algorithms. Note that most modules compile with no spill/reloads inserted, but a few (notably</p>
<pre><code>real/compress2/Encode</code></pre>
<p>) need several hundred.</p>
<p><code> I've found it useful to maintain three darcs repos when working on the allocator. </code></p>
<pre><code>ghc-HEAD-work</code></pre>
<p>compiled with</p>
<pre><code>-Onot</code></pre>
<p>for fast compilation during hacking,</p>
<pre><code>ghc-HEAD-prof</code></pre>
<p>for testing with profiling turned on, and</p>
<pre><code>ghc-HEAD-validate</code></pre>
<p>for running the validate script. Patches are created in</p>
<pre><code>work</code></pre>
<p>, pushed into</p>
<pre><code>prof</code></pre>
<p>where</p>
<pre><code>checkSpills</code></pre>
<p>is used to compile the nofib benchmarks with the most register pressure. Once we're happy that the performance is ok, the patch is then pushed into</p>
<pre><code>validate</code></pre>
<p>for validation before pushing to the main repo on</p>
<pre><code>darcs.haskell.org</code></pre>
<ul>
<li><strong>SHA from darcs</strong><br />
</li>
</ul>
<p><code>  The </code></p>
<pre><code>SHA1.lhs</code></pre>
<p>module from the darcs source, compiled with</p>
<pre><code>-O2</code></pre>
<p>creates the most register pressure out of any Haskell code that I'm aware of. When compiling SHA1, GHC inlines several worker functions and the native code block that computes the hash ends up being around 1700 instructions long. vregs that live in the middle of the block have in the order of 30 conflict neighbors. (evidently, the conflict graph is too large for most of the graphviz layout algorithms to cope with)</p>
<p><code> For these reasons, </code></p>
<pre><code>SHA1.lhs</code></pre>
<p>can be treated as a good worst-case input to the allocator. In fact, the current linear allocator cannot compile it with</p>
<pre><code>-O2 -prof</code></pre>
<p>on x86 as it runs out of stack slots, which are allocated from a static pool. Make sure to test any changes to the allocator against this module.</p>
<h2 id="hackingdebugging">Hacking/Debugging</h2>
<ul>
<li>'''Turn on
<pre><code>-fasm-lint</code></pre>
<p>'''<br />
</p></li>
</ul>
<p><code>  Breaking the allocator can result in compiled programs crashing randomly (if you're lucky) or producing the wrong output. Make sure to always turn on </code></p>
<pre><code>-fasm-lint</code></pre>
<p>. Doing this makes the allocator call</p>
<pre><code>GraphOps.validateGraph</code></pre>
<p>after every spill/color stage.</p>
<pre><code>validateGraph</code></pre>
<p>checks that all the edges point to valid nodes, that no conflicting nodes have the same color, and if the graph is supposed to be colored then all nodes are really colored.</p>
<ul>
<li><strong>Some useful dump flags</strong></li>
</ul>
<pre><code>-ddump-asm-regalloc-stages</code></pre>
<p><br />
 Shows the code and conflict graph after ever spill/color stage. Also shows spill costs, and what registers were coalesced.</p>
<pre><code>-ddump-asm-stats</code></pre>
<p><br />
 Gives statistics about how many spills/reloads/reg-reg-moves are in the output program.</p>
<pre><code>-ddump-asm</code></pre>
<p><br />
 Gives the final output code.</p>
<pre><code>-ddump-to-file</code></pre>
<p><br />
 Diverts dump output to files. This can be used to get dumps from each module in a nofib benchmark.</p>
<pre><code>  cd nofib/real/anna
  make EXTRA_HC_OPTS=&quot;-O2 -fregs-iterative -ddump-to-file -ddump-asm-regalloc-stages&quot;
  </code></pre>
<ul>
<li><strong>Visualisation of conflict graphs</strong><br />
</li>
</ul>
<p><code>  Graphviz, available from </code><a href="http://www.graphviz.org"><code>13</code></a><code> can be used to make nice visualisations of the register conflict graphs. Use </code></p>
<pre><code>-ddump-asm-regalloc-stages</code></pre>
<p>, and copy one of the graph descriptions into a new file</p>
<pre><code>niceGraph.dot</code></pre>
<pre><code> 
  circo -Tpng niceGraph.dot -o niceGraph.png 
  </code></pre>
<p><code> Here's two from </code></p>
<pre><code>nofib/real/compress2/Encode</code></pre>
<p>compiled with</p>
<pre><code>-O2 -prof</code></pre>
<dl>

<dd>
</dd>
</dl>
<p><code>  </code><a href="attachment:graph.dot"><code>14</code></a><code> -&gt; </code><a href="attachment:graph.png"><code>15</code></a></p>
<p><code>  </code><a href="attachment:graph-colored.dot"><code>16</code></a><code> -&gt; </code><a href="attachment:graph-colored.png"><code>17</code></a></p>
<ul>
<li><strong>checkSpills</strong><br />
</li>
</ul>
<p><code>  </code><a href="attachment:checkSpills.hs"><code>18</code></a><code> is a nasty, throw away script which can be used to automate the comparison of allocation algorithms. Copy it and a list of test like </code><a href="attachment:checkSpills.tests"><code>19</code></a><code> to the top level nofib directory, compile and run. It will build the nofib benchmarks in the list 6 times each, once each with each of the allocators to extract spill counts, and then once again to get compile timings which are unperterbed by the space leaks introduced by compiling with debugging turned on. It's only needed if you're hacking on the allocator, parses the nofib make output directly, and is likely to rot - which is why it isn't included in the main source tree.</code></p>
<h2 id="runtime-performance">Runtime performance</h2>
<p>Runtime performance of the graph coloring allocator is proportional to the size of the conflict graph and the number of build/spill cycles needed to obtain a coloring. Most functions have graphs &lt; 100 nodes and generate no spills, so register allocation is a small fraction of overall compile time.</p>
<h2 id="possible-improvements">Possible Improvements</h2>
<p>These are some ideas for improving the current allocator, most potentially useful first.</p>
<ul>
<li><strong>Work lists for iterative coalescing.</strong><br />
</li>
</ul>
<p><code>  The iterative coalescing alternates between scanning the graph for trivially colorable (triv) nodes and perforing coalescing. When two nodes are coalesced, other nodes that are not adjacent to the coalesced nodes do not change and do not need to be rescanned straight away. Runtime performance of the iterative coalescer could probably be improved by keeping a work-list of &quot;nodes that might have become trivially colorable&quot;, to help find nodes that won't have changed.</code></p>
<ul>
<li><strong>Improve spill code generator/cleaner.</strong><br />
</li>
</ul>
<p><code>  When spilling a particular vreg, the current spill code generator simply inserts a spill after each def and a reload before each use. This quickly reduces the density of conflicts in the graph, but produces inefficient code because more spill/reloads are inserted than strictly nessesary. Good code is recovered by the spill cleaner which runs after allocation and removes spill/reload instructions that aren't nessesary. Some things to try:</code></p>
<ul>
<li><strong>Spill coalescing</strong><br />
</li>
</ul>
<p><code>    No attempt is currently made to share spill slots between different vregs. Each named vreg is spilled to its own static spill slot on the C stack. The amount of stack space needed could be reduced by sharing spill slots between vregs so long as their live ranges do not overlap.</code></p>
<ul>
<li><strong>Try to split live ranges before spilling</strong><br />
</li>
</ul>
<p><code>    If a live range has several use/defs then we could insert fresh reg-reg moves to break it up into several smaller live ranges. We then might get away with spilling just one section instead of the whole range. Not sure if this would be a win over the current situation. We would need spill-coalescing to be implemented before this so that we don't require an extra slot for each new live range.</code></p>
<ul>
<li><strong>Rematerialization</strong><br />
</li>
</ul>
<p><code>    As the spill cleaner walks through the code it builds a mapping of which slots and registers hold the same value. On each reload instruction, if the slot and reg are known to already have the same value then the reload can be erased. This mapping could be extended with constants, so that if a vreg holding a constant value cannot be allocated a hreg, the constant value can be rematerialized instead of being spilled/reloaded to a stack slot.</code></p>
<ul>
<li><strong>Revisit choosing of spill candidates</strong><br />
</li>
</ul>
<p><code>  If the graph cannot be colored then a node/vreg must be chosen to be potentially spilled. Chaitin's forumula says to calculate the spill cost by adding up the number of uses and defs of that vreg and divide by the degree of the node. In the code that I've tested against, it's been better to just choose the live range that lives the longest. Perhaps this is because the 'real' spill cost would depend on the spills/reloads actually inserted, not a simple count of use/defs. Perhaps choosing the longest live range is just better for the particular kind of code that GHC generates.</code></p>
<ul>
<li><strong>Revisit trivColorable / aliasing of register sets</strong><br />
</li>
</ul>
<p><code>  For the architectures currently supported, x86, x86_64 and ppc, the native code generator currently emits code using only two register classes </code></p>
<pre><code>RcInteger</code></pre>
<p>and</p>
<pre><code>RcDouble</code></pre>
<p>. As these classes are disjoint (ie, none of the regs from one class alias with with regs from another), checking whether a node of a certain class is trivially colorable reduces to counting up the number of neighbours of that class.</p>
<p><code> If the NCG starts to use aliasing register classes eg: both 32bit </code></p>
<pre><code>RcFloat</code></pre>
<p>s and 64bit</p>
<pre><code>RcDouble</code></pre>
<p>s on sparc; combinations of 8, 16, and 32 bit integers on x86 / x86_x6 or usage of sse / altivec regs in different modes, then this can be supported via the method described in [Smith et al]. The allocator was designed with this in mind - ie, by passing a function to test if a node is trivially colorable as a parameter to the coloring function - and there is already a description of the register set for x86 in <a href="GhcFile(compiler/nativeGen/RegArchX86.hs)" class="uri" title="wikilink">GhcFile(compiler/nativeGen/RegArchX86.hs)</a>, but the native code generator doesn't currently emit code to test it against.</p>
<h1 id="haskell-excecution-registers">Haskell Excecution: Registers</h1>
<p>Source files: <a href="GhcFile(includes/stg/Regs.h)" class="uri" title="wikilink">GhcFile(includes/stg/Regs.h)</a>, <a href="GhcFile(includes/stg/MachRegs.h)" class="uri" title="wikilink">GhcFile(includes/stg/MachRegs.h)</a></p>
<p>During execution of Haskell code the following (virtual) registers are always valid:</p>
<ul>
<li><pre><code>Hp</code></pre>
<p>points to the byte before the first free byte in the (contiguous) allocation space.</p></li>
</ul>
<ul>
<li><pre><code>HpLim</code></pre>
<p>points to the last available byte in the current chunk of allocation space.</p></li>
</ul>
<ul>
<li><pre><code>Sp</code></pre>
<p>points to the youngest allocated byte of stack. The stack grows downwards. Why? Because that means a return address is at a lower address than the stack frame it &quot;knows about&quot;, and that in turn means that we can treat a stack frame very like a heap object, with an info pointer (return address) as its first word.</p></li>
</ul>
<ul>
<li><pre><code>SpLim</code></pre>
<p>points to the last (youngest) available byte in the current stack.</p></li>
</ul>
<p>There are bunch of other virtual registers, used for temporary argument passing, for words, floats and doubles:</p>
<pre><code>R1` .. `R10`, `F1` .. `F4`, `D1` .. `D4`, `L1` .. `L2</code></pre>
<p>.</p>
<p>In a register-rich machine, many of these virtual registers will be mapped to real registers. In a register-poor machine, they are instead allocated in a static memory record, pointed to by a real register,</p>
<pre><code>BaseReg</code></pre>
<p>.</p>
<p>The code generator knows how many real registers there are, and tries to avoid using virtual registers that are not mapped to real registers. So, for example, it does not use</p>
<pre><code>R5</code></pre>
<p>if the latter is memory-mapped; instead, it passes arguments on the stack.</p>
<h1 id="relevant-ghc-parts-for-demand-analysis-results">Relevant GHC parts for Demand Analysis results</h1>
<ul>
<li><pre><code>compiler/basicTypes/Demand.lhs</code></pre>
<p>-- contains all information about demands and operations on them, as well as about serialization/deserialization of demand signatures. This module is supposed to be changed whenever the demand nature should be enhanced;</p></li>
</ul>
<ul>
<li><pre><code>compiler/stranal/DmdAnal.lhs</code></pre>
<p>-- the demand analysis itself. Check multiple comments to figure out main principles of the algorithm.</p></li>
</ul>
<ul>
<li><pre><code>compiler/stranal/WorkWrap.lhs` -- a worker-wrapper transform, main client of the demand analysis. The function split is performed in `worthSplittingFun</code></pre>
<p>basing on demand annotations of a function's parameters.</p></li>
</ul>
<ul>
<li><pre><code>compiler/stranal/WwLib.lhs` -- a helper module for the worker-wrapper machinery. The &quot;deep&quot; splitting of a product type argument makes use of the strictness info and is implemented by the function `mkWWstr_one`. The function `mkWWcpr</code></pre>
<p>makes use of the CPR info.</p></li>
</ul>
<ul>
<li><pre><code>compiler/basicTypes/Id.lhs` -- implementation of identifiers contains a number of utility functions to check/set demand annotations of binders. All of them are just delegating to appropriate functions/fields of the `IdInfo</code></pre>
<p>record;</p></li>
</ul>
<ul>
<li><pre><code>compiler/basicTypes/IdInfo.lhs` -- `IdInfo` record contains all information about demand and strictness annotations of an identifier. `strictnessInfo` contains a representation of an abstract two-point demand transformer of a binder, considered as a reference to a value. `demandInfo` indicates, which demand is put to the identifier, which is a function parameter, if the function is called in a strict/used context. `seq*</code></pre>
<p>-functions are invoked to avoid memory leaks caused by transforming new ASTs by each of the compiler passes (i.e., no thunks pointing to the parts of the processed trees are left).</p></li>
</ul>
<ul>
<li><pre><code>compiler/basicTypes/MkId.lhs</code></pre>
<p>-- A machinery, responsible for generation of worker-wrappers makes use of demands. For instance, when a signature for a worker is generated, the following strictness signature is created:</p></li>
</ul>
<pre><code>  wkr_sig = mkStrictSig (mkTopDmdType (replicate wkr_arity top) cpr_info)</code></pre>
<p><code> In words, a non-bottoming demand type with </code></p>
<pre><code>N` lazy/used arguments (`top`) is created for a worker, where `N` is just a worker&#39;s pre-computed arity. Also, particular demands are used when creating signatures for dictionary selectors (see `mkDictSelId</code></pre>
<p>).</p>
<ul>
<li><pre><code>compiler/prelude/primops.txt.pp` -- this file defines demand signatures for primitive operations, which are inserted by `cpp` pass on the module `compiler/basicTypes/MkId.lhs</code></pre>
<p>;</p></li>
</ul>
<ul>
<li><pre><code>compiler/coreSyn/CoreArity.lhs` -- demand signatures are used in order to compute the unfolding info of a function: bottoming functions should no be unfolded. See `exprBotStrictness_maybe` and `arityType</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>compiler/coreSyn/CoreLint.lhs` -- the checks are performed (in `lintSingleBinding</code></pre>
<p>):</p>
<ul>
<li>whether arity and demand type are consistent (only if demand analysis already happened);</li>
<li>if the binder is top-level or recursive, it's not demanded (i.e., its demand is not strict).</li>
</ul></li>
</ul>
<ul>
<li><pre><code>compiler/coreSyn/CorePrep.lhs</code></pre>
<p>-- strictness signatures are examining before converting expression to A-normal form.</p></li>
</ul>
<ul>
<li><pre><code>compiler/coreSyn/MkCore.lhs` -- a bottoming strictness signature created for `error`-like functions (see `pc_bottoming_Id</code></pre>
<p>).</p></li>
</ul>
<ul>
<li><pre><code>compiler/coreSyn/PprCore.lhs</code></pre>
<p>-- standard pretty-printing machinery, should be modified to change PP of demands.</p></li>
</ul>
<ul>
<li><pre><code>compiler/iface/IfaceSyn.lhs`  -- serialization, grep for `HsStrictness</code></pre>
<p>constructors.</p></li>
</ul>
<ul>
<li><pre><code>compiler/iface/MkIface.lhs`  -- a client of `IfaceSyn`, see usages of `HsStrictness</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>compiler/iface/TcIface.lhs` -- the function `tcUnfolding</code></pre>
<p>checks if an identifier binds a bottoming function in order to decide if it should be unfolded or not</p></li>
</ul>
<ul>
<li><pre><code>compiler/main/TidyPgm.lhs` -- Multiple checks of an identifier to bind a bottoming expression, running a cheap-an-cheerful bottom analyser. See `addExternal` and occurrences of `exprBotStrictness_maybe</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>compiler/simplCore/SetLevels.lhs` -- It is important to zap demand information, when an identifier is moved to a top-level (due to let-floating), hence look for occurrences of `zapDemandIdInfo</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>compiler/simplCore/SimplCore.lhs</code></pre>
<p>-- this module is responsible for running the demand analyser and the subsequent worker-wrapper split passes.</p></li>
</ul>
<ul>
<li><pre><code>compiler/simplCore/SimplUtils.lhs`  -- is a new arity is less than the arity of the demand type, a warning is emitted; check `tryEtaExpand</code></pre>
<p>.</p></li>
</ul>
<ul>
<li><pre><code>compiler/specialise/SpecConstr.lhs` -- strictness info is used when creating a specialized copy of a function, see `spec_one` and `calcSpecStrictness</code></pre>
<p>.</p></li>
</ul>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="remembered-sets">Remembered Sets</h1>
<p>Since in generational GC we may need to find all the live objects in a young generation without traversing the older generation(s), we need a record of the pointers from those old generations into the young generations. This is termed the &quot;remembered set&quot;.</p>
<p>In GHC each</p>
<pre><code>generation` structure contains a field `mut_list</code></pre>
<p>, which points to a chain of blocks. Each block in the chain contains a list of pointers to objects in that generation which contain pointers to objects in younger generations. There are alternative schemes, e.g.</p>
<ul>
<li>Keeping track of each <em>pointer</em>, rather than <em>object</em> that points to a younger generation. The remembered set would</li>
</ul>
<p><code>  be larger (possibly very much larger, in the case of arrays), but it would be more accurate, and traversing the</code><br />
<code>  remembered set at GC time would be faster.</code></p>
<ul>
<li>Some GCs use &quot;card-marking&quot; schemes whereby the heap is divided into &quot;cards&quot; of a fixed size, and each card has a bit to</li>
</ul>
<p><code>  indicate whether that card contains pointers to a younger generation.  This is much less accurate than a remembered set,</code><br />
<code>  but it is faster at runtime if a lot of mutation is taking place, and it takes less space than a remembered set.  In GHC</code><br />
<code>  we typically do not have much mutation to worry about, so card marking would be a poor compromise in our case.</code></p>
<p>The remembered set may contain duplicates, or it may contain pointers to objects that don't really point to young generations.</p>
<h2 id="remembered-set-maintenance-during-mutation">Remembered set maintenance during mutation</h2>
<p>While the mutator is running, we have to add any old-to-new generation pointers that are created. Old-to-new pointers are created by mutating (writing to) an object in the old generation, and catching these writes is called a &quot;write barrier&quot;.</p>
<p>A pointer can be added to a remembered set using</p>
<pre><code>void recordMutableCap (StgClosure *p, Capability *cap, nat gen);</code></pre>
<p>This adds the pointer</p>
<pre><code>p` to the remembered set for generation `gen`, using Capability `cap</code></pre>
<p>. Each Capability has its own remembered set for each generation, so that when running in parallel we can update remembered sets without taking a lock, and also so that we can take advantage of locality in the GC, by traversing a remembered set on the same CPU that created it.</p>
<p>Here are the cases where we need a write barrier in GHC:</p>
<h3 id="thunk-updates">Thunk Updates</h3>
<p>Updating a thunk in an old generation. This is taken care of by the update code, see <a href="GhcFile(rts/Updates.h)" class="uri" title="wikilink">GhcFile(rts/Updates.h)</a>.</p>
<h3 id="mutable-objects-mut_var-mvar">Mutable objects: MUT_VAR, MVAR</h3>
<p>For</p>
<pre><code>MUT_VAR`, the writer must call `dirty_MUT_VAR</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>void dirty_MUT_VAR(StgRegTable *reg, StgClosure *p);</code></pre>
<p>(in <a href="GhcFile(rts/sm/Storage.c)" class="uri" title="wikilink">GhcFile(rts/sm/Storage.c)</a>). The code generator inserts calls to</p>
<pre><code>dirty_MUT_VAR` when it compiles a call to the primitive `writeMutVar#</code></pre>
<p>.</p>
<pre><code>dirty_MUT_VAR` does the following: if the object&#39;s header is `MUT_VAR_CLEAN`, then the header is set to `MUT_VAR_DIRTY`, and the object is added to the remembered set if it resides in an old generation.  If the header was already `MUT_VAR_DIRTY</code></pre>
<p>, no action is taken.</p>
<pre><code>MVAR</code></pre>
<p>is handled in the same way, with</p>
<pre><code>void dirty_MVAR(StgRegTable *reg, StgClosure *p)</code></pre>
<h3 id="arrays-mut_arr_ptrs">Arrays: MUT_ARR_PTRS</h3>
<p>Unlike mutable variables and MVARs, mutable arrays are kept in the remembered set permanently. This reflects the fact that mutable arrays are likely to be written to more often, and there are likely to be fewer of them. However, we still mark arrays according to whether the array is dirty or not, using</p>
<pre><code>MUT_ARR_PTRS_DIRTY` and `MUT_ARR_PTRS_CLEAN</code></pre>
<p>.</p>
<p>There are also</p>
<pre><code>MUT_ARR_PTRS_FROZEN` and `MUT_ARR_PTRS_FROZEN0`, which are used to indicate arrays that have been frozen using `unsafeFreezeArray#</code></pre>
<p>. A frozen array is different from a mutable array in the sense that while it may have old-to-new pointers, it is not going to be mutated any further, and so we probably want to use [wiki:Commentary/Rts/Storage/GC/EagerPromotion eager promotion] on it.</p>
<h3 id="threads-tso">Threads: TSO</h3>
<p>Threads (TSOs) have stacks, which are by definition mutable. Running a thread is therefore an act of mutation, and if the thread resides in an old generation, it must be placed in the remembered set. Threads have two dirty bits:</p>
<pre><code>tso-&gt;dirty</code></pre>
<p>is set to non-zero if the thread's stack or any part of the TSO structure may be dirty, and also there is a bit</p>
<pre><code>TSO_LINK_DIRTY` in `tso-&gt;flags</code></pre>
<p>which is set if the TSO's link field may be dirty. If the thread is executed, then</p>
<pre><code>dirty_TSO()` must be called in order to set the `tso-&gt;dirty</code></pre>
<p>bit and add the TSO to the appropriate remembered set.</p>
<pre><code>void dirty_TSO (Capability *cap, StgTSO *tso);</code></pre>
<p>To set the TSO's link field, use</p>
<pre><code>setTSOLink()</code></pre>
<p>(from <a href="GhcFile(rts/sm/Storage.c)" class="uri" title="wikilink">GhcFile(rts/sm/Storage.c)</a>) which arranges to add the TSO to the remembered set if necessary.</p>
<pre><code>void setTSOLink (Capability *cap, StgTSO *tso, StgTSO *target);</code></pre>
<p>there are a few exceptions where</p>
<pre><code>setTSOLink()</code></pre>
<p>does not need to be called; see <a href="GhcFile(rts/sm/Storage.c)" class="uri" title="wikilink">GhcFile(rts/sm/Storage.c)</a> for details.</p>
<h2 id="remembered-set-maintenance-during-gc">Remembered set maintenance during GC</h2>
<p>During GC, the principle of write barriers is quite similar: whenever we create an old-to-new pointer, we have to record it in the remembered set. The GC achieves this as follows:</p>
<ul>
<li>The GC thread structure has a field
<pre><code>gct-&gt;evac_gen</code></pre>
<p>which specifies the desired destination generation.</p></li>
<li>there is a flag
<pre><code>gct-&gt;failed_to_evac`, which is set to true by `evacuate</code></pre>
<p>if it did not manage to evacuate</p></li>
</ul>
<p><code>  the object into the desired generation.</code></p>
<ul>
<li>after scavenging an object,
<pre><code>scavenge_block` checks the `failed_to_evac` flag, and if it is set, adds the object to the remembered set, using `recordMutableGen_GC()` (the equivalent of `recordMutableCap</code></pre>
<p>for calling within the GC).</p></li>
</ul>
<h1 id="the-renamer">The renamer</h1>
<p>The renamer's Number One task is to replace [wiki:Commentary/Compiler/RdrNameType RdrNames] with [wiki:Commentary/Compiler/NameType Names]. For example, consider</p>
<pre><code>module K where
  f x = True

module N where
  import K

module M where
  import N( f ) as Q
  f = (f, M.f, Q.f, \f -&gt; f)</code></pre>
<p>(where all the variables are</p>
<pre><code>RdrName</code></pre>
<p>s). The result of renaming module M is:</p>
<pre><code>M.f = (M.f, M.f, K.f, \f_22 -&gt; f_22)</code></pre>
<p>where all these names are now</p>
<pre><code>Name</code></pre>
<p>s.</p>
<ul>
<li>The top-level unqualifed
<pre><code>RdrName</code></pre>
<p>&quot;</p>
<pre><code>f</code></pre>
<p>&quot; has become the</p>
<pre><code>External</code></pre>
<pre><code>Name</code></pre>
<pre><code>M.f</code></pre>
<p>.</p></li>
<li>The occurrences &quot;
<pre><code>f</code></pre>
<p>&quot; and &quot;</p>
<pre><code>M.f</code></pre>
<p>&quot; are both bound to this</p>
<pre><code>Name</code></pre>
<p>.</p></li>
<li>The qualified
<pre><code>RdrName</code></pre>
<p>&quot;</p>
<pre><code>Q.f</code></pre>
<p>&quot; becomes the</p>
<pre><code>Name</code></pre>
<pre><code>K.f</code></pre>
<p>, because the function is defined in module K.</p></li>
<li>The lambda-bound &quot;
<pre><code>f</code></pre>
<p>&quot; becomes an</p>
<pre><code>Internal</code></pre>
<p>name, here written</p>
<pre><code>f_22</code></pre>
<p>. (All the</p>
<pre><code>External</code></pre>
<p>names have uniques too, but we often do not print them.)</p></li>
</ul>
<p>In addition, the renamer does the following things:</p>
<ul>
<li>Sort out fixities. The parser parses all infix applications as <strong>left-associative</strong>, regardless of fixity. For example &quot;
<pre><code>a + b * c</code></pre>
<p>&quot; is parsed as &quot;</p>
<pre><code>(a + b) * c</code></pre>
<p>&quot;. The renamer re-associates such nested operator applications, using the fixities declared in the module.</p></li>
</ul>
<ul>
<li>Dependency analysis for mutually-recursive groups of declarations. This divides the declarations into strongly-connected components.</li>
</ul>
<ul>
<li>Lots of lexical error checking: variables out of scope, unused bindings, unused imports, patterns that use the same binder many times, etc.</li>
</ul>
<p>The renamer sits between the parser and the typechecker. However, its operation is quite tightly interwoven with the typechecker. This is mainly due to support for Template Haskell, where spliced code has to be renamed and type checked. In particular, top-level splices lead to multiple rounds of renaming and type checking. It uses the [wiki:Commentary/Compiler/TcRnMonad same monad as the typechecker].</p>
<p>== The global renamer environment,</p>
<pre><code>GlobalRdrEnv</code></pre>
<p>==</p>
<p>A big part of the renamer's task is to build the <strong>global rdr-env</strong> for the module, of type</p>
<pre><code>GlobalRdrEnv</code></pre>
<p>. This environment allows us to take a qualified or un-qualified</p>
<pre><code>RdrName</code></pre>
<p>and figure out which</p>
<pre><code>Name</code></pre>
<p>it means. The global rdr-env is built by looking at all the imports, and the top-level declarations of the module.</p>
<p>You might think that the global rdr-env would be a mapping from</p>
<pre><code>RdrName</code></pre>
<p>to</p>
<pre><code>Name</code></pre>
<p>, but it isn't. Here is what it looks like, after at least three iterations (all in <a href="GhcFile(compiler/basicTypes/RdrName.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/RdrName.hs)</a>):</p>
<pre><code>type GlobalRdrEnv = OccEnv [GlobalRdrElt]
  -- An (OccEnv a) is a mapping from OccName to a

data GlobalRdrElt = GRE { gre_name :: Name
                        , gre_prov :: Provenance
                        , gre_par :: Parent }

data Provenance = LocalDef | Imported [ImportSpec]

data ImportSpec = ImpSpec { is_decl :: ImpDeclSpec, is_item ::  ImpItemSpec }

data Parent = NoParent | ParentIs Name</code></pre>
<p>Here is how to understand these types:</p>
<ul>
<li>The environment (
<pre><code>GlobalRdrEnv</code></pre>
<p>) maps an</p>
<pre><code>OccName</code></pre>
<p>to a list of all entities with that occurrence name that are in scope (in any way).</p></li>
</ul>
<ul>
<li>Each of these is represented by a
<pre><code>GlobalRdrElt</code></pre>
<p>, which gives the entity's</p>
<pre><code>Name</code></pre>
<p>plus a specification of how it is in scope, its</p>
<pre><code>Provenance</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>The
<pre><code>Provenance</code></pre>
<p>has one of two forms. Either it is in scope because it is defined in this module (</p>
<pre><code>LocalDef</code></pre>
<p>), or because it is imported. In the latter case, the</p>
<pre><code>[ImportSpec]</code></pre>
<p>describes all the import statements that bring it into scope.</p></li>
</ul>
<ul>
<li>An
<pre><code>ImportSpec</code></pre>
<p>has two components:</p>
<ul>
<li>An
<pre><code>ImpDeclSpec</code></pre>
<p>that describes the entire import declaration. This is shared between all entities brought into scope by a particular import declaration.</p></li>
<li>An
<pre><code>ImpItemSpec</code></pre>
<p>that describes the import item that brought the entity into scope.</p></li>
</ul></li>
</ul>
<p><code>For example, given</code></p>
<pre><code>import qualified M( x, T(g) ) as Q</code></pre>
<p><code>the </code></p>
<pre><code>ImpDeclSpec</code></pre>
<p>would describe the</p>
<pre><code>qualified</code></pre>
<p>and</p>
<pre><code>as</code></pre>
<p>part, while the</p>
<pre><code>ImpItemSpec</code></pre>
<p>describes the</p>
<pre><code>T(g)</code></pre>
<p>part. You can look in</p>
<pre><code>RdrName.hs</code></pre>
<p>to see what an</p>
<pre><code>ImportDeclSpec</code></pre>
<p>and</p>
<pre><code>ImpItemSpec</code></pre>
<p>are like!</p>
<ul>
<li>The
<pre><code>Parent</code></pre>
<p>of an entity is the</p>
<pre><code>Name</code></pre>
<p>under which it is grouped when the forms</p>
<pre><code>T(..)` or `T(C,D)` are used in an export or import list.  In the `T(..)` form, all the things whose &lt;pre&gt;Parent</code></pre>
<p>is `T` are chosen. In the `T(C,D)` form, it is required that `C` and `D` have `T</p>
</pre>
<p>as parents.</p></li>
</ul>
<p><code>  For example, </code></p>
<ul>
<li>The
<pre><code>Parent</code></pre>
<p>of a data constructor is its data type</p></li>
<li>The
<pre><code>Parent</code></pre>
<p>of a record field selector is its data type</p></li>
<li>The
<pre><code>Parent</code></pre>
<p>of a class operation is its class</p></li>
</ul>
<p>With all that information, we can give good error messages, especially in the case where an occurrence &quot;f&quot; is ambiguous (i.e. different entities, both called &quot;f&quot;, were imported by different import statements).</p>
<p>The global rdr-env is created by <a href="GhcFile(compiler/rename/RnNames.hs)" class="uri" title="wikilink">GhcFile(compiler/rename/RnNames.hs)</a>.</p>
<p>It is important to note that the global rdr-env is created <em>before</em> the renamer actually descends into the top-level bindings of a module. In other words, before</p>
<pre><code>TcRnDriver.rnTopSrcDecls</code></pre>
<p>performs the renaming of a module by way of</p>
<pre><code>RnSource.rnSrcDecls</code></pre>
<p>, it uses</p>
<pre><code>RnNames.importsFromLocalDecls</code></pre>
<p>to set up the global rdr-env environment, which contains</p>
<pre><code>Names</code></pre>
<p>for all imported and all locally defined toplevel binders. Hence, when the helpers of</p>
<pre><code>rnSrcDecls</code></pre>
<p>come across the defining occurences of a toplevel</p>
<pre><code>RdrName</code></pre>
<p>, they don't rename it by generating a new name, but they simply look up its name in the global rdr-env.</p>
<h2 id="unused-imports">Unused imports</h2>
<p>See [wiki:Commentary/Compiler/UnusedImports how the renamer reports unused imports]</p>
<h2 id="name-space-management">Name Space Management</h2>
<p>(too much detail?)</p>
<p>As anticipated by the variants</p>
<pre><code>Orig</code></pre>
<p>and</p>
<pre><code>Exact</code></pre>
<p>of</p>
<pre><code>RdrName</code></pre>
<p>, some names should not change during renaming, whereas others need to be turned into unique names. In this context, the two functions</p>
<pre><code>RnEnv.newTopSrcBinder</code></pre>
<p>and</p>
<pre><code>RnEnv.newLocalBndrRn</code></pre>
<p>are important:</p>
<pre><code>newTopSrcBinder :: Module -&gt; Maybe Name -&gt; Located RdrName -&gt; RnM Name
newLocalBndrRn :: Located RdrName -&gt; RnM Name</code></pre>
<p>The two functions introduces new toplevel and new local names, respectively, where the first two arguments to newTopSrcBinder determine the currently compiled module and the parent construct of the newly defined name. Both functions create new names only for [wiki:Commentary/Compiler/RdrNameType RdrNames] that are neither exact nor original.</p>
<h2 id="rebindable-syntax">Rebindable syntax</h2>
<p>(ToDo: Not fully proof-read.)</p>
<p>In Haskell when one writes &quot;3&quot; one gets &quot;fromInteger 3&quot;, where &quot;fromInteger&quot; comes from the Prelude (regardless of whether the Prelude is in scope). If you want to completely redefine numbers, that becomes inconvenient. So GHC lets you say &quot;-fno-implicit-prelude&quot;; in that case, the &quot;fromInteger&quot; comes from whatever is in scope. (This is documented in the User Guide.)</p>
<p>This feature is implemented as follows (I always forget).</p>
<ul>
<li>Names that are implicitly bound by the Prelude, are marked by the type
<pre><code>HsExpr.SyntaxExpr</code></pre>
<p>. Moreover, the association list</p>
<pre><code>HsExpr.SyntaxTable</code></pre>
<p>is set up by the renamer to map rebindable names to the value they are bound to.</p></li>
<li>Currently, five constructs related to numerals (
<pre><code>HsExpr.NegApp</code></pre>
<p>,</p>
<pre><code>HsPat.NPat</code></pre>
<p>,</p>
<pre><code>HsPat.NPlusKPat</code></pre>
<p>,</p>
<pre><code>HsLit.HsIntegral</code></pre>
<p>, and</p>
<pre><code>HsLit.HsFractional</code></pre>
<p>) and two constructs related to do-expressions (</p>
<pre><code>HsExpr.BindStmt</code></pre>
<p>and</p>
<pre><code>HsExpr.ExprStmt</code></pre>
<p>) have rebindable syntax.</p></li>
<li>When the parser builds these constructs, it puts in the built-in Prelude Name (e.g.
<pre><code>PrelNum.fromInteger</code></pre>
<p>).</p></li>
<li>When the renamer encounters these constructs, it calls
<pre><code>RnEnv.lookupSyntaxName</code></pre>
<p>. This checks for</p>
<pre><code>-fno-implicit-prelude</code></pre>
<p>; if not, it just returns the same Name; otherwise it takes the occurrence name of the Name, turns it into an unqualified</p>
<pre><code>RdrName</code></pre>
<p>, and looks it up in the environment. The returned name is plugged back into the construct.</p></li>
<li>The typechecker uses the
<pre><code>Name</code></pre>
<p>to generate the appropriate typing constraints.</p></li>
</ul>
<h1 id="replacing-the-native-code-generator">Replacing the Native Code Generator</h1>
<p>The existence of LLVM is definitely an argument not to put any more effort into backend optimisation in GHC, at least for those optimisations that LLVM can already do. There's also the question of whether it's worth extending the NCG to support SIMD primops. At the moment only the LLVM backend supports these, but current processor architectures will rely more and more on wide vector SIMD instructions for performance. Given that the LLVM project is now stable and widely used, it may be better to drop the NCG entirely (and delete the code).</p>
<p>However, there are a few ways that the LLVM backend needs to be improved before it can be considered to be a complete replacement for the existing NCG:</p>
<p>1. Compilation speed. LLVM approximately doubles compilation time. Avoiding going via the textual intermediate syntax would probably help here.</p>
<p>2. Shared library support (#4210, #5786). It works (or worked?) on a couple of platforms. But even on those platforms it generated worse code than the NCG due to using dynamic references for *all* symbols, whereas the NCG knows which symbols live in a separate package and need to use dynamic references.</p>
<p>3. Some low-level optimisation problems (#4308, #5567). The LLVM backend generates bad code for certain critical bits of the runtime, perhaps due to lack of good aliasing information. This hasn't been revisited in the light of the new codegen, so perhaps it's better now.</p>
<p>Someone should benchmark the LLVM backend against the NCG with new codegen in GHC 7.8. It's possible that the new codegen is getting a slight boost because it doesn't have to split up proc points, so it can do better code generation for let-no-escapes. It's also possible that LLVM is being penalised a bit for the same reason.</p>
<p>Other considerations:</p>
<p>1. The GHC distribution would need to start shipping with its own copy of LLVM. The LLVM code that GHC produces typically lags the current version of LLVM, so we'd need to ensure there was a usable version.</p>
<p>2. If we did ship our own version of LLVM, we could add custom plugins to improve the GHC generated code. At one stage Max Bolingbroke wrote an LLVM alias analysis plugin, but making it work against an arbitrary existing LLVM version would be infeasible.</p>
<p>note (carter): If we're very thoughtful about the changes / extensions to llvm needed for GHC, I'm somewhat confident that we could get any such patches upstreamed to llvm proper. The down side of this is that any such features would be subject to the llvm release cycle, plus we'd want to make sure that we're not just completely changing what we'd like upstreamed every ghc release cycle. The upside is that we'd get a lot more scrutiny / feedback / checking by llvm devs than we'd get with our own patched variant</p>
<h1 id="resource-limits">Resource Limits</h1>
<p>This page describes a proposed resource limits capabilities for GHC. The idea is to give users the ability to create and utilize resource containers inside programs, and then provide in-program access to heap census and other information. The semantics of resource containers are quite similar to cost centers used in profiling, except that they do not have &quot;stack&quot; semantics (more on this later). The end result is the ability to impose resource limits on space usage.</p>
<h2 id="code-generation-changes">Code generation changes</h2>
<p>Resource limits is a new way (similar to profiled and dynamic). Here are the relevant changes:</p>
<h3 id="dynamic-closure-allocation">Dynamic closure allocation</h3>
<p><a href="GhcFile(compiler/codeGen/StgCmmHeap.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmHeap.hs)</a>:allocDynClosureCmm (via StgCmmCon, also handles StgCmmBind:mkRhsClosure/cgRhsStdThunk. link_caf needs special treatment.)</p>
<pre><code>// profDynAlloc rep use_cc
// use_cc == CurCCS for the cases we&#39;re looking at
         I64[CCCS + 72] = I64[CCCS + 72] + %MO_UU_Conv_W64_W64(4 - 2);
// ALLOCATE THE OBJECT
// emitSetDynHdr base info_ptr use_cc
         I64[Hp - 24] = Data.Maybe.Just_con_info; // info_ptr
         I64[Hp - 16] = CCCS;                     // use_cc
         I64[Hp - 8] = (%MO_UU_Conv_W32_W64(I32[era]) &lt;&lt; 30) | 0; // dynLdvInit
// let (cmm_args, offsets) = unzip amodes_w_offsets
// hpStore base cmm_args offsets
         I64[Hp + 0] = I64[R1 + 32];</code></pre>
<p>Changes to:</p>
<pre><code>// invariant: Hp points to nursery of current resource container
         I64[Hp - 8] = Data.Maybe.Just_con_info; // info_ptr
         I64[Hp + 0] = I64[R1 + 32];</code></pre>
<p>I.e. no change from un-profiled.</p>
<h3 id="caf-allocation">CAF Allocation</h3>
<p><a href="GhcFile(compiler/codeGen/StgCmmBind.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmBind.hs)</a>:thunkCode</p>
<p>Here is an interesting bugger:</p>
<pre><code>// ldvEnterClosure
     c17Q:
         if (%MO_UU_Conv_W32_W64(I32[era]) &gt; 0) goto c17R;
         goto c17S;
     c17R:
         I64[R1 + 16] = I64[R1 + 16] &amp; 1152921503533105152 | %MO_UU_Conv_W32_W64(I32[era]) | 1152921504606846976;
         goto c17S;
// entryHeapCheck
     c17S:
         if (Sp - 80 &lt; SpLim) goto c17U;
         Hp = Hp + 64;
         if (Hp &gt; HpLim) goto c17W;
// setupUpdate
//// linkCaf
         I64[I64[R1 + 8] + 72] = I64[I64[R1 + 8] + 72] + %MO_UU_Conv_W64_W64(4 - 2);
         I64[Hp - 56] = stg_CAF_BLACKHOLE_info;
         I64[Hp - 48] = I64[R1 + 8];
         I64[Hp - 40] = (%MO_UU_Conv_W32_W64(I32[era]) &lt;&lt; 30) | 0;
         I64[Hp - 32] = CurrentTSO;
         (_c17X::I64,) = foreign &quot;ccall&quot;
           newCAF((BaseReg, PtrHint), (R1, PtrHint), (Hp - 56, PtrHint));
         if (_c17X::I64 == 0) goto c17Y;
         goto c17Z;
     c17Z:
//// pushUpdateFrame
         I64[Sp - 32] = stg_bh_upd_frame_info;
         I64[Sp - 8] = Hp - 56;
         I64[Sp - 24] = CCCS;
// enterCostCentreThunk
         CCCS = I64[R1 + 8];
         I64[CCCS + 72] = I64[CCCS + 72] + %MO_UU_Conv_W64_W64(4 - 2);
// cgExpr body
         I64[Hp - 24] = GHC.Integer.Type.S#_con_info;
         I64[Hp - 16] = CCCS;
         I64[Hp - 8] = (%MO_UU_Conv_W32_W64(I32[era]) &lt;&lt; 30) | 0;
         I64[Hp + 0] = 2;
         I64[Sp - 40] = CCCS;
         I64[Sp - 56] = Hp - 23;
         I64[Sp - 64] = stg_ap_p_info;
         I64[Sp - 72] = CCCS;
         I64[Sp - 80] = stg_restore_cccs_info;
         R2 = Foreign.C.Types.$fNumCInt_closure;
         I64[Sp - 48] = s15P_info;
         Sp = Sp - 80;
         jump GHC.Num.fromInteger_info; // [R2]
     c17U: jump stg_gc_enter_1; // [R1]
     c17W:
         HpAlloc = 64;
         goto c17U;
     c17Y: jump I64[R1]; // [R1]</code></pre>
<p>Notice the heap check serves for the later branch too. On the other hand, the CCCS coincides with the later change. This seems to be the general pattern. So we might be able to handle this CAF by special-casing CAFs.</p>
<pre><code>         _crc = Bdescr(Hp)-&gt;rc;
         CHANGE_NURSERY(I64[R1 + 8]);
// entryHeapCheck
     c17S:
         if (Sp - 80 &lt; SpLim) goto c17U;
         Hp = Hp + 32;
         if (Hp &gt; HpLim) goto c17W;
// setupUpdate
//// linkCaf
         I64[Hp - 24] = stg_CAF_BLACKHOLE_info;
         I64[Hp - 16] = CurrentTSO;
         (_c17X::I64,) = foreign &quot;ccall&quot;
           newCAF((BaseReg, PtrHint), (R1, PtrHint), (Hp - 56, PtrHint));
         if (_c17X::I64 == 0) goto c17Y;
         goto c17Z;
     c17Z:
//// pushUpdateFrame
         I64[Sp - 32] = stg_bh_upd_frame_info;
         I64[Sp - 8] = Hp - 56;
* *
// cgExpr body
         I64[Hp - 8] = GHC.Integer.Type.S#_con_info;
         I64[Hp + 0] = 2;
         I64[Sp - 56] = Hp - 23;
         I64[Sp - 64] = stg_ap_p_info;
* *
** *
         R2 = Foreign.C.Types.$fNumCInt_closure;
         I64[Sp - 48] = s15P_info;
         Sp = Sp - 80;
         jump GHC.Num.fromInteger_info; // [R2]
     c17U: jump stg_gc_enter_1; // [R1]
     c17W:
         HpAlloc = 32;
         goto c17U;
     c17Y: jump I64[R1]; // [R1]</code></pre>
<p>We also hit the slow function application path.</p>
<h3 id="thunk-code">Thunk code</h3>
<p><a href="GhcFile(compiler/codeGen/StgCmmBind.hs)" class="uri" title="wikilink">GhcFile(compiler/codeGen/StgCmmBind.hs)</a>:thunkCode</p>
<pre><code>// ldvEnterClosure cl_info
     clc:
         if (%MO_UU_Conv_W32_W64(I32[era]) &gt; 0) goto cld;
         goto cle;
     cld:
         I64[R1 + 16] = I64[R1 + 16] &amp; 1152921503533105152 | %MO_UU_Conv_W32_W64(I32[era]) | 1152921504606846976;
         goto cle;
     cle:
// entryHeapCheck cl_info node&#39; arity []
         if (Sp - 32 &lt; SpLim) goto clg;
         Hp = Hp + 40;
         if (Hp &gt; HpLim) goto cli;
// when (blackHoleOnEntry cl_info &amp;&amp; node_points)
//    (blackHoleIt node)
         // empty
// setupUpdate cl_info node
         I64[Sp - 32] = stg_upd_frame_info;
         I64[Sp - 8] = R1;
         I64[Sp - 24] = CCCS;
// enterCostCentreThunk (CmmReg nodeReg)
         CCCS = I64[R1 + 8];
// let lf_info = closureLFInfo cl_info
// fv_bindings &lt;- mapM bind_fv fv_details
// load_fvs node lf_info fv_bindings
         // empty
// cgExpr body
         ...
// due to &#39;entryHeapCheck cl_info node&#39; arity []&#39;
     clg: jump stg_gc_enter_1; // [R1]
     cli:
         HpAlloc = 40;
         goto clg;</code></pre>
<p>Changes to:</p>
<pre><code>         if (Sp - 32 &lt; SpLim) goto clg;
         _crc = Bdescr(Hp);
         // XXX ugh this is really expensive
         // XXX is it worth avoiding the rigamorole when it&#39;s the same? maybe.
         // closeNursery
         I64[CurrentNursery + 8] = Hp + 8;
         // change the nursery
         CurrentNursery = Bdescr(R1)-&gt;rc[CurrentCap]
         // openNursery
         Hp = I64[CurrentNursery + 8] - 8;
* 4096 - 1);
         // XXX end expensive bit
         Hp = Hp + 40; // or whatever this adjusts to
         if (Hp &gt; HpLim) goto cli;
         // (blackhole)
         I64[Sp - 32] = stg_upd_frame_info;
         I64[Sp - 8] = R1;
         // XXX or maybe omit this
         I64[Sp - 24] = _crc; // so we can restore it on return, NOT the same as current nursery
         // (load free variables)
         ...
     clg: jump stg_gc_enter_1; // [R1]
     cli:
         HpAlloc = 40;
         goto clg;</code></pre>
<h3 id="foreign-calls">Foreign calls</h3>
<pre><code>// savethreadState
//   mkStore (cmmOffset dflags (CmmLoad (cmmOffset dflags stgCurrentTSO (tso_stackobj dflags)) (bWord dflags)) (stack_SP dflags)) stgSp
         I64[I64[CurrentTSO + 40] + 32] = Sp;
//   closeNursery dflags
         I64[CurrentNursery + 8] = Hp + 8;
//   mkStore (cmmOffset dflags stgCurrentTSO (tso_CCCS dflags)) curCCS
         I64[CurrentTSO + 120] = CCCS;
// caller_save
         // (empty)
// mkMiddle (callSuspendThread dflags id intrbl)
         (_c17B::I64, PtrHint) = foreign &quot;ccall&quot;
           suspendThread((BaseReg, PtrHint), (0,));
// mkUnsafeCall tgt res args
         (_c17l::I64, `signed&#39;) = foreign &quot;ccall&quot;
           cos((_c17e::I64, `signed&#39;));
// mkMiddle (callResumeThread new_base id)
         (_c17D::I64, PtrHint) = foreign &quot;ccall&quot;
           resumeThread((_c17B::I64, PtrHint));
// mkAssign (CmmGlobal BaseReg) (CmmReg (CmmLocal new_base))
         BaseReg = _c17D::I64;
// caller_load
         // empty
// loadThreadState
//   tso = CurrentTSO
         _c17F::I64 = CurrentTSO;
//   stack = tso-&gt;stackobj
         _c17H::I64 = I64[_c17F::I64 + 40];
//   Sp = stack-&gt;sp
         Sp = I64[_c17H::I64 + 32];
//   SpLim = stack-&gt;stack + RESERVED_STACK_WORDS
         SpLim = _c17H::I64 + 208;
//   HpAlloc = 0
         HpAlloc = 0;
//   openNursery dflags
         Hp = I64[CurrentNursery + 8] - 8;
* 4096 - 1);
//   storeCurCCSm (CmmLoad (cmmOffset dflags (CmmReg (CmmLocal tso)) (tso_CCCS dflags)) (ccsType dflags))
         CCCS = I64[_c17F::I64 + 120];</code></pre>
<p>Changes to:</p>
<pre><code>         I64[I64[CurrentTSO + 40] + 32] = Sp;
         I64[CurrentNursery + 8] = Hp + 8;
         // assume CurrentResourceContainer and nursery are consistent
         (_c17B::I64, PtrHint) = foreign &quot;ccall&quot; suspendThread((BaseReg, PtrHint), (0,));
         (_c17l::I64, &lt;pre&gt;signed&#39;) = foreign &quot;ccall&quot; cos((_c17e::I64, </code></pre>
<p>signed'));</p>
<p><code>        (_c17D::I64, PtrHint) = foreign &quot;ccall&quot; resumeThread((_c17B::I64, PtrHint));</code><br />
<code>        BaseReg = _c17D::I64;</code><br />
<code>        _c17F::I64 = CurrentTSO;</code><br />
<code>        _c17H::I64 = I64[_c17F::I64 + 40];</code><br />
<code>        Sp = I64[_c17H::I64 + 32];</code><br />
<code>        SpLim = _c17H::I64 + 208;</code><br />
<code>        HpAlloc = 0;</code><br />
<code>        Hp = I64[CurrentNursery + 8] - 8;</code></p>
<ul>
<li>4096 - 1);</li>
</ul>
<p><code>        // (once again, using implicit Hp)</code><br />
<code>        R1 = _c17l::I64;</code></p>
</pre>
<p>No change from unprofiled</p>
<h2 id="case-split">Case split</h2>
<p>Do a nursery swap.</p>
<ul>
<li><ul>
<li>Warning:** The rest of this document describes an old iteration of the system, which directly used</li>
</ul></li>
</ul>
<h2 id="front-end-changes">Front-end changes</h2>
<p>The basic idea behind this patch is that data collected during **profiling** can also be used at runtime to enforce limits. So most of the API involves (1) dynamically setting cost-centres, which GHC uses to do profiling, and (2) querying and receiving callbacks when certain events happen during profiling. Costs can be collected anywhere you could have placed an</p>
<pre><code>SCC</code></pre>
<p>annotation statically.</p>
<pre><code>-- | A cost-centre; not garbage-collected.
data CostCentre

-- | A cost-centre stack.  Cost-centres are composed into cost-centre
-- stacks, for which costs are actually attributed.  Cost-centre stacks
-- are not garbage-collected.
data CostCentreStack

-- | A listener on a cost-centre stack.  Active listeners are considered
-- roots, so be sure to unlisten when you are done.
data Listener

-- | Type of profiling information to track.  We currently support two
-- types: instantaneous heap residence, and overall memory allocation
-- (which is monotonically increasing).
data ProfType = Resident | Allocated

-- | Allocates a new cost-centre.
newCC :: IO CostCentre

-- | Pushes a cost-centre onto a new cost-centre stack.  This function
-- is memoized, so if you push the same CostCentre onto the same CostCentreStack, you will
-- get the same CostCentreStack back.
pushCC :: CostCentreStack -&gt; CostCentre -&gt; IO CostCentreStack

-- | Attaches a listener to a cost-centre.  The resolution of the
-- listener depends on the type and runtime options.  For resident
-- memory listeners, listeners are checked whenever a heap census is run
-- (which is controllable using @-i@).  For allocated memory listeners,
-- listeners are checked every GC.  When you are no longer interested
-- in events from a listener, make sure you unregister the listener, or
-- you will leak memory.
listenCCS :: CostCentreStack -&gt; ProfType -&gt; Int -&gt; IO () -&gt; IO Listener

-- | Unregisters a listener, so that it action will no longer be run.
unlistenCCS :: Listener -&gt; IO ()

-- | Sets the cost-centre of a object on the heap.
setCCSOf :: CostCentreStack -&gt; a -&gt; IO ()

-- | Runs an IO action with the CostCentreCS set to @ccs@.
withCCS :: CostCentreStack -&gt; IO a -&gt; IO a

-- | Allocates a new dynamic cost-centre stack; generally, if you want
-- something to check usage, this is what you want.
newCCS :: IO CostCentreStack

-- | Queries for memory statistics about a cost-centre stack.
queryCCS :: CostCentreStack -&gt; ProfType -&gt; IO Int

-- | Root cost-center stack for dynamically allocated cost center
-- stacks.
ccsDynamic :: CostCentreStack</code></pre>
<p>The general usage of this API goes like:</p>
<pre><code>f n =
    let xs = [1..n::Integer]
* product xs

newCCS :: IO CCS
newCCS = pushCC ccsDynamic =&lt;&lt; newCC

main = do
  m &lt;- newEmptyMVar
  forkIO $ do
    x &lt;- newCCS
    tid &lt;- myThreadId
    l &lt;- listenCCS x 2000 (putStrLn &quot;Too much memory is being used&quot; &gt;&gt; killThread tid)
    withCCS x $ do
      evaluate (f 20000)
    unlistenCostCentreStack l
    putMVar m ()
  takeMVar m</code></pre>
<p>Another use-case is more fine-grained SCCs based on runtime properties, not source-level features.</p>
<p>I am planning on providing semantics, based on GHC</p>
<h1 id="garbage-collection-roots">Garbage Collection Roots</h1>
<p>The &quot;roots&quot; are the set of pointers that the GC starts traversing from, i.e. the roots of the live object graph.</p>
<p>Most roots belong to a particular Capability. Traversing the roots of a capbility is done by</p>
<pre><code>markSomeCapabilities()</code></pre>
<p>in <a href="GhcFile(rts/Capability.c)" class="uri" title="wikilink">GhcFile(rts/Capability.c)</a>. The roots of a Capability are:</p>
<ul>
<li>The run queue (head and tail)</li>
<li>The wakeup queue (head and tail)</li>
<li>For each Task on the
<pre><code>suspended_ccalling_tasks</code></pre>
<p>list, the TSO for that Task</p></li>
<li>The Spark Pool</li>
<li>Only for the non-threaded RTS: The blocked queue (head and tail), and the sleeping queue</li>
</ul>
<p>In addition, each Capability has a [wiki:Commentary/Rts/Storage/GC/RememberedSets remembered set] for each generation. A remembered set is a source of roots if that generation is <em>not</em> being collected during this cycle; otherwise the remembered set is discarded. During GC, all remembered sets are discarded and new ones will be constructed for each generation and Capability; see</p>
<pre><code>scavenge_capability_mut_lists()</code></pre>
<p>in <a href="GhcFile(rts/sm/Scav.c)" class="uri" title="wikilink">GhcFile(rts/sm/Scav.c)</a>.</p>
<p>There are also roots from other parts of the system:</p>
<ul>
<li>Signal handlers (only in the non-threaded RTS; in the threaded RTS signal handlers are maintained by the IO manager in
<pre><code>GHC.Conc</code></pre>
<p>rather than the RTS).</p></li>
<li>[wiki:Commentary/Rts/Storage/GC/Weak Weak pointers]</li>
<li>[wiki:Commentary/Rts/Stable Stable pointers]</li>
</ul>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="ghc-source-tree-roadmap-rts">GHC Source Tree Roadmap: rts/</h1>
<p>This directory contains the source code for the runtime system.</p>
<p>There are three types of files:</p>
<p>;</p>
<pre><code>.h</code></pre>
<dl>

<dd>Header files that are <em>private to the RTS</em>. That is, header files in this directory are
</dd>
</dl>
<p><code>  not shipped with GHC, and APIs they define are therefore intended to be private and not</code><br />
<code>  usable by client code (in practice, we do not and probably cannot enforce this).  Header</code><br />
<code>  files that we </code><em><code>do</code></em><code> ship with GHC are in the [wiki:Commentary/SourceTree/Includes includes]</code><br />
<code>  directory.</code></p>
<p>;</p>
<pre><code>.c</code></pre>
<dl>

<dd>C source code for the runtime system. Conventions used in this code are described in
</dd>
</dl>
<p><code>  [wiki:Commentary/Rts/Conventions].</code></p>
<p>;</p>
<pre><code>.cmm</code></pre>
<dl>

<dd>C-- code for parts of the runtime that are part of the Haskell execution environment: for
</dd>
</dl>
<p><code>  example, the implementation of primitives, exceptions, and so on.  A </code></p>
<pre><code>.cmm</code></pre>
<p>file is</p>
<p><code>  pseudo C--: more or less C-- syntax with some omissions and some additional macro-like</code><br />
<code>  extensions implemented by GHC.  The </code></p>
<pre><code>.cmm</code></pre>
<p>files are compiled using GHC itself: see</p>
<p><code>  [wiki:Commentary/Rts/Cmm].</code></p>
<h3 id="subdirectories-of-rts">Subdirectories of rts/</h3>
<p>;</p>
<pre><code>posix/</code></pre>
<dl>

<dd><pre><code>win32/</code></pre>
<dl>

<dd><dl>

<dd>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p><code>  POSIX and Win32-specific parts of the runtime respectively.  We try to put platform-specific stuff in these directories,</code><br />
<code>  however not all of the RTS follows this convention right now.</code></p>
<p>;</p>
<pre><code>hooks/</code></pre>
<dl>

<dd>Hooks for changing the RTS behaviour from client code, eg. changing the default heap size.
</dd>
</dl>
<p><code>  (see </code><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#rts-hooks"><code>User's</code> <code>Guide</code> <code>for</code> <code>more</code> <code>about</code> <code>hooks</code></a><code>).</code></p>
<p>;</p>
<pre><code>sm/</code></pre>
<dl>

<dd>The [wiki:Commentary/Rts/Storage Storage Manager].
</dd>
</dl>
<h3 id="haskell-execution">Haskell Execution</h3>
<p>All this code runs on the Haskell side of the Haskell/C divide;</p>
<pre><code>StgCRun</code></pre>
<p>is the interface between the two layers.</p>
<p>; <a href="http://darcs.haskell.org/ghc/rts/Apply.cmm">Apply.cmm</a>, <a href="http://darcs.haskell.org/ghc/rts/AutoApply.h">AutoApply.h</a>,</p>
<pre><code>AutoApply.cmm</code></pre>
<p>, <a href="http://darcs.haskell.org/ghc/rts/Apply.h">Apply.h</a></p>
<dl>

<dd>The eval/apply machinery. Note:
<pre><code>AutoApply.cmm</code></pre>
<p>is the family</p>
</dd>
</dl>
<p><code> of functions for performing generic application of unknown</code><br />
<code> functions, this code depends on the number of registers available</code><br />
<code> for argument passing, so it is generated automatically by the program</code><br />
<code> </code></p>
<pre><code>genapply</code></pre>
<p>in</p>
<pre><code>utils/genapply</code></pre>
<p>.</p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Exception.cmm">Exception.cmm</a></dt>
<dd>Support for execptions.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/HeapStackCheck.cmm">HeapStackCheck.cmm</a></dt>
<dd>Code for preparing the stack when the current Haskell thread needs
</dd>
</dl>
<p><code> to return to the RTS, because we either ran out of heap or stack, or</code><br />
<code> need to block (eg. </code></p>
<pre><code>takeMVar</code></pre>
<p>), or yield.</p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/PrimOps.cmm">PrimOps.cmm</a></dt>
<dd>Implementation of out-of-line primitives (see [wiki:Commentary/PrimOps]).
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/StgMiscClosures.cmm">StgMiscClosures.cmm</a></dt>
<dd>Some built-in closures, such as the family of small
<pre><code>Int</code></pre>
<p>s and</p>
</dd>
</dl>
<pre><code>Chars</code></pre>
<p>, and some built-in info tables such as</p>
<pre><code>BLACKHOLE</code></pre>
<p><code> and </code></p>
<pre><code>ARR_WORDS</code></pre>
<p>.</p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/StgStartup.cmm">StgStartup.cmm</a></dt>
<dd>Code that executes when a Haskell thread begins and ends.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/StgStdThunks.cmm">StgStdThunks.cmm</a></dt>
<dd>Some built-in thunks: [wiki:Commentary/Rts/Storage/HeapObjects#Selectorthunks selector thunks] and &quot;apply&quot; thunks.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Updates.cmm">Updates.cmm</a>, <a href="http://darcs.haskell.org/ghc/rts/Updates.h">Updates.h</a></dt>
<dd>[wiki:Commentary Updates].
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/HCIncludes.h">HCIncludes.h</a></dt>
<dd>Header file included when compiling
<pre><code>.cmm</code></pre>
<p>files via C.</p>
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/StgCRun.c">StgCRun.c</a>, <a href="http://darcs.haskell.org/ghc/rts/StgRun.h">StgRun.h</a></dt>
<dd>The interface between the C execution layer and the Haskell
</dd>
</dl>
<p><code> execution layer.</code></p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/StgPrimFloat.c">StgPrimFloat.c</a></dt>
<dd>Floating-point stuff.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/STM.c">STM.c</a></dt>
<dd>Implementation of Software Transactional Memory.
</dd>
</dl>
<h3 id="the-wikicommentaryrtsstorage-storage-manager">The [wiki:Commentary/Rts/Storage Storage Manager]</h3>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/sm/Storage.c">sm/Storage.c</a></dt>
<dd>Top-level of the storage manager.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/sm/MBlock.c">sm/MBlock.c</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/MBlock.h">sm/MBlock.h</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/OSMem.h">sm/OSMem.h</a></dt>
<dd>The &quot;megablock&quot; allocator; this is the thin layer between the RTS and
</dd>
</dl>
<p><code> the operating system for allocating memory.</code></p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/sm/BlockAlloc.c">sm/BlockAlloc.c</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/BlockAlloc.h">sm/BlockAlloc.h</a></dt>
<dd>The low-level block allocator, requires only
<pre><code>MBlock</code></pre>
<p>.</p>
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/sm/GC.c">sm/GC.c</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/Scav.c">sm/Scav.c</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/Evac.c">sm/Evac.c</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/GCUtils.c">sm/GCUtils.c</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/MarkWeak.c">sm/MarkWeak.c</a></dt>
<dd>The generational copying garbage collector.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/sm/Compact.c">sm/Compact.c</a>, <a href="http://darcs.haskell.org/ghc/rts/sm/Compact.h">sm/Compact.h</a></dt>
<dd>The compacting garbage collector.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/ClosureFlags.c">ClosureFlags.c</a></dt>
<dd>Determining properties of various types of closures.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Sanity.c">Sanity.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Sanity.h">Sanity.h</a></dt>
<dd>A sanity-checker for the heap and related data structures.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Stats.c">Stats.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Stats.h">Stats.h</a></dt>
<dd>Statistics for the garbage collector and storage manager.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Stable.c">Stable.c</a></dt>
<dd>Stable names and stable pointers.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Weak.c">Weak.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Weak.h">Weak.h</a></dt>
<dd>Weak pointers.
</dd>
</dl>
<h3 id="data-structures">Data Structures</h3>
<p>Data structure abstractions for use in the RTS:</p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Arena.c">Arena.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Arena.h">Arena.h</a></dt>
<dd>An arena allocator
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Hash.c">Hash.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Hash.h">Hash.h</a></dt>
<dd>A generic hash table implementation.
</dd>
</dl>
<h3 id="the-wikicommentaryrtsscheduler-scheduler">The [wiki:Commentary/Rts/Scheduler Scheduler]</h3>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Capability.c">Capability.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Capability.h">Capability.h</a></dt>
<dd>Capabilities: virtual CPUs for executing Haskell code.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/RaiseAsync.c">RaiseAsync.c</a>, <a href="http://darcs.haskell.org/ghc/rts/RaiseAsync.h">RaiseAsync.h</a></dt>
<dd>Asynchronous exceptions.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Schedule.c">Schedule.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Schedule.h">Schedule.h</a></dt>
<dd>The scheduler itself.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Sparks.c">Sparks.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Sparks.h">Sparks.h</a></dt>
<dd>Sparks: the implementation of
<pre><code>par</code></pre>
<p>.</p>
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/ThreadLabels.c">ThreadLabels.c</a>, <a href="http://darcs.haskell.org/ghc/rts/ThreadLabels.h">ThreadLabels.h</a></dt>
<dd>Labelling threads.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Threads.c">Threads.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Threads.h">Threads.h</a></dt>
<dd>Various thread-related functionality.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/ThreadPaused.c">ThreadPaused.c</a></dt>
<dd>Suspending a thread before it returns to the RTS.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Task.c">Task.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Task.h">Task.h</a></dt>
<dd>Task: an OS-thread abstraction.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/AwaitEvent.h">AwaitEvent.h</a></dt>
<dd>Waiting for events (non-threaded RTS only).
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Timer.c">Timer.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Timer.h">Timer.h</a>, <a href="http://darcs.haskell.org/ghc/rts/Ticker.h">Ticker.h</a></dt>
<dd>The runtime's interval timer, used for context switching and profiling.
</dd>
</dl>
<h3 id="c-files-the-wikicommentaryrtsffi-ffi">C files: the [wiki:Commentary/Rts/FFI FFI]</h3>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Adjustor.c">Adjustor.c</a></dt>
<dd>Very hairy support for
<pre><code>foreign import &quot;wrapper&quot;</code></pre>
<p>.</p>
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/HsFFI.c">HsFFI.c</a>, <a href="http://darcs.haskell.org/ghc/rts/RtsAPI.c">RtsAPI.c</a></dt>
<dd>Implementation of the Haskell FFI C interface:
<pre><code>hs_init()</code></pre>
<p>,</p>
</dd>
</dl>
<pre><code>hs_exit()</code></pre>
<p>, etc.</p>
<h3 id="the-wikicommentaryrtsinterpreter-byte-code-interpreter">The [wiki:Commentary/Rts/Interpreter Byte-code Interpreter]</h3>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Disassembler.c">Disassembler.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Disassembler.h">Disassembler.h</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/Interpreter.c">Interpreter.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Interpreter.h">Interpreter.h</a>::
</dd>
</dl>
<p><code> The [wiki:Commentary/Rts/Interpreter byte-code interpreter] and disassembler.</code></p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Linker.c">Linker.c</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/LinkerInternals.h">LinkerInternals.h</a>
</dd>
</dl>
<p><code> The [wiki:Commentary/Rts/Linker dynamic object-code linker].</code></p>
<h3 id="wikicommentaryprofiling-profiling">[wiki:Commentary/Profiling Profiling]</h3>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/LdvProfile.c">LdvProfile.c</a>, <a href="http://darcs.haskell.org/ghc/rts/LdvProfile.h">LdvProfile.h</a></dt>
<dd>Lag-drag-void profiling (also known as Biographical Profiling).
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/ProfHeap.c">ProfHeap.c</a>, <a href="http://darcs.haskell.org/ghc/rts/ProfHeap.h">ProfHeap.h</a></dt>
<dd>Generic heap-profilng support.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Profiling.c">Profiling.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Profiling.h">Profiling.h</a></dt>
<dd>Generic profilng support.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Proftimer.c">Proftimer.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Proftimer.h">Proftimer.h</a></dt>
<dd>The profiling timer.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/RetainerProfile.c">RetainerProfile.c</a>, <a href="http://darcs.haskell.org/ghc/rts/RetainerProfile.h">RetainerProfile.h</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/RetainerSet.c">RetainerSet.c</a>, <a href="http://darcs.haskell.org/ghc/rts/RetainerSet.h">RetainerSet.h</a>::
</dd>
</dl>
<p><code> Retainer profiling.</code></p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Ticky.c">Ticky.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Ticky.h">Ticky.h</a></dt>
<dd>Ticky-ticky profiling (currently defunct; needs reviving).
</dd>
</dl>
<h3 id="rts-debugging">RTS Debugging</h3>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Printer.c">Printer.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Printer.h">Printer.h</a></dt>
<dd>Generic printing for heap objects and stacks (not used much).
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Trace.c">Trace.c</a>, <a href="http://darcs.haskell.org/ghc/rts/Trace.h">Trace.h</a></dt>
<dd>Generic support for various kinds of trace and debugging messages.
</dd>
</dl>
<h3 id="the-front-panel">The Front Panel</h3>
<p>The front panel is currently defunct. It offers a graphical view of the running Haskell program in real time, and was pretty cool when it worked.</p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/FrontPanel.c">FrontPanel.c</a>, <a href="http://darcs.haskell.org/ghc/rts/FrontPanel.h">FrontPanel.h</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/VisCallbacks.c">VisCallbacks.c</a>, <a href="http://darcs.haskell.org/ghc/rts/VisCallbacks.h">VisCallbacks.h</a>::
</dd>
<dt><a href="http://darcs.haskell.org/ghc/rts/VisSupport.c">VisSupport.c</a>, <a href="http://darcs.haskell.org/ghc/rts/VisSupport.h">VisSupport.h</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/VisWindow.c">VisWindow.c</a>, <a href="http://darcs.haskell.org/ghc/rts/VisWindow.h">VisWindow.h</a>::
</dd>
</dl>
<h3 id="other">Other</h3>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/Main.c">Main.c</a></dt>
<dd>The C
<pre><code>main()</code></pre>
<p>function for a standalone Haskell program;</p>
</dd>
</dl>
<p><code> basically this is just a client of </code></p>
<pre><code>HsFFI.h</code></pre>
<p>.</p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/RtsFlags.c">RtsFlags.c</a></dt>
<dd>Understands the
<pre><code>+RTS ... -RTS</code></pre>
<p>flags.</p>
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/RtsMessages.c">RtsMessages.c</a></dt>
<dd>Support for emitting messages from the runtime.
</dd>
</dl>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/RtsSignals.c">RtsSignals.c</a>, <a href="http://darcs.haskell.org/ghc/rts/RtsSignals.h">RtsSignals.h</a></dt>
<dd>Signal-related stuff.
</dd>
</dl>
<p>Miscellaneous stuff:</p>
<dl>
<dt><a href="http://darcs.haskell.org/ghc/rts/RtsUtils.c">RtsUtils.c</a>, <a href="http://darcs.haskell.org/ghc/rts/RtsUtils.h">RtsUtils.h</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/GetTime.h">GetTime.h</a>::
</dd>
<dt><a href="http://darcs.haskell.org/ghc/rts/PosixSource.h">PosixSource.h</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/Prelude.h">Prelude.h</a>::
</dd>
<dt><a href="http://darcs.haskell.org/ghc/rts/Typeable.c">Typeable.c</a></dt>
<dd><a href="http://darcs.haskell.org/ghc/rts/RtsDllMain.c">RtsDllMain.c</a>::
</dd>
</dl>
<h3 id="old-stuff">OLD stuff</h3>
<p>;</p>
<pre><code>parallel/</code></pre>
<dl>

<dd>Code for GUM: parallel GHC. This is heavily bitrotted and currently doesn't work (as of GHC 6.6; it last worked around
</dd>
</dl>
<ol>
<li>02 I believe).</li>
</ol>
<p>;</p>
<pre><code>dotnet/</code></pre>
<dl>

<dd>Bitrotted code for GHC.NET.
</dd>
</dl>
<h1 id="sanity-checking">Sanity Checking</h1>
<p>Source code: <a href="GhcFile(rts/Sanity.c)" class="uri" title="wikilink">GhcFile(rts/Sanity.c)</a>, <a href="GhcFile(rts/Sanity.h)" class="uri" title="wikilink">GhcFile(rts/Sanity.h)</a>.</p>
<p>The purpose of sanity checking is to catch bugs in the RTS as early as possible; if the program is going to crash, we want it to crash as soon as possible after the error occurred. The problem with debugging the RTS is that heap corruption can go unnoticed through several GC cycles, making it particularly difficult to trace back to the erroneous code.</p>
<p>Sanity checking is turned on by the</p>
<pre><code>+RTS -DS` option.  We treat it like an expensive assertion: normal assertions are allowed to take a few extra percent of run time, so we don&#39;t mind having them on all the time in a `DEBUG` RTS, but sanity checking may double the run time of the program or worse.  So the rule of thumb is that expensive assertions go into sanity checking, cheap assertions are on in `DEBUG</code></pre>
<p>, or possibly even on all the time.</p>
<p>Sanity checking does a complete traversal of the heap after each GC to look for dangling pointers (see</p>
<pre><code>checkHeap` in [[GhcFile(rts/Sanity.c)]]).  For this it needs to ensure that there is no [wiki:Commentary/Rts/Storage/Slop slop], which is why we can only do this in a `DEBUG` runtime: the slop-avoiding machinery is only on with `DEBUG</code></pre>
<p>.</p>
<p>Sanity checking also turns on some other expensive checks: for example in the [wiki:Commentary/Rts/HaskellExecution#Genericapply generic apply] code we check that the arguments point to valid closures.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="the-scheduler">The Scheduler</h1>
<p>The scheduler is the heart of the runtime: it is the single part of the system through which all entry to the Haskell world goes, and it handles requests from outside to invoke Haskell functions (foreign export).</p>
<p>In this part of the commentary we'll discuss the <em>threaded</em> version of the runtime (see [wiki:Commentary/Rts/Config]), that is, the version of the runtime that uses multiple OS threads, because it is by far the most complex beast.</p>
<p>See also <a href="http://blog.ezyang.com/2013/01/the-ghc-scheduler/">Edward Yang's blog post</a> (2013); some of the material there has been incorporated here.</p>
<p>We begin by discussing the basic abstractions used in the scheduler.</p>
<h2 id="os-threads">OS Threads</h2>
<p>Source files: <a href="GhcFile(includes/rts/OSThreads.h)" class="uri" title="wikilink">GhcFile(includes/rts/OSThreads.h)</a>, <a href="GhcFile(rts/win32/OSThreads.c)" class="uri" title="wikilink">GhcFile(rts/win32/OSThreads.c)</a>, <a href="GhcFile(rts/posix/OSThreads.c)" class="uri" title="wikilink">GhcFile(rts/posix/OSThreads.c)</a></p>
<p>We assume that the OS provides some kind of native threads, and for SMP parallelism we assume that the OS will schedule multiple OS threads across the available CPUs.</p>
<p>OS threads are only used by the runtime for two reasons:</p>
<ul>
<li>To support non-blocking foreign calls: a foreign call</li>
</ul>
<p><code>  should not block the other Haskell threads in the system from</code><br />
<code>  running, and using OS threads is the only way to ensure that.</code></p>
<ul>
<li>To support SMP parallelism.</li>
</ul>
<p>Haskell threads are much lighter-weight (at least 100x) than OS threads.</p>
<p>When running on an SMP, we begin by creating the number of OS threads specified by the</p>
<pre><code>+RTS -N` option, although during the course of running the program more OS threads might be created in order to continue running Haskell code while foreign calls execute.  Spare OS threads are kept in a pool attached to each `Capability</code></pre>
<p>(see [#Capabilities]).</p>
<p>The RTS provides a platform-independent abstraction layer for OS threads in <a href="GhcFile(includes/rts/OSThreads.h)" class="uri" title="wikilink">GhcFile(includes/rts/OSThreads.h)</a>.</p>
<h2 id="haskell-threads">Haskell threads</h2>
<p>A Haskell thread is represented by a Thread State Object ([wiki:Commentary/Rts/Storage/HeapObjects#ThreadStateObjects TSO]). These objects are <em>garbage-collected</em>, like other closures in Haskell. The TSO, along with the stack allocated with it (STACK), constitute the primary memory overhead of a thread. Default stack size, in particular, is controlled by the GC flag</p>
<pre><code>-ki</code></pre>
<p>, and is 1k by default (Actually, your usable stack will be a little smaller than that because this size also includes the size of the</p>
<pre><code>StgTSO</code></pre>
<p>struct, so that a lot of allocated threads will fit nicely into a single block.) There are two kinds of Haskell thread:</p>
<ul>
<li>A <em>bound</em> thread is created as the result of a <em>call-in</em> from</li>
</ul>
<p><code>  outside Haskell; that is, a call to </code></p>
<pre><code>foreign export</code></pre>
<p>or</p>
<pre><code>foreign import &quot;wrapper&quot;</code></pre>
<p>. A bound thread is tied to the</p>
<p><code>  OS thread that made the call; all further foreign calls made by</code><br />
<code>  this Haskell thread are made in the same OS thread.  (this is part</code><br />
<code>  of the design of the FFI, described in the paper </code><br />
<code>  </code><a href="http://www.haskell.org/~simonmar/papers/conc-ffi.pdf"><code>Extending</code> <code>the</code> <code>Haskell</code> <code>Foreign</code> <code>Function</code> <code>Inteface</code> <code>with</code> <code>Concurrency</code></a><code>).</code></p>
<ul>
<li>An <em>unbound</em> thread is created by</li>
</ul>
<pre><code>Control.Concurrent.forkIO</code></pre>
<p>. Foreign calls made by an unbound</p>
<p><code>  thread are made by an arbitrary OS thread.</code></p>
<p>Initialization of TSOs is handled in</p>
<pre><code>createThread</code></pre>
<p>in <a href="GhcFile(rts/Threads.c)" class="uri" title="wikilink">GhcFile(rts/Threads.c)</a>; this function is in turn invoked by</p>
<pre><code>createGenThread</code></pre>
<p>,</p>
<pre><code>createIOThread</code></pre>
<p>and</p>
<pre><code>createStrictIOThread</code></pre>
<p>in <a href="GhcFile(rts/RtsAPI.c)" class="uri" title="wikilink">GhcFile(rts/RtsAPI.c)</a>. These functions setup the initial stack state, which controls what the thread executes when it actually gets run. These functions are the ones invoked by the</p>
<pre><code>fork#</code></pre>
<p>and other primops (recall entry-points for primops are located in <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a>).</p>
<p>Being garbage collected has two major implications for TSOs. First, TSOs are not GC roots, so they will get GC'd if there is nothing holding on to them (e.g. <a href="http://blog.ezyang.com/2011/07/blockedindefinitelyonmvar">in the case of deadlock</a>), and their space is not automatically reclaimed when they finish executing (so</p>
<pre><code>ThreadId</code></pre>
<p>can cause memory leaks</p>
</pre>
<p>. Usually, a TSO will be retained by a Capability</p>
<h1 id="seq-magic">Seq magic</h1>
<p>The innocent-looking</p>
<pre><code>seq</code></pre>
<p>operator causes all manner of mayhem in GHC. This page summarises the issues. See also discussion in Trac #5129, #5262</p>
<h2 id="the-baseline-position">The baseline position</h2>
<p>Our initial story was that</p>
<pre><code>(seq e1 e2)</code></pre>
<p>meant precisely</p>
<pre><code>   case e1 of { _ -&gt; e2 }</code></pre>
<p>Indeed this was</p>
<pre><code>seq</code></pre>
<p>'s inlining. This translation validates some important rules</p>
<pre><code>* &lt;pre&gt;seq</code></pre>
<p>is strict in both its arguments</p>
<ul>
<li>(e1
<pre><code>seq` e2) e3            ===&gt;   e1 `seq</code></pre>
<p>(e2 e3)</p></li>
<li>case (e1
<pre><code>seq` e2) of alts  ===&gt;   e1 `seq</code></pre>
<p>(case e2 of alts)</p></li>
<li>value
<pre><code>seq</code></pre>
<p>e ===&gt; e</p></li>
</ul>
</pre>
<p>But this approach has problems; see</p>
<pre><code>Note [Deguaring seq]` in `DsUtils</code></pre>
<p>.</p>
<h3 id="problem-1-trac-1031">Problem 1 (Trac #1031)</h3>
<p>Consider</p>
<pre><code>   f x y = x &lt;pre&gt;seq` (y `seq</code></pre>
<p>(# x,y #))</p>
</pre>
<p>The</p>
<pre><code>[CoreSyn let/app invariant]` (see `CoreSyn</code></pre>
<p>) means that, other things being equal, because the argument to the outer</p>
<pre><code>seq</code></pre>
<p>has an unlifted type, we'll use call-by-value thus:</p>
<pre><code>   f x y = case (y &lt;pre&gt;seq` (# x,y #)) of v -&gt; x `seq</code></pre>
<p>v</p>
</pre>
<p>But that is bad for two reasons:</p>
<ul>
<li>we now evaluate
<pre><code>y` before `x</code></pre>
<p>, and</p></li>
<li>we can't bind
<pre><code>v</code></pre>
<p>to an unboxed pair</p></li>
</ul>
<p>Seq is very, very special! Treating it as a two-argument function, strict in both arguments, doesn't work. We &quot;fixed&quot; this by treating</p>
<pre><code>seq</code></pre>
<p>as a language construct, desugared by the desugarer, rather than as a function that may (or may not) be inlined by the simplifier. So the above term is desugared to:</p>
<pre><code>        case x of _ -&gt; case y of _ -&gt; (# x,y #)</code></pre>
<h3 id="problem-2-trac-2273">Problem 2 (Trac #2273)</h3>
<p>Consider</p>
<pre><code>   let chp = case b of { True -&gt; fst x; False -&gt; 0 }
   in chp &lt;pre&gt;seq</code></pre>
<p>...chp...</p>
</pre>
<p>Here the</p>
<pre><code>seq` is designed to plug the space leak of retaining `(snd x)</code></pre>
<p>for too long.</p>
<p>If we rely on the ordinary inlining of</p>
<pre><code>seq</code></pre>
<p>, we'll get</p>
<pre><code>   let chp = case b of { True -&gt; fst x; False -&gt; 0 }
   case chp of _ { I# -&gt; ...chp... }</code></pre>
<p>But since</p>
<pre><code>chp</code></pre>
<p>is cheap, and the case is an alluring contet, we'll inline</p>
<pre><code>chp` into the case scrutinee.  Now there is only one use of `chp</code></pre>
<p>, so we'll inline a second copy. Alas, we've now ruined the purpose of the seq, by re-introducing the space leak:</p>
<pre><code>    case (case b of {True -&gt; fst x; False -&gt; 0}) of
      I# _ -&gt; ...case b of {True -&gt; fst x; False -&gt; 0}...</code></pre>
<p>We can try to avoid doing this by ensuring that the binder-swap in the case happens, so we get his at an early stage:</p>
<pre><code>   case chp of chp2 { I# -&gt; ...chp2... }</code></pre>
<p>But this is fragile. The real culprit is the source program. Perhaps we should have said explicitly</p>
<pre><code>   let &lt;nowiki&gt;chp2&lt;/nowiki&gt; = chp in ...chp2...</code></pre>
<p>But that's painful. So the desugarer does a little hack to make</p>
<pre><code>seq</code></pre>
<p>more robust: a saturated application of</p>
<pre><code>seq</code></pre>
<p>is turned <strong>directly</strong> into the case expression, thus:</p>
<pre><code>   x  &lt;pre&gt;seq</code></pre>
<p>e2 ==&gt; case x of x -&gt; e2 -- Note shadowing!</p>
<p><code>  e1 </code></p>
<pre><code>seq</code></pre>
<p>e2 ==&gt; case x of _ -&gt; e2</p>
</pre>
<p>So we desugar our example to:</p>
<pre><code>   let chp = case b of { True -&gt; fst x; False -&gt; 0 }
   case chp of chp { I# -&gt; ...chp... }</code></pre>
<p>And now all is well.</p>
<p>Be careful not to desugar</p>
<pre><code>   True &lt;pre&gt;seq</code></pre>
<p>e ==&gt; case True of True { ... }</p>
</pre>
<p>which stupidly tries to bind the datacon 'True'. This is easily avoided.</p>
<p>The whole thing is a hack though; if you define</p>
<pre><code>mySeq=seq</code></pre>
<p>, the hack won't work on</p>
<pre><code>mySeq</code></pre>
<p>.</p>
<h3 id="problem-3-trac-5262">Problem 3 (Trac #5262)</h3>
<p>Consider</p>
<pre><code>  f x = x &lt;pre&gt;seq</code></pre>
<p>(\y.y)</p>
</pre>
<p>With the above desugaring we get</p>
<pre><code>  f x = case x of x { _ -&gt; \y.y }</code></pre>
<p>and now ete expansion gives</p>
<pre><code>  f x y = case x of x { _ -&gt; y }</code></pre>
<p>Now suppose that we have</p>
<pre><code>       f (length xs) &lt;pre&gt;seq</code></pre>
<p>3</p>
</pre>
<p>Plainly</p>
<pre><code>(length xs)` should be evaluated... but it isn&#39;t because `f</code></pre>
<p>has arity 2. (Without -O this doesn't happen.)</p>
<h3 id="problem-4-seq-in-the-io-monad">Problem 4: seq in the IO monad</h3>
<p>See the extensive discussion in Trac #5129.</p>
<h3 id="problem-5-the-need-for-special-rules">Problem 5: the need for special rules</h3>
<p>Roman found situations where he had</p>
<pre><code>      case (f n) of _ -&gt; e</code></pre>
<p>where he knew that</p>
<pre><code>f` (which was strict in `n</code></pre>
<p>) would terminate if n did. Notice that the result of</p>
<pre><code>(f n)</code></pre>
<p>is discarded. So it makes sense to transform to</p>
<pre><code>      case n of _ -&gt; e</code></pre>
<p>Rather than attempt some general analysis to support this, I've added enough support that you can do this using a rewrite rule:</p>
<pre><code>  RULE &quot;f/seq&quot; forall n e.  seq (f n) e = seq n e</code></pre>
<p>You write that rule. When GHC sees a case expression that discards its result, it mentally transforms it to a call to</p>
<pre><code>seq</code></pre>
<p>and looks for a RULE. (This is done in</p>
<pre><code>Simplify.rebuildCase</code></pre>
<p>.) As usual, the correctness of the rule is up to you.</p>
<p>To make this work, we need to be careful that</p>
<pre><code>seq</code></pre>
<p>is <strong>not</strong> desguared into a case expression on the LHS of a rule.</p>
<p>To increase applicability of these user-defined rules, we also have the following built-in rule for</p>
<pre><code>seq</code></pre>
<pre><code>  seq (x |&gt; co) y = seq x y</code></pre>
<p>This eliminates unnecessary casts and also allows other seq rules to match more often. Notably,</p>
<pre><code>   seq (f x |&gt; co) y  --&gt;  seq (f x) y
  </code></pre>
<p>and now a user-defined rule for</p>
<pre><code>seq</code></pre>
<p>may fire.</p>
<h1 id="a-better-way">A better way</h1>
<p>Here's our new plan.</p>
<ul>
<li>Introduce a new primop
<pre><code>seq# :: a -&gt; State# s -&gt; (# a, State# s #)</code></pre>
<p>(see be5441799b7d94646dcd4bfea15407883537eaaa)</p></li>
<li>Implement
<pre><code>seq#` by turning it into the obvious eval in the backend.  In fact, since the return convention for `(# State# s, a #)` is exactly the same as for `a`, we can implement `seq# s a` by `a</code></pre>
<p>(even when it appears as a case scrutinee).</p></li>
<li>Define
<pre><code>evaluate</code></pre>
<p>thus</p></li>
</ul>
<pre><code>  evaluate :: a -&gt; IO a
  evaluate x = IO $ \s -&gt; seq# x s</code></pre>
<p>That fixes problem 4.</p>
<p>We could go on and desugar</p>
<pre><code>seq</code></pre>
<p>thus:</p>
<pre><code>   x  &lt;pre&gt;seq</code></pre>
<p>e2 ==&gt; case seq# x RW of (# x, _ #) -&gt; e2 -- Note shadowing!</p>
<p><code>  e1 </code></p>
<pre><code>seq</code></pre>
<p>e2 ==&gt; case seq# x RW of (# _, _ #) -&gt; e2</p>
</pre>
<p>and if we consider</p>
<pre><code>seq#</code></pre>
<p>to be expensive, then we won't eta-expand around it, and that would fix problem 3.</p>
<p>However, there is a concern that this might lead to performance regressions in examples like this:</p>
<pre><code>f :: Int -&gt; Int -&gt; IO Int
f x y | x &lt;pre&gt;seq</code></pre>
<p>False = undefined f x 3 = do</p>
<p><code> ... some IO monad code here ...</code></p>
</pre>
<p>so</p>
<pre><code>f</code></pre>
<p>turns into</p>
<pre><code>f = \x . \y . case seq# x RW of (# _, x #) -&gt; case y of 3 -&gt; \s . some IO monad code</code></pre>
<p>and we won't get to eta-expand the</p>
<pre><code>\s</code></pre>
<p>as we would normally do (this is pretty important for getting good performance from IO and ST monad code).</p>
<p>Arguably</p>
<pre><code>f` should be rewritten with a bang pattern, and we should treat bang patterns as the eta-expandable seq and translate them directly into `case`, not `seq#`.  But this would be a subtle difference between `seq</code></pre>
<p>and bang patterns.</p>
<p>Furthermore, we already have</p>
<pre><code>pseq`, which is supposed to be a &quot;strictly ordered seq&quot;, that is it preserves evaluation order.  So perhaps `pseq` should be the one that more accurately implements the programmer&#39;s intentions, leaving `seq</code></pre>
<p>as it currently is.</p>
<p>We are currently pondering what to do here.</p>
<h1 id="the-ghc-commentary-signals">The GHC Commentary: Signals</h1>
<p>This section describes how the RTS interacts with the OS signal facilities. Throughout we use the term &quot;signal&quot; to refer to both POSIX-style signals and Windows <em>ConsoleEvents</em>.</p>
<p>Signal handling differs between the <em>threaded</em> version of the runtime and the non-threaded version (see [wiki:Commentary/Rts/Config]). Here we discuss only the threaded version, since we expect that to become the standard version in due course.</p>
<p>Source files:</p>
<ul>
<li>POSIX signal handling:
<ul>
<li><a href="GhcFile(rts/posix/Signals.h)" class="uri" title="wikilink">GhcFile(rts/posix/Signals.h)</a>, <a href="GhcFile(rts/posix/Signals.c)" class="uri" title="wikilink">GhcFile(rts/posix/Signals.c)</a></li>
</ul></li>
<li>Windows console events:
<ul>
<li><a href="GhcFile(rts/win32/ConsoleHandler.h)" class="uri" title="wikilink">GhcFile(rts/win32/ConsoleHandler.h)</a>, <a href="GhcFile(rts/win32/ConsoleHandler.c)" class="uri" title="wikilink">GhcFile(rts/win32/ConsoleHandler.c)</a></li>
</ul></li>
</ul>
<h2 id="signal-handling-in-the-rts">Signal handling in the RTS</h2>
<p>The RTS is interested in two signals: a timer signal, and an interrupt signal.</p>
<h3 id="the-timer-signal">The timer signal</h3>
<p>The timer signal is used for several things:</p>
<ul>
<li>To cause the [wiki:Commentary/Rts/Scheduler scheduler] to context switch</li>
<li>Sampling for [wiki:Commentary/Profiling time profiling]</li>
<li>To detect deadlock (see [wiki:Commentary/Rts/Scheduler])</li>
</ul>
<p>Source files:</p>
<ul>
<li>The timer interrupt handler, and starting/stopping the timer:
<ul>
<li><a href="GhcFile(rts/Timer.h)" class="uri" title="wikilink">GhcFile(rts/Timer.h)</a>, <a href="GhcFile(rts/Timer.c)" class="uri" title="wikilink">GhcFile(rts/Timer.c)</a></li>
</ul></li>
<li>Platform-independent ticker interface, used by the timer:
<ul>
<li><a href="GhcFile(rts/Ticker.h)" class="uri" title="wikilink">GhcFile(rts/Ticker.h)</a></li>
</ul></li>
<li>Posix implementation of ticker:
<ul>
<li><a href="GhcFile(rts/posix/Itimer.h)" class="uri" title="wikilink">GhcFile(rts/posix/Itimer.h)</a>, <a href="GhcFile(rts/posix/Itimer.h)" class="uri" title="wikilink">GhcFile(rts/posix/Itimer.h)</a></li>
</ul></li>
<li>Windows implementation of ticker:
<ul>
<li><a href="GhcFile(rts/win32/Ticker.c)" class="uri" title="wikilink">GhcFile(rts/win32/Ticker.c)</a></li>
</ul></li>
</ul>
<p>On Posix, the timer signal is implemented by calling</p>
<pre><code>timer_create()` to generate regular `SIGVTALRM</code></pre>
<p>signals (this was changed from SIGALRM in #850).</p>
<p>On Windows, we spawn a new thread that repeatedly sleeps for the timer interval and then executes the timer interrupt handler.</p>
<h2 id="the-interrupt-signal">The interrupt signal</h2>
<p>The interrupt signal is</p>
<pre><code>SIGINT` on POSIX systems or `CTRL_C_EVENT/CTRL_BREAK_EVENT`on Windows, and is normally sent to the process when the user hits Control-C.   By default, interrupts are handled by the runtime.  They can be caught and handled by Haskell code instead, using `System.Posix.Signals` on POSIX systems or `GHC.ConsoleHandler</code></pre>
<p>on Windows systems. For example, [wiki:Commentary/Compiler/Backends/GHCi GHCi] hooks the interrupt signal so that it can abort the current interpreted computation and return to the prompt, rather than terminating the whole GHCi process.</p>
<p>When the interrupt signal is received, the default behaviour of the runtime is to attempt to shut down the Haskell program gracefully. It does this by calling</p>
<pre><code>interruptStgRts()</code></pre>
<p>in <a href="GhcFile(rts/Schedule.c)" class="uri" title="wikilink">GhcFile(rts/Schedule.c)</a> (see [wiki:Commentary/Rts/Scheduler#ShuttingDown]). If a second interrupt signal is received, then we terminate the process immediately; this is just in case the normal shutdown procedure failed or hung for some reason, the user is always able to stop the process with two control-C keystrokes.</p>
<h2 id="signal-handling-in-haskell-code">Signal handling in Haskell code</h2>
<p>Source files:</p>
<ul>
<li>POSIX: <a href="GhcFile(rts/posix/Signals.h)" class="uri" title="wikilink">GhcFile(rts/posix/Signals.h)</a>, <a href="GhcFile(rts/posix/Signals.c)" class="uri" title="wikilink">GhcFile(rts/posix/Signals.c)</a></li>
<li>Windows: <a href="GhcFile(rts/win32/ConsoleHandler.h)" class="uri" title="wikilink">GhcFile(rts/win32/ConsoleHandler.h)</a>, <a href="GhcFile(rts/win32/ConsoleHandler.c)" class="uri" title="wikilink">GhcFile(rts/win32/ConsoleHandler.c)</a></li>
</ul>
<p>A Haskell program can ask to install signal handlers, via the</p>
<pre><code>System.Posix.Signals` API, or `GHC.ConsoleHandler</code></pre>
<p>on Windows. When a signal arrives that has a Haskell handler, it is the job of the runtime to create a new Haskell thread to run the signal handler and place the new thread on the run queue of a suitable [wiki:Commentary/Rts/Scheduler#Capabilities Capability].</p>
<p>When the runtime is idle, the OS threads will all be waiting inside</p>
<pre><code>yieldCapability()</code></pre>
<p>, waiting for some work to arrive. We want a signal to be able to create a new Haskell thread and wake up one of these OS threads to run it, but unfortunately the range of operations that can be performed inside a POSIX signal handler is extremely limited, and doesn't include any inter-thread synchronisation (because the signal handler might be running on the same stack as the OS thread it is communicating with).</p>
<p>The solution we use, on both Windows and POSIX systems, is to pass all signals that arrive to the [wiki:Commentary/Rts/IOManager IO Manager] thread. On POSIX this works by sending the signal number down a pipe, on Windows it works by storing the signal number in a buffer and signaling the IO Manager's</p>
<pre><code>Event</code></pre>
<p>object to wake it up. The IO Manager thread then wakes up and creates a new thread for the signal handler, before going back to sleep again.</p>
<h2 id="rts-alarm-signals-and-foreign-libraries">RTS Alarm Signals and Foreign Libraries</h2>
<p>When using foreign libraries through the Haskell FFI, it is important to ensure that the foreign code is capable of dealing with system call interrupts due to alarm signals GHC is generating.</p>
<p>For example, in this</p>
<pre><code>strace</code></pre>
<p>output a</p>
<pre><code>select</code></pre>
<p>call is interrupted, but the foreign C code interprets the interrupt as an application error and closes a critical file descriptor:</p>
<pre><code>[pid 22338] send(7, &quot;\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0
    \0\0\0\0\0\0\0\0\0\0\0&quot;..., 116, MSG_NOSIGNAL) = 116
[pid 22338] select(8, [7], NULL, NULL, NULL) = ? ERESTARTNOHAND (To be restarted)
[pid 22338] --- SIGVTALRM (Virtual timer expired) @ 0 (0) ---
[pid 22338] sigreturn()                 = ? (mask now [])
[pid 22338] gettimeofday({1267656511, 467069}, NULL) = 0
[pid 22338] stat64(&quot;/etc/localtime&quot;, {st_mode=S_IFREG|0644, st_size=3519, ...}) = 0
[pid 22338] write(6, &quot;Communication failed in RPC&quot;..., 176) = 176
[pid 22338] close(7)                    = 0</code></pre>
<p>Once the C code was modified to deal with the interrupt properly, it proceeded correctly (note that foreign call is restarted 3 times before it succeeds).</p>
<pre><code>[pid 23967] send(7, &quot;\f\0\0\0\244\1\0\0\0\0\0\0B\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;..., 536, MSG_NOSIGNAL &lt;unfinished ...&gt;
[pid 23968] &lt;... select resumed&gt; )      = ? ERESTARTNOHAND (To be restarted)
[pid 23968] --- SIGVTALRM (Virtual timer expired) @ 0 (0) ---
[pid 23968] sigreturn()                 = ? (mask now [])
[pid 23968] futex(0x9b52a88, FUTEX_WAIT_PRIVATE, 7, NULL &lt;unfinished ...&gt;
[pid 23967] &lt;... send resumed&gt; )        = 536
[pid 23967] select(8, [7], NULL, NULL, NULL) = ? ERESTARTNOHAND (To be restarted)
[pid 23967] --- SIGVTALRM (Virtual timer expired) @ 0 (0) ---
[pid 23967] sigreturn()                 = ? (mask now [])
[pid 23967] select(8, [7], NULL, NULL, NULL) = ? ERESTARTNOHAND (To be restarted)
[pid 23967] --- SIGVTALRM (Virtual timer expired) @ 0 (0) ---
[pid 23967] sigreturn()                 = ? (mask now [])
[pid 23967] select(8, [7], NULL, NULL, NULL) = 1 (in [7])
[pid 23967] recv(7, &quot;\7\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\244]\0\0\0\0\0\0\0\0\0\0&quot;..., 116, 0) = 116</code></pre>
<h1 id="slop">Slop</h1>
<p>Slop is unused memory between objects in the heap.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Object1</p></td>
<td align="left"><p>... Slop ...</p></td>
<td align="left"><p>Object2</p></td>
</tr>
</tbody>
</table>
<h2 id="why-do-we-want-to-avoid-slop">Why do we want to avoid slop?</h2>
<p>Slop makes it difficult to traverse an area of memory linearly, visiting all the objects, because we can't tell where</p>
<pre><code>Object2</code></pre>
<p>starts in the above diagram. We need to do linear traversals for two reasons, currently:</p>
<ul>
<li>[wiki:Commentary/Profiling/Heap Heap profiling] needs to perform a census on the whole heap.</li>
<li>[wiki:Commentary/Rts/Sanity Sanity checking] needs to ensure that all the pointers in the heap</li>
</ul>
<p><code>  point to valid objects.</code></p>
<p>Additionally, linear traversals are useful for the mark phase of the [wiki:Commentary/Rts/Storage compacting garbage collector], and would be useful if we were to allow objects to be pinned arbitrarily (currently pinned objects cannot contain pointers, which means they don't need to be scavenged by the GC).</p>
<h2 id="how-does-slop-arise">How does slop arise?</h2>
<p>Slop can arise for two reasons:</p>
<ul>
<li>The compiled code allocates too much memory, and only fills part of it with objects. For example,</li>
</ul>
<p><code>  when compiling code for a function like this:</code></p>
<pre><code>f = \x -&gt; case x of
            True  -&gt; e1
            False -&gt; e2</code></pre>
<p><code>  the code generator takes the maximum of the heap requirements of e1 and e2 and aggregates it into</code><br />
<code>  the heap check at the beginning of the function </code></p>
<pre><code>f</code></pre>
<p>(to avoid doing too many heap checks).</p>
<p><code>  Unfortunately that means either </code></p>
<pre><code>e1` or `e2</code></pre>
<p>has too much heap allocated to it, leaving some slop.</p>
<p><code>  We solve this problem by moving the heap pointer </code><em><code>backwards</code></em><code> before making a tail-call if</code><br />
<code>  there is any heap slop.</code></p>
<ul>
<li>When an object is overwritten with a smaller object. This happens in two ways:</li>
</ul>
<p><code>  [wiki:Commentary/Rts/HaskellExecution/Updates Updates] and [wiki:Commentary/Rts/Storage/HeapObjects#Blackholes Black Holes].</code></p>
<h2 id="what-do-we-do-about-it">What do we do about it?</h2>
<p>We avoid the problem for [wiki:Commentary/Profiling/Heap heap profiling] by arranging that we only ever do a census on a newly garbage-collected heap, which has no slop in it (the garbage collector never leaves slop between objects in the heap).</p>
<p>Slop does arise due to updates and black holes during normal execution, and GHC does not attempt to avoid it (because avoiding or filling slop during an update is costly). However, if we're doing [wiki:Commentary/Rts/Sanity sanity checking], then we need to arrange that slop is clearly marked: so in a</p>
<pre><code>DEBUG` version of the RTS (see [wiki:Commentary/Rts/Config RTS configurations])  the update code and the blackhole code both arrange to fill slop with zeros: see the `FILL_SLOP` macro in [[GhcFile(rts/Updates.h)]].  Hence sanity checking only works with a `DEBUG</code></pre>
<p>version of the RTS.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="layout-of-important-files-and-directories">Layout of important files and directories</h1>
<p>This page summarises the overall file and directory structure of GHC. We include both source files and generated files; the latter are always identified &quot;build-tree only&quot;.</p>
<p>Everything starts with the main GHC repository (see [wiki:Building/GettingTheSources]). The build system calls that directory</p>
<pre><code>$(TOP)`. All the paths below are relative to `$(TOP)</code></pre>
<p>.</p>
<p>== Files in</p>
<pre><code>$(TOP)</code></pre>
<p>==</p>
<p>; '''</p>
<pre><code>packages</code></pre>
<p>'''</p>
<dl>

<dd>Despite the name &quot;package&quot;, this file contains the master list of the *repositories* that make up GHC. It is parsed by
<pre><code>./boot</code></pre>
<p>.</p>
</dd>
</dl>
<p>; '''</p>
<pre><code>tarballs</code></pre>
<p>'''</p>
<dl>

<dd>Lists the various tarballs (binary packages) that ghc relies on and where to unpack them during a build.
</dd>
</dl>
<p><code>'''</code></p>
<pre><code>validate`&#39;&#39;&#39;:: Run `validate</code></pre>
<p>(a shell script) before committing (see [wiki:TestingPatches]). The script is documented in the file itself.</p>
<p><strong><code>Documentation</code> <code>files</code></strong><code>:: </code></p>
<pre><code>README`, `ANNOUNCE`, `HACKING`, `LICENSE`, `new_tc_notes</code></pre>
<p><strong><code>GNU</code> <code>autoconf</code> <code>machinery</code></strong><code>:: </code></p>
<pre><code>aclocal.m4`, `config.guess`, `config.sub`, `configure.ac`, `install-sh`, `config.mk.in`, `settings.in</code></pre>
<p><code>'''</code></p>
<pre><code>Makefile</code></pre>
<p>''':: The top-level</p>
<pre><code>Makefile</code></pre>
<dl>

<dd>see [wiki:Building/Architecture GHC Build System Architecture]. GHC requires
</dd>
</dl>
<p><code> </code><a href="http://www.gnu.org/software/make/"><code>GNU</code> <code>make</code></a><code>.</code></p>
<p><strong><code>Make</code> <code>system</code> <code>files</code></strong><code>:: </code></p>
<pre><code>ghc.mk`, `MAKEHELP`, `SUBMAKEHELP</code></pre>
<p>==</p>
<pre><code>libraries/</code></pre>
<p>==</p>
<p>The</p>
<pre><code>libraries/` directory contains all the packages that GHC needs to build. It has one sub-directory for each package repository (e.g. `base`, `haskell98`, `random`). Usually each such repository builds just one package, but there is more than one in `dph</code></pre>
<p>.</p>
<p>GHC's libraries are described in more detail on the [wiki:Commentary/Libraries libraries page].</p>
<p>==</p>
<pre><code>compiler/`, `docs/`, `ghc/</code></pre>
<p>==</p>
<p>These directories contain the main GHC compiler and documentation. The</p>
<pre><code>compiler/</code></pre>
<p>directory contains the ghc package, which is linked into an executable in the</p>
<pre><code>ghc/</code></pre>
<p>directory.</p>
<p>There is [wiki:ModuleDependencies documentation of the intended module dependency structure] of the</p>
<pre><code>compiler/</code></pre>
<p>directory.</p>
<ul>
<li>'''
<pre><code>compiler/ghc.cabal.in`&#39;&#39;&#39;: the Cabal file for GHC is generated from this. If you add a module to GHC&#39;s source code, you must add it in the `ghc.cabal.in</code></pre>
<p>file too, else you'll get link errors.</p></li>
</ul>
<p>The following directories appear only in the build tree:</p>
<ul>
<li>'''
<pre><code>compiler/stage1`&#39;&#39;&#39;: generated files for the stage1 build of GHC. There are a handful of files (`ghc_boot_platform.h` etc), and a directory `compiler/stage1/build/` that contains all the `.o` and `.hi</code></pre>
<p>files for the compiler.</p></li>
<li>'''
<pre><code>compiler/stage2</code></pre>
<p>''': similarly stage2.</p></li>
</ul>
<p>You can't run a binary from here: look in the</p>
<pre><code>inplace/</code></pre>
<p>directory below for that.</p>
<p>==</p>
<pre><code>rts/</code></pre>
<p>==</p>
<p>Sources for the runtime system; see [wiki:Commentary/SourceTree/Rts].</p>
<p>==</p>
<pre><code>includes/</code></pre>
<p>==</p>
<p>Header files for the runtime system; see [wiki:Commentary/SourceTree/Includes].</p>
<p>==</p>
<pre><code>utils/`, `libffi/</code></pre>
<p>==</p>
<p>The</p>
<pre><code>utils</code></pre>
<p>directory contains support utilities that GHC uses.</p>
<p>These utils may be built with the bootstrapping compiler, for use during the build, or with the stage1 or stage2 compiler, for installing. Some of them are built with both; we can't install the utils built with the bootstrapping compiler as they may use different versions of C libraries. The reason we use sometimes stage2 rather than stage1 is that some utils, e.g. haddock, need the GHC API package.</p>
<ul>
<li>'''
<pre><code>utils/ghc-cabal`&#39;&#39;&#39; is a little program we use for building the libraries. It&#39;s similar to cabal-install, but without the dependencies on `http</code></pre>
<p>etc.</p></li>
<li>'''
<pre><code>utils/count_lines</code></pre>
<p>''' is a program that counts the number of source-code lines in GHC's code-base. It distinguishes comments from non-comments.</p></li>
</ul>
<p>==</p>
<pre><code>driver/</code></pre>
<p>==</p>
<p>This contains some simple wrapper programs and scripts, for example the</p>
<pre><code>ghci` wrapper that invokes the `ghc` binary with the `--interactive</code></pre>
<p>flag. These wrappers tend to be executable programs on Windows and scripts on Unix systems.</p>
<p>==</p>
<pre><code>ghc-tarballs/</code></pre>
<p>(Windows only) ==</p>
<p>This contains some tarball files (binary packages) that GHC relies upon. Used for easier development / deployment on windows.</p>
<p>==</p>
<pre><code>testsuite/`, `nofib/</code></pre>
<p>==</p>
<p>The</p>
<pre><code>testsuite/` and `nofib/</code></pre>
<p>directories contain apparatus for testing GHC.</p>
<ul>
<li>[wiki:Building/RunningTests]</li>
<li>[wiki:Building/RunningNoFib]</li>
</ul>
<p>==</p>
<pre><code>mk/`, `rules/</code></pre>
<p>==</p>
<p>The</p>
<pre><code>mk/` and `rules.mk</code></pre>
<p>directories contains all the build system Makefile boilerplate; see [wiki:Building/Architecture GHC Build System Architecture]. Some particular files are interesting:</p>
<ul>
<li>'''
<pre><code>mk/build.mk`&#39;&#39;&#39;: contains Makefile settings that control your build. Details [wiki:Building/Using here].  The file `mk/build.mk.sample` contains a starting point that you can copy to `mk/build.mk</code></pre>
<p>if you want.</p></li>
<li>'''
<pre><code>mk/are-validating.mk`&#39;&#39;&#39;: this file records the fact that you are doing [wiki:TestingPatches validation], by containing the single line `Validating=YES`.  That in turn means the the build system gets its settings from `mk/validate-settings.mk` instead of from `mk/build.mk</code></pre>
<p>. Remove the file to stop validating.</p></li>
<li>'''
<pre><code>mk/validate.mk`&#39;&#39;&#39;: just like `build.mk`, but applies when validating.  Use this file to override the default settings for validation, which are in `mk/validate-settings.mk</code></pre>
<p>.</p></li>
</ul>
<p>==</p>
<pre><code>distrib/</code></pre>
<p>==</p>
<p>Miscellaneous files for building distributions.</p>
<h2 id="stuff-that-appears-only-in-a-build-tree">Stuff that appears only in a build tree</h2>
<p>===</p>
<pre><code>inplace/</code></pre>
<p>===</p>
<p>The</p>
<pre><code>inplace/</code></pre>
<p>directory is where we &quot;install&quot; stage1 and stage2 compilers, and other utility programs, when they are built, to be used when building other things in the build tree. The layout is exactly the same as that of an installed GHC on the host platform.</p>
<ul>
<li>'''
<pre><code>inplace/bin/</code></pre>
<p>''': executables, including</p>
<ul>
<li><pre><code>ghc-stage1</code></pre></li>
<li><pre><code>ghc-stage2</code></pre></li>
<li><pre><code>ghc-pkg</code></pre></li>
<li><pre><code>hasktags</code></pre></li>
<li><pre><code>hsc2hs</code></pre></li>
<li><pre><code>haddock</code></pre></li>
<li><pre><code>count_lines</code></pre></li>
<li><pre><code>compareSizes</code></pre></li>
</ul></li>
</ul>
<ul>
<li>'''
<pre><code>inplace/lib/</code></pre>
<p>''': suppporting libraries for the executables.</p></li>
</ul>
<p>===</p>
<pre><code>.../dist*/</code></pre>
<p>===</p>
<p>In many directories,</p>
<pre><code>dist*</code></pre>
<p>subdirectories appear. These are where Cabal, and the build system makefiles, put all of the files generated while building. Some particularly interesting files are:</p>
<ul>
<li>'''
<pre><code>docs/users_guide/users_guide/index.html</code></pre>
<p>''': the HTML for the user manual</p></li>
<li>'''
<pre><code>libraries/`&#39;&#39;lib&#39;&#39;`/dist-install/doc/html/</code></pre>
<p><em>lib</em>''': contains the Haddock'd documentation for library <em>lib</em></p></li>
</ul>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<hr />
<h2 id="stack-layout-1">Stack Layout</h2>
<p>The stack-layout phase decides where to spill variables. The important goals are to avoid memory traffic and to minimize the size of the stack frame. Both of these goals are accomplished by reusing stack slots.</p>
<h3 id="representing-stack-slots">Representing Stack Slots</h3>
<p>For each stack slot, we introduce a new name, then treat the name as the addressing expression for the slot. At the end of the pipeline, we choose a stack layout, then replace each stack slot with its offset from the stack pointer. The benefit is that we break the phase-ordering problem: any phase of the compiler can name a stack slot.</p>
<p>For example, for a variable</p>
<pre><code>x`, the expression `SS(x)` is the address of the stack slot where we can spill `x`. (I don&#39;t think we output any C-- that uses SS anymore, but the new code generator marks its stack slots prior to layout with `young&lt;k&gt; + 4`, etc. -- Edward) The stack is assumed to grow down, and we assume that the address `SS(x)` points to the old end of the slot. Therefore, to address the low address of a 4-byte slot, we would use the expression `SS(x + 4)`. And we would spill `x</code></pre>
<p>using the following instruction:</p>
<pre><code>m[SS(x + 4)] := x;</code></pre>
<p>where</p>
<pre><code>m[e]</code></pre>
<p>refers to an address</p>
<pre><code>e</code></pre>
<p>in memory.</p>
<p>But what about parameter passing? We use a similar technique, but this time we describe the slot for each location as an offset within the area where the parameters are passed. For example, we lower a function call</p>
<pre><code>x, y = f(a, b, c);</code></pre>
<p>into approximately the following C--:</p>
<pre><code>  sp := SS(k + 16);
  m[SS(k + 4)]  := k_info_table;
  m[SS(k + 8)]  := a;
  m[SS(k + 12)] := b;
  m[SS(k + 16)] := c;
  call f returns to k;
k:  // on entry to k, sp == stack&lt;k+12&gt;
  x := m[SS(k + 8)]
  y := m[SS(k + 12)]</code></pre>
<p>We use the following types to represent stack slots and parameter-passing areas:</p>
<pre><code>data Area
  = RegSlot  LocalReg
  | CallArea AreaId
  deriving (Eq, Ord)

data AreaId
  = Old
  | Young BlockId
  deriving (Eq, Ord)

data CmmExpr
  = CmmLit CmmLit
  ...
  | CmmStackSlot Area Int
  deriving Eq</code></pre>
<p>An</p>
<pre><code>Area` represents space on the stack; it may use either the `RegSlot` constructor to represent a single stack slot for a register or the `CallArea` constructor to represent parameters passed to/from a function call/return. In a young `CallArea`, the `BlockId</code></pre>
<p>is the label of the function call's continuation, and it passes parameters to the call.</p>
<p><strong>Area layout and addressing</strong></p>
<ul>
<li>Each
<pre><code>Area</code></pre>
<p>grows down, towards lower machine addresses.</p></li>
<li><em>Offsets</em> are always-positive byte displacements within an
<pre><code>Area</code></pre>
<p>.</p></li>
<li>The low-offset end is also called the &quot;old end&quot; of the area, the high-offset end is also called the &quot;young end&quot;.</li>
<li>Notice that the low-offset (old) end has higher machine addresses.</li>
<li>Offset 0 (if we allowed it) would address the byte one <em>beyond</em> the high-address end of the
<pre><code>Area</code></pre>
<p>.</p></li>
<li>Larger offsets (from the beginning of the
<pre><code>Area</code></pre>
<p>) correspond to lower machine addresses.</p></li>
<li>Hence, to address a 4-byte object at the old end of
<pre><code>Area` a, we use the offset +4, thus `(CmmStackSlot a 4)</code></pre>
<p>.</p></li>
</ul>
<p>The</p>
<pre><code>Old` call area is the initial state of the stack on entry to the function (the overflow parameters and the return address) as well as any arguments that will be passed to a tail call.  (SLPJ believes that:) On entry to the function, register `Sp` contains the address of the youngest (lowest-address, highest offset) byte in the `Old</code></pre>
<p>area.</p>
<p>Note that</p>
<pre><code>RegSlot` areas are very small (since they only need to store a single register), while `CallArea</code></pre>
<p>are contiguous chunks of arguments.</p>
<p>To name a specific location on the stack, we represent its address with a new kind of</p>
<pre><code>CmmExpr`: the `CmmStackSlot</code></pre>
<p>. A</p>
<pre><code>CmmStackSlot` is just an integer offset into an `Area</code></pre>
<p>.<br />
</p>
<p>Notice that a</p>
<pre><code>CmmStackSlot</code></pre>
<p>is an <em>address</em>, so we can say</p>
<pre><code>  Sp = SS(a+4)</code></pre>
<p>to make</p>
<pre><code>Sp` point to a particular stack slot.   Use a `CmmLoad</code></pre>
<p>to load from the stack slot.</p>
<p>The following figure shows the layout of a</p>
<pre><code>CallArea</code></pre>
<p>for both the outgoing parameters (function call) and incoming results (continuation after returning from the function call). Note that the incoming and outgoing parameters may be different, and they may overlap.</p>
<p><a href="Image(CallArea.png)" class="uri" title="wikilink">Image(CallArea.png)</a></p>
<p>A</p>
<pre><code>RegSlot</code></pre>
<p>is laid out in the same fashion, with the offset 0 pointing off the high byte of the stack slot. To address an 8-byte double-word, we would use the offset 8. To address only the high word of the same stack slot, we would use the offset 4.</p>
<p>Currently, the intermediate code does not explicitly use a virtual frame pointer, but when we talk about offsets into the stack, we implicitly assume that there is a virtual frame pointer that points just off the oldest byte of the return address on entry to the procedures. Therefore, on entry to the procedure, the offset of the (4-byte) return address is 4.</p>
<h3 id="laying-out-the-stack">Laying out the stack</h3>
<p>The business of the stack-layout pass is to construct a mapping (fixed across a single procedure)</p>
<pre><code>   Area |-&gt; VirtualOffset</code></pre>
<p>which assigns a virtual stack slot (i.e. offset in bytes, relative to the virtual frame pointer) to each</p>
<pre><code>Area</code></pre>
<p>.</p>
<p>A naive approach to laying out the stack would be to give each variable its own stack slot for spilling, and allocate only the ends of the stack frame for parameter-passing areas. But this approach misses two opportunities for optimization:</p>
<ul>
<li>Stack slots can be reused by variables that are never on the stack at the same time</li>
<li>If a function returns a variable on the stack, we might be able to use the return location as the variable's stack slot.</li>
</ul>
<p>As it turns out, it is quite common in GHC that the first definition of a variable comes when its value is returned from a function call. If the value is returned on the stack, then an important optimization is to avoid copying that value to some other location on the stack. How is that achieved? By making sure the location where the value is returned is also its spill slot.</p>
<h3 id="a-greedy-algorithm">A greedy algorithm</h3>
<p>We rewrite the stack slots in two passes:</p>
<ol>
<li>Walk over the graph and choose an offset for each
<pre><code>Area</code></pre>
<p>.</p></li>
<li>Walk over the graph, keeping track of the stack pointer, and rewrite each address of a stack slot with an offset from the stack pointer. Also, insert adjustments to the stack pointer before and after proc points.</li>
</ol>
<p>The details are in cmm/CmmProcPointZ.hs (they have not yet been committed, but will be soon - Aug 4, 2008).</p>
<h1 id="layout-of-the-stack">Layout of the stack</h1>
<p>Every [wiki:Commentary/Rts/HeapObjects#ThreadStateObjects TSO object] contains a stack. The stack of a TSO grows downwards, with the topmost (most recently pushed) word pointed to by</p>
<pre><code>tso-&gt;sp</code></pre>
<p>, and the bottom of the stack given by</p>
<pre><code>tso-&gt;stack + tso-&gt;stack_size</code></pre>
<p>.</p>
<p>The stack consists of a sequence of <em>stack frames</em> (also sometimes called <em>activation records</em>) where each frame has the same layout as a heap object:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Header</p></td>
<td align="left"><p>Payload...</p></td>
</tr>
</tbody>
</table>
<p>There are several kinds of [wiki:Commentary/Rts/Storage/Stack#KindsofStackFrame stack frames], but the most common types are those pushed when evaluating a</p>
<pre><code>case</code></pre>
<p>expression:</p>
<pre><code>  case e0 of p1 -&gt; e1; ...; pn -&gt; en </code></pre>
<p>The code for evaluating a</p>
<pre><code>case</code></pre>
<p>pushes a new stack frame representing the alternatives of the case, and continues by evaluating</p>
<pre><code>e0</code></pre>
<p>. When</p>
<pre><code>e0</code></pre>
<p>completes, it returns to the stack frame pushed earlier, which inspects the value and selects the appropriate branch of the case. The stack frame for a</p>
<pre><code>case</code></pre>
<p>includes the values of all the free variables in the case alternatives.</p>
<h2 id="info-tables-for-stack-frames">Info tables for stack frames</h2>
<p>The info table for a stack frame has a couple of extra fields in addition to the [wiki:Commentary/Rts/HeapObjects#InfoTables basic info table layout]. A stack-frame info table is defined by</p>
<pre><code>StgRetInfoTable</code></pre>
<p>in <a href="GhcFile(includes/rts/storage/InfoTables.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/InfoTables.h)</a>.</p>
<p><a href="Image(ret-itbl-no-rv.png)" class="uri" title="wikilink">Image(ret-itbl-no-rv.png)</a></p>
<p>The <em>SRT</em> field points to the static reference table (SRT) for this stack frame (see [wiki:Commentary/Rts/Storage/GC/CAFs] for details of SRTs).</p>
<h2 id="layout-of-the-payload">Layout of the payload</h2>
<p>Unlike heap objects which mainly have &quot;pointers first&quot; layout, in a stack frame the pointers and non-pointers are intermingled. This is so that we can support &quot;stack stubbing&quot; whereby a live variable stored on the stack can be later marked as dead simply by pushing a new stack frame that identifies that slot as containing a non-pointer, so the GC will not follow it.</p>
<p>Stack frames therefore have [wiki:Commentary/Rts/HeapObjects#Bitmaplayout bitmap layout].</p>
<h2 id="kinds-of-stack-frame">Kinds of Stack Frame</h2>
<p>The constants for the different types of stack frame are defined in <a href="GhcFile(includes/rts/storage/ClosureTypes.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/ClosureTypes.h)</a>. More details about the layouts are available in <a href="GhcFile(includes/rts/storage/Closures.h)" class="uri" title="wikilink">GhcFile(includes/rts/storage/Closures.h)</a></p>
<ul>
<li><pre><code>RET_BCO</code></pre></li>
<li><pre><code>RET_SMALL</code></pre></li>
<li><pre><code>RET_BIG</code></pre></li>
<li><pre><code>RET_FUN</code></pre>
<p>- (Explained a bit here: <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CPS#Notes" class="uri">https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CPS#Notes</a>)</p></li>
<li><pre><code>UPDATE_FRAME</code></pre></li>
<li><pre><code>CATCH_FRAME</code></pre></li>
<li><pre><code>UNDERFLOW_FRAME</code></pre>
<p>- The stack is chunked now. Connected as a linked list. (Since Dec 2010: f30d527344db528618f64a25250a3be557d9f287, <a href="https://ghc.haskell.org/trac/ghc/blog/stack-chunks">Blogpost</a>)</p></li>
<li><pre><code>STOP_FRAME</code></pre></li>
<li><pre><code>ATOMICALLY_FRAME</code></pre></li>
<li><pre><code>CATCH_RETRY_FRAME</code></pre></li>
<li><pre><code>CATCH_STM_FRAME</code></pre></li>
</ul>
<p>Video: <a href="http://www.youtube.com/watch?v=v0J1iZ7F7W8&amp;list=PLBkRCigjPwyeCSD_DFxpd246YIF7_RDDI">STG language</a> (17'21&quot;)</p>
<h1 id="the-stg-syntax-data-types">The STG syntax data types</h1>
<p>Before code generation, GHC converts the Core-language program into</p>
<pre><code>StgSyn</code></pre>
<p>. The basic ideas are still pretty much exactly as described in the paper <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/spineless-tagless-gmachine.ps.gz">Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine</a>.</p>
<p>The best way to think of STG is as special form of [wiki:Commentary/Compiler/CoreSynType Core]. Specifically, the differences are these (see <a href="GhcFile(compiler/stgSyn/StgSyn.hs)" class="uri" title="wikilink">GhcFile(compiler/stgSyn/StgSyn.hs)</a>):</p>
<ul>
<li>Function arguments are atoms (literals or variables), of type
<pre><code>StgArg</code></pre>
<p>.</p></li>
<li>The right hand side of a let-binding,
<pre><code>StgRhs</code></pre>
<p>, is either</p>
<ul>
<li><pre><code>StgRhsCon</code></pre>
<dl>

<dd>a constructor application, or
</dd>
</dl></li>
<li><pre><code>StgRhsClosure</code></pre>
<dl>

<dd><strong>lambda-form</strong> (possibly with zero arguments, in which case it's a thunk).
</dd>
</dl></li>
</ul></li>
<li>Constructor applications are saturated.</li>
<li>Applications of primitive operators are saturated.</li>
<li>Lambdas can only appear the right-hand side of a let-binding. (There is an expression form
<pre><code>StgLam</code></pre>
<p>, but it is only used during the Core-to-STG transformation, not in a valid STG program.)</p></li>
<li>Types have largely been discarded, retaining only enough type information as is needed to guide code generation. There is an
<pre><code>StgLint</code></pre>
<p>checker, which makes some consistency checks, but the CoreLint guarantee that &quot;if the program passes Lint it cannot crash&quot; has been lost.</p></li>
</ul>
<p>In addition, the STG program is decorated with the results of some analyses:</p>
<ul>
<li>Every lambda-form (
<pre><code>StgRhsClosure</code></pre>
<p>) lists its free variables. These are the variables that are in the thunk of function closure that is allocated by the let.</p></li>
</ul>
<ul>
<li>Every lambda-form gives its [wiki:Commentary/Rts/CAFs <strong>Static Reference Table</strong>] or <strong>SRT</strong>. You should think of the SRT as the <em>top-level</em> free variables of the body. They do not need to be dynamically allocated in the heap object, but they do need to be accessible from the object's info-table, so that the garbage collector can find the CAFs kept alive by the object.</li>
</ul>
<ul>
<li>A
<pre><code>StgCase</code></pre>
<p>expression is decorated with its <strong>live variables</strong>; that is, variables reachable from the continuation of the case. More precisely, two sets of live variables, plus the SRT for the continuation. Todo: say more.</p></li>
</ul>
<ul>
<li>The STG program has a new construct called <strong>let-no-escape</strong>, that encodes so-called <strong>join points</strong>. Variables bound by a let-no-escape are guaranteed to be tail-calls, not embedded inside a data structure, in which case we don</li>
</ul>
<h1 id="ghc-commentary-software-transactional-memory-stm">GHC Commentary: Software Transactional Memory (STM)</h1>
<p>This document gives an overview of the runtime system (RTS) support for GHC's STM implementation. We will focus on the case where fine grain locking is used (</p>
<pre><code>STM_FG_LOCKS</code></pre>
<p>).</p>
<p>Some details about the implementation can be found in the papers <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf">&quot;Composable Memory Transactions&quot;</a> and <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm-invariants.pdf">&quot;Transactional memory with data invariants&quot;</a>. Additional details can be found in the Harris et al book <a href="http://www.morganclaypool.com/doi/abs/10.2200/s00272ed1v01y201006cac011">&quot;Transactional memory&quot;</a>. Some analysis on performance can be found in the paper <a href="https://www.bscmsrc.eu/sites/default/files/cf-final.pdf">&quot;The Limits of Software Transactional Memory&quot;</a> though this work only looks at the coarse grain lock version. Many of the other details here are gleaned from the comments in the source code.</p>
<h1 id="background">Background</h1>
<p>This document assumes the reader is familiar with some general details of GHC's execution and memory layout. A good starting point for this information is can be found here: [wiki:Commentary/Compiler/GeneratedCode Generated Code].</p>
<h2 id="definitions">Definitions</h2>
<h3 id="useful-rts-terms">Useful RTS terms</h3>
<pre><code>Capability</code></pre>
<p><code>Corresponds to a CPU. The number of capabilities should match the number of CPUs. See [wiki:Commentary/Rts/Scheduler#Capabilities Capabilities].</code></p>
<p>TSO</p>
<p><code> Thread State Object. The state of a Haskell thread. See [wiki:Commentary/Rts/Storage/HeapObjects#ThreadStateObjects Thread State Objects].</code></p>
<p>Heap object</p>
<p><code> Objects on the heap all take the form of an </code></p>
<pre><code>StgClosure</code></pre>
<p>structure with a header pointing and a payload of data. The header points to code and an info table. See [wiki:Commentary/Rts/Storage/HeapObjects Heap Objects].</p>
<h3 id="transactional-memory-terms">Transactional Memory terms</h3>
<p>Read set</p>
<p><code> The set of </code></p>
<pre><code>TVar</code></pre>
<p>s that are read, but not written to during a transaction. Write set</p>
<p><code> The set of </code></p>
<pre><code>TVar</code></pre>
<p>s that are written to during a transaction. In the code each written</p>
<pre><code>TVar</code></pre>
<p>is called an &quot;update entry&quot; in the transactional record. Access set</p>
<p><code> All </code></p>
<pre><code>TVar</code></pre>
<p>s accessed during the transaction.</p>
<p>While GHC's STM does not have a separate read set and write set these terms are useful for discussion.</p>
<p>Retry</p>
<p><code> Here we will use the term retry exclusively for the blocking primitive in GHC's STM. This should not be confused with the steps taken when a transaction detects that it has seen an inconsistent view of memory and must start again from the beginning.</code></p>
<p>Failure</p>
<p><code> A failed transaction is one that has seen inconsistent state. This should not be confused with a successful transaction that executes the </code></p>
<pre><code>retry</code></pre>
<p>primitive.</p>
<hr />
<h1 id="overview-of-features">Overview of Features</h1>
<p>At the high level, transactions are computations that read and write to</p>
<pre><code>TVar</code></pre>
<p>s with changes only being committed atomically after seeing a consistent view of memory. Transactions can also be composed together, building new transactions out of existing transactions. In the RTS each transaction keeps a record of its interaction with the</p>
<pre><code>TVar</code></pre>
<p>s it touches in a</p>
<pre><code>TRec</code></pre>
<p>. A pointer to this record is stored in the TSO that is running the transaction.</p>
<h2 id="reading-and-writing">Reading and Writing</h2>
<p>The semantics of a transaction require that when a</p>
<pre><code>TVar</code></pre>
<p>is read in a transaction, its value will stay the same for the duration of execution. Similarly a write to a</p>
<pre><code>TVar</code></pre>
<p>will keep the same value for the duration of the transaction. The transaction itself, however, from the perspective of other threads can apply all of its effects in one moment. That is, other threads cannot see intermediate states of the transaction, so it is as if all the effects happen in a single moment.</p>
<p>As a simple example we can consider a transaction that transfers value between two accounts:</p>
<pre><code>transfer :: Int -&gt; TVar Int -&gt; TVar Int -&gt; STM ()
transfer v a b = do
    x &lt;- readTVar a
    y &lt;- readTVar b
    writeTVar a (x - v)
    writeTVar b (y + v)</code></pre>
<p>No other thread can observe the value</p>
<pre><code>x - v</code></pre>
<p>in</p>
<pre><code>a</code></pre>
<p>without also observing</p>
<pre><code>y + v</code></pre>
<p>in</p>
<pre><code>b</code></pre>
<p>.</p>
<h2 id="blocking">Blocking</h2>
<p>Transactions can choose to block until changes are made to</p>
<pre><code>TVar</code></pre>
<p>s that allow it to try again. This is enabled with an explicit</p>
<pre><code>retry</code></pre>
<p>. Note that when changes are made the transaction is restarted from the beginning.</p>
<p>Continuing the example, we can choose to block when there are insufficient funds:</p>
<pre><code>transferBlocking :: Int -&gt; TVar Int -&gt; TVar Int -&gt; STM ()
transferBlocking v a b = do
    x &lt;- readTVar a
    y &lt;- readTVar b
    if x &lt; v
      then retry
      else do
              writeTVar a (x - v)
              writeTVar b (y + v)</code></pre>
<h2 id="choice">Choice</h2>
<p>Any blocking transaction can be composed with</p>
<pre><code>orElse</code></pre>
<p>to choose an alternative transaction to run instead of blocking. The</p>
<pre><code>orElse</code></pre>
<p>primitive operation creates a nested transaction and if this first transaction executes</p>
<pre><code>retry</code></pre>
<p>, the effects of the nested transaction are rolled back and the alternative transaction is executed. This choice is biased towards the first parameter. A validation failure in the first branch aborts the entire transaction, not just the nested part. An explicit</p>
<pre><code>retry</code></pre>
<p>is the only mechanism that gives partial rollback.</p>
<p>We now can choose the account that has enough funds for the transfer:</p>
<pre><code>transferChoice :: Int -&gt; TVar Int -&gt; TVar Int -&gt; TVar Int -&gt; STM ()
transferChoice v a a&#39; b = do
    transferBlocking v a b &lt;pre&gt;orElse</code></pre>
<p>transferBlocking v a' b</p>
</pre>
<h2 id="data-invariants">Data Invariants</h2>
<p>Invariants support checking global data invariants beyond the atomicity transactions demand. For instance, a transactional linked list (written correctly) will never have an inconsistent structure due to the atomicity of updates. It is no harder to maintain this property in a concurrent setting then in a sequential one with STM. It may be desired, however, to make statements about the consistency of the <em>data</em> in a particular a sorted linked list is sorted, not because of the structure (where the</p>
<pre><code>TVar</code></pre>
<p>s point to) but instead because of the data in the structure (the relation between the data in adjacent nodes). Global data invariant checks can be introduced with the</p>
<pre><code>always</code></pre>
<p>operation which demands that the transaction it is given results in</p>
<pre><code>True</code></pre>
<p>and that it continues to hold for every transaction that is committed globally.</p>
<p>We can use data invariants to guard against negative balances:</p>
<pre><code>newNonNegativeAccount :: STM (TVar Int)
newNonNegativeAccount = do
    t &lt;- newTVar 0
    always $ do
        x &lt;- readTVar t
        return (x &gt; 0)
    return t</code></pre>
<h2 id="exceptions">Exceptions</h2>
<p>Exceptions inside transactions should only propagate outside if the transaction has seen a consistent view of memory. Note that the semantics of exceptions allow the exception itself to capture the view of memory from inside the transaction, but this transaction is not committed.</p>
<hr />
<h1 id="overview-of-the-implementation">Overview of the Implementation</h1>
<p>We will start this section by considering building GHC's STM with only the features of reading and writing. Then we will add</p>
<pre><code>retry</code></pre>
<p>then</p>
<pre><code>orElse</code></pre>
<p>and finally data invariants. Each of the subsequent features adds more complexity to the implementation. Taken all at once it can be difficult to understand the subtlety of some of the design choices.</p>
<hr />
<h2 id="transactions-that-read-and-write.">Transactions that Read and Write.</h2>
<p>With this simplified view we only support</p>
<pre><code>newTVar</code></pre>
<p>,</p>
<pre><code>readTVar</code></pre>
<p>, and</p>
<pre><code>writeTVar</code></pre>
<p>as well as all the STM type class instances except</p>
<pre><code>Alternative</code></pre>
<p>.</p>
<h3 id="transactional-record">Transactional Record</h3>
<p>The overall scheme of GHC's STM is to perform all the effects of a transaction locally in the transactional record or</p>
<pre><code>TRec</code></pre>
<p>. Once the transaction has finished its work locally, a value based consistency check determines if the values read for the entire access set are consistent. This only needs to consider the</p>
<pre><code>TRec</code></pre>
<p>and the main memory view of the access set as it is assumed that main memory is always consistent. This check also obtains locks for the write set and with those locks we can update main memory and unlock. Rolling back the effects of a transaction is just forgetting the current</p>
<pre><code>TRec</code></pre>
<p>and starting again.</p>
<p>The transactional record itself will have an entry for each transactional variable that is accessed. Each entry has a pointer to the</p>
<pre><code>TVar</code></pre>
<p>heap object and a record of the value that the</p>
<pre><code>TVar</code></pre>
<p>held when it was first accessed.</p>
<h3 id="starting">Starting</h3>
<p>A transaction starts by initializing a new</p>
<pre><code>TRec</code></pre>
<p>(</p>
<pre><code>stmStartTransaction</code></pre>
<p>) assigning the TSO's</p>
<pre><code>trec</code></pre>
<p>pointer to the new</p>
<pre><code>TRec</code></pre>
<p>then executing the transaction's code.</p>
<p>(See <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a></p>
<pre><code>stg_atomicallyzh</code></pre>
<p>and <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmStartTransaction</code></pre>
<p>).</p>
<h3 id="reading">Reading</h3>
<p>When a read is attempted we first search the</p>
<pre><code>TRec</code></pre>
<p>for an existing entry. If it is found, we use that local view of the variable. On the first read of the variable, a new entry is allocated and the value of the variable is read and stored locally. The original</p>
<pre><code>TVar</code></pre>
<p>does not need to be accessed again for its value until a validation check is needed.</p>
<p>In the coarse grain version, the read is done without synchronization. With the fine grain lock, the lock variable is the</p>
<pre><code>current_value</code></pre>
<p>of the</p>
<pre><code>TVar</code></pre>
<p>structure. While reading an inconsistent value is an issue that can be resolved later, reading a value that indicates a lock and handing that value to code that expects a different type of heap object will almost certainly lead to a runtime failure. To avoid this the fine grain lock version of the code will spin if the value read is a lock, waiting to observe the lock released with an appropriate pointer to a heap object.</p>
<p>(See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmReadTVar</code></pre>
<p>)</p>
<h3 id="writing">Writing</h3>
<p>Writing to a</p>
<pre><code>TVar</code></pre>
<p>requires that the variable first be in the</p>
<pre><code>TRec</code></pre>
<p>. If it is not currently in the</p>
<pre><code>TRec</code></pre>
<p>, a read of the</p>
<pre><code>TVar</code></pre>
<p>'s value is stored in a new entry (this value will be used to validate and ensure that no updates were made concurrently to this variable).</p>
<p>In both the fine grain and coarse grain lock versions of the code no synchronization is needed to perform the write as the value is stored locally in the</p>
<pre><code>TRec</code></pre>
<p>until commit time.</p>
<p>(See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmWriteTVar</code></pre>
<p>)</p>
<h3 id="validation">Validation</h3>
<p>Before a transaction can make its effects visible to other threads it must check that it has seen a consistent view of memory while it was executing. Most of the work is done in</p>
<pre><code>validate_and_acquire_ownership</code></pre>
<p>by checking that</p>
<pre><code>TVar</code></pre>
<p>s hold their expected values.</p>
<p>For the coarse grain lock version the lock is held before entering</p>
<pre><code>validate_and_acquire_ownership</code></pre>
<p>through the writing of values to</p>
<pre><code>TVar</code></pre>
<p>s. With the fine grain lock, validation acquires locks for the write set and reads a version number consistent with the expected value for each</p>
<pre><code>TVar</code></pre>
<p>in the read set. After all the locks for writes have been acquired, The read set is checked again to see if each value is still the expected value and the version number still matches (</p>
<pre><code>check_read_only</code></pre>
<p>).</p>
<p>(See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>validate_and_acquire_ownership</code></pre>
<p>and</p>
<pre><code>check_read_only</code></pre>
<p>)</p>
<h3 id="committing">Committing</h3>
<p>Before committing, each invariant associated with each accessed</p>
<pre><code>TVar</code></pre>
<p>needs to be checked by running the invariant transaction with its own</p>
<pre><code>TRec</code></pre>
<p>. The read set for each invariant is merged into the transaction as those reads must be included in the consistency check. The</p>
<pre><code>TRec</code></pre>
<p>is then validated. If validation fails, the transaction must start over from the beginning after releasing all locks. In the case of the coarse grain lock validation and commit are in a critical section protected by the global STM lock. Updates to</p>
<pre><code>TVar</code></pre>
<p>s proceeds while holding the global lock.</p>
<p>With the fine grain lock version when validation, including any read-only phase, succeeds, two properties will hold simultaneously that give the desired atomicity:</p>
<ul>
<li>Validation has witnessed all
<pre><code>TVar</code></pre>
<p>s with their expected value.</p></li>
<li>Locks are held for all of the
<pre><code>TVar</code></pre>
<p>s in the write set.</p></li>
</ul>
<p>Commit can proceed to increment each locked</p>
<pre><code>TVar</code></pre>
<p>'s</p>
<pre><code>num_updates</code></pre>
<p>field and unlock by writing the new value to the</p>
<pre><code>current_value</code></pre>
<p>field. While these updates happen one-by-one, any attempt to read from this set will spin while the lock is held. Any reads made before the lock was acquired will fail to validate as the number of updates will change.</p>
<p>(See <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a></p>
<pre><code>stg_atomically_frame</code></pre>
<p>and <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmCommitTransaction</code></pre>
<p>)</p>
<h3 id="aborting">Aborting</h3>
<p>Aborting is simply throwing away changes that are stored in the</p>
<pre><code>TRec</code></pre>
<p>.</p>
<p>(See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmAbortTransaction</code></pre>
<p>)</p>
<h3 id="exceptions-1">Exceptions</h3>
<p>An exception in a transaction will only propagate outside of the transaction if the transaction can be validated. If validation fails, the whole transaction will abort and start again from the beginning. Nothing special needs to be done to support the semantics allowing the view <em>inside</em> the aborted transaction.</p>
<p>(See <a href="GhcFile(rts/Exception.cmm)" class="uri" title="wikilink">GhcFile(rts/Exception.cmm)</a> which calls</p>
<pre><code>stmValidateNestOfTransactions</code></pre>
<p>from <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a>).</p>
<hr />
<p>== Blocking with</p>
<pre><code>retry</code></pre>
<p>==</p>
<p>We will now introduce the blocking feature. To support this we will add a watch queue to each</p>
<pre><code>TVar</code></pre>
<p>where we can place a pointer to a blocked TSO. When a transaction commits we will now wake up the TSOs on watch queues for</p>
<pre><code>TVar</code></pre>
<p>s that are written.</p>
<p>The mechanism for</p>
<pre><code>retry</code></pre>
<p>is similar to exception handling. In the simple case of only supporting blocking and not supporting choice, an encountered retry should validate, and if valid, add the TSO to the watch queue of every accessed</p>
<pre><code>TVar</code></pre>
<p>(see <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmWait</code></pre>
<p>and</p>
<pre><code>build_watch_queue_entries_for_trec</code></pre>
<p>). Locks are acquired for all</p>
<pre><code>TVar</code></pre>
<p>s when validating to control access to the watch queues and prevent missing an update to a</p>
<pre><code>TVar</code></pre>
<p>before the thread is sleeping. In particular if validation is successful the locks are held after the return of</p>
<pre><code>stmWait</code></pre>
<p>, through the return to the scheduler, after the thread is safely paused (see <a href="GhcFile(rts/HeapStackCheck.cmm)" class="uri" title="wikilink">GhcFile(rts/HeapStackCheck.cmm)</a></p>
<pre><code>stg_block_stmwait</code></pre>
<p>), and until</p>
<pre><code>stmWaitUnlock</code></pre>
<p>is called. This ensures that no updates to the</p>
<pre><code>TVar</code></pre>
<p>s are made until the TSO is ready to be woken. If validation fails, the</p>
<pre><code>TRec</code></pre>
<p>is discarded and the transaction is started from the beginning. (See <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a></p>
<pre><code>stg_retryzh</code></pre>
<p>)</p>
<p>When a transaction is committed, each write that it makes to a</p>
<pre><code>TVar</code></pre>
<p>is preceded by waking up each TSO in the watch queue. Eventually these TSOs will be run, but before restarting the transaction its</p>
<pre><code>TRec</code></pre>
<p>is validated again if valid then nothing has changed that will allow the transaction to proceed with a different result. If invalid, some other transaction has committed and progress may be possible (note there is the additional case that some other transaction is merely holding a lock temporarily, causing validation to fail). The TSO is not removed from the watch queues it is on until the transaction is aborted (at this point we no longer need the</p>
<pre><code>TRec</code></pre>
<p>) and the abort happens after the failure to validate on wakeup. (See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmReWait</code></pre>
<p>and</p>
<pre><code>stmAbortTransaction</code></pre>
<p>)</p>
<hr />
<p>== Choice with</p>
<pre><code>orElse</code></pre>
<p>==</p>
<p>When</p>
<pre><code>retry#</code></pre>
<p>executes it searches the stack for either a</p>
<pre><code>CATCH_RETRY_FRAME</code></pre>
<p>or the outer</p>
<pre><code>ATOMICALLY_FRAME</code></pre>
<p>(the boundary between normal execution and the transaction). The former is placed on the stack by an</p>
<pre><code>orElse</code></pre>
<p>(see <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a></p>
<pre><code>stg_catchRetryzh</code></pre>
<p>) and if executing the first branch we can partially abort and switch to the second branch, otherwise we propagate the</p>
<pre><code>retry</code></pre>
<p>further. In the latter case this</p>
<pre><code>retry</code></pre>
<p>represents a transaction that should block and the behavior is as above with only</p>
<pre><code>retry</code></pre>
<p>.</p>
<p>How do we support a &quot;partial abort&quot;? This introduces the need for a nested transaction. Our</p>
<pre><code>TRec</code></pre>
<p>will now have a pointer to an outer</p>
<pre><code>TRec</code></pre>
<p>(the</p>
<pre><code>enclosing_trec</code></pre>
<p>field). This allows us to isolate effects from the branch of the</p>
<pre><code>orElse</code></pre>
<p>that we might need to abort. Let's revisit the features that need to take this into account.</p>
<ul>
<li><strong>Reading</strong> -- Reads now search the chain of nested transactions in addition to the local
<pre><code>TRec</code></pre>
<p>. When an entry is found in a parent it is copied into the local</p>
<pre><code>TRec</code></pre>
<p>. Note that there is still only a single access to the actual</p>
<pre><code>TVar</code></pre>
<p>through the life of the transaction (until validation).</p></li>
<li><strong>Writing</strong> -- Writes, like reads, now search the parent
<pre><code>TRec</code></pre>
<p>s and the write is stored in the local copy.</p></li>
<li><strong>Retry</strong> -- As described above, we now need to search the stack for a
<pre><code>CATCH_RETRY_FRAME</code></pre>
<p>and if found, aborting the nested transaction and attempting the alternative or propagating the retry instead of immediately working on blocking.</p></li>
<li><strong>Validation</strong> -- If we are validating in the middle of a running transaction we will need to validate the whole nest of transactions.<br />
(See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a>
<pre><code>stmValidateNestOfTransactions</code></pre>
<p>and its uses in <a href="GhcFile(rts/Exception.cmm)" class="uri" title="wikilink">GhcFile(rts/Exception.cmm)</a> and <a href="GhcFile(rts/Schedule.c)" class="uri" title="wikilink">GhcFile(rts/Schedule.c)</a>)</p></li>
<li><strong>Committing</strong> -- Just as we now have a partial abort, we need a partial commit when we finish a branch of an
<pre><code>orElse</code></pre>
<p>. This commit is done with</p>
<pre><code>stmCommitNestedTransaction</code></pre>
<p>which validates just the inner</p>
<pre><code>TRec</code></pre>
<p>and merges updates back into its parent. Note that an update is distinguished from a read only entry by value. This means that if a nested transaction performs a write that reverts a value this is a change and must still propagate to the parent (see ticket #7493).</p></li>
<li><strong>Aborting</strong> -- There is another subtle issue with how choice and blocking interact. When we block we need to wake up if there is a change to <em>any</em> accessed
<pre><code>TVar</code></pre>
<p>. Consider a transaction:<br />
</p>
<pre><code>t = t1 &lt;pre&gt;orElse</code></pre>
<p>t2</p>
</pre>
<p><br />
If both</p>
<pre><code>t1</code></pre>
<p>and</p>
<pre><code>t2</code></pre>
<p>execute</p>
<pre><code>retry</code></pre>
<p>then even though the effects of</p>
<pre><code>t1</code></pre>
<p>are thrown away, it could be that a change to a</p>
<pre><code>TVar</code></pre>
<p>that is only in the access set of</p>
<pre><code>t1</code></pre>
<p>will allow the whole transaction to succeed when it is woken.<br />
To solve this problem, when a branch on a nested transaction is aborted the access set of the nested transaction is merged as a read set into the parent</p>
<pre><code>TRec</code></pre>
<p>. Specifically if the</p>
<pre><code>TVar</code></pre>
<p>is in <em>any</em></p>
<pre><code>TRec</code></pre>
<p>up the chain of nested transactions it must be ignored, otherwise it is entered as a new entry (retaining just the read) in the parent</p>
<pre><code>TRec</code></pre>
<p>.<br />
(See again ticket #7493 and <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>merge_read_into</code></pre>
<p>)</p></li>
<li><strong>Exceptions</strong> -- The only change needed here each
<pre><code>CATCH_RETRY_FRAME</code></pre>
<p>on the stack represents a nested transaction. As the stack is searched for a handler, at each encountered</p>
<pre><code>CATCH_RETRY_FRAME</code></pre>
<p>the nested transaction is aborted. When the</p>
<pre><code>ATOMICALLY_FRAME</code></pre>
<p>is encountered we then know that there is no nested transaction.<br />
(See <a href="GhcFile(rts/Exception.cmm)" class="uri" title="wikilink">GhcFile(rts/Exception.cmm)</a></p>
<pre><code>stg_raisezh</code></pre>
<p>)</p></li>
</ul>
<p>(See <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a></p>
<pre><code>stg_retryzh</code></pre>
<p>and</p>
<pre><code>stg_catch_retry_frame</code></pre>
<p>)</p>
<hr />
<h2 id="invariants-1">Invariants</h2>
<p>We will start this section with an overview of some of the details then review with notes on the changes from the choice case.</p>
<h3 id="details">Details</h3>
<p>As a transaction is executing it can collect dynamically checked data invariants. These invariants are transactions that are never committed, but if they raise an exception when executed successfully that exception will propagate out of the atomic frame.</p>
<pre><code>check#</code></pre>
<p><code> Primitive operation that adds an invariant (transaction to run) to the queue of the current </code></p>
<pre><code>TRec</code></pre>
<p>by calling</p>
<pre><code>stmAddInvariantToCheck</code></pre>
<p>.</p>
<pre><code>checkInv :: STM a -&gt; STM ()</code></pre>
<p><code> A wrapper for </code></p>
<pre><code>check#</code></pre>
<p>(to give it the</p>
<pre><code>STM</code></pre>
<p>type).</p>
<pre><code>alwaysSucceeds :: STM a -&gt; STM ()</code></pre>
<p><code> This is the </code></p>
<pre><code>check</code></pre>
<p>from the &quot;Transactional memory with data invariants&quot; paper. The action immediately runs, wrapped in a nested transaction so that it will never commit but will have an opportunity to raise an exception. If successful, the originally passed action is added to the invariant queue.</p>
<pre><code>always :: STM Bool -&gt; STM ()</code></pre>
<p><code> Takes an </code></p>
<pre><code>STM</code></pre>
<p>action that results in a</p>
<pre><code>Bool</code></pre>
<p>and adds an invariant that throws an exception when the result of the transaction is</p>
<pre><code>False</code></pre>
<p>.</p>
<p>The bookkeeping for invariants is in each</p>
<pre><code>TRec</code></pre>
<p>s</p>
<pre><code>invariants_to_check</code></pre>
<p>queue and the</p>
<pre><code>StgAtomicallyFrame</code></pre>
<p>s</p>
<pre><code>next_invariant_to_check</code></pre>
<p>field. Each invariant is in a</p>
<pre><code>StgAtomicInvariant</code></pre>
<p>structure that includes the</p>
<pre><code>STM</code></pre>
<p>action, the</p>
<pre><code>TRec</code></pre>
<p>where it was last executed, and a lock. This is added to the current</p>
<pre><code>TRec</code></pre>
<p>s queue when</p>
<pre><code>check#</code></pre>
<p>is executed.</p>
<p>When a transaction completes, execution will reach the</p>
<pre><code>stg_atomically_frame</code></pre>
<p>and the</p>
<pre><code>TRec</code></pre>
<p>s</p>
<pre><code>enclosing_trec</code></pre>
<p>will be</p>
<pre><code>NO_TREC</code></pre>
<p>(a nested transaction would have a</p>
<pre><code>stg_catch_retry_frame</code></pre>
<p>before the</p>
<pre><code>stg_atomically_frame</code></pre>
<p>to handle cases of non-empty</p>
<pre><code>enclosing_trec</code></pre>
<p>). The frame will then check the invariants by collecting the invariants it needs to check with</p>
<pre><code>stmGetInvariantsToCheck</code></pre>
<p>, dequeuing each, executing, and when (or if) we get back to the frame, aborting the invariant action. If the invariant failed to hold, we would not get here due to an exception and if it succeeds we do not want its effects. Once all the invariants have been checked, the frame will to commit.</p>
<p>Which invariants need to be checked for a given transaction? Clearly invariants introduced in the transaction will be checked these are added to the</p>
<pre><code>TRec</code></pre>
<p>s</p>
<pre><code>invariants_to_check</code></pre>
<p>queue directly when</p>
<pre><code>check#</code></pre>
<p>is executed. In addition, once the transaction has finished executing, we can look at each entry in the write set and search its watch queue for any invariants.</p>
<p>Note that there is a</p>
<pre><code>check</code></pre>
<p>in the</p>
<pre><code>stm</code></pre>
<p>package in</p>
<pre><code>Control.Monad.STM</code></pre>
<p>which matches the</p>
<pre><code>check</code></pre>
<p>from the <a href="http://research.microsoft.com/pubs/74063/beautiful.pdf">beauty</a> chapter of &quot;Beautiful code&quot;:</p>
<pre><code>check :: Bool -&gt; STM ()
check b = if b then return () else retry</code></pre>
<p>It requires no additional runtime support. If it is a transaction that produces the</p>
<pre><code>Bool</code></pre>
<p>argument it will be committed (when</p>
<pre><code>True</code></pre>
<p>) and it is only a one time check, not an invariant that will be checked at commits.</p>
<h3 id="changes-from-choice">Changes from Choice</h3>
<p>With the addition of data invariants we have the following changes to the implementation:</p>
<ul>
<li><strong>Retrying</strong> -- A retry in an invariant indicates that the invariant could not proceed and the whole transaction should block. This special case is detected when an
<pre><code>ATOMICALLY_FRAME</code></pre>
<p>is encountered with a nest of transactions (i.e. when the</p>
<pre><code>enclosing_trec</code></pre>
<p>field is not</p>
<pre><code>NO_TREC</code></pre>
<p>). The invariant is simply aborted and execution proceeds to</p>
<pre><code>stmWait</code></pre>
<p>(see <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a></p>
<pre><code>stg_retryzh</code></pre>
<p>).</p></li>
<li><strong>Commiting</strong> -- Commit now needs a phase where it runs invariants after the code of the transaction has completed but before commit. The implementation recycles the structure already in place for this phase so special cases are needed in the
<pre><code>ATOMICALLY_FRAME</code></pre>
<p>that collects invariants and works through them one at a time then moves on to committing (see <a href="GhcFile(rts/PrimOps.cmm)" class="uri" title="wikilink">GhcFile(rts/PrimOps.cmm)</a></p>
<pre><code>stg_atomically_frame</code></pre>
<p>).<br />
To efficiently handle invariants they need to only be checked when a relevant data dependency changes. This means we can associate them with the</p>
<pre><code>TRec</code></pre>
<p>of the last commit that needed to check the invariant at the cost of serializing invariant handling commits. This is enforced by the lock on each invariant. If it cannot be acquired the whole transaction must start over.<br />
At commit time, each invariant is locked and the read set for the last commited transaction of each invariant is merged into the</p>
<pre><code>TRec</code></pre>
<p>.<br />
Validation acuqires lock for all entries in the</p>
<pre><code>TRec</code></pre>
<p>(not just the writes). After validation, each invariant is removed from the watch queue of each</p>
<pre><code>TVar</code></pre>
<p>it previously depended on, then the</p>
<pre><code>TRec</code></pre>
<p>that was used when executing the invariant code is updated to reflect the values from the final execution of the main transaction and each</p>
<pre><code>TVar</code></pre>
<p>, being a data depenency of the invariant, has the invariant added to its watch queue.<br />
(See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>stmCommitTransaction</code></pre>
<p>,</p>
<pre><code>disconnect_invariant</code></pre>
<p>and</p>
<pre><code>connect_invariant_to_trec</code></pre>
<p>)</p></li>
<li><strong>Exceptions</strong> -- When an exception propagates to the
<pre><code>ATOMICALLY_FRAME</code></pre>
<p>there are now two states that it could encounter. If there is no enclosing</p>
<pre><code>TRec</code></pre>
<p>we are not dealing with an exception from an invariant and it proceeds as above. Seeing a nest of transactions indicates that the transaction was checking an invariant when it encountered the exception. The effect of a failed invariant <em>is</em> this exception so nothing special needs to be done except to validate and abort both the outer transaction and the nested transaction (see <a href="GhcFile(rts/Exception.cmm)" class="uri" title="wikilink">GhcFile(rts/Exception.cmm)</a></p>
<pre><code>stg_raisezh</code></pre>
<p>).</p></li>
</ul>
<hr />
<h2 id="other-details">Other Details</h2>
<p>This section describes some details that can be discussed largely in isolation from the rest of the system.</p>
<h3 id="detecting-long-running-transactions">Detecting Long Running Transactions</h3>
<p>While the type system enforces STM actions to be constrained to STM side effects, pure computations in Haskell can be non-terminating. It could be that a transaction sees inconsistent data that leads to non-termination that would never happen in a program that only saw consistent data. To detect this problem, every time a thread yields it is validated. A validation failure causes the transaction to be condemned.</p>
<h3 id="transaction-state">Transaction State</h3>
<p>Each</p>
<pre><code>TRec</code></pre>
<p>has a</p>
<pre><code>state</code></pre>
<p>field that holds the status of the transaction. It can be one of the following:</p>
<pre><code>TREC_ACTIVE</code></pre>
<p><code> The transaction is actively running.</code></p>
<pre><code>TREC_CONDEMNED</code></pre>
<p><code> The transaction has seen an inconsistency.</code></p>
<pre><code>TREC_COMMITTED</code></pre>
<p><code> The transaction has committed and is in the process of updating </code></p>
<pre><code>TVar</code></pre>
<p>values.</p>
<pre><code>TREC_ABORTED</code></pre>
<p><code> The transaction has aborted and is working to release locks.</code></p>
<pre><code>TREC_WAITING</code></pre>
<p><code> The transaction has hit a </code></p>
<pre><code>retry</code></pre>
<p>and is waiting to be woken.</p>
<p>If a</p>
<pre><code>TRec</code></pre>
<p>state is</p>
<pre><code>TREC_CONDEMNED</code></pre>
<p>(some inconsistency was seen) validate does nothing. When a top-level transaction is aborted in</p>
<pre><code>stmAbortTransaction</code></pre>
<p>, if the state is</p>
<pre><code>TREC_WAITING</code></pre>
<p>it will remove the watch queue entries for the</p>
<pre><code>TRec</code></pre>
<p>. Similarly if a waiting</p>
<pre><code>TRec</code></pre>
<p>is condemned via an asynchronous exception when a validation failure is observed after a thread yield, its watch queue entries are removed. Finally a</p>
<pre><code>TRec</code></pre>
<p>in the</p>
<pre><code>TREC_WAITING</code></pre>
<p>state is not condemned by a validation. In this case the</p>
<pre><code>TRec</code></pre>
<p>is already waiting for a wake up from a</p>
<pre><code>TVar</code></pre>
<p>that changes and observing an inconsistency merely indicates that this will happen soon.</p>
<p>In the work of Keir Fraser a transaction state is used for cooperative efforts of transactions to give lock-free properties for STM systems. The design of GHC's STM is clearly influenced by this work and seems close to some of the algorithms in Fraser's work. It does not, however, implement what would be required to be lock-free or live-lock free (in the fine grain lock code). For instance, if two transactions</p>
<pre><code>T1</code></pre>
<p>and</p>
<pre><code>T2</code></pre>
<p>are committing at the same time and</p>
<pre><code>T1</code></pre>
<p>has read</p>
<pre><code>A</code></pre>
<p>and written</p>
<pre><code>B</code></pre>
<p>while</p>
<pre><code>T2</code></pre>
<p>has read</p>
<pre><code>B</code></pre>
<p>and written</p>
<pre><code>A</code></pre>
<p>, both the transactions can fail to commit. For example, consider the interleaving:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>'''</p>
<pre><code>T1</code></pre>
<p>'''</p></td>
<td align="left"><p>'''</p>
<pre><code>TVar</code></pre>
<p>'''</p></td>
<td align="left"><p>'''</p>
<pre><code>T2</code></pre>
<p>'''</p></td>
<td align="left"><p><strong>Action</strong></p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>A 0 0</code></pre></td>
<td align="left"><pre><code>A 0</code></pre></td>
<td align="left"></td>
<td align="left"><pre><code>T1</code></pre>
<p>read A</p></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><pre><code>B 0</code></pre></td>
<td align="left"><pre><code>B 0 0</code></pre></td>
<td align="left"><pre><code>T2</code></pre>
<p>read B</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>B 0 1</code></pre></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><pre><code>T1</code></pre>
<p>write B 1</p></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left"><pre><code>A 0 1</code></pre></td>
<td align="left"><pre><code>T2</code></pre>
<p>write A 1</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>A 0 0 0</code></pre></td>
<td align="left"><pre><code>A 0</code></pre></td>
<td align="left"></td>
<td align="left"><pre><code>T1</code></pre>
<p>Validation Part 1 (read A)</p></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><pre><code>A T2</code></pre></td>
<td align="left"></td>
<td align="left"><pre><code>T2</code></pre>
<p>Validation (Lock A)</p></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><pre><code>B 0</code></pre></td>
<td align="left"><pre><code>B 0 0 0</code></pre></td>
<td align="left"><pre><code>T2</code></pre>
<p>Validation (Read B)</p></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><pre><code>B T1</code></pre></td>
<td align="left"></td>
<td align="left"><pre><code>T1</code></pre>
<p>Validation Part 2 (Lock B)</p></td>
</tr>
</tbody>
</table>
<p>Note: the first and third columns are the local state of the</p>
<pre><code>TRec</code></pre>
<p>s and the second column is the values of the</p>
<pre><code>TVar</code></pre>
<p>structures. Each</p>
<pre><code>TRec</code></pre>
<p>entry has the expected value followed by the new value and a number of updates field when it is read for validation.</p>
<p>At this point</p>
<pre><code>T1</code></pre>
<p>and</p>
<pre><code>T2</code></pre>
<p>both perform their</p>
<pre><code>read_only_check</code></pre>
<p>and both could (at least one will) discover that a</p>
<pre><code>TVar</code></pre>
<p>in their read set is now locked. This leads to both transactions aborting. The chances of this are narrow but not impossible (see ticket #7815). Fraser's work avoids this by using the transaction status and the fact that locks point back to the</p>
<pre><code>TRec</code></pre>
<p>holding the lock to detect other transactions in a read only check (read phase) and resolving conflicts so that at least one of the transactions can commit.</p>
<p>A simpler example can also cause both transactions to abort. Consider two transactions with the same write set, but the writes entered the</p>
<pre><code>TRec</code></pre>
<p>s in a different order. Both transactions could encounter a lock from the other before they have a chance to release locks and get out of the way. Having an ordering on lock could avoid this problem but would add a little more complexity.</p>
<h3 id="gc-and-aba">GC and ABA</h3>
<p>GHC's STM does comparisons for validation by value. Since these are always pure computations these values are represented by heap objects and a simple pointer comparison is sufficient to know if the same value is in place. This presents an ABA problem however if the location of some value is recycled it could appear as though the value has not changed when, in fact, it is a different value. This is avoided by making the</p>
<pre><code>expected_value</code></pre>
<p>fields of the</p>
<pre><code>TRec</code></pre>
<p>entries pointers into the heap followed by the garbage collector. As long as a</p>
<pre><code>TRec</code></pre>
<p>is still alive it will keep the original value it read for a</p>
<pre><code>TVar</code></pre>
<p>alive.</p>
<p>=== Management of</p>
<pre><code>TRec</code></pre>
<p>s ===</p>
<p>The</p>
<pre><code>TRec</code></pre>
<p>structure is built as a list of chunks to give better locality and amortize the cost of searching and allocating entries. Additionally</p>
<pre><code>TRec</code></pre>
<p>s are recycled to aid locality further when a transaction is aborted and started again. Both of these details add a little complexity to the implementation that is abated with some macros such as</p>
<pre><code>FOR_EACH_ENTRY</code></pre>
<p>and</p>
<pre><code>BREAK_FOR_EACH</code></pre>
<p>.</p>
<h3 id="tokens-and-version-numbers.">Tokens and Version Numbers.</h3>
<p>When validating a transaction each entry in the</p>
<pre><code>TRec</code></pre>
<p>is checked for consistency. Any entry that is an update (in the write set) is locked. This locking is a visible effect to the rest of the system and prevents other committing transactions from progress. Reads, however, are not going to be updated. Instead we check that a read to the value matches our expected value, then we read a version number (the</p>
<pre><code>num_updates</code></pre>
<p>field) and check again that the expected value holds. This gives us a read of</p>
<pre><code>num_updates</code></pre>
<p>that is consistent with the</p>
<pre><code>TVar</code></pre>
<p>holding the expected value. Once all the locks for the write set are acquired we know that only our transaction can have an effect on the write set. All that remains is to rule out some change to the read set while we were still acquiring locks for the writes. This is done in the read phase (with</p>
<pre><code>read_only_check</code></pre>
<p>) which checks first if the value matches the expectation then checks if the version numbers match. If this holds for each entry in the read set then there must have existed a moment, while we held the locks for all the write set, where the read set held all its values. Even if some other transaction committed a new value and yet another transaction committed the expected value back the version number will have been incremented.</p>
<p>All that remains is managing these version numbers. When a</p>
<pre><code>TVar</code></pre>
<p>is updated its version number is incremented before the value is updated with the lock release. There is the unlikely case that the finite version numbers wrap around to an expected value while the transaction is committing (even with a 32-bit version number this is <em>highly</em> unlikely to happen). This is, however, accounted for by allocating a batch of tokens to each capability from a global</p>
<pre><code>max_commits</code></pre>
<p>variable. Each time a transaction is started it decrements it's batch of tokens. By sampling</p>
<pre><code>max_commits</code></pre>
<p>at the beginning of commit and after the read phase the possibility of an overflow can be detected (when more then 32-bits worth of commits have been allocated out).</p>
<p>(See <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a></p>
<pre><code>validate_and_acquire_ownership</code></pre>
<p>,</p>
<pre><code>check_read_only</code></pre>
<p>,</p>
<pre><code>getToken</code></pre>
<p>,</p>
<pre><code>stmStartTransaction</code></pre>
<p>, and</p>
<pre><code>stmCommitTransaction</code></pre>
<p>)</p>
<h3 id="implementation-invariants">Implementation Invariants</h3>
<p>Some of the invariants of the implementation:</p>
<ul>
<li>Locks are only acquired in <a href="GhcFile(rts/STM.c)" class="uri" title="wikilink">GhcFile(rts/STM.c)</a> and are always released before the end of a function call (with the exception of
<pre><code>stmWait</code></pre>
<p>which must release locks after the thread is safe).</p></li>
<li>When running a transaction each
<pre><code>TVar</code></pre>
<p>is read exactly once and if it is a write, is updated exactly once.</p></li>
<li>Main memory (
<pre><code>TVar</code></pre>
<p>s) always holds consistent values or locks of a partially updated commit. That is a set of reads at any moment from</p>
<pre><code>TVar</code></pre>
<p>s will result in consistent data if none of the values are locks.</p></li>
<li>A nest of
<pre><code>TRec</code></pre>
<p>s has a matching nest of</p>
<pre><code>CATCH_RETRY_FRAME</code></pre>
<p>s ending with an</p>
<pre><code>ATOMICALLY_FRAME</code></pre>
<p>on the stack. One exception to this is when checking data invariants the invariant's</p>
<pre><code>TRec</code></pre>
<p>is nested under the top level</p>
<pre><code>TRec</code></pre>
<p>without a</p>
<pre><code>CATCH_RETRY_FRAME</code></pre>
<p>.</p></li>
</ul>
<h3 id="fine-grain-locking">Fine Grain Locking</h3>
<p>The locks in fine grain locking (</p>
<pre><code>STM_FG_LOCKS</code></pre>
<p>) are at the</p>
<pre><code>TVar</code></pre>
<p>level and are implemented by placing the locking thread's</p>
<pre><code>TRec</code></pre>
<p>in the</p>
<pre><code>TVar</code></pre>
<p>s current value using a compare and swap (</p>
<pre><code>lock_tvar</code></pre>
<p>). The value observed when locking is returned by</p>
<pre><code>lock_tvar</code></pre>
<p>. To test if a</p>
<pre><code>TVar</code></pre>
<p>is locked the value is inspected to see if it is a</p>
<pre><code>TRec</code></pre>
<p>(checking that the closure's info table pointer is to</p>
<pre><code>stg_TREC_HEADER_info</code></pre>
<p>). If a</p>
<pre><code>TRec</code></pre>
<p>is found</p>
<pre><code>lock_tvar</code></pre>
<p>will spin reading the</p>
<pre><code>TVar</code></pre>
<p>s current value until it is not a</p>
<pre><code>TRec</code></pre>
<p>and then attempt again to obtain the lock. Unlocking is simply a write of the current value of the</p>
<pre><code>TVar</code></pre>
<p>. There is also a conditional lock</p>
<pre><code>cond_lock_tvar</code></pre>
<p>which will obtain the lock if the</p>
<pre><code>TVar</code></pre>
<p>s current value is the given expected value. If the</p>
<pre><code>TVar</code></pre>
<p>is already locked this will not be the case (the value would be a</p>
<pre><code>TRec</code></pre>
<p>) and if the</p>
<pre><code>TVar</code></pre>
<p>has been updated to a new (different) value then locking will fail because the value does not match the expected value. A compare and swap is used for</p>
<pre><code>cond_lock_tvar</code></pre>
<p>.</p>
<p>This arrangement is useful for allowing a transaction that encounters a locked</p>
<pre><code>TVar</code></pre>
<p>to know which particular transaction is locked (used in algorithms in from Fraser). GHC's STM does not, however, use this information.</p>
<h2 id="bibliography">Bibliography</h2>
<p>Fraser, Keir. <em>Practical lock-freedom</em>. Diss. PhD thesis, University of Cambridge Computer Laboratory, 2004.</p>
<p>Jones, Simon Peyton. &quot;Beautiful concurrency.&quot; <em>Beautiful Code: Leading Programmers Explain How They Think</em> (2007): 385-406.</p>
<p>Harris, Tim, et al. &quot;Composable memory transactions.&quot; <em>Proceedings of the tenth ACM SIGPLAN symposium on Principles and practice of parallel programming.</em> ACM, 2005.</p>
<p>Harris, Tim, James Larus, and Ravi Rajwar. &quot;Transactional memory.&quot; <em>Synthesis Lectures on Computer Architecture</em> 5.1 (2010): 1-263.</p>
<p>Harris, Tim, and Simon Peyton Jones. &quot;Transactional memory with data invariants.&quot; <em>First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT'06), Ottowa.</em> 2006.</p>
<h1 id="ghc-commentary-storage">GHC Commentary: Storage</h1>
<p>GHC's storage manager is designed to be quite flexible: there are a large number of tunable parameters in the garbage collector, and partly the reason for this was because we wanted to experiment with tweaking these settings in the context of Haskell.</p>
<p><a href="Image(sm-top.png)" class="uri" title="wikilink">Image(sm-top.png)</a></p>
<ul>
<li>[wiki:Commentary/Rts/Storage/HeapObjects Layout of Heap Objects]</li>
<li>[wiki:Commentary/Rts/Storage/Stack Layout of the Stack]</li>
<li>[wiki:Commentary/Rts/Storage/Slop Slop]</li>
<li>[wiki:Commentary/Rts/Storage/BlockAlloc The Block Allocator]</li>
<li>[wiki:Commentary/Rts/Storage/GC The Garbage Collector]</li>
<li>[wiki:Commentary/Rts/Storage/HeapAlloced The HEAP_ALLOCED() macro]</li>
</ul>
<p>See also:</p>
<ul>
<li>[wiki:Commentary/Rts/HaskellExecution/PointerTagging Pointer tagging]</li>
</ul>
<h1 id="general-overview">General overview</h1>
<p>GHC's approach to strictness analysis is that of &quot;demand analysis&quot;, a backwards analysis in which strictness analysis and absence analysis are done in a single pass. In the future, analysis to perform unboxing, as well as other analyses, may be implemented within this framework as well.</p>
<h1 id="important-note">IMPORTANT NOTE</h1>
<p>The rest of this commentary describes code that is not checked in to the HEAD yet.</p>
<p>Update: as of 2014-02-12, newer documentation (apparently on the same topic and apparently more up-to-date) is available at <a href="Commentary/Compiler/Demand" class="uri" title="wikilink">Commentary/Compiler/Demand</a> (I am not an expert on the GHC internals though). Also, <a href="GhcFile(compiler/basicTypes/NewDemand.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/NewDemand.lhs)</a> is not any more in the sources, replaced by (or renamed to?) <a href="GhcFile(compiler/basicTypes/Demand.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Demand.lhs)</a>.</p>
<h1 id="the-demand-analyzer">The demand analyzer</h1>
<p>Most of the demand analyzer lives in two files:</p>
<ul>
<li><a href="GhcFile(compiler/basicTypes/NewDemand.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/NewDemand.lhs)</a> (defines the datatypes used by the demand analyzer, and some functions on them)</li>
<li><a href="GhcFile(compiler/stranal/DmdAnal.lhs)" class="uri" title="wikilink">GhcFile(compiler/stranal/DmdAnal.lhs)</a> (the demand analyzer itself)</li>
</ul>
<p>The demand analyzer does strictness analysis, absence analysis, and box-demand analysis in a single pass. (ToDo: explain what these are.)</p>
<p>In <a href="GhcFile(compiler/stranal/DmdAnal.lhs)" class="uri" title="wikilink">GhcFile(compiler/stranal/DmdAnal.lhs)</a>,</p>
<pre><code>dmdAnal</code></pre>
<p>is the function that performs demand analysis on an expression. It has the following type:</p>
<pre><code>dmdAnal :: SigEnv -&gt; Demand-&gt; CoreExpr -&gt; (DmdType, CoreExpr)</code></pre>
<p>The first argument is an environment mapping variables onto demand signatures. (ToDo: explain more.) The second argument is the demand that's being placed on the expression being analyzed, which was determined from the context already. The third argument is the expression being analyzed.</p>
<pre><code>dmdAnal</code></pre>
<p>returns a pair of a new expression (possibly with demand information added to any [wiki:Commentary/Compiler/NameType Ids] in it), and a</p>
<pre><code>DmdType</code></pre>
<p>.</p>
<h2 id="important-datatypes">Important datatypes</h2>
<pre><code>data Demand
  = D Usage Demands    </code></pre>
<p>A demand consists of usage information, along with information about usage of the subcomponents of the expression it's associated with.</p>
<pre><code>data Usage
  = U Str Abs Box        </code></pre>
<p>Usage information consists of a triple of three properties: strictness (or evaluation demand), usage demand, and box demand.</p>
<pre><code>data Str 
  = Bot                 
  | Strict       
  | Lazy           </code></pre>
<p>Something that is</p>
<pre><code>Lazy</code></pre>
<p>may or may not be evaluated. Something that is</p>
<pre><code>Strict</code></pre>
<p>will definitely be evaluated at least to its outermost constructor. Something that is</p>
<pre><code>Bot</code></pre>
<p>will be fully evaluated (e.g., in</p>
<pre><code>x &lt;pre&gt;seq</code></pre>
<p>(error &quot;urk&quot;)</p>
</pre>
<p>,</p>
<pre><code>x</code></pre>
<p>can be said to have strictness</p>
<pre><code>Bot</code></pre>
<p>, because it doesn't matter how much we evaluate</p>
<pre><code>x</code></pre>
<p>-- this expression will diverge anyway.)</p>
<pre><code>data Abs
  = Zero     
  | OneOrZero     
  | Many       </code></pre>
<p>In the context of function arguments, an argument that is</p>
<pre><code>Zero</code></pre>
<p>is never used by its caller (e.g., syntactically, it doesn't appear in the body of the function at all). An argument that is</p>
<pre><code>OneOrZero</code></pre>
<p>will be used zero or one times, but not more. Something that is</p>
<pre><code>Many</code></pre>
<p>may be used zero, one, or many times -- we don't know.</p>
<pre><code>data Box
  = Box  
  | Unpack  </code></pre>
<p>Again in the context of function arguments, an argument that is</p>
<pre><code>Box</code></pre>
<p>is a value constructed by a data constructor of a product type whose &quot;box&quot; is going to be needed. For example, we say that</p>
<pre><code>f x = case x of { (a, b) -&gt; x</code></pre>
<p>} &quot;uses the box&quot;, so in</p>
<pre><code>f</code></pre>
<p>,</p>
<pre><code>x</code></pre>
<p>has box-demand information</p>
<pre><code>Box</code></pre>
<p>. In</p>
<pre><code>g x = case x of { (a, b) -&gt; a</code></pre>
<p>},</p>
<pre><code>g</code></pre>
<p>doesn't &quot;use the box&quot; for its argument, so in</p>
<pre><code>g</code></pre>
<p>,</p>
<pre><code>x</code></pre>
<p>has box-demand information</p>
<pre><code>Unpack</code></pre>
<p>. When in doubt, we assume</p>
<pre><code>Box</code></pre>
<p>.</p>
<pre><code>data Demands = Poly          
            |  Prod [Demand] (Maybe Coercion)</code></pre>
<p>For a compound data value, the</p>
<pre><code>Demands</code></pre>
<p>type describes demands on its components.</p>
<pre><code>Poly</code></pre>
<p>means that we don't know anything about the expression's type.</p>
<pre><code>Prod</code></pre>
<p>says &quot;this expression has a product type, and the demands on its components consist of the demands in the following list&quot;. If the</p>
<pre><code>Coercion</code></pre>
<p>is supplied, that means that this expression must be cast using the given coercion before it is evaluated. (ToDo: explain this more.)</p>
<p>(ToDo: explain why all the above information is important)</p>
<p>Though any expression can have a</p>
<pre><code>Demand</code></pre>
<p>associated with it, another datatype,</p>
<pre><code>DmdType</code></pre>
<p>, is associated with a function body.</p>
<pre><code>data DmdType = DmdType 
            DmdEnv  
            [Demand]    
            DmdResult</code></pre>
<p>A</p>
<pre><code>DmdType</code></pre>
<p>consists of a</p>
<pre><code>DmdEnv</code></pre>
<p>(which provides demands for all explicitly mentioned free variables in a functions body), a list of</p>
<pre><code>Demand</code></pre>
<p>s on the function's arguments, and a</p>
<pre><code>DmdResult</code></pre>
<p>, which indicates whether this function returns an explicitly constructed product:</p>
<pre><code>data DmdResult = TopRes -- Nothing known    
           | RetCPR -- Returns a constructed product
           | BotRes -- Diverges or errors</code></pre>
<p>The</p>
<pre><code>dmdTransform</code></pre>
<p>function takes a strictness environment, an [wiki:Commentary/Compiler/NameType Id] corresponding to a function, and a</p>
<pre><code>Demand</code></pre>
<p>representing demand on the function -- in a particular context -- and returns a</p>
<pre><code>DmdType</code></pre>
<p>, representing the function's demand type in this context.</p>
<pre><code>dmdTransform :: SigEnv      
         -&gt; Id      
         -&gt; Demand      
         -&gt; DmdType     </code></pre>
<p>Demand analysis is implemented as a backwards analysis, so</p>
<pre><code>dmdTransform</code></pre>
<p>takes the demand on a function's result (which was inferred based on how the function's result is used) and uses that to compute the demand type of this particular occurrence of the function itself.</p>
<pre><code>dmdTransform</code></pre>
<p>has four cases, depending on whether the function being analyzed is a [wiki:Commentary/Compiler/EntityTypes data constructor] worker, an imported (global) function, a local</p>
<pre><code>let</code></pre>
<p>-bound function, or &quot;anything else&quot; (e.g., a local lambda-bound function).</p>
<p>The data constructor case checks whether this particular constructor call is saturated. If not, it returns</p>
<pre><code>topDmdType</code></pre>
<p>, indicating that we know nothing about the demand type. If so, it returns a</p>
<pre><code>DmdType</code></pre>
<p>with an empty environment (since there are no free variables), a list of arg-demands based on the</p>
<pre><code>Demand</code></pre>
<p>that was passed in to</p>
<pre><code>dmdTransform</code></pre>
<p>(that is, the demand on the result of the data constructor call), and a</p>
<pre><code>DmdResult</code></pre>
<p>taken from the constructor Id's strictness signature.</p>
<p>There are a couple of tricky things about the list of arg-demands:</p>
<ul>
<li>If the result demand (i.e., the passed-in demand) has its box demanded, then we want to make sure the box is demanded in each of the demands for the args. (ToDo: this may not be true)</li>
<li>If the result demand is not strict, we want to use <em>n</em> copies of
<pre><code>topDmd</code></pre>
<p>as the list of arg-demands, where <em>n</em> is this data constructor's arity.</p></li>
</ul>
<p>(ToDo: explain the other cases of</p>
<pre><code>dmdTransform</code></pre>
<p>)</p>
<p>[wiki:Commentary/Compiler/StrictnessAnalysis/KirstenNotes even more sketchy notes]</p>
<p>[wiki:Commentary/Compiler/StrictnessAnalysis/Examples]</p>
<h1 id="symbol-names">Symbol Names</h1>
<p>Since Haskell allows many symbols in constructor and variable names that C compilers or assembly might not allow (e.g. :, %, #) these have to be encoded using z-encoding. The encoding is as follows. See <a href="GhcFile(compiler/utils/Encoding.hs)" class="uri" title="wikilink">GhcFile(compiler/utils/Encoding.hs)</a>.</p>
<h2 id="tuples">Tuples</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Decoded</p></td>
<td align="left"><p>Encoded</p></td>
<td align="left"><p>Comment</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>()</code></pre></td>
<td align="left"><p>Z0T</p></td>
<td align="left"><p>Unit / 0-tuple</p></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>There is no Z1T</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>(,)</code></pre></td>
<td align="left"><p>Z2T</p></td>
<td align="left"><p>2-tuple</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>(,,)</code></pre></td>
<td align="left"><p>Z3T</p></td>
<td align="left"><p>3-tuple</p></td>
</tr>
<tr class="even">
<td align="left"><p>...</p></td>
<td align="left"></td>
<td align="left"><p>And so on</p></td>
</tr>
</tbody>
</table>
<h2 id="unboxed-tuples">Unboxed Tuples</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Decoded</p></td>
<td align="left"><p>Encoded</p></td>
<td align="left"><p>Comment</p></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>There is no Z0H</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>(# #)</code></pre></td>
<td align="left"><p>Z1H</p></td>
<td align="left"><p>unboxed 1-tuple (note the space)</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>(#,#)</code></pre></td>
<td align="left"><p>Z2H</p></td>
<td align="left"><p>unboxed 2-tuple</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>(#,,#)</code></pre></td>
<td align="left"><p>Z3H</p></td>
<td align="left"><p>unboxed 3-tuple</p></td>
</tr>
<tr class="even">
<td align="left"><p>...</p></td>
<td align="left"></td>
<td align="left"><p>And so on</p></td>
</tr>
</tbody>
</table>
<h2 id="alphanumeric-characters">Alphanumeric Characters</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Decoded</p></td>
<td align="left"><p>Encoded</p></td>
<td align="left"><p>Comment</p></td>
</tr>
<tr class="even">
<td align="left"><p>a-y, A-Y, 0-9</p></td>
<td align="left"><p>a-y, A-Y, 0-9</p></td>
<td align="left"><p>Regular letters don't need escape sequences</p></td>
</tr>
<tr class="odd">
<td align="left"><p>z, Z</p></td>
<td align="left"><p>zz, ZZ</p></td>
<td align="left"><p>'Z' and 'z' must be escaped</p></td>
</tr>
</tbody>
</table>
<h2 id="constructor-characters">Constructor Characters</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Decoded</p></td>
<td align="left"><p>Encoded</p></td>
<td align="left"><p>Comment</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>(</code></pre></td>
<td align="left"><p>ZL</p></td>
<td align="left"><p>Left</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>)</code></pre></td>
<td align="left"><p>ZR</p></td>
<td align="left"><p>Right</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>[</code></pre></td>
<td align="left"><p>ZM</p></td>
<td align="left"><p>'M' before 'N' in []</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>]</code></pre></td>
<td align="left"><p>ZN</p></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><pre><code>:</code></pre></td>
<td align="left"><p>ZC</p></td>
<td align="left"><p>Colon</p></td>
</tr>
</tbody>
</table>
<h2 id="variable-characters">Variable Characters</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Decoded</p></td>
<td align="left"><p>Encoded</p></td>
<td align="left"><p>Mnemonic</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>&amp;</code></pre></td>
<td align="left"><p>za</p></td>
<td align="left"><p>Ampersand</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>|</code></pre></td>
<td align="left"><p>zb</p></td>
<td align="left"><p>Bar</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>^</code></pre></td>
<td align="left"><p>zc</p></td>
<td align="left"><p>Caret</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>$</code></pre></td>
<td align="left"><p>zd</p></td>
<td align="left"><p>Dollar</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>=</code></pre></td>
<td align="left"><p>ze</p></td>
<td align="left"><p>Equals</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>&gt;</code></pre></td>
<td align="left"><p>zg</p></td>
<td align="left"><p>Greater than</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>#</code></pre></td>
<td align="left"><p>zh</p></td>
<td align="left"><p>Hash</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>.</code></pre></td>
<td align="left"><p>zi</p></td>
<td align="left"><p>The dot of the 'i'</p></td>
</tr>
<tr class="even">
<td align="left"><p>&lt;pre&gt;&lt;</p>
</pre></td>
<td align="left"><p>zl</p></td>
<td align="left"><p>Less than</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>-</code></pre></td>
<td align="left"><p>zm</p></td>
<td align="left"><p>Minus</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>&lt;nowiki&gt;</code></pre>
<p></nowiki></p></td>
<td align="left"><p>zn</p></td>
<td align="left"><p>Not</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>+</code></pre></td>
<td align="left"><p>zp</p></td>
<td align="left"><p>Plus</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>&#39;</code></pre></td>
<td align="left"><p>zq</p></td>
<td align="left"><p>Quote</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>\</code></pre></td>
<td align="left"><p>zr</p></td>
<td align="left"><p>Reverse slash</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>/</code></pre></td>
<td align="left"><p>zs</p></td>
<td align="left"><p>Slash</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>*</code></pre></td>
<td align="left"><p>zt</p></td>
<td align="left"><p>Times sign</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>_</code></pre></td>
<td align="left"><p>zu</p></td>
<td align="left"><p>Underscore</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>%</code></pre></td>
<td align="left"><p>zv</p></td>
<td align="left"><p>(TODO: I don't know what the mnemonic for this one is. Perhaps relatiVe or diVide?)</p></td>
</tr>
</tbody>
</table>
<h2 id="other-1">Other</h2>
<p>Any other character is encoded as a 'z' followed by its hex code (lower case, variable length) followed by 'U'. If the hex code starts with 'a', 'b, 'c', 'd', 'e' or 'f', then an extra '0' is placed before the hex code to avoid conflicts with the other escape characters.</p>
<h2 id="examples">Examples</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><p>Before</p></td>
<td align="left"><p>After</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>Trak</code></pre></td>
<td align="left"><pre><code>Trak</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>foo_wib</code></pre></td>
<td align="left"><pre><code>foozuwib</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>&gt;</code></pre></td>
<td align="left"><pre><code>zg</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>&gt;1</code></pre></td>
<td align="left"><pre><code>zg1</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>foo#</code></pre></td>
<td align="left"><pre><code>foozh</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>foo##</code></pre></td>
<td align="left"><pre><code>foozhzh</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>foo##1</code></pre></td>
<td align="left"><pre><code>foozhzh1</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>fooZ</code></pre></td>
<td align="left"><pre><code>fooZZ</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>:+</code></pre></td>
<td align="left"><pre><code>ZCzp</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>()</code></pre></td>
<td align="left"><pre><code>Z0T</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>(,,,,)</code></pre></td>
<td align="left"><pre><code>Z5T</code></pre></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>(# #)</code></pre></td>
<td align="left"><pre><code>Z1H</code></pre></td>
</tr>
<tr class="even">
<td align="left"><pre><code>(#,,,,#)</code></pre></td>
<td align="left"><pre><code>Z5H</code></pre></td>
</tr>
</tbody>
</table>
<p>[ Up: [wiki:Commentary/Compiler/TypeChecker] ]</p>
<h1 id="the-monad-for-renaming-typechecking-desugaring">The monad for renaming, typechecking, desugaring</h1>
<p>The renamer, typechecker, interface-file typechecker, and desugarer all share a certain amount in common: they must report errors, handle environments, do I/O, etc. Furthermore, because of Template Haskell we have to interleave renaming and typechecking. So all four share a common monad, called</p>
<pre><code>TcRnIf</code></pre>
<p>. This infrastructure is defined by the following modules:</p>
<ul>
<li><a href="GhcFile(compiler/utils/IOEnv.lhs)" class="uri" title="wikilink">GhcFile(compiler/utils/IOEnv.lhs)</a>: extends the IO monad with an environment (just a simple reader monad).</li>
<li><a href="GhcFile(compiler/typecheck/TcRnTypes)" class="uri" title="wikilink">GhcFile(compiler/typecheck/TcRnTypes)</a>: builds the
<pre><code>TcRnIf</code></pre>
<p>monad on top of</p>
<pre><code>IOEnv</code></pre>
<dl>

<dd>
</dd>
</dl></li>
<li><a href="GhcFile(compiler/typecheck/TcRnMonad)" class="uri" title="wikilink">GhcFile(compiler/typecheck/TcRnMonad)</a>: defines lots of access functions for the renamer, typechecker, and interface typechecker.</li>
<li><a href="GhcFile(compiler/typecheck/DsMonad)" class="uri" title="wikilink">GhcFile(compiler/typecheck/DsMonad)</a>: specialises the
<pre><code>TcRnIf</code></pre>
<p>monad for the desugarer.</p></li>
</ul>
<p>The typechecker and renamer use <em>exactly</em> the same monad,</p>
<pre><code>TcRn</code></pre>
<p>; the desugarer and interface-file checker use different instantiations of</p>
<pre><code>TcRnIf</code></pre>
<p>. To give you the idea, here is how the</p>
<pre><code>TcRn</code></pre>
<p>monad looks:</p>
<pre><code>type TcRn a       = TcRnIf TcGblEnv TcLclEnv a
type TcRnIf a b c = IOEnv (Env a b) c

data Env gbl lcl    -- Changes as we move into an expression
  = Env {
    env_top  :: HscEnv, -- Top-level stuff that never changes
                -- Includes all info about imported things

    env_us   :: TcRef UniqSupply,   -- Unique supply for local varibles

    env_gbl  :: gbl,    -- Info about things defined at the top level
                -- of the module being compiled

    env_lcl  :: lcl     -- Nested stuff; changes as we go into 
                -- an expression
    }

type RnM  a = TcRn a        -- Historical
type TcM  a = TcRn a        -- Historical</code></pre>
<p>The details of the global environment type</p>
<pre><code>TcGblEnv</code></pre>
<p>and local environment type</p>
<pre><code>TcLclEnv</code></pre>
<p>are also defined in <a href="GhcFile(compiler/typecheck/TcRnTypes.lhs)" class="uri" title="wikilink">GhcFile(compiler/typecheck/TcRnTypes.lhs)</a>. Side effecting operations, such as updating the unique supply, are done with TcRefs, which are simply a synonym for IORefs.</p>
<p>(NB out-of-date, but maybe historically useful; cf [wiki:Debugging/TickyTicky])</p>
<h1 id="kirstens-sketchy-notes-on-getting-ticky-to-work">Kirsten's sketchy notes on getting ticky to work</h1>
<p>Macros for bumping ticky counters are now defined in <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a>. Currently, code compiled with the</p>
<pre><code>-fticky-ticky</code></pre>
<p>flag fails to link because the macros rely on counter variables (things with names like</p>
<pre><code>ENT_DYN_IND_ctr</code></pre>
<p>being declared, but there are actually no declarations for them. I'll add those declarations to <a href="GhcFile(includes/RtsExternal.h)" class="uri" title="wikilink">GhcFile(includes/RtsExternal.h)</a> so I can get something working. Really, there should be something that automatically generates both the macros that are in <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a> and the declarations for the corresponding variables, so that they stay in sync.</p>
<p>Actually, maybe it would make more sense to add a new file,</p>
<pre><code>RtsTicky.h</code></pre>
<p>or something, which contains only ticky counter declarations (the same declarations that still exist in <a href="GhcFile(includes/StgTicky.h)" class="uri" title="wikilink">GhcFile(includes/StgTicky.h)</a>, which isn't used anymore), and that include that from <a href="GhcFile(includes/RtsExternal.h)" class="uri" title="wikilink">GhcFile(includes/RtsExternal.h)</a>.</p>
<p>No -- put actual declarations for counter variables in another file,</p>
<pre><code>TickyCounters.h</code></pre>
<p>or something, and include that only from <a href="GhcFile(rts/Ticky.c)" class="uri" title="wikilink">GhcFile(rts/Ticky.c)</a>; put <em>extern</em> declarations for those counters in</p>
<pre><code>RtsTicky.h</code></pre>
<p>, still included from <a href="GhcFile(includes/RtsExternal.h)" class="uri" title="wikilink">GhcFile(includes/RtsExternal.h)</a>. Then later we can automatically generate both</p>
<pre><code>RtsTicky.h</code></pre>
<p>and</p>
<pre><code>TickyCounters.h</code></pre>
<p>. The reason for this is that the ticky <strong>macros</strong> are all over the place and they refer to the ticky counters, so the ticky counters have to be <strong>declared</strong> someplace that everyone includes, but of course the actual initializations only need to happen in one place. (Maybe there's a better way to do this...)</p>
<p>No, there don't need to be two files; I was confused. Just</p>
<pre><code>TickyCounters.h</code></pre>
<p>.</p>
<p>Huh - we define ticky macros now in</p>
<pre><code>Cmm.h</code></pre>
<p>but we can only include that in CMM files and some C files, like</p>
<pre><code>Schedule.c</code></pre>
<p>, use ticky macros. This makes my brain hurt a little.</p>
<p>''' Index by Title ''' | ''' [RecentChanges Index by Date] '''</p>
<p><a href="TitleIndex(format=group,min=4)" class="uri" title="wikilink">TitleIndex(format=group,min=4)</a></p>
<h1 id="the-ghc-commentary-checking-types">The GHC Commentary: Checking Types</h1>
<p>Probably the most important phase in the frontend is the type checker, which is located at <a href="GhcFile(compiler/typecheck/)" class="uri" title="wikilink">GhcFile(compiler/typecheck/)</a>. GHC type checks programs in their original Haskell form before the desugarer converts them into Core code. This complicates the type checker as it has to handle the much more verbose Haskell AST, but it improves error messages, as those message are based on the same structure that the user sees.</p>
<p>GHC defines the abstract syntax of Haskell programs in <a href="GhcModule(compiler/hsSyn/HsSyn.lhs)" class="uri" title="wikilink">GhcModule(compiler/hsSyn/HsSyn.lhs)</a> using a structure that abstracts over the concrete representation of bound occurences of identifiers and patterns. The module <a href="GhcModule(compiler/typecheck/TcHsSyn.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcHsSyn.lhs)</a> defines a number of helper function required by the type checker. Note that the type <a href="GhcModule(compiler/typecheck/TcRnTypes.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcRnTypes.lhs)</a>.</p>
<pre><code>TcId</code></pre>
<p>used to represent identifiers in some signatures during type checking is, in fact, nothing but a synonym for a [wiki:Commentary/Compiler/EntityTypes#Typevariablesandtermvariables plain Id].</p>
<p>It is also noteworthy, that the representations of types changes during type checking from</p>
<pre><code>HsType` to `TypeRep.Type`. The latter is a [wiki:Commentary/Compiler/TypeType hybrid type] representation that is used to type Core, but still contains sufficient information to recover source types. In particular, the type checker maintains and compares types in their `Type</code></pre>
<p>form.</p>
<h2 id="the-overall-flow-of-things">The Overall Flow of Things</h2>
<ul>
<li><pre><code>TcRnDriver</code></pre>
<p>is the top level. It calls</p>
<ul>
<li><pre><code>TcTyClsDecls</code></pre>
<dl>

<dd>type and class declaration
</dd>
</dl></li>
<li><pre><code>TcInstDcls</code></pre>
<dl>

<dd>instance declarations
</dd>
</dl></li>
<li><pre><code>TcBinds</code></pre>
<dl>

<dd>value bindings
</dd>
</dl>
<ul>
<li><pre><code>TcExpr</code></pre>
<dl>

<dd>expressions
</dd>
</dl></li>
<li><pre><code>TcMatches</code></pre>
<dl>

<dd>lambda, case, list comprehensions
</dd>
</dl></li>
<li><pre><code>TcPat</code></pre>
<dl>

<dd>patterns
</dd>
</dl></li>
</ul></li>
<li><pre><code>TcForeign</code></pre>
<dl>

<dd>FFI declarations
</dd>
</dl></li>
<li><pre><code>TcRules</code></pre>
<dl>

<dd>rewrite rules
</dd>
</dl></li>
<li><pre><code>TcHsTypes</code></pre>
<dl>

<dd>kind-checking type signatures
</dd>
</dl></li>
<li><pre><code>TcValidity</code></pre>
<dl>

<dd>a second pass that walks over things like types or type constructors, checking a number of extra side conditions.
</dd>
</dl></li>
</ul></li>
</ul>
<ul>
<li>The constraint solver consists of:
<ul>
<li><pre><code>TcSimplify</code></pre>
<dl>

<dd>top level of the constraint solver
</dd>
</dl></li>
<li><pre><code>TcCanonical</code></pre>
<dl>

<dd>canonicalising constraints
</dd>
</dl></li>
<li><pre><code>TcInteract</code></pre>
<dl>

<dd>solving constraints where they interact with each other
</dd>
</dl></li>
<li><pre><code>TcTypeNats</code></pre>
<dl>

<dd>solving natural-number constraints
</dd>
</dl></li>
<li><pre><code>TcSMonad</code></pre>
<dl>

<dd>the monad of the constraint solver (built on top of the main typechecker monad)
</dd>
</dl></li>
<li><pre><code>TcEvidence</code></pre>
<dl>

<dd>the data types used for evidence (mostly pure)
</dd>
</dl></li>
<li><pre><code>TcUnify</code></pre>
<dl>

<dd>solves unification constraints &quot;on the fly&quot;; if it can't, it generates a constraint for the constraint solver to deal with later
</dd>
</dl></li>
<li><pre><code>TcErrors</code></pre>
<dl>

<dd>generates good error messages from the residual, unsolved constraints.<br />

</dd>
</dl></li>
</ul></li>
</ul>
<p><code>The best place reading for the constraint solver is the paper </code><a href="http://www.haskell.org/haskellwiki/Simonpj/Talk:OutsideIn"><code>Modular</code> <code>type</code> <code>inference</code> <code>with</code> <code>local</code> <code>assumptions</code></a></p>
<ul>
<li>Underlying infrastructure:
<ul>
<li><pre><code>TcRnTypes</code></pre>
<dl>

<dd>a big collection of the types used during type checking
</dd>
</dl></li>
<li>[wiki:Commentary/Compiler/TcRnMonad TcRnMonad]: the main typechecker monad</li>
<li><pre><code>TcType</code></pre>
<dl>

<dd>pure functions over types, used by the type checker
</dd>
</dl></li>
</ul></li>
</ul>
<h3 id="entry-points-into-the-type-checker">Entry Points Into the Type Checker</h3>
<p>The interface of the type checker (and [wiki:Commentary/Compiler/Renamer renamer]) to the rest of the compiler is provided by <a href="GhcModule(compiler/typecheck/TcRnDriver.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcRnDriver.lhs)</a>. Entire modules are processed by calling</p>
<pre><code>tcRnModule` and GHCi uses `tcRnStmt`, `tcRnExpr`, and `tcRnType` to typecheck statements and expressions, and to kind check types, respectively. Moreover, `tcTopSrcDecls` is used by Template Haskell - more specifically by `TcSplice.tc_bracket</code></pre>
<p>- to type check the contents of declaration brackets.</p>
<h3 id="renaming-and-type-checking-a-module">Renaming and Type Checking a Module</h3>
<p>The functions</p>
<pre><code>tcRnModule` and `tcRnModuleTcRnM</code></pre>
<p>control the complete static analysis of a Haskell module. They set up the combined renamer and type checker monad, resolve all import statements, take care of hi-boot files, initiate the actual renaming and type checking process, and finally, wrap off by processing the export list.</p>
<p>The actual type checking and renaming process is initiated via</p>
<pre><code>TcRnDriver.tcRnSrcDecls`, which uses a helper called `tc_rn_src_decls` to implement the iterative renaming and type checking process required by [http://darcs.haskell.org/ghc/docs/comm/exts/th.html Template Haskell] (TODO: Point at new commentary equivalent). After it invokes `tc_rn_src_decls</code></pre>
<p>, it simplifies type constraints and zonking (see below regarding the later).</p>
<p>The function</p>
<pre><code>tc_rn_src_decls` partitions static analysis of a whole module into multiple rounds, where the initial round is followed by an additional one for each toplevel splice. It collects all declarations up to the next splice into an `HsDecl.HsGroup`. To rename and type check that declaration group it calls `TcRnDriver.rnTopSrcDecls` and `TcRnDriver.tcTopSrcDecls</code></pre>
<p>. Afterwards, it executes the splice (if there are any left) and proceeds to the next group, which includes the declarations produced by the splice.</p>
<p>The renamer, apart from renaming, computes the global type checking environment, of type</p>
<pre><code>TcRnTypes.TcGblEnv</code></pre>
<p>, which is stored in the [wiki:Commentary/Compiler/TcRnMonad type checking monad] before type checking commences.</p>
<h2 id="type-checking-a-declaration-group">Type Checking a Declaration Group</h2>
<p>The type checking of a declaration group, performed by</p>
<pre><code>tcTopSrcDecls` and its helper function `tcTyClsInstDecls`, starts by processing of the type and class declarations of the current module, using the function `TcTyClsDecls.tcTyAndClassDecls`. This is followed by a first round over instance declarations using `TcInstDcls.tcInstDecls1`, which in particular generates all additional bindings due to the deriving process. Then come foreign import declarations (`TcForeign.tcForeignImports`) and default declarations (`TcDefaults.tcDefaults</code></pre>
<p>).</p>
<p>Now, finally, toplevel value declarations (including derived ones) are type checked using</p>
<pre><code>TcBinds.tcTopBinds`. Afterwards, `TcInstDcls.tcInstDecls2` traverses instances for the second time. Type checking concludes with processing foreign exports (`TcForeign.tcForeignExports`) and rewrite rules (`TcRules.tcRules</code></pre>
<p>). Finally, the global environment is extended with the new bindings.</p>
<h2 id="type-checking-type-and-class-declarations">Type checking Type and Class Declarations</h2>
<p>Type and class declarations are type checked in a couple of phases that contain recursive dependencies - aka <em>knots</em>. The first knot encompasses almost the whole type checking of these declarations and forms the main piece of</p>
<pre><code>TcTyClsDecls.tcTyAndClassDecls</code></pre>
<p>.</p>
<p>Inside this big knot, the first main operation is kind checking, which again involves a knot. It is implemented by</p>
<pre><code>kcTyClDecls`, which performs kind checking of potentially recursively-dependent type and class declarations using kind variables for initially unknown kinds. During processing the individual declarations some of these variables will be instantiated depending on the context; the rest gets by default kind * (during &#39;&#39;zonking&#39;&#39; of the kind signatures). Type synonyms are treated specially in this process, because they can have an unboxed type, but they cannot be recursive. Hence, their kinds are inferred in dependency order. Moreover, in contrast to class declarations and other type declarations, synonyms are not entered into the global environment as a global `TyThing`. (`TypeRep.TyThing</code></pre>
<p>is a sum type that combines the various flavours of typish entities, such that they can be stuck into type environments and similar.)</p>
<h2 id="more-details">More Details</h2>
<h3 id="types-variables-and-zonking">Types Variables and Zonking</h3>
<p>During type checking type variables are represented by mutable variables - cf. the <a href="http://darcs.haskell.org/ghc/docs/comm/the-beast/vars.html#TyVar">variable story</a> (TODO: Point at new commentary equivalent). Consequently, unification can instantiate type variables by updating those mutable variables. This process of instantiation is (for reasons that elude me) called <a href="http://dictionary.reference.com/browse/zonk">zonking</a> in GHC's sources. The zonking routines for the various forms of Haskell constructs are responsible for most of the code in the module <a href="GhcModule(compiler/typecheck/TcHsSyn.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcHsSyn.lhs)</a>, whereas the routines that actually operate on mutable types are defined in <a href="GhcModule(compiler/typecheck/TcMType.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcMType.lhs)</a>; this includes the zonking of type variables and type terms, routines to create mutable structures and update them as well as routines that check constraints, such as that type variables in function signatures have not been instantiated during type checking. The actual type unification routine is</p>
<pre><code>uTys</code></pre>
<p>in the module <a href="GhcModule(compiler/typecheck/TcUnify.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcUnify.lhs)</a>.</p>
<p>All type variables that may be instantiated (those in signatures may not), but haven't been instantiated during type checking, are zonked to</p>
<pre><code>()</code></pre>
<p>, so that after type checking all mutable variables have been eliminated.</p>
<h3 id="type-representation">Type Representation</h3>
<p>The representation of types is fixed in the module <a href="GhcModule(compiler/types/TypeRep.lhs)" class="uri" title="wikilink">GhcModule(compiler/types/TypeRep.lhs)</a> and exported as the data type</p>
<pre><code>Type`. Read the comments in the `TypeRep</code></pre>
<p>module! A couple of points:</p>
<ul>
<li>Type synonym applications are represented as a
<pre><code>TyConApp` with a `TyCon` that contains the expansion.  The expansion is done on-demand by `Type.coreView</code></pre>
<p>. Unexpanded type synonyms are useful for generating comprehensible error messages.</p></li>
</ul>
<ul>
<li>The
<pre><code>PredTy` constructor wraps a type constraint argument (dictionary, implicit parameter, or equality).  They are expanded on-demand by `coreView</code></pre>
<p>.</p></li>
</ul>
<p>As explained in <a href="GhcModule(compiler/typecheck/TcType.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcType.lhs)</a>, GHC supports rank-N types, but during type inference maintains the restriction that type variables cannot be instantiated to quantified types (i.e., the type system is predicative). However the type system of Core is fully impredicative.</p>
<h3 id="type-checking-environment">Type Checking Environment</h3>
<p>During type checking, GHC maintains a <em>type environment</em> whose type definitions are fixed in the module <a href="GhcModule(compiler/typecheck/TcRnTypes.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcRnTypes.lhs)</a> with the operations defined in <a href="GhcModule(compiler/typecheck/TcEnv.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcEnv.lhs)</a>. Among other things, the environment contains all imported and local instances as well as a list of <em>global</em> entities (imported and local types and classes together with imported identifiers) and <em>local</em> entities (locally defined identifiers). This environment is threaded through the [wiki:Commentary/Compiler/TcRnMonad type checking monad].</p>
<h3 id="expressions-1">Expressions</h3>
<p>Expressions are type checked by <a href="GhcModule(compiler/typecheck/TcExpr)" class="uri" title="wikilink">GhcModule(compiler/typecheck/TcExpr)</a>.</p>
<p>Usage occurences of identifiers are processed by the function tcId whose main purpose is to [#HandlingofDictionariesandMethodInstances instantiate overloaded identifiers]. It essentially calls</p>
<pre><code>TcInst.instOverloadedFun</code></pre>
<p>once for each universally quantified set of type constraints. It should be noted that overloaded identifiers are replaced by new names that are first defined in the LIE (Local Instance Environment?) and later promoted into top-level bindings.</p>
<h3 id="handling-of-dictionaries-and-method-instances">Handling of Dictionaries and Method Instances</h3>
<p>GHC implements overloading using so-called <em>dictionaries</em>. A dictionary is a tuple of functions -- one function for each method in the class of which the dictionary implements an instance. During type checking, GHC replaces each type constraint of a function with one additional argument. At runtime, the extended function gets passed a matching class dictionary by way of these additional arguments. Whenever the function needs to call a method of such a class, it simply extracts it from the dictionary.</p>
<p>This sounds simple enough; however, the actual implementation is a bit more tricky as it wants to keep track of all the instances at which overloaded functions are used in a module. This information is useful to optimise the code. The implementation is the module <a href="GhcModule(compiler/typecheck/Inst.lhs)" class="uri" title="wikilink">GhcModule(compiler/typecheck/Inst.lhs)</a>.</p>
<p>The function</p>
<pre><code>instOverloadedFun` is invoked for each overloaded usage occurrence of an identifier, where overloaded means that the type of the identifier contains a non-trivial type constraint. It proceeds in two steps: (1) Allocation of a method instance (`newMethodWithGivenTy</code></pre>
<p>) and (2) instantiation of functional dependencies. The former implies allocating a new unique identifier, which replaces the original (overloaded) identifier at the currently type-checked usage occurrence.</p>
<p>The new identifier (after being threaded through the LIE) eventually will be bound by a top-level binding whose rhs contains a partial application of the original overloaded identifier. This papp applies the overloaded function to the dictionaries needed for the current instance. In GHC lingo, this is called a <em>method</em>. Before becoming a top-level binding, the method is first represented as a value of type Inst.Inst, which makes it easy to fold multiple instances of the same identifier at the same types into one global definition. (And probably other things, too, which I haven't investigated yet.)</p>
<p><strong>Note:</strong> As of 13 January 2001 (wrt. to the code in the CVS HEAD), the above mechanism interferes badly with RULES pragmas defined over overloaded functions. During instantiation, a new name is created for an overloaded function partially applied to the dictionaries needed in a usage position of that function. As the rewrite rule, however, mentions the original overloaded name, it won't fire anymore -- unless later phases remove the intermediate definition again. The latest CVS version of GHC has an option '-fno-method-sharing', which avoids sharing instantiation stubs. This is usually/often/sometimes sufficient to make the rules fire again.</p>
<h2 id="connection-with-ghcs-constraint-solver">Connection with GHC's Constraint Solver</h2>
<p>The solver for the type nats is implemented as an extra stage in GHC's constrraint solver (see</p>
<pre><code>TcInteract.thePipeline</code></pre>
<p>).</p>
<p>The following modules contain most of the code relevant for the solver:</p>
<ul>
<li><pre><code>TcTypeNats</code></pre>
<dl>

<dd>The main solver machinery
</dd>
</dl></li>
<li><pre><code>TcTypeNatsRules</code></pre>
<dl>

<dd>The rules used by the solver
</dd>
</dl></li>
<li><pre><code>TcTYpeNatsEval</code></pre>
<dl>

<dd>Functions for direct evaluation on constants
</dd>
</dl></li>
</ul>
<h2 id="generating-evidence">Generating Evidence</h2>
<p>The solver produces evidence (i.e., proofs) when computing new &quot;given&quot; constraints, or when solving existing &quot;wanted&quot; constraints. The evidence is constructed by applications of a set of pre-defined rules. The rules are values of type</p>
<pre><code>TypeRep.CoAxiomRule</code></pre>
<p>. Conceptually, rules have the form:</p>
<pre><code>    name :: forall tyvars. assumptions =&gt; conclusion</code></pre>
<p>The rules have the usual logical meaning: the variables are universally quantified, and the assumptions imply the concluson. As a concrete example, consider the rule for left-cancellation of addtion:</p>
<pre><code>    AddCanceL :: forall a b c d. (a + b ~ d, a + c ~ d) =&gt; b ~ c</code></pre>
<p>The type</p>
<pre><code>CoAxiomRule</code></pre>
<p>also supports infinte literal-indexed families of simple axioms using constructor</p>
<pre><code>CoAxiomTyLit</code></pre>
<p>. These have the form:</p>
<pre><code>    name(l_1 .. l_n) :: conclusion</code></pre>
<p>In this case</p>
<pre><code>conclusion</code></pre>
<p>is an equation that contains no type variables but may depend on the literals in the name of the family. For example, the basic definitional axiom for addition,</p>
<pre><code>TcTypeNatsRules.axAddDef</code></pre>
<p>, uses this mechanism:</p>
<pre><code>    AddDef(2,3) :: 2 + 3 ~ 5</code></pre>
<p>At present, the assumptions and conclusion of all rules are equations between types but this restriction is not important and could be lifted in the future.</p>
<p>The rules used by the solver are in module</p>
<pre><code>TcTypeNatsRules</code></pre>
<p>.</p>
<h2 id="the-solver">The Solver</h2>
<p>The entry point to the solver is</p>
<pre><code>TcTypeNats.typeNatStage</code></pre>
<p>.</p>
<p>We start by examining the constraint to see if it is obviously unsolvable (using function</p>
<pre><code>impossible</code></pre>
<p>), and if so we stash it in the constraint-solver's state and stop. Note that there is no assumption that</p>
<pre><code>impossible</code></pre>
<p>is complete, but it is important that it is sound, so if</p>
<pre><code>impossible` returns `True</code></pre>
<p>, then the constraint is definitely unsolvable, but if</p>
<pre><code>impossible` returns `False</code></pre>
<p>, then we don't know if the constraint is solvable or not.</p>
<p>The rest of the stage proceeds depending on the type of constraint, as follows.</p>
<h3 id="given-constraints">Given Constraints</h3>
<p>Given constraints correspond to adding new assumptions that may be used by the solver. We start by checking if the new constraint is trivial (using function</p>
<pre><code>solve</code></pre>
<p>). A constraint is considered to be trivial if it matches an already existing constraint or a rule that is known to the solver. Such given constraints are ignored because they do not contribute new information. If the new given is non-trivial, then it will be recorded to the inert set as a new fact, and we proceed to &quot;interact&quot; it with existing givens, in the hope of computing additional useful facts (function</p>
<pre><code>computeNewGivenWork</code></pre>
<p>).</p>
<p>IMPORTANT: We assume that &quot;given&quot; constraints are processed before &quot;wanted&quot; ones. A new given constraint may be used to solve any existing wanted, so every time we added a new given to the inert set we should move all potentially solvable &quot;wanted&quot; constraint from the inert set back to the work queue. We DON'T do this, because it is quite inefficient: there is no obvious way to compute which &quot;wanted&quot;s might be affected, so we have to restart all of them!</p>
<p>The heart of the interaction is the function</p>
<pre><code>interactCt</code></pre>
<p>, which performs one step of &quot;forward&quot; reasoning. The idea is to compute new constraints whose proofs are made by an application of a rule to the new given, and some existing givens. These new constraints are added as new work, to be processed further on the next iteration of GHC's constraint solver.</p>
<p>Aside: when we compute the new facts, we check to see if any are obvious contradictions. This is not strictly necessary because they would be detected on the next iteration of the solver. However, by doing the check early we get slightly better error messages because we can report the original constraint as being unsolvable (it leads to a contradiction), which tends to be easier to relate to the original program. Of course, this is not completely fool-proof---it is still possible that a contradiction is detected at a later iteration. An alternative idea---not yet implemented---would be to examine the proof of a contradiction and extract the original constraints that lead to it in the first place.</p>
<h3 id="derived-constraints">Derived Constraints</h3>
<pre><code>`Derived`</code></pre>
<p>constraints are facts that are implied by the constraints in the inert set. They do not have complete proofs because they may depend on proofs of as yet unsolved wanted constraints. GHC does not associate any proof terms with derived constraints (to keep things simple?). In the constraint solver, they are mostly used as &quot;hints&quot;. For example, consider the wanted constraint</p>
<pre><code>5 + 3 ~ x</code></pre>
<p>, where</p>
<pre><code>x</code></pre>
<p>is a free unification variable. These are the steps we'll take to solve the constraint:</p>
<pre><code>    Rules:
    Add_def(5,3) : 5 + 3 ~ 8
    Add_fun      : forall a b c1 c2. (a + b ~ c1, a + b ~ c2) =&gt; c1 ~ c2

#  Add to inert set:
       [W] C: 5 + 3 ~ x
##  Generate new derived:
       [D] Add_fun(C,Add_def) : x ~ 8   (proof discarded)
###  GHC uses this hint to improve and reconsider the wanted:
       [W] C: 5 + 3 ~ 8
####  Solved:
       [W] C = Add_def(5,3)</code></pre>
<p>The type-nat solver processes derived constraints in a similar fashion to given constraints (</p>
<pre><code>computeNewDerivedWork</code></pre>
<p>): it checks to see if they are trivially known and, if not, then it tries to generate some additional derived constraints. The main difference is that derived constraints can be interacted with all existing constraints to produce new facts, while given constraints only interact with other givens.</p>
<h3 id="wanted-constraints">Wanted Constraints</h3>
<p>The main purpose of the solver is to discharge</p>
<pre><code>`wanted`</code></pre>
<p>constraints (the purpose of processing given and derived constraints is to help solve existing wanted goals). When we encounter a new wanted goals we proceed as follows:</p>
<ol>
<li><ol>
<li>Try to solve the goal, using a few different strategies:
<ol>
<li>Try to see if it matches the conclusion of an iff rule (
<pre><code>solveIff</code></pre>
<p>). Aassumptions of rule become new wanted work.</p></li>
<li>Try to see if it matches an axiom exactly (
<pre><code>solve</code></pre>
<p>)</p></li>
<li>Try the ordering solver for &lt;pre&gt;&lt;=` goals (`solveLeq
</pre>
<p>)</p></li>
<li>Try to use a (possibly synthesized) assumption</li>
</ol></li>
</ol></li>
</ol>
<ol>
<li><ol>
<li>If that didn't work:
<ol>
<li>Wanted is added to the inert set</li>
<li>Check to see if any of the existing wanteds in the inert set can be solved in terms of the new goal (
<pre><code>reExamineWanteds</code></pre>
<p>)</p></li>
<li>Generate new derived facts.</li>
</ol></li>
</ol></li>
</ol>
<h4 id="using-iff-rules">Using IFF Rules</h4>
<p>These rules are used to replace a wanted constraint with a collection of logically equivalent wanted constraints. If a wanted constraint matches the head of one of these rules, than it is solved using the rules, and the we generate new wanted constraints for the rule's assumptions.</p>
<p>The following are important properties of IFF rules:</p>
<ul>
<li>They need to be sound (of course)</li>
<li>The assumptions need to be logically equivalent to the conclusion (i.e., they should not result in a harder problem to solve than the original goal).</li>
<li>The assumptions need to be <em>simpler</em> from the point of view of the constraint solver (i.e., we shouldn't end up with the original goal after some steps---this would lead to non-termination).</li>
</ul>
<p>At present, IFF rules are used to define certain operators in terms of others. For example, this is the only rule for solving constraints about subtraction:</p>
<pre><code>    forall a b c. (a + b ~ c) =&gt; (c - a ~ b)</code></pre>
<h4 id="using-axioms">Using Axioms</h4>
<p>Basic operators are defined with an infinite family of axiom schemes. As we can't have these written as a long list (searching might never stop), we have some custom code that checks to see if a constraint might be solvable using one of the definitional axioms (see</p>
<pre><code>solveWithAxiom`, `byAxiom</code></pre>
<p>).</p>
<h4 id="using-the-order-model">Using the Order Model</h4>
<p>Constraints about the ordering of type-level numbers are kept in a datastructure (</p>
<pre><code>LeqFacts`) which forms a `</code></pre>
<p>model'' of the information represented by the constraints (in a similar fashion to how substitutions form a model for a set of equations).</p>
<p>The purpose of the model is to eliminate redundant constraints, and to make it easy to find proofs for queries of the form</p>
<pre><code>x &lt;= y</code></pre>
<p>. In practise, of particular interest are questions such as</p>
<pre><code>1 &lt;= x</code></pre>
<p>because these appear as assumptions on a number of rules (e.g., cancellation of multiplication). In the future, this model could also be used to implement an interval analysis, which would compute intervals approximating the values of variables.</p>
<p>TODO: At present, this model is reconstructed every time it needs to be used, which is a bit inefficient. Perhaps it'd be better to use this directly as the representation of &lt;pre&gt;&lt;=</p>
</pre>
<p>constraints in the inert set.</p>
<p>The model is a directed acyclic graph, as follows:</p>
<ul>
<li>vertices: constants or variables (of kind
<pre><code>Nat</code></pre>
<p>)</p></li>
<li>edges: the edge from
<pre><code>A` to `B` is a proof that `A &lt;= B</code></pre>
<p>.</p></li>
</ul>
<p>So, to find a proof of</p>
<pre><code>A &lt;= B`, we insert `A` and `B</code></pre>
<p>in the model, and then look for a path from</p>
<pre><code>A` to `B</code></pre>
<p>. The proofs on the path can be composed using the rule for transitivity of &lt;pre&gt;&lt;=</p>
</pre>
<p>to form the final proof.</p>
<p>When manipulating the model, we maintain the following &quot;minimality&quot; invariant: there should be no direct edge between two vertices</p>
<pre><code>A</code></pre>
<p>and</p>
<pre><code>B`, if there is a path that can already get us from `A` to </code></pre>
<p>B. Here are some examples (with edges pointing upwards)</p>
<pre><code>    B                                            B
    |\                                          / \
    | C                                        C   D
    |/                                          \ /
    A                                            A

 Invariant does not hold                 Invariant holds</code></pre>
<p>The purpose of the invariant is to eliminate redundant information. Note, however, that it does not guarantee that there is a unique way to prove a goal.</p>
<h4 id="using-extended-assumptions">Using Extended Assumptions</h4>
<p>Another way to prove a goal is to look it up in the assumptions. If the goal matched an assumption exactly, then GHC would have already solved it in one of its previous stages of the constraint solver. However, due to the commutativity and associativity of some of the operators, it is possible to have goal that could be solved by assumption, only if the assumption was &quot;massaged&quot; a bit.</p>
<p>This &quot;massaging&quot; is implemented by the function</p>
<pre><code>widenAsmps</code></pre>
<p>, which extends the set of assumption by performing a bit of forward reasoning using a limited set of rules. Typically, these are commutativity an associativity rules, and the</p>
<pre><code>widenAsmps</code></pre>
<p>function tries to complete the set of assumptions with respect to these operations. For example:</p>
<pre><code>    assumptions: C: x + y ~ z
    cur. goal:   D: y + x ~ z

    extended assumptions: C: x + y ~ z, Add_Comm(C) : y + x ~ z
    solved:               D = Add_Comm(C)</code></pre>
<p>Note that the extended assumptions are very similar to derived constraints, except that we keep their proofs.</p>
<h4 id="re-examining-wanteds">Re-examining Wanteds</h4>
<p>If none of the strategies for solving a wanted constraint worked, then the constraint is added to the inert set. Since we'd like to keep the inert set minimal, we have to see if any of the existing wanted constraints might be solvable in terms of the new wanted (</p>
<pre><code>reExamineWanteds</code></pre>
<p>).</p>
<p>It is good to keep the inert set minimal for the following reasons:</p>
<ul>
<li>Inferred types are nicer,</li>
<li>It helps GHC to solve constraints by &quot;inlining&quot; (e.g., if we</li>
</ul>
<p><code>   have only a single constraint </code></p>
<pre><code>x + y ~ z</code></pre>
<p>, then we can eliminate it</p>
<p><code>   by replacing all occurrences of </code></p>
<pre><code>z` with `x + y</code></pre>
<p>, however we can't</p>
<p><code>   do that if we ended up with two constraints `(x + y ~ z, y + x ~ z)).</code></p>
<p>We consider each (numeric) wanted constraint in the inert set and check if we can solve it in terms of the new wanted and all other wanteds. If so, then it is removed from the inert set, otherwise it stays there.</p>
<p>Note that we can't implement this by kicking out the existing wanted constraints and putting them back on the work queue, because this would lead to non-termination. Here is an example of how this might happen:</p>
<pre><code>    inert: [W] A : x &lt;= 5
    new:   [W] B : y &lt;= 5

    Can&#39;t solve B, add to inert, kick out A
    inert: [W] B : y &lt;= 5
    new:   [W] A : x &lt;= 5

    Can&#39;t solve A, add to inert, kick out B...

    ... and we are back to the beginning.</code></pre>
<p>Perhaps there is a way around this but, for the moment, we just re-examine the numeric wanteds locally, without going through the constraint solver pipe-line.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<p>= The data type</p>
<pre><code>Type</code></pre>
<p>and its friends =</p>
<p>GHC compiles a typed programming language, and GHC's intermediate language is explicitly typed. So the data type that GHC uses to represent types is of central importance.</p>
<p>The single data type</p>
<pre><code>Type</code></pre>
<p>is used to represent</p>
<ul>
<li>Types (possibly of higher kind); e.g.
<pre><code>[Int]`, `Maybe</code></pre></li>
<li>Kinds (which classify types and coercions); e.g.
<pre><code>(* -&gt; *)`, `T :=: [Int]</code></pre>
<p>. See [wiki:Commentary/Compiler/Kinds]</p></li>
<li>Sorts (which classify types); e.g.
<pre><code>TY`, `CO</code></pre></li>
</ul>
<p>GHC's use of [wiki:Commentary/Compiler/FC coercions and equality constraints] is important enough to deserve its own page.</p>
<p>The module</p>
<pre><code>TypeRep</code></pre>
<p>exposes the representation because a few other modules (</p>
<pre><code>Type</code></pre>
<p>,</p>
<pre><code>TcType</code></pre>
<p>,</p>
<pre><code>Unify</code></pre>
<p>, etc) work directly on its representation. However, you should not lightly pattern-match on</p>
<pre><code>Type</code></pre>
<p>; it is meant to be an abstract type. Instead, try to use functions defined by</p>
<pre><code>Type</code></pre>
<p>,</p>
<pre><code>TcType</code></pre>
<p>etc.</p>
<h2 id="views-of-types">Views of types</h2>
<p>Even when considering only types (not kinds, sorts, coercions) you need to know that GHC uses a <em>single</em> data type for types. You can look at the same type in different ways:</p>
<ul>
<li>The &quot;typechecker view&quot; regards the type as a Haskell type, complete with implicit parameters, class constraints, and the like. For example:</li>
</ul>
<pre><code>  forall a. (Eq a, ?x::Int) =&gt; a -&gt; Int</code></pre>
<p><code>Functions in </code></p>
<pre><code>TcType` take this view of types; e.g. `tcSplitSigmaTy</code></pre>
<p>splits up a type into its forall'd type variables, its constraints, and the rest.</p>
<ul>
<li>The &quot;core view&quot; regards the type as a Core-language type, where class and implicit parameter constraints are treated as function arguments:</li>
</ul>
<pre><code>  forall a. Eq a -&gt; Int -&gt; a -&gt; Int</code></pre>
<p><code>Functions in </code></p>
<pre><code>Type</code></pre>
<p>take this view.</p>
<p>The data type</p>
<pre><code>Type</code></pre>
<p>represents type synonym applications in un-expanded form. E.g.</p>
<pre><code>type T a = a -&gt; a
f :: T Int</code></pre>
<p>Here</p>
<pre><code>f`&#39;s type doesn&#39;t look like a function type, but it really is.  The function `Type.coreView :: Type -&gt; Maybe Type` takes a type and, if it&#39;s a type synonym application, it expands the synonym and returns `Just &lt;expanded-type&gt;`.  Otherwise it returns `Nothing</code></pre>
<p>.</p>
<p>Now, other functions use</p>
<pre><code>coreView</code></pre>
<p>to expand where necessary, thus:</p>
<pre><code>  splitFunTy_maybe :: Type -&gt; Maybe (Type,Type)
  splitFunTy_maybe ty | Just ty&#39; &lt;- coreView ty = splitFunTy_maybe ty&#39;
  splitFunTy_maybe (FunTy t1 t2) = Just (t1,t2)
  splitFunTy_maybe other         = Nothing</code></pre>
<p>Notice the first line, which uses the view, and recurses when the view 'fires'. Since</p>
<pre><code>coreView</code></pre>
<p>is non-recursive, GHC will inline it, and the optimiser will ultimately produce something like:</p>
<pre><code>  splitFunTy_maybe :: Type -&gt; Maybe (Type,Type)
  splitFunTy_maybe (PredTy p)    = splitFunTy_maybe (predTypeRep p)
  splitFunTy_maybe (NoteTy _ ty) = splitFunTy_maybe ty
  splitFunTy_maybe (FunTy t1 t2) = Just (t1,t2)
  splitFunTy_maybe other         = Nothing</code></pre>
<p>== The representation of</p>
<pre><code>Type</code></pre>
<p>==</p>
<p>Here, then is the representation of types (see <a href="GhcFile(compiler/types/TypeRep.hs)" class="uri" title="wikilink">GhcFile(compiler/types/TypeRep.hs)</a> for more details):</p>
<pre><code>type TyVar = Var

data Type = TyVarTy TyVar           -- Type variable
      | AppTy Type Type         -- Application
      | TyConApp TyCon [Type]       -- Type constructor application
      | FunTy Type Type         -- Arrow type
      | ForAllTy Var Type           -- Polymorphic type
      | LitTy TyLit             -- Type literals

data TyLit = NumTyLit Integer           -- A number
           | StrTyLit FastString        -- A string</code></pre>
<p>Invariant: if the head of a type application is a</p>
<pre><code>TyCon</code></pre>
<p>, GHC <em>always</em> uses the</p>
<pre><code>TyConApp</code></pre>
<p>constructor, not</p>
<pre><code>AppTy</code></pre>
<p>. This invariant is maintained internally by 'smart constructors'. A similar invariant applies to</p>
<pre><code>FunTy</code></pre>
<p>;</p>
<pre><code>TyConApp</code></pre>
<p>is never used with an arrow type.</p>
<p>Type variables are represented by the</p>
<pre><code>TyVar</code></pre>
<p>constructor of the [wiki:Commentary/Compiler/EntityTypes data type Var].</p>
<h2 id="overloaded-types">Overloaded types</h2>
<p>In Haskell we write</p>
<pre><code>f :: forall a. Num a =&gt; a -&gt; a</code></pre>
<p>but in Core the</p>
<pre><code>=&gt;` is represented by an ordinary `FunTy</code></pre>
<p>. So f's type looks like this:</p>
<pre><code>   ForAllTy a (TyConApp num [TyVarTy a] &lt;pre&gt;FunTy` TyVarTy a `FunTy</code></pre>
<p>TyVarTy a) where</p>
<p><code>  a   :: TyVar</code><br />
<code>  num :: TyCOn</code></p>
</pre>
<p>Nevertheless, we can tell when a function argument is actually a predicate (and hence should be displayed with</p>
<pre><code>=&gt;</code></pre>
<p>, etc), using</p>
<pre><code>isPredTy :: Type -&gt; Bool</code></pre>
<p>The various forms of predicate can be extracted thus:</p>
<pre><code>classifyPredType :: Type -&gt; PredTree

data PredTree = ClassPred Class [Type]   -- Class predicates e.g. (Num a)
              | EqPred Type Type         -- Equality predicates e.g. (a ~ b)
              | TuplePred [PredType]     -- Tuples of predicates e.g. (Num a, a~b)
              | IrredPred PredType       -- Higher order predicates e.g. (c a)</code></pre>
<p>These functions are defined in module</p>
<pre><code>Type</code></pre>
<p>.</p>
<h2 id="classifying-types">Classifying types</h2>
<p>GHC uses the following nomenclature for types:</p>
<p><strong><code>Unboxed</code></strong><code>:: A type is unboxed iff its representation is other than a pointer. Unboxed types are also unlifted.</code></p>
<p><strong><code>Lifted</code></strong><code>:: A type is lifted iff it has bottom as an element. Closures always have lifted types:  i.e. any let-bound identifier in Core must have a lifted type.  Operationally, a lifted object is one that can be entered. Only lifted types may be unified with a type variable.</code></p>
<p><strong><code>Data</code></strong><code>:: A type declared with '''</code></p>
<pre><code>data</code></pre>
<p>'''. Also boxed tuples.</p>
<p><strong><code>Algebraic</code></strong><code>:: An algebraic data type is a data type with one or more constructors, whether declared with </code></p>
<pre><code>data</code></pre>
<p>or</p>
<pre><code>newtype</code></pre>
<p>. An algebraic type is one that can be deconstructed with a case expression. &quot;Algebraic&quot; is <strong>NOT</strong> the same as &quot;lifted&quot;, because unboxed (and thus unlifted) tuples count as &quot;algebraic&quot;.</p>
<p><strong><code>Primitive</code></strong><code>:: a type is primitive iff it is a built-in type that can't be expressed    in Haskell.</code><br />
<code> </code><br />
<code> Currently, all primitive types are unlifted, but that's not necessarily the case.  (E.g. Int could be primitive.)</code></p>
<p><code> Some primitive types are unboxed, such as Int#, whereas some are boxed but unlifted (such as </code></p>
<pre><code>ByteArray#</code></pre>
<p>). The only primitive types that we classify as algebraic are the unboxed tuples.</p>
<p>Examples of type classifications:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><p><strong>Primitive</strong></p></td>
<td align="left"><p><strong>Boxed</strong></p></td>
<td align="left"><p><strong>Lifted</strong></p></td>
<td align="left"><p><strong>Algebraic</strong></p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>Int#</code></pre></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>No</p></td>
<td align="left"><p>No</p></td>
<td align="left"><p>No</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>ByteArray#</code></pre></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>No</p></td>
<td align="left"><p>No</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>(# a, b #)</code></pre></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>No</p></td>
<td align="left"><p>No</p></td>
<td align="left"><p>Yes</p></td>
</tr>
<tr class="odd">
<td align="left"><pre><code>(  a, b  )</code></pre></td>
<td align="left"><p>No</p></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>Yes</p></td>
</tr>
<tr class="even">
<td align="left"><pre><code>[a]</code></pre></td>
<td align="left"><p>No</p></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>Yes</p></td>
<td align="left"><p>Yes</p></td>
</tr>
</tbody>
</table>
<h2 id="unique">Unique</h2>
<pre><code>Unique`s provide a fast comparison mechanism for more complex things. Every `RdrName`, `Name`, `Var`, `TyCon`, `TyVar`, etc. has a `Unique`. When these more complex structures are collected (in `UniqFM`s or other types of collection), their `Unique</code></pre>
<p>typically provides the key by which the collection is indexed.</p>
<hr />
<h2 id="current-design">Current design</h2>
<p>A</p>
<pre><code>Unique` consists of the &#39;&#39;domain&#39;&#39; of the thing it identifies and a unique integer value &#39;within&#39; that domain. The two are packed into a single `Int#</code></pre>
<p>, with the <em>domain</em> being the top 8 bits.</p>
<p>The domain is never inspected (SLPJ believes). The sole reason for its existence is to provide a number of different ranges of</p>
<pre><code>Unique</code></pre>
<p>values that are guaranteed not to conflict.</p>
<p>=== Lifetime</p>
<p>The lifetime of a</p>
<pre><code>Unique` is a single invocation of GHC, i.e. they must not &#39;leak&#39; to compiler output, the reason being that `Unique</code></pre>
<p>s may be generated/assigned non-deterministically. When compiler output is non-deterministic, it becomes significantly harder to, for example, [wiki:Commentary/Compiler/RecompilationAvoidance avoid recompilation]. Uniques do not get serialised into .hi files, for example.</p>
<p>Note, that &quot;one compiler invocation&quot; is not the same as the compilation of a single</p>
<pre><code>Module`. Invocations such as `ghc --make` or `ghc --interactive</code></pre>
<p>give rise to longer invocation life-times.</p>
<p>This is also the reasons why</p>
<pre><code>OccName`s are &#39;&#39;not&#39;&#39; ordered based on the `Unique`s of their underlying `FastString</code></pre>
<p>s, but rather <em>lexicographically</em> (see <a href="GhcFile(compiler/basicTypes/OccName.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/OccName.lhs)</a> for details). &gt; &gt; <strong>SLPJ:</strong> I am far from sure that the Ord instance for</p>
<pre><code>OccName</code></pre>
<p>is ever used, so this remark is probably misleading. Try deleting it and see where it is used (if at all). &gt; <strong>PKFH:</strong> At least</p>
<pre><code>Name` and `RdrName` (partially) define their own `Ord` instances in terms of the instance of `OccName`. Maybe these `Ord` instances are also redundant, but for now it seems wise to keep them in. When everything has `Data</code></pre>
<p>instances (after this and many other redesigns), I'm sure it will be easier to find such dependency relations.</p>
<h3 id="known-key-things">Known-key things</h3>
<p>A hundred or two library entities (types, classes, functions) are so-called &quot;known-key things&quot;. See [wiki:Commentary/Compiler/WiredIn this page]. A known-key thing has a fixed</p>
<pre><code>Unique` that is fixed when the compiler is built, and thus lives across all invocations of that compiler.  These known-key `Unique</code></pre>
<p>s <em>are</em> written into .hi files. But that's ok because they are fully deterministic and never change.</p>
<p>&gt; <strong>PKFH</strong> That's fine then; we also know for sure these things fit in the 30 bits used in the</p>
<pre><code>hi</code></pre>
<p>-files. I'll comment appropriately.</p>
<h3 id="interface-files-1">Interface files</h3>
<p>Entities in a interface file (.hi file) are, for the most part, stored in a symbol table, and referred to (from elsewhere in the same interface file) by an index into that table. Here are the details from <a href="GhcFile(compiler/iface/BinIface.lhs)" class="uri" title="wikilink">GhcFile(compiler/iface/BinIface.lhs)</a>:</p>
<pre><code>-- Note [Symbol table representation of names]
-- &lt;strike&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&lt;/strike&gt;
--
-- An occurrence of a name in an interface file is serialized as a single 32-bit word.
-- The format of this word is:
--  00xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
--   A normal name. x is an index into the symbol table
--  01xxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyy
--   A known-key name. x is the Unique&#39;s Char, y is the int part
--  10xxyyzzzzzzzzzzzzzzzzzzzzzzzzzzzz
--   A tuple name:
--    x is the tuple sort (00b ==&gt; boxed, 01b ==&gt; unboxed, 10b ==&gt; constraint)
--    y is the thing (00b ==&gt; tycon, 01b ==&gt; datacon, 10b ==&gt; datacon worker)
--    z is the arity
--  11xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
--   An implicit parameter TyCon name. x is an index into the FastString *dictionary*
--
-- Note that we have to have special representation for tuples and IP TyCons because they
-- form an &quot;infinite&quot; family and hence are not recorded explicitly in wiredInTyThings or
-- basicKnownKeyNames.</code></pre>
<hr />
<h2 id="redesign-2014">Redesign (2014)</h2>
<p>=== TL;DR The redesign is to accomplish the following:</p>
<ul>
<li>Allow derivation of type class instances for
<pre><code>Unique</code></pre></li>
<li>Restore invariants from the original design; hide representation details</li>
<li>Eliminate violations of invariants and design-violations in other places of the compiler (e.g.
<pre><code>Unique`s shouldn&#39;t be written to `hi</code></pre>
<p>-files, but are).</p></li>
</ul>
<p>&gt; &gt; <strong>SLPJ</strong> I don't think this is a design violation; see above. Do you have any other examples in mind? &gt; <strong>PKFH</strong> Not really of design-violations (and no other compiler-output stuff) other than the invariants mentioned above it, just yet. The key point, though, is that there are a lot of comments in</p>
<pre><code>Unique` about not exporting things so that we know X, Y and Z, but then those things &#39;&#39;are&#39;&#39; exported, so we don&#39;t know them to be true. Case in point is the export of `mkUnique`, but also `mkUniqueGrimily`. The latter has a comment &#39;only for `UniqSupply`&#39; but is also used in other places (like Template Haskell). One redesign is to put this restriction in the name, so there still is the facility offered by `mkUniqueGrimily`, but now it&#39;s called `mkUniqueOnlyForUniqSupply` (and `mkUniqueOnlyForTemplateHaskell</code></pre>
<p>), the ugliness of which should help, over time, to get rid of them.</p>
<p>=== Longer</p>
<p>In an attempt to give more of GHC's innards well-behaved instances of</p>
<pre><code>Typeable`, `Data`, `Foldable`, `Traversable`, etc. the implementation of `Unique</code></pre>
<p>s was a bit of a sore spot. They were implemented (20+ years earlier) using custom boxing, viz.</p>
<pre><code>data Unique = MkUnique Int#</code></pre>
<p>making automatic derivation of such type class instances hard. There was already a comment asking why it wasn't simply a</p>
<pre><code>newtype` around a normal (boxed) `Int`. Independently, there was some discussion on the mailinglists about the use of (signed) `Int`s in places where `Word`s would be more appropriate. Further inspection of the `Unique</code></pre>
<p>implementation made clear that a lot of invariants mentioned in comments had been violated by incremental edits. This is discussed in more detail below, but these things together (the desire for automatic derivation and the restoration of some important invariants) motivated a moderate redesign.</p>
<p>=== Status Quo (pre redesign)</p>
<p>A</p>
<pre><code>Unique` has a domain (`TyCon`, `DataCon`, `PrelName`, `Builtin`, etc.) that was codified by a character. The remainder of the `Unique</code></pre>
<p>was an integer that should be unique for said domain. This <strong>was</strong> once guaranteed through the export list of <a href="GhcFile(compiler/basicTypes/Unique.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Unique.lhs)</a>, where direct access to the domain-character was hidden, i.e.</p>
<pre><code>mkUnique :: Char -&gt; Int -&gt; Unique
unpkUnique :: Unique -&gt; (Char,Int)</code></pre>
<p>were not exported. This should have guaranteed that every domain was assigned its own unique character, because only in <a href="GhcFile(compiler/basicTypes/Unique.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/Unique.lhs)</a> could those</p>
<pre><code>Char</code></pre>
<p>s be assigned. However, through</p>
<pre><code>mkUniqueGrimily :: Int -&gt; Unique
mkUniqueGrimily i = MkUnique (iUnbox i)</code></pre>
<p>this separation of concerns leaked out to <a href="GhcFile(compiler/basicTypes/UniqSupply.lhs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/UniqSupply.lhs)</a>, because its</p>
<pre><code>Int` argument is the &#39;&#39;entire&#39;&#39; `Unique</code></pre>
<p>and not just the integer part 'under' the domain character. &gt; &gt; <strong>SLPJ</strong> OK, but to eliminate</p>
<pre><code>mkUniqueGrimily</code></pre>
<p>you need to examine the calls, decide how to do it better, and document the new design. &gt; <strong>PKFH</strong> See above; the solution for now is</p>
<pre><code>mkUniqueOnlyForUniqSupply`. A separate patch will deal with trying to refactor/redesign `UniqSupply</code></pre>
<p>if this is necessary.</p>
<p>The function</p>
<pre><code>mkSplitUniqSupply` made the domain-character accessible to all the other modules, by having a wholly separate implementation of the functionality of `mkUnique</code></pre>
<p>.</p>
<p>Where the intention was still to have a clean interface, the (would-be) hidden</p>
<pre><code>mkUnique` is only called by functions defined in the `Unique</code></pre>
<p>module with the corresponding character, e.g.</p>
<pre><code>mkAlphaTyVarUnique   i = mkUnique &#39;1&#39; i
mkPreludeClassUnique i = mkUnique &#39;2&#39; i
mkPreludeTyConUnique i = mkUnique &#39;3&#39; (3*i)
...</code></pre>
<p>=== New plan</p>
<p>In the new design, the domains are explicitly encoded in a sum-type</p>
<pre><code>UniqueDomain`. At the very least, this should help make the code a little more self-documenting &#39;&#39;and&#39;&#39; prevent accidental overlap in the choice of bits to identify the domain. Since the purpose of `Unique`s is to provide &#39;&#39;fast&#39;&#39; comparison for different types of things, the redesign should remain performance concious. With this in mind, keeping the `UniqueDomain</code></pre>
<p>and the integer-part explicitly in the type</p>
<pre><code>data Unique = MkUnique UniqueDomain Word</code></pre>
<p>seems unwise, but by choosing</p>
<pre><code>newtype Unique = MkUnique Word</code></pre>
<p>we win the ability to automatically derive things and should also be able to test how far optimisation has come in the past 20+ years; does default boxing with</p>
<pre><code>newtype</code></pre>
<p>-style wrapping have (nearly) the same performance as manual unboxing? This should follow from the tests.</p>
<p>The encoding is kept the same, i.e. the</p>
<pre><code>Word` is still built up with the domain encoded in the most significant bits and the integer-part in the remaining bits. However, instead encoding the domain as a `Char` in the (internal &#39;&#39;and&#39;&#39; external interface), we now create an ADT (sum-type) that encodes the domain. This has two advantages. First, it prevents people from picking domain-tags ad hoc an possibly overlapping. Second, encoding in the `Word` does not rely on the assumption that the domain requires and/or fits in 8 bits. Since Haskell `Char</code></pre>
<p>s are unicode, the 8-bit assumption is wrong for the old design. In other words, the above examples are changed to:</p>
<pre><code>data UniqueDomain
  = AlphaTyVar
  | PreludeClass
  | PreludeTyCon
  ...
  deriving (Enum,Bounded)

domSiz :: Int  -- The size of domain in the encoded Unique. *NOT* exported, but change-safe and compile-time constant.
domSiz = ceiling $ logBase 2 $ fromIntegral $ fromEnum (maxBound :: UniqueDomain) - fromEnum (minBound::UniqueDomain) + 1


mkUnique :: UniqueDomain -&gt; Int -&gt; Unique -- *Can* be exported now, but all those helper functions are gone.</code></pre>
<p>Ideal world scenario, the entire external interface would be:</p>
<pre><code> UniqueDomain(..)
 mkUnique    :: UniqueDomain -&gt; Word -&gt; Unique
 pprUnique   :: Unique -&gt; SDoc
 showUnique  :: Unique -&gt; String
 serialise   :: Word8   -- number of bits to keep for other encoding
             -&gt; Unique  -- the thing to serialise
             -&gt; Word32  -- the serialised representation (for BinIface)
 deserialise :: Word 8 -&gt; Word32 -&gt; Unique</code></pre>
<p>and the instances for</p>
<pre><code>Eq`, `Ord`, `Data</code></pre>
<p>, etc. For now, though, it will also have</p>
<pre><code> getKey :: Unique -&gt; Int
 mkUniqueOnlyForUniqSupply :: Int -&gt; Unique
 mkUniqueOnlyForTemplateHaskell :: FastInt -&gt; Unique
 incrUnique :: Unique -&gt; Unique
 deriveUnique :: Unique -&gt; Int -&gt; Unique
 newTagUnique :: Unique -&gt; UniqueDomain -&gt; Unique</code></pre>
<p>&gt; &gt; <strong>SLPJ</strong> I agree that a</p>
<pre><code>newtype` around a `Word` is better than a `data` type around `Int#`. That is a small, simple change.  But I think you plan to do more than this, and that &quot;more&quot; is not documented here.  E.g. what is the new API to `Unique</code></pre>
<p>? &gt; <strong>PKFH</strong> Added. See above.</p>
<h1 id="unpacking-primitive-fields">Unpacking primitive fields</h1>
<p>This page describes a proposal to automatically unpack (strict) primitive fields. A primitive fields is a field that when unpacked has a pointer-sized representation. Examples include</p>
<pre><code>Int`, `Word`, `Float`, and `newtype</code></pre>
<p>s thereof.</p>
<h2 id="goals-and-non-goals">Goals and non-goals</h2>
<p>This proposal is about changing the default behavior of GHC, not changing expressiveness. Users can still use</p>
<pre><code>UNPACK` and `NOUNPACK</code></pre>
<p>to explicitly control the memory representation of fields.</p>
<p>There are two goals:</p>
<ol>
<li>Reduce the amount of boilerplate experienced programmers have to write: As of Feb 18th 2012, the <a href="http://hackage.haskell.org/package/bytestring">bytestring</a>, <a href="http://hackage.haskell.org/package/text">text</a>, and <a href="http://hackage.haskell.org/package/containers">containers</a> packages had 46 fields that matched the definition of primitive given above. 43 of these had an explicit
<pre><code>UNPACK</code></pre>
<p>pragma (and the remaining 3 could have had one without changing the performance of the program.)</p></li>
</ol>
<ol>
<li><ol>
<li>To provide better defaults for beginner and intermediate level Haskellers. Not unpacking e.g.
<pre><code>Int</code></pre>
<p>fields can have a large, negative effect on performance and many beginner and intermediate level Haskellers are bitten by this.</p></li>
</ol></li>
</ol>
<h2 id="detailed-design">Detailed design</h2>
<h2 id="benchmarks">Benchmarks</h2>
<h1 id="unused-imports-1">Unused imports</h1>
<p>GHC has a series of bugs related to the &quot;report unused imports&quot; flags, including #1148, #2267, #1074, #2436, #10117.</p>
<p>This page describes a new design.</p>
<h2 id="the-current-story">The current story</h2>
<p>Currently (GHC 6.10) we report three different things:</p>
<ul>
<li>warnUnusedModules: import M, where nothing is used from M</li>
<li>warnUnusedImports: import M(f), where f is unused, and M doesn't fall under warnUnusedModules</li>
<li>warnDuplicateImports: import M + import M(f), even when f is used complain about duplicate import of f</li>
</ul>
<h2 id="examples-1">Examples</h2>
<p>The hard bit is to specify what the warning should do. Consider these examples, where</p>
<pre><code>Foo` exports `x` and `y`, and `FooPlus</code></pre>
<p>re-exports all of</p>
<pre><code>Foo`, plus `z</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>  module X0 where                  module X1 where  
    import Foo                       import Foo     
    import Foo( x )                  import Foo( x )    
    bar = x                      bar = x+y      

  module X2 where                  module X3 where  
    import Foo( x, y )               import Foo( x, y ) 
    import Foo( x )              import Foo( x )    
    bar = x                  bar = x + y         
 
  module X4 where                  module X5 where        
    import Foo( x, y )               import Foo( x, y ) as Bar 
    import Foo( x, y )               import Foo( x, y )       
    bar = x + y                  bar = x + Bar.y           
 
  module X6 where                  module X7 whjre  
    import Foo( x, y ) as Bar        import FooPlus(x,y)    
    import Foo( x, y )           import FooPlus(y,z)    
    bar = Foo.x + Bar.y          import FooPlus(z,x)    
                     bar = (x,y,z)       

  module X8
    import Control.Monad
    import Control.Monad.State
    import Control.Monad.Reader
    -- NB : Control.Monad.State re-exports all of Control.Monad
    --      so the first decl is actually redundant</code></pre>
<p>Which import is redudant, in each case?</p>
<p>Also: we might warn if you import the same module more than once, and the imports can be combined (ie they have the same 'qualified' and 'as' attributes)</p>
<pre><code>  module Y1 where
    import Foo(x)
    import Foo(y)
    bar = (x,y)</code></pre>
<p>Here both are used, but we might want to suggest combining them.</p>
<h2 id="specfication">Specfication</h2>
<p>We can at least agree on this:</p>
<ul>
<li>If the warning suggests that an import can be omitted, and you omit it,</li>
</ul>
<p><code>  the program should still compile.</code></p>
<ul>
<li>It's not worth trying to be too subtle. The 90% case is very simple.</li>
</ul>
<p>Say that an <em>import-item</em> is either an entire import-all decl (eg</p>
<pre><code>import Foo</code></pre>
<p>), or a particular item in an import list (eg</p>
<pre><code>import Foo( ..., x, ...)</code></pre>
<p>). The general idea is that for each use of an imported name, we will attribute that use to one (or possibly more) import-items. Then, any import items with no uses attributed to them are unused, and are warned about. More precisely:</p>
<ol>
<li>For every
<pre><code>RdrName` in the program text, find all the import-items that brought it     into scope.  The lookup mechanism on `RdrNames` already takes account of whether the `RdrName</code></pre>
<p>was qualified, and which imports have the right qualification etc, so this step is very easy.</p></li>
</ol>
<ol>
<li><ol>
<li>Choose one of these, the &quot;chosen import-item&quot;, and mark it &quot;used&quot;.</li>
</ol></li>
</ol>
<ol>
<li><ol>
<li>Now bleat about any import-items that are unused. For a decl</li>
</ol></li>
</ol>
<pre><code>import Foo(x,y)`, if both the `x` and `y</code></pre>
<p>items are unused, it'd be better</p>
<p><code>to bleant about the entire decl rather than the individual items.</code></p>
<p>The import-item choosing step 2 implies that there is a total order on import-items. We say import-item A</p>
<pre><code>`dominates`</code></pre>
<p>import-item B if we chooose A over B. Here is one possible dominance relationship:</p>
<ul>
<li><pre><code>import Foo` dominates `import Foo(x)</code></pre>
<p>. (You could also argue that the</p></li>
</ul>
<p><code>  reverse should hold.)</code></p>
<ul>
<li>Otherwise choose the textually first one.</li>
</ul>
<p>Other notes:</p>
<ul>
<li>The algorithm chooses exactly one import-item in step 2. It would</li>
</ul>
<p><code>also be sound to choose more than one if there was a tie, but then completely-duplicate</code><br />
<code>imports might not be reported.</code></p>
<ul>
<li>Note that if we have an import item
<pre><code>import Foo (Bar(bar))</code></pre>
<p>, then</p></li>
</ul>
<p><code>it's marked as used if either </code></p>
<pre><code>Bar` or `bar</code></pre>
<p>are used. We could have yet finer</p>
<p><code>resolution and report even unused sub-items.</code></p>
<ul>
<li>We should retain the special case of not warning about
<pre><code>import Foo ()</code></pre>
<p>, which implies &quot;instance declarations only&quot;.</p></li>
</ul>
<hr />
<h2 id="implementation-1">Implementation</h2>
<p>We want to collect the set of all</p>
<pre><code>RdrNames</code></pre>
<p>that are mentioned in the program. We must collect '''</p>
<pre><code>RdrNames`&#39;&#39;&#39; not `Names</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>   import Foo( x ) as Bar
   import Foo( x )
   q = (Foo.x, Bar.x)</code></pre>
<p>Here both imports are required, but you can only tell that by seeing the RdrNames, not by knowing that the name 'x' is used.</p>
<p>I think that all lookups go through either,</p>
<pre><code>RnEnv.lookupGreRn_maybe` or `RnEnv.lookup_sub_bndr</code></pre>
<p>. So in</p>
<pre><code>RnEnv.lookupGreRn_maybe`, if `(gre_prov gre)` is `(Imported _)</code></pre>
<p>, and in</p>
<pre><code>RnEnv.lookup_sub_bndr</code></pre>
<p>, put</p>
<pre><code>rdr_name</code></pre>
<p>in a new</p>
<pre><code>tcg_used_rdrnames :: TcRef (Set RdrName)</code></pre>
<p>in</p>
<pre><code>TcGblEnv`.  All the `tcg_used_rdrnames</code></pre>
<p>are in scope; if not, we report an error and do not add it to</p>
<pre><code>tcg_used_rdrnames</code></pre>
<p>.</p>
<p>Other notes</p>
<ul>
<li>Any particular (in-scope) used
<pre><code>RdrName</code></pre>
<p>is bought into scope by</p></li>
</ul>
<p><code> one or more </code></p>
<pre><code>RdrName.ImportSpec`&#39;s.  You can find these `ImportSpecs</code></pre>
<p><code> in the GRE returned by the lookup.</code></p>
<ul>
<li>The unit of &quot;unused import&quot; reporting is one of these
<pre><code>ImportSpecs</code></pre>
<p>.</p></li>
</ul>
<ul>
<li>Suppose that 'rn' is a used, imported
<pre><code>RdrName</code></pre>
<p>, and 'iss' is</p></li>
</ul>
<p><code> the </code></p>
<pre><code>[ImportSpecs]</code></pre>
<p>that brought it into scope. Then, to a first</p>
<p><code> approximation all the iss are counted 'used'.  </code></p>
<ul>
<li>We can compare
<pre><code>ImportSpecs` for equality by their `SrcSpans</code></pre></li>
</ul>
<ul>
<li>In
<pre><code>TcRnDriver.tcRnImports</code></pre>
<p>, save import_decls in a new</p></li>
</ul>
<pre><code>tcg_rn_rdr_imports :: Maybe [LImportDecl RdrName]</code></pre>
<p><code> in </code></p>
<pre><code>TcGblEnv</code></pre>
<hr />
<h2 id="algorithm">Algorithm</h2>
<p>The algorithm for deciding which imports have been used is based around this datatype:</p>
<pre><code>data ImportInfo = ImportInfo SrcSpan
                             SDoc
                             (Maybe ModuleName) -- The effective module name
                             [RdrName] -- The names the import provides
                             Bool -- Has it been used yet?
                             [ImportInfo] -- Child import infos</code></pre>
<p>We convert import declarations into trees of</p>
<pre><code>ImportInfo</code></pre>
<p>s, e.g.</p>
<pre><code>import Foo (a, D(c1, c2))</code></pre>
<p>becomes (only the</p>
<pre><code>SDoc` and `[RdrName]</code></pre>
<p>fields are given, as that's the interesting bit)</p>
<pre><code>ImportInfo &quot;Foo&quot; []
    ImportInfo &quot;a&quot; [&quot;a&quot;, &quot;Foo.a&quot;]
    ImportInfo &quot;D&quot; [&quot;D&quot;, &quot;Foo.D&quot;]
        ImportInfo &quot;c1&quot; [&quot;c1&quot;, &quot;Foo.c1&quot;]
        ImportInfo &quot;c2&quot; [&quot;c2&quot;, &quot;Foo.c2&quot;]</code></pre>
<p>If a node in the tree is marked as used, then so are all nodes above it. For example, given the tree a use of</p>
<pre><code>&quot;D&quot;</code></pre>
<p>marks both the first and third lines as used.</p>
<p>When we come to giving warnings, if a node is unused then we warn about it, and do not descend into the rest of that subtree, as the node we warn about subsumes its children. If the node is marked as used then we descend, looking to see if any of its children are unused.</p>
<p>Here are how some example imports map to trees of</p>
<pre><code>ImportInfo`, assuming `Foo` exports `a`, `b`, `D(c1, c2)</code></pre>
<p>.</p>
<pre><code>import Foo
-&gt;
ImportInfo &quot;Foo&quot; [&quot;a&quot;, &quot;b&quot;, &quot;D&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;Foo.a&quot;, &quot;Foo.b&quot;, &quot;Foo.D&quot;, &quot;Foo.c1&quot;, &quot;Foo.c2&quot;]

import qualified Foo as Bar
-&gt;
ImportInfo &quot;Foo&quot; [&quot;Bar.a&quot;, &quot;Bar.b&quot;, &quot;Bar.D&quot;, &quot;Bar.c1&quot;, &quot;Bar.c2&quot;]

import qualified Foo (a, D)
-&gt;
ImportInfo &quot;Foo&quot; []
    ImportInfo &quot;a&quot; [&quot;Foo.a&quot;]
    ImportInfo &quot;D&quot; [&quot;Foo.D&quot;]

import qualified Foo hiding (a, D(..))
-&gt;
ImportInfo &quot;Foo&quot; [&quot;Foo.b&quot;]

import Foo (D(c1, c2))
-&gt;
ImportInfo &quot;Foo&quot; []
    ImportInfo &quot;D&quot; [&quot;D&quot;, &quot;Foo.D&quot;]
        ImportInfo &quot;c1&quot; [&quot;c1&quot;, &quot;Foo.c1&quot;]
        ImportInfo &quot;c2&quot; [&quot;c2&quot;, &quot;Foo.c2&quot;]

import qualified Foo (D(..))
-&gt;
ImportInfo &quot;Foo&quot; []
    ImportInfo &quot;D(..)&quot; [&quot;Foo.D&quot;, &quot;Foo.c1&quot;, &quot;Foo.c2&quot;]</code></pre>
<p>These trees are built by</p>
<pre><code>RnNames.mkImportInfo`. In `RnNames.warnUnusedImportDecls` we make two lists of `ImportInfo</code></pre>
<p>s; one list contains all the explicit imports, e.g.</p>
<pre><code>import Foo (a, b)</code></pre>
<p>and the other contains the implicit imports, e.g.</p>
<pre><code>import Foo
import Foo hiding (a, b)</code></pre>
<p>Then</p>
<pre><code>RnNames.markUsages` is called for each `RdrName` that was used in the program. The current implementation marks all explicit import as used unless there are no such imports, in which case it marks all implicit imports as used. A small tweak to `markUsages</code></pre>
<p>would allow it to mark only the first import it finds as used.</p>
<p>As well as the</p>
<pre><code>RdrName`s used in the source, we also need to mark as used the names that are exported. We first call `RnNames.expandExports` to expand `D(..)` into `D(c1, c2)`, and then call `RnNames.markExportUsages`. Normally this just marks the `RdrName`s as used in the same way that uses in the module body are handled, but it is also possible for an entire module to be &quot;used&quot;, if `module Foo` is in the export list. In this case `RnNames.markModuleUsed</code></pre>
<p>does the hard work, marking every module imported with that name as used.</p>
<h1 id="updates">Updates</h1>
<p>Source files: <a href="GhcFile(rts/Updates.h)" class="uri" title="wikilink">GhcFile(rts/Updates.h)</a>, <a href="GhcFile(rts/Updates.cmm)" class="uri" title="wikilink">GhcFile(rts/Updates.cmm)</a></p>
<hr />
<p>CategoryStub</p>
<h1 id="the-user-manual">The user manual</h1>
<p>GHC's user manual contains documentation intended for users of GHC. They are not interested in how GHC works; they just want to use it.</p>
<p>The user manual is held in <a href="GhcFile(docs/user_guide)" class="uri" title="wikilink">GhcFile(docs/user_guide)</a>, and is written in ReStructuredText format (</p>
<pre><code>.rst</code></pre>
<p>files). This allows us to typeset it as HTML pages, or as LaTeX.</p>
<p>See also the [wiki:Building/Docs notes on building the documentation].</p>
<p>See the &quot;Care and feeding of your GHC User's Guide&quot; section for conventions and a basic introduction to ReST.</p>
<h1 id="ghc-boot-library-version-history">GHC Boot Library Version History</h1>
<p>This table lists the versions of GHC against those of its boot libraries, including most notably the</p>
<pre><code>base` library.  This may be useful if you ever want to find out which version of the `base</code></pre>
<p>package was bundled with which version of GHC or vice versa.</p>
<p>See also: LanguagePragmaHistory, which lists the language extensions added and/or removed in each GHC version.</p>
<pre><code>#!comment
This table is generated by a script. Ask hvr instead of editing manually.</code></pre>
<table>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><h1 id="head"><strong>HEAD</strong></h1></td>
<td align="left"><h1 id="section-1"><strong>7.10.3</strong></h1></td>
<td align="left"><h1 id="section-2"><strong>7.10.2</strong></h1></td>
<td align="left"><h1 id="section-3"><strong>7.10.1</strong></h1></td>
<td align="left"><h1 id="section-4"><strong>7.8.4</strong></h1></td>
<td align="left"><h1 id="section-5"><strong>7.8.3</strong></h1></td>
<td align="left"><h1 id="section-6"><strong>7.8.2</strong></h1></td>
<td align="left"><h1 id="section-7"><strong>7.8.1</strong></h1></td>
<td align="left"><h1 id="section-8"><strong>7.6.3</strong></h1></td>
<td align="left"><h1 id="section-9"><strong>7.6.2</strong></h1></td>
<td align="left"><h1 id="section-10"><strong>7.6.1</strong></h1></td>
<td align="left"><h1 id="section-11"><strong>7.4.2</strong></h1></td>
<td align="left"><h1 id="section-12"><strong>7.4.1</strong></h1></td>
<td align="left"><h1 id="section-13"><strong>7.2.2</strong></h1></td>
<td align="left"><h1 id="section-14"><strong>7.2.1</strong></h1></td>
<td align="left"><h1 id="section-15"><strong>7.0.4</strong></h1></td>
<td align="left"><h1 id="section-16"><strong>7.0.3</strong></h1></td>
<td align="left"><h1 id="section-17"><strong>7.0.2</strong></h1></td>
<td align="left"><h1 id="section-18"><strong>7.0.1</strong></h1></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>Cabal</code></pre>
<p>=</p></td>
<td align="left"><p>1.23.0.0</p></td>
<td align="left"><p>1.22.5.0</p></td>
<td align="left"><p>1.22.4.0</p></td>
<td align="left"><p>1.22.2.0</p></td>
<td align="left"><p>1.18.1.5</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.18.1.3</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.16.0</p></td>
<td align="left"></td>
<td align="left"><p>1.14.0</p></td>
<td align="left"></td>
<td align="left"><p>1.12.0</p></td>
<td align="left"><p>1.10.2.0</p></td>
<td align="left"></td>
<td align="left"><p>1.10.1.0</p></td>
<td align="left"><p>1.10.0.0</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>Win32</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.3.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.3.0.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.3.0.0</p></td>
<td align="left"></td>
<td align="left"><p>2.2.2.0</p></td>
<td align="left"></td>
<td align="left"><p>2.2.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.2.0.2</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>array</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.4.0.1</p></td>
<td align="left"></td>
<td align="left"><p>0.4.0.0</p></td>
<td align="left"></td>
<td align="left"><p>0.3.0.3</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.3.0.2</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>base</code></pre>
<p>=</p></td>
<td align="left"><p>4.9.0.0</p></td>
<td align="left"><p>4.8.2.0</p></td>
<td align="left"><p>4.8.1.0</p></td>
<td align="left"><p>4.8.0.0</p></td>
<td align="left"><p>4.7.0.2</p></td>
<td align="left"><p>4.7.0.1</p></td>
<td align="left"></td>
<td align="left"><p>4.7.0.0</p></td>
<td align="left"></td>
<td align="left"><p>4.6.0.1</p></td>
<td align="left"><p>4.6.0.0</p></td>
<td align="left"><p>4.5.1.0</p></td>
<td align="left"><p>4.5.0.0</p></td>
<td align="left"><p>4.4.1.0</p></td>
<td align="left"><p>4.4.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>4.3.1.0</p></td>
<td align="left"><p>4.3.0.0</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>bin-package-db</code></pre>
<p>=</p></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.0.0.0</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>binary</code></pre>
<p>=</p></td>
<td align="left"><p>0.8.0.0</p></td>
<td align="left"></td>
<td align="left"><p>0.7.5.0</p></td>
<td align="left"><p>0.7.3.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.7.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.1.1</p></td>
<td align="left"></td>
<td align="left"><p>0.5.1.0</p></td>
<td align="left"></td>
<td align="left"><p>0.5.0.2*</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>bytestring</code></pre>
<p>=</p></td>
<td align="left"><p>0.10.7.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.10.6.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.10.4.0</p></td>
<td align="left"></td>
<td align="left"><p>0.10.0.2</p></td>
<td align="left"><p>0.10.0.0</p></td>
<td align="left"></td>
<td align="left"><p>0.9.2.1</p></td>
<td align="left"></td>
<td align="left"><p>0.9.2.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.9.1.10</p></td>
<td align="left"><p>0.9.1.8</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>containers</code></pre>
<p>=</p></td>
<td align="left"><p>0.5.7.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.6.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.5.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.0.0</p></td>
<td align="left"></td>
<td align="left"><p>0.4.2.1</p></td>
<td align="left"></td>
<td align="left"><p>0.4.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.4.0.0</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>deepseq</code></pre>
<p>=</p></td>
<td align="left"><p>1.4.2.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.4.1.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.3.0.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.3.0.1</p></td>
<td align="left"></td>
<td align="left"><p>1.3.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>directory</code></pre>
<p>=</p></td>
<td align="left"><p>1.2.5.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.2.2.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.2.1.0</p></td>
<td align="left"></td>
<td align="left"><p>1.2.0.1</p></td>
<td align="left"><p>1.2.0.0</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.2</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.0.0</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>extensible-exceptions</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"><p>0.1.1.4</p></td>
<td align="left"></td>
<td align="left"><p>0.1.1.3</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.1.1.2</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>ffi</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>filepath</code></pre>
<p>=</p></td>
<td align="left"><p>1.4.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.4.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.3.0.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.3.0.1</p></td>
<td align="left"></td>
<td align="left"><p>1.3.0.0</p></td>
<td align="left"></td>
<td align="left"><p>1.2.0.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.2.0.0</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>ghc</code></pre>
<p>=</p></td>
<td align="left"><p>7.11.20151220*</p></td>
<td align="left"><p>7.10.3*</p></td>
<td align="left"><p>7.10.2*</p></td>
<td align="left"><p>7.10.1*</p></td>
<td align="left"><p>7.8.4*</p></td>
<td align="left"><p>7.8.3*</p></td>
<td align="left"><p>7.8.2*</p></td>
<td align="left"><p>7.8.1*</p></td>
<td align="left"><p>7.6.3*</p></td>
<td align="left"><p>7.6.2*</p></td>
<td align="left"><p>7.6.1*</p></td>
<td align="left"><p>7.4.2*</p></td>
<td align="left"><p>7.4.1*</p></td>
<td align="left"><p>7.2.2*</p></td>
<td align="left"><p>7.2.1*</p></td>
<td align="left"><p>7.0.4*</p></td>
<td align="left"><p>7.0.3*</p></td>
<td align="left"><p>7.0.2*</p></td>
<td align="left"><p>7.0.1*</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>ghc-binary</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.0.2*</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>ghc-boot</code></pre>
<p>=</p></td>
<td align="left"><p>0.0.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>ghc-prim</code></pre>
<p>=</p></td>
<td align="left"><p>0.5.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.4.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.3.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.3.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.2.0.0</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>ghci</code></pre>
<p>=</p></td>
<td align="left"><p>0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>haskeline</code></pre>
<p>=</p></td>
<td align="left"><p>0.7.2.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.7.2.1</p></td>
<td align="left"></td>
<td align="left"><p>0.7.1.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>haskell2010</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.2.0*</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.1.0*</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.1*</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.0*</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.0.0*</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>haskell98</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.0.0.3*</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.0.0.2*</p></td>
<td align="left"></td>
<td align="left"><p>2.0.0.1*</p></td>
<td align="left"></td>
<td align="left"><p>2.0.0.0*</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.0.1</p></td>
<td align="left"><p>1.1.0.0</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>hoopl</code></pre>
<p>=</p></td>
<td align="left"><p>3.10.2.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>3.10.0.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>3.10.0.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>3.9.0.0</p></td>
<td align="left"></td>
<td align="left"><p>3.8.7.3</p></td>
<td align="left"></td>
<td align="left"><p>3.8.7.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>hpc</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.6.0.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.6.0.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.6.0.0</p></td>
<td align="left"></td>
<td align="left"><p>0.5.1.1</p></td>
<td align="left"></td>
<td align="left"><p>0.5.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.0.6</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>integer-gmp</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.5.0.0</p></td>
<td align="left"></td>
<td align="left"><p>0.4.0.0</p></td>
<td align="left"></td>
<td align="left"><p>0.3.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.2.0.3</p></td>
<td align="left"><p>0.2.0.2</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>old-locale</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.0.6</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.0.5</p></td>
<td align="left"></td>
<td align="left"><p>1.0.0.4</p></td>
<td align="left"></td>
<td align="left"><p>1.0.0.3</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.0.2</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>old-time</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.0.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.0.1</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.0</p></td>
<td align="left"></td>
<td align="left"><p>1.0.0.7</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.0.6</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>pretty</code></pre>
<p>=</p></td>
<td align="left"><p>1.1.3.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.2.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.1.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.1.0</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.1.2</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>process</code></pre>
<p>=</p></td>
<td align="left"><p>1.4.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.2.3.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.2.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.1.0.2</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.1</p></td>
<td align="left"></td>
<td align="left"><p>1.1.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.1.5</p></td>
<td align="left"><p>1.0.1.4</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>random</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0.0.3</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>rts</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.0</p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>template-haskell</code></pre>
<p>=</p></td>
<td align="left"><p>2.11.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.10.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.9.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.8.0.0</p></td>
<td align="left"></td>
<td align="left"><p>2.7.0.0</p></td>
<td align="left"></td>
<td align="left"><p>2.6.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.5.0.0</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>terminfo</code></pre>
<p>=</p></td>
<td align="left"><p>0.4.0.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.4.0.1</p></td>
<td align="left"></td>
<td align="left"><p>0.4.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>time</code></pre>
<p>=</p></td>
<td align="left"><p>1.6</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.5.0.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.4.2</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.4.0.1</p></td>
<td align="left"></td>
<td align="left"><p>1.4</p></td>
<td align="left"></td>
<td align="left"><p>1.2.0.5</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>1.2.0.3</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>transformers</code></pre>
<p>=</p></td>
<td align="left"><p>0.5.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.4.2.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>0.3.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="even">
<td align="left"><p>=</p>
<pre><code>unix</code></pre>
<p>=</p></td>
<td align="left"><p>2.7.1.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.7.1.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.7.0.1</p></td>
<td align="left"></td>
<td align="left"><p>2.6.0.1</p></td>
<td align="left"><p>2.6.0.0</p></td>
<td align="left"><p>2.5.1.1</p></td>
<td align="left"><p>2.5.1.0</p></td>
<td align="left"></td>
<td align="left"><p>2.5.0.0</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>2.4.2.0</p></td>
<td align="left"><p>2.4.1.0</p></td>
</tr>
<tr class="odd">
<td align="left"><p>=</p>
<pre><code>xhtml</code></pre>
<p>=</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p>3000.2.1</p></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><p><em>none</em></p></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><h1 id="head-1"><strong>HEAD</strong></h1></td>
<td align="left"><h1 id="section-19"><strong>7.10.3</strong></h1></td>
<td align="left"><h1 id="section-20"><strong>7.10.2</strong></h1></td>
<td align="left"><h1 id="section-21"><strong>7.10.1</strong></h1></td>
<td align="left"><h1 id="section-22"><strong>7.8.4</strong></h1></td>
<td align="left"><h1 id="section-23"><strong>7.8.3</strong></h1></td>
<td align="left"><h1 id="section-24"><strong>7.8.2</strong></h1></td>
<td align="left"><h1 id="section-25"><strong>7.8.1</strong></h1></td>
<td align="left"><h1 id="section-26"><strong>7.6.3</strong></h1></td>
<td align="left"><h1 id="section-27"><strong>7.6.2</strong></h1></td>
<td align="left"><h1 id="section-28"><strong>7.6.1</strong></h1></td>
<td align="left"><h1 id="section-29"><strong>7.4.2</strong></h1></td>
<td align="left"><h1 id="section-30"><strong>7.4.1</strong></h1></td>
<td align="left"><h1 id="section-31"><strong>7.2.2</strong></h1></td>
<td align="left"><h1 id="section-32"><strong>7.2.1</strong></h1></td>
<td align="left"><h1 id="section-33"><strong>7.0.4</strong></h1></td>
<td align="left"><h1 id="section-34"><strong>7.0.3</strong></h1></td>
<td align="left"><h1 id="section-35"><strong>7.0.2</strong></h1></td>
<td align="left"><h1 id="section-36"><strong>7.0.1</strong></h1></td>
</tr>
</tbody>
</table>
<p>Note: A</p>
<pre><code>*</code></pre>
<p>after the version number denotes the package being hidden by default.</p>
<p>A table covering some GHC 6.* releases can be found at <a href="https://wiki.haskell.org/Libraries_released_with_GHC" class="uri">https://wiki.haskell.org/Libraries_released_with_GHC</a></p>
<p>= Warnings and Deprecations</p>
<p>For now, see the relevant <a href="http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#warning-deprecated-pragma">GHC User's Guide Section</a> describing the</p>
<pre><code>DEPRECATE` and `WARNING</code></pre>
<p>pragmas.</p>
<p>TODO</p>
<h1 id="ghc-commentary-weak-pointers-and-finalizers">GHC Commentary: Weak Pointers and Finalizers</h1>
<hr />
<p>CategoryStub</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="work-in-progress-on-the-llvm-backend">Work in Progress on the LLVM Backend</h1>
<p>This page is meant to collect together information about people working on (or interested in working on) LLVM in GHC, and the projects they are looking at. See also the [wiki:Commentary/Compiler/NewCodeGen state of play of the whole back end]. This is more a page of ideas for improvements to the LLVM backend and less so an indication of actual work going on.</p>
<h3 id="llvm-ir-representation">LLVM IR Representation</h3>
<p>The LLVM IR is modeled in GHC using an algebraic data type to represent the first order abstract syntax of the LLVM assembly code. The LLVM representation lives in the 'Llvm' subdirectory and also contains code for pretty printing. This is the same approach taken by EHC's LLVM Back-end, and we adapted the module developed by them for this purpose.</p>
<p>The current design is overly complicated and could be faster. It uses String + show operations for printing for example when it should be using FastString + Outputable. Before simplifying this design though it would be good to investigate using the LLVM API instead of the assembly language for interacting with LLVM. This would be done most likely by using the pre-existing Haskell LLVM API bindings found <a href="http://hackage.haskell.org/package/llvm">here</a>. This should hopefully provide a speed up in compilation speeds which is greatly needed since the LLVM back-end is ~2x slower at the moment.</p>
<h3 id="tables_next_to_code">TABLES_NEXT_TO_CODE</h3>
<p>We now support [wiki:Commentary/Compiler/Backends/LLVM/Issues#TABLES_NEXT_TO_CODE TNTC] using an approach of gnu as subsections. This seems to work fine but we would like still to move to a pure LLVM solution. Ideally we would implement this in LLVM by allowing a global variable to be associated with a function, so that LLVM is aware that the two will be laid out next to each other and can better optimise (e.g using this approach LLVM should be able to perform constant propagation on info-tables).</p>
<p><strong>Update (30/06/2010):</strong> The current TNTC solution doesn't work on Mac OS X. So we need to implement an LLVM based solution. We currently support OS X by post processing the assembly. Pure LLVM is a nicer way forward.</p>
<h3 id="llvm-alias-analysis-pass">LLVM Alias Analysis Pass</h3>
<p><strong>Update: This has been implemented, needs more work though</strong></p>
<p>LLVM doesn't seem to do a very good job of figuring out what can alias what in the code generated by GHC. We should write our own alias analysis pass to fix this.</p>
<h3 id="optimise-llvm-for-the-type-of-code-ghc-produces">Optimise LLVM for the type of Code GHC produces</h3>
<p>At the moment only a some fairly basic benchmarking has been done of the LLVM back-end. Enough to give an indication of how it performs on the whole (well as far as you trust benchmarks anyway) and of what it can sometimes achieve. However this is by no means exauhstive or probably even close to it and doesn't give us enough information about the areas where LLVM performs badly. The LLVM optimisation pass also at the moment just uses the standard '-O[123]' levels, which like GCC entail a whole bunch of optimisation passes. These groups are designed for C programs mostly.</p>
<p>So:</p>
<ul>
<li>More benchmarking, particularly finding some bad spots for the LLVM back-end and generating a good picture of the characteristics of the back-end.</li>
<li>Look into the LLVM optimiser, e.g perhaps some more work in the style of <a href="http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/">Don's work</a></li>
<li>Look at any new optimisation passes that could be written for LLVM which would help to improve the code it generates for GHC.</li>
<li>Look at general fixes/improvement to LLVM to improve the code it generates for LLVM.</li>
<li>Sometimes there is a benefit from running the LLVM optimiser twice of the code (e.g opt -O3 | opt -O3 ...). We should add a command line flag that allows you to specify the number of iterations you want the LLVM optimiser to do.</li>
</ul>
<h3 id="update-the-back-end-to-use-the-new-cmm-data-types-new-code-generator">Update the Back-end to use the new Cmm data types / New Code Generator</h3>
<p>There is ongoing work to produce a new, nicer, more modular code generator for GHC (the slightly confusingly name code generator in GHC refers to the pipeline stage where the Core IR is compiled to the Cmm IR). The LLVM back-end could be updated to make sure it works with the new code generator and does so in an efficient manner.</p>
<h3 id="llvms-link-time-optimisations">LLVM's Link Time Optimisations</h3>
<p>One of LLVM's big marketing features is its support for link time optimisation. This does things such as in-lining across module boundaries, more aggressive dead code elimination... etc). The LLVM back-end could be updated to make use of this. Roman apparently tried to use the new 'gold' linker with GHC and it doesn't support all the needed features.</p>
<ul>
<li><a href="http://llvm.org/releases/2.6/docs/LinkTimeOptimization.html">20</a></li>
<li><a href="http://llvm.org/docs/GoldPlugin.html">21</a></li>
</ul>
<h3 id="llvm-cross-compiler-port">LLVM Cross Compiler / Port</h3>
<p>This is more of an experimental idea but the LLVM back-end looks like it would make a great choice for Porting LLVM. That is, instead of porting LLVM through the usual route of via-C and then fixing up the NCG, just try to do it all through the LLVM back-end. As LLVM is quite portable and supported on more platforms then GHC, it would be an interesting and valuable experiment to try to port GHC to a new platform by simply getting the LLVM back-end working on it. (The LLVM back-end works in both unregistered and registered mode, another advantage for porting compared to the C and NCG back-ends).</p>
<p>It would also be interesting to looking into improving GHC to support cross compiling and doing this through the LLVM back-end as it should be easier to fix up to support this feature than the C or NCG back-ends.</p>
<h3 id="get-rid-of-proc-point-splitting">Get rid of Proc Point Splitting</h3>
<p>When Cmm code is first generated a single Haskell function will be mostly compiled to one Cmm function. This Cmm function isn't passed to the backends though as the CPS style used in it requires that the backends be able to take the address of labels in a function since they're used as return points. The C backend can't support this. While there is a GNU C extension allowing the address of a label to be taken, the address can only be used locally (in the same function). So what proc point splitting does is cut a single Cmm function into multiple top level Cmm functions so that instead of needing to take the address of a label, we now take the address of a function.</p>
<p>It would be nice to get rid of proc point splitting. This is one of the goals for the new code generator. This will give us much bigger Cmm functions which should give more room for LLVM to optimise. There is an issue though that LLVM doesn't support taking the address of a local label either. So will need to add support to LLVM for taking label addresses or convert CPS style into something more direct if thats possible.</p>
<h3 id="dont-pass-around-dead-stg-registers">Don't Pass Around Dead STG Registers</h3>
<p><strong>Update: This has been implemented</strong></p>
<p>At the moment in the LLVM backend we always pass around the pinned STG registers as arguments for every Cmm function. A huge amount of the time though we aren't storing anything in the STG registers, they are dead really. If we can treat the correctly as dead then LLVM will have more free registers and the allocator should do a better job. We need to change the STG -&gt; Cmm code generator to attach register liveness information at function exit points (e.g calls, jumps, returns).</p>
<p>e.g This <a href="http://hackage.haskell.org/trac/ghc/ticket/4308">bug (#4308)</a> is as a result of this problem.</p>
<p><a href="PageOutline" class="uri" title="wikilink">PageOutline</a></p>
<h1 id="wired-in-and-known-key-things">Wired-in and known-key things</h1>
<p>There are three categories of entities that GHC &quot;knows about&quot;; that is, information about them is baked into GHC's source code.</p>
<ul>
<li>[wiki:Commentary/Compiler/WiredIn#Wiredinthings Wired-in things] --- GHC knows everything about these</li>
<li>[wiki:Commentary/Compiler/WiredIn#Knownkeythings Known-key things] --- GHC knows the <em>name</em>, including the
<pre><code>Unique</code></pre>
<p>, but not the definition</p></li>
<li>[wiki:Commentary/Compiler/WiredIn#OrigRdrNamethings Orig RdrName things] --- GHC knows which module it's defined in</li>
</ul>
<h2 id="wired-in-things">Wired-in things</h2>
<p>A <strong>Wired-in thing</strong> is fully known to GHC. Most of these are</p>
<pre><code>TyCon`s such as `Bool`. It is very convenient to simply be able to refer to `boolTyCon :: TyCon</code></pre>
<p>without having to look it up in an environment.</p>
<p>All [wiki:Commentary/Compiler/TypeType#Classifyingtypes primitive types] are wired-in things, and have wired-in</p>
<pre><code>Name`s.  The primitive types (and their `Names</code></pre>
<p>) are all defined in <a href="GhcFile(compiler/prelude/TysPrim.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/TysPrim.hs)</a>.</p>
<p>The non-primitive wired-in type constructors are defined in <a href="GhcFile(compiler/prelude/TysWiredIn.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/TysWiredIn.hs)</a>. There are a handful of wired-in</p>
<pre><code>Id</code></pre>
<p>s in <a href="GhcFile(compiler/basicTypes/MkId.hs)" class="uri" title="wikilink">GhcFile(compiler/basicTypes/MkId.hs)</a>. There are no wired-in classes (they are too complicated).</p>
<p>All the non-primitive wired-in things are <em>also</em> defined in GHC's libraries, because even though GHC knows about them we still need to generate code for them. For example,</p>
<pre><code>Bool` is a wired-in type constructor, but it is still defined in `GHC.Base</code></pre>
<p>because we need the info table etc for the data constructors. Arbitrarily bad things will happen if the wired-in definition in <a href="GhcFile(compiler/prelude/TysWiredIn.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/TysWiredIn.hs)</a> differs from that in the library module.</p>
<p>All wired-in things have a</p>
<pre><code>WiredIn` `Name</code></pre>
<p>(see [wiki:Commentary/Compiler/NameType Names]), which in turn contains the thing. See [wiki:Commentary/Compiler/CaseStudies/Bool a case study of Bool implementation] for more details.</p>
<h2 id="known-key-things-1">Known-key things</h2>
<p>A <strong>known-key thing</strong> has a fixed, pre-allocated</p>
<pre><code>Unique</code></pre>
<p>or <strong>key</strong>. They should really be called &quot;known-Name&quot; things, because the baked-in knowledge is:</p>
<ul>
<li>Its defining
<pre><code>Module</code></pre></li>
<li>Its
<pre><code>OccName</code></pre></li>
<li>Its
<pre><code>Unique</code></pre></li>
</ul>
<p>Almost all known-key names are defined in <a href="GhcFile(compiler/prelude/PrelNames.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/PrelNames.hs)</a>; for example:</p>
<pre><code>PrelNames.eqClassName :: Name</code></pre>
<p>.</p>
<p>The point about known-key things is that GHC knows its <em>name</em>, but not its <em>definition</em>. The definition must still be read from an interface file as usual. The known key just allows an efficient lookup in the environment.</p>
<h2 id="initialisation">Initialisation</h2>
<p>When reading an interface file, GHC might come across &quot;GHC.Base.Eq&quot;, which is the name of the</p>
<pre><code>Eq` class.  How does it match up this occurrence in the interface file with `eqClassName` defined in `PrelNames`?  Because the global name cache maintained by the renamer is initialised with all the known-key names.  This is done by the (hard-to-find) function `HscMain.newHscEnv</code></pre>
<dl>

<dd>
</dd>
</dl>
<pre><code>newHscEnv :: DynFlags -&gt; IO HscEnv
newHscEnv dflags
  = do { ...
         nc_var &lt;- newIORef (initNameCache us knownKeyNames)
     ...
     return (HscEnv { ... hsc_NC = nc_var, ... }) }

knownKeyNames :: [Name]
knownKeyNames = map getName wiredInThings ++ basicKnownKeyNames ++ templateHaskellNames</code></pre>
<p>Notice that the initialisation embraces both the wired-in and (&quot;basic&quot;) known-key names.</p>
<p>==</p>
<pre><code>Orig` `RdrName</code></pre>
<p>things ==</p>
<p>An <strong>Orig RdrName thing</strong> has a top-level definition of a</p>
<pre><code>RdrName`, using the `Orig</code></pre>
<p>constructor. Here, the baked-in information is:</p>
<ul>
<li>Its defining
<pre><code>Module</code></pre></li>
<li>Its
<pre><code>OccName</code></pre></li>
</ul>
<p>Again, almost all of these are in <a href="GhcFile(compiler/prelude/PrelNames.hs)" class="uri" title="wikilink">GhcFile(compiler/prelude/PrelNames.hs)</a>. Example:</p>
<pre><code>PrelNames.not_RDR :: RdrName</code></pre>
<p>.</p>
<h1 id="ghc-commentary-the-word">GHC Commentary: The Word</h1>
<p>The most important type in the runtime is</p>
<pre><code>StgWord</code></pre>
<p>, defined in <a href="GhcFile(includes/stg/Types.h)" class="uri" title="wikilink">GhcFile(includes/stg/Types.h)</a>. A word is defined to be the same size as a pointer on the current platform. All these types are interconvertible without losing information, and have the same size (as reported by</p>
<pre><code>sizeof</code></pre>
<p>):</p>
<p>;</p>
<pre><code>StgWord</code></pre>
<dl>

<dd>An unsiged integral type of word size
</dd>
</dl>
<p>;</p>
<pre><code>StgInt</code></pre>
<dl>

<dd>A signed integral type of word size
</dd>
</dl>
<p>;</p>
<pre><code>StgPtr</code></pre>
<dl>

<dd>Pointer to
<pre><code>StgWord</code></pre>
</dd>
</dl>
<p>The word is the basic unit of allocation in GHC: the heap and stack are both allocated in units of a word. Throughout the runtime we often use sizes that are in units of words, so as to abstract away from the real word size of the underlying architecture.</p>
<p>The</p>
<pre><code>StgWord` type is also useful for storing the &#39;&#39;size&#39;&#39; of a memory object, since an `StgWord` is guaranteed to at least span the range of addressable memory. It is rather like `size_t` in this respect, although we prefer to use `StgWord</code></pre>
<p>in the RTS sources.</p>
<p>C-- only understands units of bytes, so we have various macros in <a href="GhcFile(includes/Cmm.h)" class="uri" title="wikilink">GhcFile(includes/Cmm.h)</a> to make manipulating things in units of words easier in</p>
<pre><code>.cmm</code></pre>
<p>files.</p>
</body>
</html>
